(()=>{"use strict";function t(t,e){return t-e}function e(t,e){return t!==e?t<e?-1:1:0}function i(t,e){return t===e?0:t<e?-1:1}function n(t,e,i){return void 0===e?void 0===i?0:-1:void 0===i?1:t(e,i)}function s(t,i){return n(e,t,i)}function r(t){const e=parseInt(t,16);return Number.isNaN(e)?0:e}function o(t,e,i=!0){const n=t.charCodeAt(e);return n>=(i?48:49)&&n<=57||n>=97&&n<=102}function a(t,e,i){if(0===i)return!1;if(!o(t,e,!1))return!1;for(let n=1;n<i;n++)if(!o(t,e+n))return!1;return!0}var c,l,h,d,u,f,g,p,m,_,x,y,v,P,I,S,b,A,C,T,w,E,k,F,R,M,D,O,B,N,X,z,L,Y;function V(t){return t}function U(t,e,i){return q(e,(e=>i(t,e)))}function q(t,e){let i=0,n=t.length;for(;i<n;){const s=Math.floor((i+n)/2),r=e(t[s]);if(0===r)return{index:s,equal:!0};r<0?n=s:i=s+1}return{index:i,equal:!1}}!function(t){t.getLocalId=function(t){if(g(t))return 0;const e=t.length,i=e>12?e-10:2;return r(t.slice(i))},t.getBriefcaseId=function(t){if(g(t))return 0;const e=t.length;return e<=12?0:r(t.slice(2,e-10))},t.fromJSON=function(e){return"string"==typeof e?t.fromString(e):t.invalid},t.fromString=function(e){if("string"!=typeof e)return t.invalid;if(t.isId64(e))return e;const n=(e=e.toLowerCase().trim()).length;if(n<2||"0"!==e[0]||"x"!==e[1])return t.invalid;let s=0,o=0,a=2;return n>12&&(a=n-10,o=r(e.slice(2,a))),s=r(e.slice(a)),i(s,o)};const e=["0000000000","000000000","00000000","0000000","000000","00000","0000","000","00","0",""];function i(i,n){if("number"!=typeof i||"number"!=typeof n)return t.invalid;if(0===(i=Math.floor(i)))return t.invalid;n=Math.floor(n);const s=i.toString(16);return`0x${0===n?s:n.toString(16)+(e[s.length]+s)}`}t.fromLocalAndBriefcaseIds=i;const n=[48,120,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48,48];function s(t){return t+(t<10?48:87)}function o(t,e,i){let n=0;for(let r=e;r<i;r++)n=(n|(s=t.charCodeAt(r))-(s>=87?87:48)<<(i-r-1<<2))>>>0;var s;return n}function c(e,i){if(0==(e>>>0)+4294967296*(255&i))return t.invalid;const r=n;let o=2;for(let t=7;t>=0;t--){const e=t<<2,n=(i&15<<e)>>>e;(o>2||0!==n)&&(r[o++]=s(n))}for(let t=7;t>=0;t--){const i=t<<2,n=(e&15<<i)>>>i;(o>2||0!==n)&&(r[o++]=s(n))}return r.length!==o&&(r.length=o),String.fromCharCode(...n)}function l(t){if(g(t))return 0;const e=t.length;return o(t,e>10?e-8:2,e)}function h(t){const e=t.length;return e<=10||g(t)?0:o(t,2,e-8)}function*d(t){if("string"==typeof t)yield t;else for(const e of t)yield e}function u(t){return 18===t.length&&t.startsWith("0xffffff")}function f(e){return t.invalid!==e&&t.isId64(e)}function g(e){return t.invalid===e}t.fromUint32Pair=c,t.fromUint32PairObject=function(t){return c(t.lower,t.upper)},t.isValidUint32Pair=function(t,e){return 0!==t||!!(255&e)},t.getUint32Pair=function(t,e){return e||(e={lower:0,upper:0}),e.lower=l(t),e.upper=h(t),e},t.getLowerUint32=l,t.getUpperUint32=h,t.toIdSet=function(t,e=!1){if(t instanceof Set)return e?new Set(t):t;const i=new Set;return"string"==typeof t?i.add(t):Array.isArray(t)&&t.forEach((t=>{"string"==typeof t&&i.add(t)})),i},t.iterator=d,t.iterable=function(t){return{[Symbol.iterator]:()=>d(t)}},t.getFirst=function(e){return"string"==typeof e?e:(Array.isArray(e)?e[0]:e.values().next().value)??t.invalid},t.sizeOf=function(t){return"string"==typeof t?1:Array.isArray(t)?t.length:t.size},t.has=function(t,e){return"string"==typeof t?t===e:Array.isArray(t)?-1!==t.indexOf(e):t.has(e)},t.invalid="0",t.isTransient=u,t.isTransientId64=function(t){return f(t)&&u(t)},t.isId64=function(t){const e=t.length;if(0===e||18<e)return!1;if("0"!==t[0])return!1;if(1===e)return!0;if(2===e||"x"!==t[1])return!1;let i=2;if(e>12){if(i=e-10,!a(t,2,i-2))return!1;for(let n=i;n<e&&48===t.charCodeAt(n);n++)i++;if(i>=e)return!1}return a(t,i,e-i)},t.isValid=function(e){return t.invalid!==e},t.isValidId64=f,t.isInvalid=g,t.Uint32Set=class{_map=new Map;constructor(t){void 0!==t&&this.addIds(t)}equals(t){if(this===t)return!0;if(this.size!==t.size)return!1;for(const[e,i]of this._map){const n=t._map.get(e);if(!n||i.size!==n.size)return!1;for(const t of i)if(!n.has(t))return!1}return!0}clear(){this._map.clear()}addId(e){this.add(t.getLowerUint32(e),t.getUpperUint32(e))}addIds(e){for(const i of t.iterable(e))this.addId(i)}hasId(e){return this.has(t.getLowerUint32(e),t.getUpperUint32(e))}add(t,e){let i=this._map.get(e);void 0===i&&(i=new Set,this._map.set(e,i)),i.add(t)}deleteId(e){this.delete(t.getLowerUint32(e),t.getUpperUint32(e))}deleteIds(e){for(const i of t.iterable(e))this.deleteId(i)}delete(t,e){const i=this._map.get(e);void 0!==i&&(i.delete(t),0===i.size&&this._map.delete(e))}has(t,e){const i=this._map.get(e);return void 0!==i&&i.has(t)}hasPair(t){return this.has(t.lower,t.upper)}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}toId64Array(){const e=[];for(const i of this._map)for(const n of i[1])e.push(t.fromUint32Pair(n,i[0]));return e}toId64Set(){const e=new Set;for(const i of this._map)for(const n of i[1])e.add(t.fromUint32Pair(n,i[0]));return e}forEach(t){for(const e of this._map)for(const i of e[1])t(i,e[0])}},t.Uint32Map=class{_map=new Map;clear(){this._map.clear()}getById(e){return this.get(t.getLowerUint32(e),t.getUpperUint32(e))}setById(e,i){this.set(t.getLowerUint32(e),t.getUpperUint32(e),i)}set(t,e,i){let n=this._map.get(e);void 0===n&&(n=new Map,this._map.set(e,n)),n.set(t,i)}get(t,e){const i=this._map.get(e);return void 0!==i?i.get(t):void 0}get isEmpty(){return 0===this._map.size}get size(){let t=0;for(const e of this._map)t+=e[1].size;return t}forEach(t){for(const e of this._map)for(const i of e[1])t(i[0],e[0],i[1])}}}(c||(c={})),function(t){const e=new RegExp("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");function i(t){return e.test(t)}t.empty="00000000-0000-0000-0000-000000000000",t.isGuid=i,t.isV4Guid=function(t){return/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/.test(t)},t.createValue=function(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(t=>{const e=16*Math.random()|0;return("x"===t?e:3&e|8).toString(16)}))},t.normalize=function(t){const e=t.toLowerCase().trim();if(i(e))return e;const n=e.replace(/-/g,""),s=/^([0-9a-f]{8})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{4})([0-9a-f]{12})$/;return s.test(n)?n.replace(s,((t,e,i,n,s,r)=>`${e}-${i}-${n}-${s}-${r}`)):t}}(l||(l={})),function(t){function e(t,e){return t.length!==e.length?t.length<e.length?-1:1:t!==e?t<e?-1:1:0}function*i(t){const e=t[Symbol.iterator]();let i,n=e.next();for(;!n.done;){const t=n.value;n=e.next(),t!==i&&(i=t,yield t)}}function*n(t,i){const n=t[Symbol.iterator](),s=i[Symbol.iterator]();let r,o=n.next(),a=s.next();for(;!o.done||!a.done;){const t=o.done?void 0:o.value,i=a.done?void 0:a.value;if(void 0===t&&void 0===i)break;let c;if(void 0===t)c=i,a=s.next();else if(void 0===i)c=t,o=n.next();else{const r=e(t,i);r<=0?(c=t,o=n.next(),0===r&&(a=s.next())):(c=i,a=s.next())}r!==c&&(r=c,yield c)}}function*s(t,i){const n=t[Symbol.iterator](),s=i[Symbol.iterator]();let r,o=n.next(),a=s.next();for(;!o.done&&!a.done;){const t=o.value;if(o=n.next(),t===r)continue;r=t;let i=a.value,c=e(t,i);for(;c>0;){if(a=s.next(),a.done)return;i=a.value,c=e(t,i)}0===c&&(yield t)}}function*r(t,i){const n=t[Symbol.iterator](),s=i[Symbol.iterator]();let r,o=n.next(),a=s.next();for(;!o.done;){const t=o.value;if(o=n.next(),t===r)continue;if(a.done){yield r=t;continue}let i=a.value,c=e(t,i);for(;c>0&&!a.done;)a=s.next(),a.done?yield r=t:(i=a.value,c=e(t,i));c<0&&(yield r=t)}}t.compare=e,t.sortArray=function(t){return t.sort(((t,i)=>e(t,i))),t},t.areEqualSets=function(t,n){const s=i(t),r=i(n);let o=s.next(),a=r.next();for(;!o.done&&!a.done;){if(0!==e(o.value,a.value))return!1;o=s.next(),a=r.next()}return!(!o.done||!a.done)},t.isEmptySet=function(t){return"string"==typeof t?""===t:!0===t[Symbol.iterator]().next().done},t.unique=function(t){return{[Symbol.iterator]:()=>i(t)}},t.uniqueIterator=i,t.union=function(t,e){return{[Symbol.iterator]:()=>n(t,e)}},t.intersection=function(t,e){return{[Symbol.iterator]:()=>s(t,e)}},t.difference=function(t,e){return{[Symbol.iterator]:()=>r(t,e)}},t.unionIterator=n,t.intersectionIterator=s,t.differenceIterator=r}(h||(h={})),function(t){t[t.Allow=0]="Allow",t[t.Retain=1]="Retain",t[t.Replace=2]="Replace"}(d||(d={}));class Z{_array=[];_compare;_clone;_duplicatePolicy;constructor(t,e=!1,i=V){this._compare=t,this._clone=i,"boolean"==typeof e&&(e=e?d.Allow:d.Retain),this._duplicatePolicy=e}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}indexOf(t){const e=this.lowerBound(t);return e.equal?e.index:-1}contains(t){return-1!==this.indexOf(t)}findEqual(t){const e=this.indexOf(t);return-1!==e?this._array[e]:void 0}findEquivalent(t){const e=this.indexOfEquivalent(t);return-1!==e?this._array[e]:void 0}indexOfEquivalent(t){const e=q(this._array,(e=>0-t(e)));return e.equal?e.index:-1}get(t){return t<this.length?this._array[t]:void 0}forEach(t){for(let e=0;e<this.length;e++)t(this._array[e])}slice(t,e){const i=new Z(this._compare,this._duplicatePolicy,this._clone);return i._array=this._array.slice(t,e),i}lowerBound(t){return U(t,this._array,this._compare)}_clear(){this._array.length=0}_extractArray(){const t=this._array;return this._array=[],t}_insert(t,e){const i=this.lowerBound(t);if(i.equal)switch(this._duplicatePolicy){case d.Retain:return i.index;case d.Replace:return this._array[i.index]=this._clone(t),e&&e(t),i.index}return this._array.splice(i.index,0,this._clone(t)),void 0!==e&&e(t),i.index}_remove(t){const e=this.lowerBound(t);return e.equal?(this._array.splice(e.index,1),e.index):-1}}class W extends Z{constructor(t,e=!1,i=V){super(t,e,i)}clear(){this._clear()}extractArray(){return this._extractArray()}insert(t,e){return this._insert(t,e)}remove(t){return this._remove(t)}slice(t,e){const i=new W(this._compare,this._duplicatePolicy,this._clone);return i._array=this._array.slice(t,e),i}}!function(t){function e(t){return t>=48&&t<=57||t>=65&&t<=70}function i(t,e){const i=`+${t.toString()}`;return e<=1?i:`${i}*${e.toString(16).toUpperCase()}`}function n(t){const e="string"==typeof t?[t]:Array.from(t);return h.sortArray(e),s(e)}function s(t){return r(t)}function r(t){if("string"==typeof t)return t;let e="";const n=new o,s=new o;let r=0;const a=new o,l=new o;for(const o of t){if(!c.isValidId64(o))continue;a.setFromId(o),l.setFromDifference(a,n);const t=n.compare(a);if(0!==t){if(t>0)throw new Error("CompressedId64Set.compressArray requires a sorted array as input");n.copyFrom(a),0===r?(s.copyFrom(l),r=1):l.equals(s)?++r:(e+=i(s,r),s.copyFrom(l),r=1)}}return 0<r&&(e+=i(s,r)),e}t.compressSet=function(t){return n(t)},t.sortAndCompress=n,t.compressArray=s,t.compressIds=r;class o{lower;upper;static _base=4294967296;static assertUint32(t){o._base,Math.floor(t)}assertConstraints(){o.assertUint32(this.lower),o.assertUint32(this.upper)}constructor(t=0,e=0){this.lower=t,this.upper=e,this.assertConstraints()}compare(t){const e=this.upper-t.upper;return 0===e?this.lower-t.lower:e}equals(t){return 0===this.compare(t)}isLessThan(t){return this.compare(t)<0}isGreaterThan(t){return this.compare(t)>0}get isZero(){return 0===this.lower&&0===this.upper}setFromDifference(t,e){e.isGreaterThan(t),this.lower=t.lower-e.lower,this.upper=t.upper-e.upper,this.lower<0&&(this.lower+=o._base,this.upper-=1)}add(t){let e=t.lower,i=t.upper;e+this.lower>=o._base&&(e-=o._base,i+=1),this.lower+=e,this.upper+=i,this.assertConstraints()}setFromId(t){c.getUint32Pair(t,this)}copyFrom(t){this.lower=t.lower,this.upper=t.upper}toString(){if(0===this.upper)return this.lower.toString(16).toUpperCase();const t=this.upper.toString(16),e=this.lower.toString(16).padStart(8,"0");return e.length,`${t}${e}`.toUpperCase()}toId64String(){return c.fromUint32Pair(this.lower,this.upper)}}function*a(t){if(0===t.length)return;if("+"!==t[0])throw new Error("Invalid CompressedId64Set");let i=1;const n=new o;function s(){let n=0,s=0;for(;i<t.length&&s<8;){++s;const r=t.charCodeAt(i);if(!e(r))break;n<<=4,n|=r>=65?r-65+10:r-48,n>>>=0,++i}return n}function r(n){let r=0,o=0;const a=i,c=s();if(8===i-a&&i+1<t.length&&e(t.charCodeAt(i+1))){const t=i,e=s(),n=i-t,a=8-n;o=c>>>4*a,r=(e|c-(o<<4*a>>>0)<<4*n>>>0)>>>0}else r=c;n.lower=r,n.upper=o}const a=new o;for(;i<t.length;){let e=1;if(r(a),a.isZero)throw new Error("Invalid CompressedId64Set");if(i<t.length)switch(t[i++]){case"*":if(e=s(),0===e)throw new Error("Invalid CompressedId64Set");if(i!==t.length&&"+"!==t[i++])return;break;case"+":break;default:throw new Error("Invalid CompressedId64Set")}for(let t=0;t<e;t++)n.add(a),yield n.toId64String()}}function l(t){return{[Symbol.iterator]:()=>a(t)}}t.iterator=a,t.iterable=l,t.decompressSet=function(t,e){const i=e??new Set;for(const e of l(t))i.add(e);return i},t.decompressArray=function(t,e){const i=e??[];for(const e of l(t))i.push(e);return i}}(u||(u={})),Symbol.iterator;class G{static piOver12Radians=.26179938779914946;static piOver4Radians=.7853981633974483;static piOver2Radians=1.5707963267948966;static piRadians=3.141592653589793;static pi3Over2Radians=4.71238898038469;static pi2Radians=6.283185307179586;static degreesPerRadian=45/G.piOver4Radians;static radiansPerDegree=G.piOver4Radians/45;_radians;_degrees;constructor(t=0,e){this._radians=t,this._degrees=e}clone(){return new G(this._radians,this._degrees)}freeze(){return Object.freeze(this)}static createDegrees(t){return new G(G.degreesToRadians(t),t)}static createRadians(t){return new G(t)}static createSmallAngle(){return new G(J.smallAngleRadians)}static createInterpolate(t,e,i){return new G(J.interpolate(t.radians,e,i.radians))}cloneScaled(t){return new G(this.radians*t)}setRadians(t){this._radians=t,this._degrees=void 0}setDegrees(t){this._radians=G.degreesToRadians(t),this._degrees=t}static create360(){return new G(2*Math.PI,360)}static createAtan2(t,e){return new G(Math.atan2(t,e))}setFrom(t){this._radians=t._radians,this._degrees=t._degrees}setFromJSON(t,e){this._radians=e||0,t&&("number"==typeof t?this.setDegrees(t):"number"==typeof t.degrees?this.setDegrees(t.degrees):"number"==typeof t._degrees?this.setDegrees(t._degrees):"number"==typeof t.radians?this.setRadians(t.radians):"number"==typeof t._radians&&this.setRadians(t._radians))}static fromJSON(t,e){const i=new G;return i.setFromJSON(t,e),i}toJSON(){return this.degrees}toJSONRadians(){return{radians:this.radians}}get radians(){return this._radians}get degrees(){return void 0!==this._degrees?this._degrees:G.radiansToDegrees(this._radians)}static degreesToRadians(t){return t*Math.PI/180}static radiansToDegrees(t){if(t<0)return-G.radiansToDegrees(-t);const e=Math.PI;return t<=.25*e?180/e*t:t<.75*e?90+(t-.5*e)/e*180:t<=1.25*e?180+(t-e)/e*180:t<=1.75*e?270+(t-1.5*e)/e*180:360+(t-2*e)/e*180}cos(){return Math.cos(this._radians)}sin(){return Math.sin(this._radians)}tan(){return Math.tan(this._radians)}static isFullCircleRadians(t){return Math.abs(t)>=J.fullCircleRadiansMinusSmallAngle}static isHalfCircleRadians(t){return Math.abs(Math.abs(t)-Math.PI)<=J.smallAngleRadians}get isFullCircle(){return G.isFullCircleRadians(this._radians)}get isHalfCircle(){return G.isHalfCircleRadians(this._radians)}static adjustDegrees0To360(t){if(t>=0){const e=360;return t<e?t:t-Math.floor(t/e)*e}return t<0?360-G.adjustDegrees0To360(-t):0}static adjustDegreesSigned180(t){if(Math.abs(t)<=180)return t;if(t>=0){const e=360;return t-(1+Math.floor((t-180)/e))*e}return t<0?-G.adjustDegreesSigned180(-t):0}static adjustRadians0To2Pi(t){if(t>=0){const e=2*Math.PI;return t<e?t:t-Math.floor(t/e)*e}return t<0?2*Math.PI-G.adjustRadians0To2Pi(-t):0}static adjustRadians0ToLessThan2Pi(t){return G.isAlmostEqualRadiansAllowPeriodShift(t,0)&&(t=0),this.adjustRadians0To2Pi(t)}static adjustRadiansMinusPiPlusPi(t){if(Math.abs(t)<=Math.PI)return t;if(t>=0){const e=2*Math.PI;return t-(1+Math.floor((t-Math.PI)/e))*e}return t<0?-G.adjustRadiansMinusPiPlusPi(-t):0}static zero(){return new G(0)}get isExactZero(){return 0===this.radians}get isAlmostZero(){return Math.abs(this.radians)<J.smallAngleRadians}get isAlmostNorthOrSouthPole(){return G.isHalfCircleRadians(2*this.radians)}static createDegreesAdjustPositive(t){return G.createDegrees(G.adjustDegrees0To360(t))}static createDegreesAdjustSigned180(t){return G.createDegrees(G.adjustDegreesSigned180(t))}static isAlmostEqualRadiansAllowPeriodShift(t,e,i=J.smallAngleRadians){const n=Math.abs(t-e);if(n<=i)return!0;const s=2*Math.PI;if(Math.abs(n-s)<=i)return!0;const r=n-Math.round(n/s)*s;return Math.abs(r)<=i}isMagnitudeLessThanOrEqual(t){return Math.abs(this.radians)<=Math.abs(t.radians)}isAlmostEqualAllowPeriodShift(t,e=J.smallAngleRadians){return G.isAlmostEqualRadiansAllowPeriodShift(this._radians,t._radians,e)}static isAlmostEqualRadiansNoPeriodShift(t,e,i=J.smallAngleRadians){return Math.abs(t-e)<i}isAlmostEqualNoPeriodShift(t,e=J.smallAngleRadians){return G.isAlmostEqualRadiansNoPeriodShift(this._radians,t._radians,e)}isAlmostEqual(t,e=J.smallAngleRadians){return this.isAlmostEqualNoPeriodShift(t,e)}static isPerpendicularDotSet(t,e,i){return t>J.smallMetricDistanceSquared&&e>J.smallMetricDistanceSquared&&i*i<=J.smallAngleRadiansSquared*t*e}static trigValuesToHalfAngleTrigValues(t,e){const i=J.hypotenuseXY(t,e);if(i<J.smallMetricDistance)return{c:1,s:0,radians:0};{let n,s=0;const r=t/i,o=e/i;return r>=0?(n=Math.sqrt(.5*(1+r)),s=o/(2*n)):(s=o>0?Math.sqrt(.5*(1-r)):-Math.sqrt(.5*(1-r)),n=o/(2*s)),{c:n,s,radians:Math.atan2(s,n)}}}static cleanupTrigValue(t,e=J.smallFloatingPoint){const i=Math.abs(t);if(i<=e)return 0;let n=Math.abs(i-.5);return n<=e?t<0?-.5:.5:(n=Math.abs(i-1),n<=e?t<0?-1:1:t)}static dotProductsToHalfAngleTrigValues(t,e,i,n=!0){const s=t-e,r=2*i;return n&&Math.abs(r)<J.smallAngleRadians*(Math.abs(t)+Math.abs(e))?{c:1,s:0,radians:0}:G.trigValuesToHalfAngleTrigValues(s,r)}static radiansBetweenVectorsXYZ(t,e,i,n,s,r){const o=t*n+e*s+i*r;return Math.atan2(J.crossProductMagnitude(t,e,i,n,s,r),o)}static orientedRadiansBetweenVectorsXYZ(t,e,i,n,s,r,o,a,c,l=!1){const h=t*n+e*s+i*r,d=e*r-i*s,u=i*n-t*r,f=t*s-e*n,g=o*d+a*u+c*f,p=J.hypotenuseXYZ(d,u,f);return g<0?l?Math.PI+Math.atan2(p,-h):-Math.atan2(p,h):Math.atan2(p,h)}addMultipleOf2PiInPlace(t){void 0!==this._degrees?(this._degrees+=360*t,this._radians=G.degreesToRadians(this._degrees)):this._radians+=t*G.pi2Radians}}class Q{x;y;set(t=0,e=0){this.x=t,this.y=e}setZero(){this.x=0,this.y=0}constructor(t=0,e=0){this.x=t,this.y=e}setFrom(t){t?(this.x=t.x,this.y=t.y):(this.x=0,this.y=0)}freeze(){return Object.freeze(this)}isAlmostEqual(t,e){return J.isSameCoordinate(this.x,t.x,e)&&J.isSameCoordinate(this.y,t.y,e)}isAlmostEqualXY(t,e,i){return J.isSameCoordinate(this.x,t,i)&&J.isSameCoordinate(this.y,e,i)}toJSON(){return[this.x,this.y]}toJSONXY(){return{x:this.x,y:this.y}}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0):t?this.set(t.x||0,t.y||0):this.set(0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y))}at(t){return t<.5?this.x:this.y}setAt(t,e){t<.5?this.x=e:this.y=e}indexOfMaxAbs(){let t=0;const e=Math.abs(this.x);return Math.abs(this.y)>e&&(t=1),t}get isAlmostZero(){return J.isSmallMetricDistance(this.x)&&J.isSmallMetricDistance(this.y)}get isZero(){return 0===this.x&&0===this.y}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquared(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y}isAlmostEqualMetric(t,e=J.smallMetricDistance){return this.maxDiff(t)<=e}vectorTo(t,e){return j.create(t.x-this.x,t.y-this.y,e)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}static crossProductToPoints(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}}class H extends Q{constructor(t=0,e=0){super(t,e)}clone(t){return H.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new H(t,e)}static fromJSON(t){const e=new H;return e.setFromJSON(t),e}static createFrom(t,e){return t?H.create(t.x,t.y,e):H.create(0,0,e)}static createZero(t){return H.create(0,0,t)}addForwardLeft(t,e,i,n){const s=i.x,r=i.y;return H.create(this.x+t*s-e*r,this.y+t*r+e*s,n)}forwardLeftInterpolate(t,e,i){const n=i.x-this.x,s=i.y-this.y;return H.create(this.x+t*n-e*s,this.y+t*s+e*n)}interpolate(t,e,i){if(t<=.5)return H.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),i);const n=t-1;return H.create(e.x+n*(e.x-this.x),e.y+n*(e.y-this.y),i)}interpolateXY(t,e,i,n){return H.create(J.interpolate(this.x,t,i.x),J.interpolate(this.y,e,i.y),n)}minus(t,e){return H.create(this.x-t.x,this.y-t.y,e)}plus(t,e){return H.create(this.x+t.x,this.y+t.y,e)}plusXY(t=0,e=0,i){return H.create(this.x+t,this.y+e,i)}plusScaled(t,e,i){return H.create(this.x+t.x*e,this.y+t.y*e,i)}plus2Scaled(t,e,i,n,s){return H.create(this.x+t.x*e+i.x*n,this.y+t.y*e+i.y*n,s)}plus3Scaled(t,e,i,n,s,r,o){return H.create(this.x+t.x*e+i.x*n+s.x*r,this.y+t.y*e+i.y*n+s.y*r,o)}scaleInPlace(t){this.x*=t,this.y*=t}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)}crossProductToPoints(t,e){const i=t.x-this.x,n=t.y-this.y,s=e.x-this.x;return i*(e.y-this.y)-n*s}fractionOfProjectionToLine(t,e,i=0){const n=t.distanceSquared(e);return n<J.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/n}}class j extends Q{constructor(t=0,e=0){super(t,e)}clone(t){return j.create(this.x,this.y,t)}static create(t=0,e=0,i){return i?(i.x=t,i.y=e,i):new j(t,e)}static unitX(t=1){return new j(t,0)}static unitY(t=1){return new j(0,t)}static createZero(t){return j.create(0,0,t)}static createFrom(t,e){return t instanceof Float64Array?t.length>=2?j.create(t[0],t[1]):t.length>=1?j.create(t[0],0):j.create(0,0):j.create(t.x,t.y,e)}static fromJSON(t){const e=new j;return e.setFromJSON(t),e}static createPolar(t,e){return j.create(t*e.cos(),t*e.sin())}static createStartEnd(t,e,i){return j.create(e.x-t.x,e.y-t.y,i)}static createOffsetBisector(t,e,i){let n=t.plus(e);if(n=n.normalize(),n){const e=n.dotProduct(t);return n.scale(i,n),n.safeDivideOrNull(e)}}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalize(t){const e=J.correctSmallFraction(this.magnitude());return t=t||new j,this.safeDivideOrNull(e,t)}fractionOfProjectionToVector(t,e){const i=t.magnitudeSquared();return i<J.smallMetricDistanceSquared?e||0:this.dotProduct(t)/i}negate(t){return(t=t||new j).x=-this.x,t.y=-this.y,t}rotate90CCWXY(t){t=t||new j;const e=this.x,i=this.y;return t.x=-i,t.y=e,t}rotate90CWXY(t){t=t||new j;const e=this.x,i=this.y;return t.x=i,t.y=-e,t}unitPerpendicularXY(t){t=t||new j;const e=this.x,i=this.y;t.x=-i,t.y=e;const n=e*e+i*i;if(0!==n){const e=1/Math.sqrt(n);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),n=t.cos(),s=this.x,r=this.y;return(e=e||new j).x=s*n-r*i,e.y=s*i+r*n,e}interpolate(t,e,i){if(i=i||new j,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y);else{const n=t-1;i.x=e.x+n*(e.x-this.x),i.y=e.y+n*(e.y-this.y)}return i}plus(t,e){return(e=e||new j).x=this.x+t.x,e.y=this.y+t.y,e}minus(t,e){return(e=e||new j).x=this.x-t.x,e.y=this.y-t.y,e}plusScaled(t,e,i){return(i=i||new j).x=this.x+t.x*e,i.y=this.y+t.y*e,i}plus2Scaled(t,e,i,n,s){return(s=s||new j).x=this.x+t.x*e+i.x*n,s.y=this.y+t.y*e+i.y*n,s}plus3Scaled(t,e,i,n,s,r,o){return(o=o||new j).x=this.x+t.x*e+i.x*n+s.x*r,o.y=this.y+t.y*e+i.y*n+s.y*r,o}scale(t,e){return(e=e||new j).x=this.x*t,e.y=this.y*t,e}scaleToLength(t,e){const i=J.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}dotProduct(t){return this.x*t.x+this.y*t.y}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}crossProduct(t){return this.x*t.y-this.y*t.x}radiansTo(t){return Math.atan2(this.crossProduct(t),this.dotProduct(t))}angleTo(t){return G.createRadians(this.radiansTo(t))}isParallelTo(t,e=!1,i=!1,n){const s=n?.radianSquaredTol??J.smallAngleRadiansSquared,r=n?.distanceSquaredTol??J.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();if(o<r||a<r)return i;if(this.dotProduct(t)<0&&!e)return!1;const c=this.crossProduct(t);return c*c<=s*o*a}isPerpendicularTo(t,e=!1,i){const n=i?.radianSquaredTol??J.smallAngleRadiansSquared,s=i?.distanceSquaredTol??J.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<s||o<s)return e;const a=this.dotProduct(t);return a*a<=n*r*o}}!function(t){t[t.XYZ=0]="XYZ",t[t.YZX=1]="YZX",t[t.ZXY=2]="ZXY",t[t.XZY=4]="XZY",t[t.YXZ=5]="YXZ",t[t.ZYX=6]="ZYX"}(f||(f={})),function(t){t[t.X=0]="X",t[t.Y=1]="Y",t[t.Z=2]="Z"}(g||(g={})),function(t){t[t.Top=1]="Top",t[t.Bottom=2]="Bottom",t[t.Left=3]="Left",t[t.Right=4]="Right",t[t.Front=5]="Front",t[t.Back=6]="Back",t[t.Iso=7]="Iso",t[t.RightIso=8]="RightIso"}(p||(p={})),function(t){t[t.Unit=0]="Unit",t[t.LongestRangeDirection=1]="LongestRangeDirection",t[t.NonUniformRangeContainment=2]="NonUniformRangeContainment"}(m||(m={})),function(t){t[t.Unknown=0]="Unknown",t[t.OnPolygonVertex=1]="OnPolygonVertex",t[t.OnPolygonEdgeInterior=2]="OnPolygonEdgeInterior",t[t.InsidePolygon=3]="InsidePolygon",t[t.InsidePolygonProjectsToVertex=4]="InsidePolygonProjectsToVertex",t[t.InsidePolygonProjectsToEdgeInterior=5]="InsidePolygonProjectsToEdgeInterior",t[t.OutsidePolygon=6]="OutsidePolygon",t[t.OutsidePolygonProjectsToVertex=7]="OutsidePolygonProjectsToVertex",t[t.OutsidePolygonProjectsToEdgeInterior=8]="OutsidePolygonProjectsToEdgeInterior"}(_||(_={}));class J{static smallMetricDistance=1e-6;static smallMetricDistanceSquared=1e-12;static smallAngleRadians=1e-12;static smallAngleRadiansSquared=1e-24;static smallAngleDegrees=57e-12;static smallAngleSeconds=2e-7;static smallFraction=1e-10;static smallFloatingPoint=1e-15;static fullCircleRadiansMinusSmallAngle=2*Math.PI-J.smallAngleRadians;static largeFractionResult=1e10;static largeCoordinateResult=1e13;static hugeCoordinate=1e12;static isLargeCoordinateResult(t){return t>=this.largeCoordinateResult||t<=-this.largeCoordinateResult}static isHugeCoordinate(t){return J.isLargeCoordinateResult(t)}static isOdd(t){return!(1&~t)}static correctSmallMetricDistance(t,e=0){return void 0===t||Math.abs(t)<=J.smallMetricDistance?e:t}static correctSmallFraction(t,e=0){return void 0===t||Math.abs(t)<=J.smallFraction?e:t}static inverseMetricDistance(t){return Math.abs(t)<=J.smallMetricDistance?void 0:1/t}static inverseMetricDistanceSquared(t){return Math.abs(t)<=J.smallMetricDistanceSquared?void 0:1/t}static isSameCoordinate(t,e,i=J.smallMetricDistance){let n=t-e;return n<0&&(n=-n),n<=i}static isSameCoordinateWithToleranceFactor(t,e,i){return J.isSameCoordinate(t,e,i*J.smallMetricDistance)}static isSameCoordinateXY(t,e,i,n,s=J.smallMetricDistance){let r=i-t;return r<0&&(r=-r),!(r>s)&&(r=n-e,r<0&&(r=-r),r<=s)}static isSameCoordinateSquared(t,e,i=J.smallMetricDistance){return Math.abs(Math.sqrt(t)-Math.sqrt(e))<=i}static isSamePoint3d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSameXYZ(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSamePoint3dXY(t,e,i=J.smallMetricDistance){return t.distanceXY(e)<=i}static isSameVector3d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSamePoint2d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static isSameVector2d(t,e,i=J.smallMetricDistance){return t.distance(e)<=i}static lexicalXYLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}static lexicalYXLessThan(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static lexicalXYZLessThan(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:t.z<e.z?-1:t.z>e.z?1:0}static isSmallRelative(t){return Math.abs(t)<=J.smallFraction}static isSmallAngleRadians(t){return Math.abs(t)<=J.smallAngleRadians}static isSmallAngleRadiansSquared(t){return Math.abs(t)<=J.smallAngleRadiansSquared}static isAlmostEqualOptional(t,e,i){if(void 0!==t&&void 0!==e){if(Math.abs(t-e)>i)return!1}else if(void 0!==t||void 0!==e)return!1;return!0}static isAlmostEqualNumber(t,e,i=J.smallAngleRadians){const n=1+Math.abs(t)+Math.abs(e);return Math.abs(t-e)<=i*n}static isAlmostEqualEitherNumber(t,e,i,n=J.smallAngleRadians){return this.isAlmostEqualNumber(t,e,n)||this.isAlmostEqualNumber(t,i,n)}static isAlmostEqualAnyNumber(t,e,i=J.smallAngleRadians){const n=Array.isArray(e)?t=>e[t]:e.iter;for(let s=0;s<e.length;s++)if(this.isAlmostEqualNumber(t,n(s),i))return!0;return!1}static isAlmostEqualXAndY(t,e,i=J.smallAngleRadians){const n=i*(1+Math.abs(t.x)+Math.abs(e.x)+Math.abs(t.y)+Math.abs(e.y));return Math.abs(t.x-e.x)<=n&&Math.abs(t.y-e.y)<=n}static isDistanceWithinTol(t,e=J.smallMetricDistance){return Math.abs(t)<=e}static isSmallMetricDistance(t){return Math.abs(t)<=J.smallMetricDistance}static isSmallMetricDistanceSquared(t){return Math.abs(t)<=J.smallMetricDistanceSquared}static cyclic3dAxis(t){if(t>=0)return t<3?t:t<6?t-3:t%3;const e=t+3;return e>=0?e:2-(-t-1)%3}static axisIndexToRightHandedAxisOrder(t){return 0===t?f.XYZ:1===t?f.YZX:2===t?f.ZXY:J.axisIndexToRightHandedAxisOrder(J.cyclic3dAxis(t))}static maxXYZ(t,e,i){let n=t;return e>n&&(n=e),i>n&&(n=i),n}static minXYZ(t,e,i){let n=t;return e<n&&(n=e),i<n&&(n=i),n}static maxXY(t,e){let i=t;return e>i&&(i=e),i}static minXY(t,e){let i=t;return e<i&&(i=e),i}static maxAbsXYZ(t,e,i){return J.maxXYZ(Math.abs(t),Math.abs(e),Math.abs(i))}static maxAbsXY(t,e){return J.maxXY(Math.abs(t),Math.abs(e))}static maxAbsDiff(t,e,i){return Math.max(Math.abs(t-e),Math.abs(t-i))}static split3WaySign(t,e,i,n){return t<0?e:t>0?n:i}static split3Way01(t,e=J.smallMetricDistance){return t>e?1:t<-e?-1:0}static square(t){return t*t}static hypotenuseXY(t,e){return Math.sqrt(t*t+e*e)}static hypotenuseSquaredXY(t,e){return t*t+e*e}static hypotenuseXYZ(t,e,i){return Math.sqrt(t*t+e*e+i*i)}static hypotenuseSquaredXYZ(t,e,i){return t*t+e*e+i*i}static hypotenuseXYZW(t,e,i,n){return Math.sqrt(t*t+e*e+i*i+n*n)}static hypotenuseSquaredXYZW(t,e,i,n){return t*t+e*e+i*i+n*n}static distanceXYXY(t,e,i,n){return J.hypotenuseXY(i-t,n-e)}static distanceXYZXYZ(t,e,i,n,s,r){return J.hypotenuseXYZ(n-t,s-e,r-i)}static tripleProduct(t,e,i,n,s,r,o,a,c){return t*(s*c-r*a)+e*(r*o-n*c)+i*(n*a-s*o)}static determinant4x4(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g,p){return t*this.tripleProduct(r,o,a,l,h,d,f,g,p)-s*this.tripleProduct(e,i,n,l,h,d,f,g,p)+c*this.tripleProduct(e,i,n,r,o,a,f,g,p)-u*this.tripleProduct(e,i,n,r,o,a,l,h,d)}static tripleProductXYW(t,e,i,n,s,r){return J.tripleProduct(t.x,i.x,s.x,t.y,i.y,s.y,e,n,r)}static tripleProductPoint4dXYW(t,e,i){return J.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w)}static crossProductXYXY(t,e,i,n){return t*n-e*i}static crossProductXYZXYZ(t,e,i,n,s,r,o){return tt.create(e*r-i*s,i*n-t*r,t*s-e*n,o)}static crossProductMagnitude(t,e,i,n,s,r){return J.hypotenuseXYZ(e*r-i*s,i*n-t*r,t*s-e*n)}static dotProductXYXY(t,e,i,n){return t*i+e*n}static dotProductXYZXYZ(t,e,i,n,s,r){return t*n+e*s+i*r}static meanCurvatureOfRadii(t,e){return.5*(this.safeDivideFraction(1,t,0)+this.safeDivideFraction(1,e,0))}static curvatureMagnitude(t,e,i,n,s,r){let o=e*r-i*s,a=o*o;o=i*n-t*r,a+=o*o,o=t*s-e*n,a+=o*o;const c=Math.sqrt(a),l=Math.sqrt(t*t+e*e+i*i),h=l*l*l;return h>J.smallAngleRadians*c?c/h:0}static clampToStartEnd(t,e,i){return e>i?J.clampToStartEnd(t,i,e):t<e?e:i<t?i:t}static clamp(t,e,i){return Math.max(e,Math.min(i,t))}static resolveNumber(t,e=0){return void 0!==t?t:e}static resolveValue(t,e){return void 0!==t?t:e}static resolveToUndefined(t,e){return t===e?void 0:t}static interpolate(t,e,i){return e<=.5?t+e*(i-t):i-(1-e)*(i-t)}static interpolateByte(t,e,i,n){return t=t>>>n&255,i=i>>>n&255,(255&Math.floor(t+e*(i-t)))<<n}static interpolateColor(t,e,i){return e=J.clamp(e,0,1),this.interpolateByte(t,e,i,0)|this.interpolateByte(t,e,i,8)|this.interpolateByte(t,e,i,16)|this.interpolateByte(t,e,i,24)}static axisOrderToAxis(t,e){const i=t<=f.ZXY?t+e:t-f.XZY-e;return J.cyclic3dAxis(i)}static modulo(t,e){if(e<=0)return 0===e?t:-J.modulo(-t,-e);if(t>=0){if(t<e)return t;if(t<2*e)return t-e}else if((t+=e)>0)return t;return t-Math.floor(t/e)*e}static defined01(t){return void 0===t?0:1}static conditionalDivideFraction(t,e){if(0!==e)return Math.abs(e)*J.largeFractionResult>=Math.abs(t)?t/e:void 0}static safeDivideFraction(t,e,i){const n=J.conditionalDivideFraction(t,e);return void 0!==n?n:i}static conditionalDivideCoordinate(t,e,i=J.largeCoordinateResult){if(0!==e)return Math.abs(e*i)>=Math.abs(t)?t/e:void 0}static solveTrigForm(t,e,i){const n=e*e+i*i;let s;if(n>0){const r=1/n,o=1-t*t*r;if(o<-J.smallMetricDistanceSquared)return s;const a=-t*r,c=a*e,l=a*i;if(o<=J.smallMetricDistanceSquared)s=[j.create(c,l)];else{const t=Math.sqrt(o*r);s=[j.create(c-t*i,l+t*e),j.create(c+t*i,l-t*e)]}}return s}static inverseInterpolate(t,e,i,n,s=0,r){const o=J.conditionalDivideFraction(s-e,n-e);return void 0!==o?J.interpolate(t,o,i):r}static inverseInterpolate01(t,e,i=0){return J.conditionalDivideFraction(i-t,e-t)}static isNumberArray(t,e=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!Number.isFinite(e))return!1;return!0}return!1}static isArrayOfNumberArray(t,e,i=0){if(Array.isArray(t)&&t.length>=e){let e;for(e of t)if(!J.isNumberArray(e,i))return!1;return!0}return!1}static stepCount(t,e,i=1,n=101){if(t<=0)return i;if(t>=(e=Math.abs(e)))return i;const s=Math.floor((e+.999999*t)/t);return s<i?i:s>n?n:s}static isIn01(t,e=!0){return!e||t>=0&&t<=1}static isIn01WithTolerance(t,e){return t+(e=Math.abs(e))>=0&&t-e<=1}static restrictToInterval(t,e,i){return e<=i?t<e?e:t>i?i:t:t<i?i:t>e?e:t}static equalStringNoCase(t,e){return t.toUpperCase()===e.toUpperCase()}static exactEqualNumberArrays(t,e){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return!1}static almostEqualArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!i(t[n],e[n]))return!1;return!0}return!1}static almostEqualNumberArrays(t,e,i){if(Array.isArray(t)&&0===t.length&&(t=void 0),Array.isArray(e)&&0===e.length&&(e=void 0),void 0===t&&void 0===e)return!0;if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!i(t[n],e[n]))return!1;return!0}return!1}static areEqualAllowUndefined(t,e,i=!0){return void 0===t&&void 0===e?i:void 0!==t&&void 0!==e&&t===e}static cloneMembers(t){if(void 0===t)return;const e=[];for(const i of t)e.push(i.clone());return e}static cloneArray(t){if(void 0===t)return;const e=[];for(const i of t)e.push(i.clone());return e}}!function(t){t.almostEqual=function(t,e,i){return J.isSameCoordinate(t.x,e.x,i)&&J.isSameCoordinate(t.y,e.y,i)&&J.isSameCoordinate(t.z,e.z,i)}}(x||(x={}));class K{x;y;z;set(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}setZero(){this.x=0,this.y=0,this.z=0}constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}static isXAndY(t){return void 0!==t.x&&void 0!==t.y}static hasZ(t){return void 0!==t.z}static isXYAndZ(t){return this.isXAndY(t)&&this.hasZ(t)}static isAnyImmediatePointType(t){return $.isXAndY(t)||J.isNumberArray(t,2)}static accessX(t,e){return void 0!==t.x?t.x:Array.isArray(t)&&t.length>0&&Number.isFinite(t[0])?t[0]:e}static accessY(t,e){return void 0!==t.y?t.y:Array.isArray(t)&&t.length>1&&Number.isFinite(t[1])?t[1]:e}static accessZ(t,e){return void 0!==t.z?t.z:Array.isArray(t)&&t.length>2&&Number.isFinite(t[2])?t[2]:e}setFrom(t){void 0===t?this.setZero():K.isXAndY(t)?(this.x=t.x,this.y=t.y,this.z=K.hasZ(t)?t.z:0):(this.x=t[0],this.y=t[1],this.z=t[2])}setFromPoint3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}setFromVector3d(t){t?(this.x=t.x,this.y=t.y,this.z=t.z):this.setZero()}isAlmostEqual(t,e){return x.almostEqual(this,t,e)}isAlmostEqualXYZ(t,e,i,n){return J.isSameCoordinate(this.x,t,n)&&J.isSameCoordinate(this.y,e,n)&&J.isSameCoordinate(this.z,i,n)}isAlmostEqualPointPlusScaledVector(t,e,i,n){return J.isSameCoordinate(this.x,t.x+e.x*i,n)&&J.isSameCoordinate(this.y,t.y+e.y*i,n)&&J.isSameCoordinate(this.z,t.z+e.z*i,n)}isAlmostEqualXY(t,e){return J.isSameCoordinate(this.x,t.x,e)&&J.isSameCoordinate(this.y,t.y,e)}toJSON(){return this.toArray()}toArray(){return[this.x,this.y,this.z]}toJSONXYZ(){return{x:this.x,y:this.y,z:this.z}}toFloat64Array(){return Float64Array.of(this.x,this.y,this.z)}setFromJSON(t){Array.isArray(t)?this.set(t[0]||0,t[1]||0,t[2]||0):t?this.set(t.x||0,t.y||0,t.z||0):this.set(0,0,0)}distance(t){const e=t.x-this.x,i=t.y-this.y,n=t.z-this.z;return Math.sqrt(e*e+i*i+n*n)}distanceSquared(t){const e=t.x-this.x,i=t.y-this.y,n=t.z-this.z;return e*e+i*i+n*n}distanceXY(t){const e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)}distanceSquaredXY(t){const e=t.x-this.x,i=t.y-this.y;return e*e+i*i}maxDiff(t){return Math.max(Math.abs(this.x-t.x),Math.abs(this.y-t.y),Math.abs(this.z-t.z))}at(t){return t<.5?this.x:t>1.5?this.z:this.y}setAt(t,e){t<.5?this.x=e:t>1.5?this.z=e:this.y=e}indexOfMaxAbs(){let t=0,e=Math.abs(this.x),i=Math.abs(this.y);return i>e&&(t=1,e=i),i=Math.abs(this.z),i>e&&(t=2),t}get isAlmostZero(){return J.isSmallMetricDistance(this.x)&&J.isSmallMetricDistance(this.y)&&J.isSmallMetricDistance(this.z)}get isZero(){return 0===this.x&&0===this.y&&0===this.z}maxAbs(){return Math.max(Math.abs(this.x),Math.abs(this.y),Math.abs(this.z))}magnitude(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}magnitudeSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}magnitudeXY(){return Math.sqrt(this.x*this.x+this.y*this.y)}magnitudeSquaredXY(){return this.x*this.x+this.y*this.y}isExactEqual(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}isAlmostEqualMetric(t){return this.maxDiff(t)<=J.smallMetricDistance}addInPlace(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}subtractInPlace(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}addScaledInPlace(t,e){this.x+=e*t.x,this.y+=e*t.y,this.z+=e*t.z}scaleInPlace(t){this.x*=t,this.y*=t,this.z*=t}addXYZInPlace(t=0,e=0,i=0){this.x+=t,this.y+=e,this.z+=i}cloneAsPoint3d(){return $.create(this.x,this.y,this.z)}vectorTo(t,e){return tt.create(t.x-this.x,t.y-this.y,t.z-this.z,e)}scaledVectorTo(t,e,i){return tt.create(e*(t.x-this.x),e*(t.y-this.y),e*(t.z-this.z),i)}unitVectorTo(t,e){return this.vectorTo(t,e).normalize(e)}freeze(){return Object.freeze(this)}static x(t,e=0){return void 0===t?e:Array.isArray(t)?t[0]:void 0!==t.x?t.x:e}static y(t,e=0){return void 0===t?e:Array.isArray(t)?t[1]:void 0!==t.y?t.y:e}static z(t,e=0){return void 0===t?e:Array.isArray(t)?t[2]:void 0!==t.z?t.z:e}}class $ extends K{constructor(t=0,e=0,i=0){super(t,e,i)}static fromJSON(t){const e=new $;return e.setFromJSON(t),e}clone(t){return $.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,n){return n?(n.x=t,n.y=e,n.z=i,n):new $(t,e,i)}static createFrom(t,e){if(t instanceof Float64Array){let i=0,n=0,s=0;return t.length>0&&(i=t[0]),t.length>1&&(n=t[1]),t.length>2&&(s=t[2]),$.create(i,n,s,e)}return $.create(t.x,t.y,K.hasZ(t)?t.z:0,e)}static createFromPacked(t,e,i){const n=3*e;if(n>=0&&n+2<t.length)return $.create(t[n],t[n+1],t[n+2],i)}static createFromPackedXYZW(t,e,i){const n=4*e;if(n>=0&&n+3<t.length){const e=t[n+3];if(!J.isSmallMetricDistance(e)){const s=1/e;return $.create(s*t[n],s*t[n+1],s*t[n+2],i)}}}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new $(t[i],t[i+1],t[i+2]));return e}static createZero(t){return $.create(0,0,0,t)}crossProductToPoints(t,e,i){return tt.createCrossProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i)}crossProductToPointsMagnitude(t,e){return J.crossProductMagnitude(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z)}tripleProductToPoints(t,e,i){return J.tripleProduct(t.x-this.x,t.y-this.y,t.z-this.z,e.x-this.x,e.y-this.y,e.z-this.z,i.x-this.x,i.y-this.y,i.z-this.z)}crossProductToPointsXY(t,e){return J.crossProductXYXY(t.x-this.x,t.y-this.y,e.x-this.x,e.y-this.y)}interpolate(t,e,i){if(t<=.5)return $.create(this.x+t*(e.x-this.x),this.y+t*(e.y-this.y),this.z+t*(e.z-this.z),i);const n=t-1;return $.create(e.x+n*(e.x-this.x),e.y+n*(e.y-this.y),e.z+n*(e.z-this.z),i)}interpolateXYZ(t,e,i,n,s){return $.create(J.interpolate(this.x,t,n.x),J.interpolate(this.y,e,n.y),J.interpolate(this.z,i,n.z),s)}interpolatePerpendicularXY(t,e,i,n){n=n||new $;const s=e.minus(this);return this.interpolate(t,e,n),n.x-=i*s.y,n.y+=i*s.x,n}minus(t,e){return $.create(this.x-t.x,this.y-t.y,this.z-t.z,e)}plus(t,e){return $.create(this.x+t.x,this.y+t.y,this.z+t.z,e)}plusXYZ(t=0,e=0,i=0,n){return $.create(this.x+t,this.y+e,this.z+i,n)}plusScaled(t,e,i){return $.create(this.x+t.x*e,this.y+t.y*e,this.z+t.z*e,i)}plus2Scaled(t,e,i,n,s){return $.create(this.x+t.x*e+i.x*n,this.y+t.y*e+i.y*n,this.z+t.z*e+i.z*n,s)}plus3Scaled(t,e,i,n,s,r,o){return $.create(this.x+t.x*e+i.x*n+s.x*r,this.y+t.y*e+i.y*n+s.y*r,this.z+t.z*e+i.z*n+s.z*r,o)}static createScale(t,e,i){return $.create(t.x*e,t.y*e,t.z*e,i)}static createAdd2Scaled(t,e,i,n,s){return $.create(t.x*e+i.x*n,t.y*e+i.y*n,t.z*e+i.z*n,s)}static createAdd3Scaled(t,e,i,n,s,r,o){return $.create(t.x*e+i.x*n+s.x*r,t.y*e+i.y*n+s.y*r,t.z*e+i.z*n+s.z*r,o)}dotVectorsToTargets(t,e){return(t.x-this.x)*(e.x-this.x)+(t.y-this.y)*(e.y-this.y)+(t.z-this.z)*(e.z-this.z)}fractionOfProjectionToLine(t,e,i=0){const n=t.distanceSquared(e);return n<J.smallMetricDistanceSquared?i:t.dotVectorsToTargets(e,this)/n}}class tt extends K{constructor(t=0,e=0,i=0){super(t,e,i)}static createArrayFromPackedXYZ(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push(new tt(t[i],t[i+1],t[i+2]));return e}clone(t){return tt.create(this.x,this.y,this.z,t)}static create(t=0,e=0,i=0,n){return n?(n.x=t,n.y=e,n.z=i,n):new tt(t,e,i)}static createCrossProduct(t,e,i,n,s,r,o){return tt.create(e*r-i*s,i*n-t*r,t*s-e*n,o)}addCrossProductToTargetsInPlace(t,e,i,n,s,r,o,a,c){const l=n-t,h=s-e,d=r-i,u=o-t,f=a-e,g=c-i;this.x+=h*g-d*f,this.y+=d*u-l*g,this.z+=l*f-h*u}static createCrossProductToPoints(t,e,i,n){return tt.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,n)}static createUnitCrossProductToPoints(t,e,i,n){return tt.createCrossProduct(e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,n).normalize()}static createPolar(t,e,i){return tt.create(t*e.cos(),t*e.sin(),i)}static createSpherical(t,e,i){const n=i.cos();return tt.create(n*t*e.cos(),n*t*e.sin(),t*i.sin())}static fromJSON(t){const e=new tt;return e.setFromJSON(t),e}static createFrom(t,e){if(t instanceof Float64Array){let i=0,n=0,s=0;return t.length>0&&(i=t[0]),t.length>1&&(n=t[1]),t.length>2&&(s=t[2]),tt.create(i,n,s,e)}return Array.isArray(t)?tt.create(t[0],t[1],t.length>2?t[2]:0):tt.create(t.x,t.y,K.hasZ(t)?t.z:0,e)}static createStartEnd(t,e,i){const n=K.accessZ(t,0),s=K.accessZ(e,0)-n;return i?(i.set(e.x-t.x,e.y-t.y,s),i):new tt(e.x-t.x,e.y-t.y,s)}static createStartEndXYZXYZ(t,e,i,n,s,r,o){return this.create(n-t,s-e,r-i,o)}static createRotateVectorAroundVector(t,e,i){const n=e.normalize();if(n){const e=n.crossProduct(t);let s,r;return i?(s=i.cos(),r=i.sin()):(s=0,r=1),tt.createAdd3Scaled(t,s,e,r,n,n.dotProduct(t)*(1-s))}}setStartEnd(t,e){this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z}static createZero(t){return tt.create(0,0,0,t)}static unitX(t=1){return new tt(t,0,0)}static unitY(t=1){return new tt(0,t,0)}static unitZ(t=1){return new tt(0,0,t)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}normalizeWithLength(t){const e=this.magnitude(),i=J.correctSmallFraction(e);return t=t||new tt,{v:this.safeDivideOrNull(i,t),mag:e}}normalize(t){return this.normalizeWithLength(t).v}normalizeInPlace(){return void 0!==this.normalizeWithLength(this).v}static createNormalized(t=0,e=0,i=0,n){if(void 0===n?n=tt.create(t,e,i):n.set(t,e,i),n.normalizeInPlace())return n}static createNormalizedStartEnd(t,e,i){if((i=tt.createStartEnd(t,e,i)).normalizeInPlace())return i}fractionOfProjectionToVector(t,e=0){const i=t.magnitudeSquared();return i<J.smallMetricDistanceSquared?e:this.dotProduct(t)/i}negate(t){return(t=t||new tt).x=-this.x,t.y=-this.y,t.z=-this.z,t}rotate90CCWXY(t){t=t||new tt;const e=this.x,i=this.y;return t.x=-i,t.y=e,t.z=this.z,t}rotate90CWXY(t){t=t||new tt;const e=this.x,i=this.y;return t.x=i,t.y=-e,t.z=this.z,t}unitPerpendicularXY(t){t=t||new tt;const e=this.x,i=this.y;t.x=-i,t.y=e,t.z=0;const n=e*e+i*i;if(0!==n){const e=1/Math.sqrt(n);t.x*=e,t.y*=e}return t}rotateXY(t,e){const i=t.sin(),n=t.cos(),s=this.x,r=this.y;return(e=e||new tt).x=s*n-r*i,e.y=s*i+r*n,e.z=this.z,e}rotate90Towards(t,e){const i=this.crossProduct(t).normalize();return i?i.crossProduct(this,e):void 0}rotate90Around(t,e){const i=t.normalize();return i?i.crossProduct(this).plusScaled(i,i.dotProduct(this),e):void 0}interpolate(t,e,i){if(i=i||new tt,t<=.5)i.x=this.x+t*(e.x-this.x),i.y=this.y+t*(e.y-this.y),i.z=this.z+t*(e.z-this.z);else{const n=t-1;i.x=e.x+n*(e.x-this.x),i.y=e.y+n*(e.y-this.y),i.z=e.z+n*(e.z-this.z)}return i}plus(t,e){return(e=e||new tt).x=this.x+t.x,e.y=this.y+t.y,e.z=this.z+t.z,e}minus(t,e){return(e=e||new tt).x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z,e}plusScaled(t,e,i){return(i=i||new tt).x=this.x+t.x*e,i.y=this.y+t.y*e,i.z=this.z+t.z*e,i}plus2Scaled(t,e,i,n,s){return(s=s||new tt).x=this.x+t.x*e+i.x*n,s.y=this.y+t.y*e+i.y*n,s.z=this.z+t.z*e+i.z*n,s}plus3Scaled(t,e,i,n,s,r,o){return(o=o||new tt).x=this.x+t.x*e+i.x*n+s.x*r,o.y=this.y+t.y*e+i.y*n+s.y*r,o.z=this.z+t.z*e+i.z*n+s.z*r,o}static createAdd2Scaled(t,e,i,n,s){return tt.create(t.x*e+i.x*n,t.y*e+i.y*n,t.z*e+i.z*n,s)}static createAdd2ScaledXYZ(t,e,i,n,s,r,o,a,c){return tt.create(t*n+s*a,e*n+r*a,i*n+o*a,c)}static createAdd3Scaled(t,e,i,n,s,r,o){return tt.create(t.x*e+i.x*n+s.x*r,t.y*e+i.y*n+s.y*r,t.z*e+i.z*n+s.z*r,o)}scale(t,e){return(e=e||new tt).x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scaleToLength(t,e){const i=J.correctSmallFraction(this.magnitude());if(0!==i)return this.scale(t/i,e)}unitCrossProduct(t,e){return this.crossProduct(t,e).normalize(e)}unitCrossProductWithDefault(t,e,i,n,s){const r=this.crossProduct(t,s).normalize(s);return void 0===r?tt.create(e,i,n,s):r}normalizeWithDefault(t,e,i,n){return this.normalize(n)||((n=tt.create(t,e,i,n)).normalizeInPlace()?n:tt.create(1,0,0,n))}tryNormalizeInPlace(t=J.smallFraction){const e=this.magnitude();return!(e<t||0===e||(this.scaleInPlace(1/e),0))}sizedCrossProduct(t,e,i){if((i=this.crossProduct(t,i)).tryNormalizeInPlace())return i.scaleInPlace(e),i}crossProductMagnitudeSquared(t){const e=this.y*t.z-this.z*t.y,i=this.z*t.x-this.x*t.z,n=this.x*t.y-this.y*t.x;return e*e+i*i+n*n}crossProductMagnitude(t){return Math.sqrt(this.crossProductMagnitudeSquared(t))}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}static dotProductAsXYAndZ(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}dotProductStartEnd(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)+this.z*(e.z-t.z)}dotProductStart3dEnd4d(t,e){const i=e.w;return this.x*(e.x-t.x*i)+this.y*(e.y-t.y*i)+this.z*(e.z-t.z*i)}crossProductStartEnd(t,e,i){return tt.createCrossProduct(this.x,this.y,this.z,e.x-t.x,e.y-t.y,e.z-t.z,i)}crossProductStartEndXY(t,e){return J.crossProductXYXY(this.x,this.y,e.x-t.x,e.y-t.y)}dotProductStartEndXYZ(t,e,i,n){return this.x*(e-t.x)+this.y*(i-t.y)+this.z*(n-t.z)}dotProductStartEndXY(t,e){return this.x*(e.x-t.x)+this.y*(e.y-t.y)}dotProductStartEndXYZW(t,e,i,n,s){if(J.isSmallMetricDistance(s))return 0;const r=1/s;return this.x*(r*e-t.x)+this.y*(r*i-t.y)+this.z*(r*n-t.z)}dotProductXY(t){return this.x*t.x+this.y*t.y}dotProductXYZ(t,e,i=0){return this.x*t+this.y*e+this.z*i}tripleProduct(t,e){return J.tripleProduct(this.x,this.y,this.z,t.x,t.y,t.z,e.x,e.y,e.z)}crossProductXY(t){return this.x*t.y-this.y*t.x}crossProduct(t,e){return tt.createCrossProduct(this.x,this.y,this.z,t.x,t.y,t.z,e)}crossProductXYZ(t,e,i,n){return tt.createCrossProduct(this.x,this.y,this.z,t,e,i,n)}radiansTo(t){return Math.atan2(this.crossProductMagnitude(t),this.dotProduct(t))}angleTo(t){return G.createRadians(this.radiansTo(t))}angleFromPerpendicular(t){return G.createAtan2(this.dotProduct(t),this.crossProductMagnitude(t))}radiansFromPerpendicular(t){return Math.atan2(this.dotProduct(t),this.crossProductMagnitude(t))}angleToXY(t){return G.createAtan2(this.crossProductXY(t),this.dotProductXY(t))}signedRadiansTo(t,e){const i=this.crossProduct(t),n=Math.atan2(i.magnitude(),this.dotProduct(t));return e.dotProduct(i)<0?-n:n}signedAngleTo(t,e){return G.createRadians(this.signedRadiansTo(t,e))}planarRadiansTo(t,e){const i=e.dotProduct(e);if(0===i)return 0;const n=1/i,s=this.plusScaled(e,-this.dotProduct(e)*n),r=t.plusScaled(e,-t.dotProduct(e)*n);return s.signedRadiansTo(r,e)}planarAngleTo(t,e){return G.createRadians(this.planarRadiansTo(t,e))}smallerUnorientedRadiansTo(t){const e=this.dotProduct(t),i=this.crossProductMagnitude(t);return Math.atan2(Math.abs(i),Math.abs(e))}smallerUnorientedAngleTo(t){return G.createRadians(this.smallerUnorientedRadiansTo(t))}isParallelTo(t,e=!1,i=!1,n){const s=n?.radianSquaredTol??J.smallAngleRadiansSquared,r=n?.distanceSquaredTol??J.smallMetricDistanceSquared,o=this.magnitudeSquared(),a=t.magnitudeSquared();return o<r||a<r?i:!(this.dotProduct(t)<0&&!e)&&this.crossProductMagnitudeSquared(t)<=s*o*a}isPerpendicularTo(t,e=!1,i){const n=i?.radianSquaredTol??J.smallAngleRadiansSquared,s=i?.distanceSquaredTol??J.smallMetricDistanceSquared,r=this.magnitudeSquared(),o=t.magnitudeSquared();if(r<s||o<s)return e;const a=this.dotProduct(t);return a*a<=n*r*o}}class et{isPointInPlane(t,e=J.smallMetricDistance){return Math.abs(this.altitude(t))<=e}classifyAltitude(t,e=J.smallMetricDistance){return J.split3Way01(this.altitude(t),e)}classifyAltitudeXYZ(t,e,i,n=J.smallMetricDistance){return J.split3Way01(this.altitudeXYZ(t,e,i),n)}getUnitNormal(t){return tt.createNormalized(this.normalX(),this.normalY(),this.normalZ(),t)}getAnyPointOnPlane(t){return this.projectXYZToPlane(0,0,0,t)}projectXYZToPlane(t,e,i,n){const s=$.create(t,e,i,n);return this.projectPointToPlane(s,s)}}class it{_collection;_curIndex=-1;constructor(t){this._collection=t}next(){return++this._curIndex>=this._collection.length?{done:!0}:{value:this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),done:!1}}[Symbol.iterator](){return this}}class nt{vectorIndexXYAndZ(t,e,i){const n=this.vectorXYAndZIndex(e,t,i);return n?.negate(n)}dotProductIndexIndexIndex(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length||i<0||i>=this.length)return;const n=this.getXAtUncheckedPointIndex(t),s=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-n)*(this.getXAtUncheckedPointIndex(i)-n)+(this.getYAtUncheckedPointIndex(e)-s)*(this.getYAtUncheckedPointIndex(i)-s)+(this.getZAtUncheckedPointIndex(e)-r)*(this.getZAtUncheckedPointIndex(i)-r)}dotProductIndexIndexXYAndZ(t,e,i){if(t<0||t>=this.length||e<0||e>=this.length)return;const n=this.getXAtUncheckedPointIndex(t),s=this.getYAtUncheckedPointIndex(t),r=this.getZAtUncheckedPointIndex(t);return(this.getXAtUncheckedPointIndex(e)-n)*(i.x-n)+(this.getYAtUncheckedPointIndex(e)-s)*(i.y-s)+(this.getZAtUncheckedPointIndex(e)-r)*(i.z-r)}crossProductIndexIndexXYAndZ(t,e,i,n){if(t<0||t>=this.length||e<0||e>=this.length)return;const s=this.getXAtUncheckedPointIndex(t),r=this.getYAtUncheckedPointIndex(t),o=this.getZAtUncheckedPointIndex(t);return tt.createCrossProduct(this.getXAtUncheckedPointIndex(e)-s,this.getYAtUncheckedPointIndex(e)-r,this.getZAtUncheckedPointIndex(e)-o,i.x-s,i.y-r,i.z-o,n)}distanceSquaredIndexXYAndZ(t,e){if(!(t<0||t>=this.length))return J.hypotenuseSquaredXYZ(e.x-this.getXAtUncheckedPointIndex(t),e.y-this.getYAtUncheckedPointIndex(t),e.z-this.getZAtUncheckedPointIndex(t))}isIndexValid(t){return t>=0&&t<this.length}cyclicIndex(t){return t%this.length}getRange(t,e){let i=e;i?i.setNull():i=ft.createNull();const n=this.length,s=$.create();for(let e=0;e<n;e++)this.getPoint3dAtUncheckedPointIndex(e,s),i.extendPoint(s,t);return i}findOrderedDuplicates(t=J.smallMetricDistance,e=!1){const i=[];if(this.length>1){for(let e=0;e<this.length-1;){let n=e+1;for(;this.almostEqualIndexIndex(e,n,t);++n)i.push(n);e=n}if(e&&i.length>0&&i.length<this.length-1){let t=0;for(;t<=i.length-1&&i[i.length-1-t]===this.length-1-t;++t);for(let e=0;e<t;++e)i[i.length-1-e]-=1}}return i}linearCombination(t,e){const i=Math.min(this.length,t.length),n=e instanceof tt?tt.createZero(e):$.createZero(e);for(let e=0;e<i;++e)n.x+=t[e]*this.getXAtUncheckedPointIndex(e),n.y+=t[e]*this.getYAtUncheckedPointIndex(e),n.z+=t[e]*this.getZAtUncheckedPointIndex(e);return n}interpolateIndexIndex(t,e,i,n){if(!(t<0||t>=this.length||i<0||i>=this.length))return $.create(J.interpolate(this.getXAtUncheckedPointIndex(t),e,this.getXAtUncheckedPointIndex(i)),J.interpolate(this.getYAtUncheckedPointIndex(t),e,this.getYAtUncheckedPointIndex(i)),J.interpolate(this.getZAtUncheckedPointIndex(t),e,this.getZAtUncheckedPointIndex(i)),n)}get points(){return new it(this)}getArray(){const t=[];for(const e of this.points)t.push(e);return t}front(t){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(0,t)}back(t){if(0!==this.length)return this.getPoint3dAtUncheckedPointIndex(this.length-1,t)}almostEqualIndexIndex(t,e,i=J.smallMetricDistance){if(!(t<0||t>=this.length||e<0||e>=this.length))return J.isSameCoordinate(this.getXAtUncheckedPointIndex(t),this.getXAtUncheckedPointIndex(e),i)&&J.isSameCoordinate(this.getYAtUncheckedPointIndex(t),this.getYAtUncheckedPointIndex(e),i)&&J.isSameCoordinate(this.getZAtUncheckedPointIndex(t),this.getZAtUncheckedPointIndex(e),i)}}class st extends nt{}class rt extends st{_data;_xyzInUse;_xyzCapacity;_growthFactor;constructor(t=8,e){super(),this._data=new Float64Array(3*t),this._xyzInUse=0,this._xyzCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let n=void 0!==i?3*i:0;if(n<0&&(n=0),n>=this._data.length)return{count:0,offset:0};let s=void 0!==e?3*e:t.length;return s>0&&(s>t.length&&(s=t.length),n+s>this._data.length&&(s=this._data.length-n),s%3!=0&&(s-=s%3)),s<=0?{count:0,offset:0}:(s===t.length?this._data.set(t,n):t instanceof Float64Array?this._data.set(t.subarray(0,s),n):this._data.set(t.slice(0,s),n),{count:s/3,offset:n/3})}get length(){return this._xyzInUse}set length(t){this.resize(t,!0)}get float64Length(){return 3*this._xyzInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyzCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(3*t),this.copyData(i,this._xyzInUse),this._xyzCapacity=t}}resize(t,e){t>=0&&t<this._xyzInUse?this._xyzInUse=t:t>this._xyzInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,3*this._xyzInUse),this._xyzInUse=t)}clone(t){return t?(t.length!==this.length&&t.clear(),t.resize(this.length)):t=new rt(this.length),t.copyData(this._data,this.length),t._xyzInUse=this.length,t}static createCompressed(t,e=J.smallMetricDistance,i){const n=t.findOrderedDuplicates(e,!0),s=t.length-n.length;i||(i=new rt(s)),i!==t&&(i.clear(),i.resize(s,!0));for(let e=0,s=0,r=0;e<t.length;++e)r<n.length&&e===n[r]?++r:i.transferFromGrowableXYZArray(s++,t,e);return i.resize(s),i}cloneCompressed(t=J.smallMetricDistance,e){return rt.createCompressed(this,t,e)}compressInPlace(t=J.smallMetricDistance){return rt.createCompressed(this,t,this)}static create(t,e){if(e)e.clear();else{const i="number"==typeof t[0]?t.length/3:t.length;e=new rt(i)}return e.pushFrom(t),e}static createArrayOfGrowableXYZArray(t){const e=new ct;return dt.streamXYZ(t,e),e.claimArrayOfGrowableXYZArray()}push(t){this.pushXYZ(t.x,t.y,t.z)}pushAll(t){this.ensureCapacity(this._xyzInUse+t.length,!1);for(const e of t)this.push(e)}pushFrom(t){if(t instanceof $)this.pushXYZ(t.x,t.y,t.z);else if(t instanceof rt)this.pushFromGrowableXYZArray(t);else if(t instanceof H)this.pushXYZ(t.x,t.y,0);else if(J.isNumberArray(t,4)||t instanceof Float64Array){const e=Math.trunc(t.length/3);this.ensureCapacity(this._xyzInUse+e,!1),this.copyData(t,e,this._xyzInUse),this._xyzInUse+=e}else if(J.isNumberArray(t,3))this.pushXYZ(t[0],t[1],t[2]);else if(J.isNumberArray(t,2))this.pushXYZ(t[0],t[1],0);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if($.isXYAndZ(t))this.pushXYZ(t.x,t.y,t.z);else if($.isXAndY(t))this.pushXYZ(t.x,t.y,0);else if(t instanceof nt){const e=t.length;this.ensureCapacity(this._xyzInUse+e,!1);for(let i=0;i<e;i++)this.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}}pushWrap(t){if(this._xyzInUse>=t){this.ensureCapacity(this._xyzInUse+t,!1);for(let e=0;e<t;e++){const t=3*e;this.pushXYZ(this._data[t],this._data[t+1],this._data[t+2])}}}pushXYZ(t,e,i){this.ensureCapacity(this._xyzInUse+1);const n=3*this._xyzInUse;this._data[n]=t,this._data[n+1]=e,this._data[n+2]=i,this._xyzInUse++}shiftForward(t){if(t<=0)return;this.ensureCapacity(this._xyzInUse+t);const e=3*t,i=3*this._xyzInUse;this._data.copyWithin(e,0,i),this._xyzInUse+=t}pushFrontXYZ(t,e,i){this.shiftForward(1),this._data[0]=t,this._data[1]=e,this._data[2]=i}pushFront(t){this.pushFrontXYZ(t.x,t.y,t.z)}moveIndexToIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){let i=3*t,n=3*e;this._data[n++]=this._data[i++],this._data[n++]=this._data[i++],this._data[n]=this._data[i]}}pop(){this._xyzInUse>0&&this._xyzInUse--}clear(){this._xyzInUse=0}getPoint3dAtUncheckedPointIndex(t,e){const i=3*t;return $.create(this._data[i],this._data[i+1],this._data[i+2],e)}getPoint2dAtUncheckedPointIndex(t,e){const i=3*t;return H.create(this._data[i],this._data[i+1],e)}getVector3dAtUncheckedVectorIndex(t,e){const i=3*t;return tt.create(this._data[i],this._data[i+1],this._data[i+2],e)}getPoint3dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return $.create(this._data[i],this._data[i+1],this._data[i+2],e)}}getXAtUncheckedPointIndex(t){const e=3*t;return this._data[e]}getYAtUncheckedPointIndex(t){const e=3*t;return this._data[e+1]}getZAtUncheckedPointIndex(t){const e=3*t;return this._data[e+2]}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return H.create(this._data[i],this._data[i+1],e)}}getVector3dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=3*t;return tt.create(this._data[i],this._data[i+1],this._data[i+2],e)}}transferFromGrowableXYZArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const n=3*t;return this._data[n]=e.getXAtUncheckedPointIndex(i),this._data[n+1]=e.getYAtUncheckedPointIndex(i),this._data[n+2]=e.getZAtUncheckedPointIndex(i),!0}return!1}pushFromGrowableXYZArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyzInUse+=e,e}if(t.isIndexValid(e)){const i=3*e;return this.pushXYZ(t._data[i],t._data[i+1],t._data[i+2]),1}return 0}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;let i=3*t;return this._data[i++]=e.x,this._data[i++]=e.y,this._data[i]=e.z,!0}setXYZAtCheckedPointIndex(t,e,i,n){if(!this.isIndexValid(t))return!1;let s=3*t;return this._data[s++]=e,this._data[s++]=i,this._data[s]=n,!0}getPoint3dArray(){const t=3*this._xyzInUse,e=[],i=this._data;for(let n=0;n<t;n+=3)e.push($.create(i[n],i[n+1],i[n+2]));return e}static multiplyTransformInPlace(t,e){if(Array.isArray(e))for(const i of e)i.multiplyTransformInPlace(t);else e.multiplyTransformInPlace(t)}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,n=t.matrix.coffs,s=t.origin,r=s.x,o=s.y,a=s.z;let c=0,l=0,h=0;for(let t=0;t+2<=i;t+=3)c=e[t],l=e[t+1],h=e[t+2],e[t]=n[0]*c+n[1]*l+n[2]*h+r,e[t+1]=n[3]*c+n[4]*l+n[5]*h+o,e[t+2]=n[6]*c+n[7]*l+n[8]*h+a}reverseInPlace(){const t=this.length;let e,i,n;const s=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=3*r,i=3*o,n=s[e],s[e]=s[i],s[i]=n,e++,i++,n=s[e],s[e]=s[i],s[i]=n,e++,i++,n=s[e],s[e]=s[i],s[i]=n}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,n=t.coffs;let s=0,r=0,o=0;for(let t=0;t+2<=i;t+=3)s=e[t],r=e[t+1],o=e[t+2],e[t]=n[0]*s+n[1]*r+n[2]*o,e[t+1]=n[3]*s+n[4]*r+n[5]*o,e[t+2]=n[6]*s+n[7]*r+n[8]*o}multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t){const e=this._data,i=this.float64Length;if(!t.computeCachedInverse(!0))return!1;const n=t.inverseCoffs,s=J.smallFloatingPoint;let r,o,a,c,l,h=0,d=0,u=0,f=0;for(let t=0;t+2<=i;t+=3)h=e[t],d=e[t+1],u=e[t+2],r=n[0]*h+n[3]*d+n[6]*u,o=n[1]*h+n[4]*d+n[7]*u,a=n[2]*h+n[5]*d+n[8]*u,l=r*r+o*o+a*a,l<s?(r=h,o=d,a=u,f++):Math.abs(l-1)>s&&(c=1/Math.sqrt(l),r*=c,o*=c,a*=c),e[t]=r,e[t+1]=o,e[t+2]=a;return 0===f}multiplyMatrix4dAndQuietRenormalizeMatrix4d(t){const e=this._data,i=this.float64Length,n=$.create();for(let s=0;s+2<=i;s+=3)t.multiplyXYZWQuietRenormalize(e[s],e[s+1],e[s+2],1,n),e[s]=n.x,e[s+1]=n.y,e[s+2]=n.z}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,n=t.matrix;n.computeCachedInverse(!0);const s=n.inverseCoffs;if(!s)return!1;const r=t.origin,o=r.x,a=r.y,c=r.z;let l=0,h=0,d=0;for(let t=0;t+2<i;t+=3)l=e[t]-o,h=e[t+1]-a,d=e[t+2]-c,e[t]=s[0]*l+s[1]*h+s[2]*d,e[t+1]=s[3]*l+s[4]*h+s[5]*d,e[t+2]=s[6]*l+s[7]*h+s[8]*d;return!0}extendRange(t,e){const i=this.float64Length,n=this._data;if(e)for(let s=0;s+2<i;s+=3)t.extendTransformedXYZ(e,n[s],n[s+1],n[s+2]);else for(let e=0;e+2<i;e+=3)t.extendXYZ(n[e],n[e+1],n[e+2])}getRange(t,e){let i=e;return i?i.setNull():i=ft.createNull(),this.extendRange(i,t),i}setRange(t,e){t.setNull(),this.extendRange(t,e)}sumLengths(){let t=0;const e=3*(this._xyzInUse-1),i=this._data;for(let n=0;n<e;n+=3)t+=J.hypotenuseXYZ(i[n+3]-i[n],i[n+4]-i[n+1],i[n+5]-i[n+2]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}isCloseToPlane(t,e=J.smallMetricDistance){const i=3*this._xyzInUse,n=this._data;for(let s=0;s<i;s+=3)if(Math.abs(t.altitudeXYZ(n[s],n[s+1],n[s+2]))>e)return!1;return!0}forceClosure(t=J.smallMetricDistance){const e=this.distanceIndexIndex(0,this.length-1);if(void 0===e);else if(e>t)this.pushXYZ(this._data[0],this._data[1],this._data[2]);else if(e>0){const t=this._data.length-3;for(let e=0;e<3;e++)this._data[t+e]=this._data[e]}}interpolate(t,e,i,n){if(this.isIndexValid(t)&&this.isIndexValid(i)){const s=1-e,r=this._data;return t*=3,i*=3,$.create(s*r[t]+e*r[i],s*r[t+1]+e*r[i+1],s*r[t+2]+e*r[i+2],n)}}pushInterpolatedFromGrowableXYZArray(t,e,i,n){if(t.isIndexValid(e)&&t.isIndexValid(n)){const s=1-i,r=t._data;e*=3,n*=3,this.pushXYZ(s*r[e]+i*r[n],s*r[e+1]+i*r[n+1],s*r[e+2]+i*r[n+2])}}areaXY(){let t=0;const e=3*this._xyzInUse;if(e>6){const i=this._data[e-3],n=this._data[e-2];let s=this._data[0]-i,r=this._data[1]-n,o=0,a=0;for(let c=3;c<e;c+=3,s=o,r=a)o=this._data[c]-i,a=this._data[c+1]-n,t+=J.crossProductXYXY(s,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const n=this._data;return t*=3,e*=3,tt.create(n[e]-n[t],n[e+1]-n[t+1],n[e+2]-n[t+2],i)}vectorXYAndZIndex(t,e,i){if(this.isIndexValid(e)){const n=this._data;return e*=3,tt.create(n[e]-t.x,n[e+1]-t.y,n[e+2]-t.z,i)}}crossProductIndexIndexIndex(t,e,i,n){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const s=3*t,r=3*e,o=3*i,a=this._data;return J.crossProductXYZXYZ(a[r]-a[s],a[r+1]-a[s+1],a[r+2]-a[s+2],a[o]-a[s],a[o+1]-a[s+1],a[o+2]-a[s+2],n)}}evaluateUncheckedIndexDotProductXYZ(t,e,i,n){const s=3*t,r=this._data;return r[s]*e+r[s+1]*i+r[s+2]*n}evaluateUncheckedIndexPlaneAltitude(t,e){const i=3*t,n=this._data;return e.altitudeXYZ(n[i],n[i+1],n[i+2])}accumulateCrossProductIndexIndexIndex(t,e,i,n){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const s=3*t,r=3*e,o=3*i,a=this._data;n.addCrossProductToTargetsInPlace(a[s],a[s+1],a[s+2],a[r],a[r+1],a[r+2],a[o],a[o+1],a[o+2])}}accumulateScaledXYZ(t,e,i){if(this.isIndexValid(t)){const n=3*t,s=this._data;i.x+=e*s[n],i.y+=e*s[n+1],i.z+=e*s[n+2]}}crossProductXYAndZIndexIndex(t,e,i,n){if(this.isIndexValid(e)&&this.isIndexValid(i)){const s=3*e,r=3*i,o=this._data;return J.crossProductXYZXYZ(o[s]-t.x,o[s+1]-t.y,o[s+2]-t.z,o[r]-t.x,o[r+1]-t.y,o[r+2]-t.z,n)}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=3*t;return J.hypotenuseXYZ(e.x-this._data[i],e.y-this._data[i+1],e.z-this._data[i+2])}}distanceSquaredIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,n=3*e;return J.hypotenuseSquaredXYZ(this._data[n]-this._data[i],this._data[n+1]-this._data[i+1],this._data[n+2]-this._data[i+2])}}distanceIndexIndex(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=3*t,n=3*e;return J.hypotenuseXYZ(this._data[n]-this._data[i],this._data[n+1]-this._data[i+1],this._data[n+2]-this._data[i+2])}}static distanceBetweenPointsIn2Arrays(t,e,i,n){if(t.isIndexValid(e)&&i.isIndexValid(n)){const s=3*e,r=3*n;return J.hypotenuseXYZ(i._data[r]-t._data[s],i._data[r+1]-t._data[s+1],i._data[r+2]-t._data[s+2])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint3dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyzInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,n=0;for(let s=0;s<3;s++){if(i=this._data[3*t+s],n=this._data[3*e+s],i>n)return 1;if(i<n)return-1}return t-e}component(t,e){return this._data[3*t+e]}addSteppedPoints(t,e,i,n){const s=t._data;let r=3*e;const o=3*t.length;let a=0;for(this.ensureCapacity(this._xyzInUse+n,!1);r>=0&&r+2<o&&a<n;)this.pushXYZ(s[r],s[r+1],s[r+2]),r+=3*i,a++}static distanceRangeBetweenCorrespondingPoints(t,e){const i=t._data,n=e._data,s=Math.min(t.length,e.length);let r,o=0;const a=gt.createNull();for(;o<s;)r=3*o,a.extendX(J.hypotenuseXYZ(i[r]-n[r],i[r+1]-n[r+1],i[r+2]-n[r+2])),o++;return a}static removeClosure(t,e=J.smallMetricDistance){for(;t.length>1&&t.distanceIndexIndex(0,t.length-1)<e;)t.pop()}fillLocalXYTriangleFrame(t,e,i,n){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){let s=3*t;const r=this._data,o=r[s++],a=r[s++],c=r[s++];s=3*e;const l=r[s++]-o,h=r[s++]-a,d=r[s++]-c;s=3*i;const u=r[s++]-o,f=r[s++]-a,g=r[s++]-c;return(n=mt.createRowValues(l,u,0,o,h,f,0,a,d,g,1,c,n)).computeCachedInverse()?n:void 0}}mapComponent(t,e){const i=this._data.length;let n;for(let s=0;s+2<i;s+=3)n=e(this._data[s],this._data[s+1],this._data[s+2]),this._data[s+t]=n}mapPoint(t){const e=this._data.length;let i;for(let n=0;n+2<e;n+=3)i=t(this._data[n],this._data[n+1],this._data[n+2]),this._data[n]=i.x,this._data[n+1]=i.y,this._data[n+2]=i.z}}class ot{startChain(t,e){}handleXYZ(t,e,i){}endChain(t,e){}}class at extends ot{_x0;_y0;_z0;handleXYZ(t,e,i){void 0!==this._x0&&this.handleXYZXYZ(this._x0,this._y0,this._z0,t,e,i),this._x0=t,this._y0=e,this._z0=i}startChain(t,e){this._x0=this._y0=this._z0=void 0}handleXYZXYZ(t,e,i,n,s,r){}}class ct extends ot{_pointArrays;_currentData;startChain(t,e){this._currentData=void 0}handleXYZ(t,e,i){this._currentData||(this._currentData=new rt),this._currentData.pushXYZ(t,e,i)}endChain(t,e){void 0!==this._currentData&&(void 0===this._pointArrays&&(this._pointArrays=[]),this._pointArrays.push(this._currentData),this._currentData=void 0)}claimArrayOfGrowableXYZArray(){const t=this._pointArrays;return this._pointArrays=void 0,t}}class lt extends ot{_range=ft.createNull();handleXYZ(t,e,i){this._range||(this._range=ft.createNull()),this._range.extendXYZ(t,e,i)}claimResult(){const t=this._range;return this._range=void 0,t||ft.createNull()}}class ht{_resultStack;_xyzFunction;constructor(t){this._xyzFunction=t,this._resultStack=[],this._resultStack.push([])}startChain(t,e){this._resultStack.push([])}handleXYZ(t,e,i){this._resultStack[this._resultStack.length-1].push(this._xyzFunction(t,e,i))}endChain(t,e){const i=this._resultStack[this._resultStack.length-1];this._resultStack.pop(),this._resultStack[this._resultStack.length-1].push(i)}claimResult(){const t=this._resultStack[0];return 1===t.length?t[0]:t}}class dt{static _workPoint;static streamXYZ(t,e){let i=0;if(Array.isArray(t))if(t.length>0&&$.isAnyImmediatePointType(t[0])){e.startChain(t,!0);for(const n of t){const t=$.accessX(n),s=$.accessY(n),r=$.accessZ(n,0);void 0!==t&&void 0!==s&&e.handleXYZ(t,s,r),i++}e.endChain(t,!0)}else{e.startChain(t,!1);for(const n of t)i+=this.streamXYZ(n,e);e.endChain(t,!1)}else if(t instanceof nt){e.startChain(t,!0);const n=dt._workPoint=$.create(0,0,0,dt._workPoint);for(let s=0;s<t.length;s++)t.getPoint3dAtCheckedPointIndex(s,n),i++,e.handleXYZ(n.x,n.y,n.z);e.endChain(t,!0)}return i}}class ut{static _EXTREME_POSITIVE=1e200;static _EXTREME_NEGATIVE=-1e200;static npcScaleFactor(t,e){return e<=t?0:1/(e-t)}static isExtremeValue(t){return Math.abs(t)>=ut._EXTREME_POSITIVE}static isExtremePoint3d(t){return ut.isExtremeValue(t.x)||ut.isExtremeValue(t.y)||ut.isExtremeValue(t.z)}static isExtremePoint2d(t){return ut.isExtremeValue(t.x)||ut.isExtremeValue(t.y)}static rangeToRangeAbsoluteDistance(t,e,i,n){return e<t||n<i?ut._EXTREME_POSITIVE:n<t?t-n:n<=e||i<=e?0:i-e}static coordinateToRangeAbsoluteDistance(t,e,i){return i<e?ut._EXTREME_POSITIVE:t<e?e-t:t>i?t-i:0}static multiplyIfPositive(t,e,i=0){return t>0?e*t:i}}class ft extends ut{low;high;setNull(){this.low.x=ut._EXTREME_POSITIVE,this.low.y=ut._EXTREME_POSITIVE,this.low.z=ut._EXTREME_POSITIVE,this.high.x=ut._EXTREME_NEGATIVE,this.high.y=ut._EXTREME_NEGATIVE,this.high.z=ut._EXTREME_NEGATIVE}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z)}toFloat64Array(){return ft.toFloat64Array(this)}static fromFloat64Array(t){if(6!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3],t[4],t[5])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=ut._EXTREME_POSITIVE,e=ut._EXTREME_POSITIVE,i=ut._EXTREME_POSITIVE,n=ut._EXTREME_NEGATIVE,s=ut._EXTREME_NEGATIVE,r=ut._EXTREME_NEGATIVE){super(),this.low=$.create(t,e,i),this.high=$.create(n,s,r)}isAlmostEqual(t,e){return this.low.isAlmostEqual(t.low,e)&&this.high.isAlmostEqual(t.high,e)||this.isNull&&t.isNull}setFrom(t){this.low.setFrom(t.low),this.high.setFrom(t.high)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYZXYZOrCorrectToNull(t.low.x,t.low.y,t.low.z,t.high.x,t.high.y,t.high.z,e)}setFromJSON(t){if(!t)return;if(this.setNull(),Array.isArray(t)){const e=$.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=$.fromJSON(t.low),i=$.fromJSON(t.high);ut.isExtremePoint3d(e)||ut.isExtremePoint3d(i)||(this.extendPoint(e),this.extendPoint(i))}toJSON(){return{low:this.low.toJSON(),high:this.high.toJSON()}}static fromJSON(t){const e=new this;return e.setFromJSON(t),e}setDirect(t,e,i,n,s,r,o){this.low.x=t,this.low.y=e,this.low.z=i,this.high.x=n,this.high.y=s,this.high.z=r,o&&(this.low.x>this.high.x||this.low.y>this.high.y||this.low.z>this.high.z)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.low.z,this.high.x,this.high.y,this.high.z,!1),t}cloneTranslated(t,e){return e=e||new this.constructor,this.isNull||e.setDirect(this.low.x+t.x,this.low.y+t.y,this.low.z+t.z,this.high.x+t.x,this.high.y+t.y,this.high.z+t.z,!1),e}static createNull(t){return(t=t||new this).setNull(),t}extend(...t){let e;for(e of t)this.extendPoint(e)}static create(...t){const e=ft.createNull();let i;for(i of t)e.extendPoint(i);return e}static createFromVariantData(t){const e=new lt;return dt.streamXYZ(t,e),e.claimResult()}static createTransformed(t,...e){const i=this.createNull();let n;for(n of e)i.extendTransformedXYZ(t,n.x,n.y,n.z);return i}static createTransformedArray(t,e){const i=this.createNull();return i.extendArray(e,t),i}static createInverseTransformedArray(t,e){const i=this.createNull();return i.extendInverseTransformedArray(e,t),i}setXYZ(t,e,i){this.low.x=this.high.x=t,this.low.y=this.high.y=e,this.low.z=this.high.z=i}static createXYZ(t,e,i,n){return(n=n||new this).setDirect(t,e,i,t,e,i,!1),n}static createXYZXYZ(t,e,i,n,s,r,o){return(o=o||new this).setDirect(Math.min(t,n),Math.min(e,s),Math.min(i,r),Math.max(t,n),Math.max(e,s),Math.max(i,r),!1),o}static createXYZXYZOrCorrectToNull(t,e,i,n,s,r,o){return o=o||new this,t>n||e>s||i>r?this.createNull(o):(o.setDirect(Math.min(t,n),Math.min(e,s),Math.min(i,r),Math.max(t,n),Math.max(e,s),Math.max(i,r),!0),o)}static createRange2d(t,e=0,i){const n=i||new this;return n.setNull(),n.extendXYZ(t.low.x,t.low.y,e),n.extendXYZ(t.high.x,t.high.y,e),n}static createArray(t,e){let i;for(i of((e=e||new this).setNull(),t))e.extendPoint(i);return e}extendArray(t,e){if(Array.isArray(t))if(e)for(const i of t)this.extendTransformedXYZ(e,i.x,i.y,i.z);else for(const e of t)this.extendXYZ(e.x,e.y,e.z);else if(e)for(let i=0;i<t.length;i++)this.extendTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i));else for(let e=0;e<t.length;e++)this.extendXYZ(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e))}extendInverseTransformedArray(t,e){if(Array.isArray(t))for(const i of t)this.extendInverseTransformedXYZ(e,i.x,i.y,i.z);else for(let i=0;i<t.length;i++)this.extendInverseTransformedXYZ(e,t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i))}extendTransformedXYZ(t,e,i,n){const s=t.origin,r=t.matrix.coffs;this.extendXYZ(s.x+r[0]*e+r[1]*i+r[2]*n,s.y+r[3]*e+r[4]*i+r[5]*n,s.z+r[6]*e+r[7]*i+r[8]*n)}extendTransformedXYZW(t,e,i,n,s){const r=t.origin,o=t.matrix.coffs;this.extendXYZW(r.x*s+o[0]*e+o[1]*i+o[2]*n,r.y*s+o[3]*e+o[4]*i+o[5]*n,r.z*s+o[6]*e+o[7]*i+o[8]*n,s)}extendInverseTransformedXYZ(t,e,i,n){const s=t.origin;if(!t.matrix.computeCachedInverse(!0))return!1;const r=t.matrix.inverseCoffs,o=e-s.x,a=i-s.y,c=n-s.z;return this.extendXYZ(r[0]*o+r[1]*a+r[2]*c,r[3]*o+r[4]*a+r[5]*c,r[6]*o+r[7]*a+r[8]*c),!0}extendTransformTransformedXYZ(t,e,i,n,s){const r=e.origin,o=e.matrix.coffs;this.extendTransformedXYZ(t,r.x+o[0]*i+o[1]*n+o[2]*s,r.y+o[3]*i+o[4]*n+o[5]*s,r.z+o[6]*i+o[7]*n+o[8]*s)}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y||this.high.z<this.low.z}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y||t.high.z<t.low.z}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y&&this.high.z===this.low.z}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get zLow(){return this.low.z}get xHigh(){return this.high.x}get yHigh(){return this.high.y}get zHigh(){return this.high.z}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}zLength(){const t=this.high.z-this.low.z;return t>0?t:0}maxLength(){return Math.max(this.xLength(),this.yLength(),this.zLength())}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i=0,n){return this.low.interpolateXYZ(t,e,i,this.high,n)}localXYZToWorld(t,e,i,n){if(!this.isNull)return this.low.interpolateXYZ(t,e,i,this.high,n)}localToWorld(t,e){return this.localXYZToWorld(t.x,t.y,t.z,e)}localToWorldArrayInPlace(t){if(this.isNull)return!1;for(const e of t)this.low.interpolateXYZ(e.x,e.y,e.z,this.high,e);return!1}worldToLocal(t,e){const i=ut.npcScaleFactor(this.low.x,this.high.x),n=ut.npcScaleFactor(this.low.y,this.high.y),s=ut.npcScaleFactor(this.low.z,this.high.z);if(0!==i&&0!==n&&0!==s)return $.create((t.x-this.low.x)*i,(t.y-this.low.y)*n,(t.z-this.low.z)*s,e)}worldToLocalArrayInPlace(t){const e=ut.npcScaleFactor(this.low.x,this.high.x),i=ut.npcScaleFactor(this.low.y,this.high.y),n=ut.npcScaleFactor(this.low.z,this.high.z);if(0===e||0===i||0===n)return!1;for(const s of t)$.create((s.x-this.low.x)*e,(s.y-this.low.y)*i,(s.z-this.low.z)*n,s);return!0}corners(t){return void 0!==t&&t.length>=8?(t[0].set(this.low.x,this.low.y,this.low.z),t[1].set(this.high.x,this.low.y,this.low.z),t[2].set(this.low.x,this.high.y,this.low.z),t[3].set(this.high.x,this.high.y,this.low.z),t[4].set(this.low.x,this.low.y,this.high.z),t[5].set(this.high.x,this.low.y,this.high.z),t[6].set(this.low.x,this.high.y,this.high.z),t[7].set(this.high.x,this.high.y,this.high.z),t.length=8,t):[$.create(this.low.x,this.low.y,this.low.z),$.create(this.high.x,this.low.y,this.low.z),$.create(this.low.x,this.high.y,this.low.z),$.create(this.high.x,this.high.y,this.low.z),$.create(this.low.x,this.low.y,this.high.z),$.create(this.high.x,this.low.y,this.high.z),$.create(this.low.x,this.high.y,this.high.z),$.create(this.high.x,this.high.y,this.high.z)]}static faceCornerIndices(t){return 0===t?[0,4,6,2]:1===t?[1,3,7,5]:2===t?[0,1,5,4]:3===t?[3,2,6,7]:4===t?[0,2,3,1]:[4,5,7,6]}rectangleXY(t=0,e=!0,i=!0){if(this.isNull)return;const n=[this.fractionToPoint(0,0,t),this.fractionToPoint(1,0,t),this.fractionToPoint(1,1,t),this.fractionToPoint(0,1,t)];return i&&n.push(n[0].clone()),e||n.reverse(),n}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return J.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return J.isSmallMetricDistance(this.yLength())}get isAlmostZeroZ(){return J.isSmallMetricDistance(this.zLength())}containsXYZ(t,e,i){return t>=this.low.x&&e>=this.low.y&&i>=this.low.z&&t<=this.high.x&&e<=this.high.y&&i<=this.high.z}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXYZ(t.x,t.y,t.z)}containsPointXY(t){return t.x>=this.low.x&&t.y>=this.low.y&&t.x<=this.high.x&&t.y<=this.high.y}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.low.z>=this.low.z&&t.high.x<=this.high.x&&t.high.y<=this.high.y&&t.high.z<=this.high.z}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||this.low.z>t.high.z||t.low.x>this.high.x||t.low.y>this.high.y||t.low.z>this.high.z)}intersectsRangeXY(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?ut._EXTREME_POSITIVE:Math.min(J.hypotenuseXYZ(ut.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),ut.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y),ut.coordinateToRangeAbsoluteDistance(t.z,this.low.z,this.high.z)),ut._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(J.hypotenuseXYZ(ut.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),ut.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y),ut.rangeToRangeAbsoluteDistance(this.low.z,this.high.z,t.low.z,t.high.z)),ut._EXTREME_POSITIVE)}extendXYZ(t,e,i){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e),i<this.low.z&&(this.low.z=i),i>this.high.z&&(this.high.z=i)}extendInterpolated(t,e,i){if(e<.5)this.extendXYZ(t.x+e*(i.x-t.x),t.y+e*(i.y-t.y),t.z+e*(i.z-t.z));else{const n=1-e;this.extendXYZ(i.x+n*(t.x-i.x),i.y+n*(t.y-i.y),i.z+n*(t.z-i.z))}}extendXOnly(t){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t)}extendYOnly(t){t<this.low.y&&(this.low.y=t),t>this.high.y&&(this.high.y=t)}extendZOnly(t){t<this.low.z&&(this.low.z=t),t>this.high.z&&(this.high.z=t)}extendSingleAxis(t,e){e===g.X&&this.extendXOnly(t),e===g.Y&&this.extendYOnly(t),e===g.Z&&this.extendZOnly(t)}extendXYZW(t,e,i,n){J.isSmallMetricDistance(n)||this.extendXYZ(t/n,e/n,i/n)}extendPoint(t,e){e?this.extendTransformedXYZ(e,t.x,t.y,t.z):this.extendXYZ(t.x,t.y,t.z)}extendTransformedPoint(t,e){this.extendTransformedXYZ(t,e.x,e.y,e.z)}extendRange(t){ft.isNull(t)||(this.extendXYZ(t.low.x,t.low.y,t.low.z),this.extendXYZ(t.high.x,t.high.y,t.high.z))}extendWhenLarger(t,e){ft.isNull(t)||ft.isNull(this)||(this.high.x+=ut.multiplyIfPositive(this.high.x-t.high.x,e),this.high.y+=ut.multiplyIfPositive(this.high.y-t.high.y,e),this.high.z+=ut.multiplyIfPositive(this.high.z-t.high.z,e),this.low.x-=ut.multiplyIfPositive(t.low.x-this.low.x,e),this.low.y-=ut.multiplyIfPositive(t.low.y-this.low.y,e),this.low.z-=ut.multiplyIfPositive(t.low.z-this.low.z,e))}intersect(t,e){return this.intersectsRange(t)?ft.createXYZXYZOrCorrectToNull(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.max(this.low.z,t.low.z),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),Math.min(this.high.z,t.high.z),e):ft.createNull(e)}union(t,e){return this.isNull?t.clone(e):t.isNull?this.clone(e):ft.createXYZXYZOrCorrectToNull(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.min(this.low.z,t.low.z),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),Math.max(this.high.z,t.high.z),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y),n=.5*(this.low.z+this.high.z);this.high.x=J.interpolate(e,t,this.high.x),this.high.y=J.interpolate(i,t,this.high.y),this.high.z=J.interpolate(n,t,this.high.z),this.low.x=J.interpolate(e,t,this.low.x),this.low.y=J.interpolate(i,t,this.low.y),this.low.z=J.interpolate(n,t,this.low.z)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.low.z-t,this.high.x+t,this.high.y+t,this.high.z+t,!0)}getLocalToWorldTransform(t){return mt.createOriginAndMatrix($.create(this.low.x,this.low.y,this.low.z),xt.createRowValues(this.high.x-this.low.x,0,0,0,this.high.y-this.low.y,0,0,0,this.high.z-this.low.z),t)}getNpcToWorldRangeTransform(t){const e=this.getLocalToWorldTransform(t),i=e.matrix;return 0===i.coffs[0]&&(i.coffs[0]=1),0===i.coffs[4]&&(i.coffs[4]=1),0===i.coffs[8]&&(i.coffs[8]=1),e}ensureMinLengths(t=.001){let e=(t-this.xLength())/2;e>0&&(this.low.x-=e,this.high.x+=e),e=(t-this.yLength())/2,e>0&&(this.low.y-=e,this.high.y+=e),e=(t-this.zLength())/2,e>0&&(this.low.z-=e,this.high.z+=e)}}class gt extends ut{low;high;setNull(){this.low=ut._EXTREME_POSITIVE,this.high=ut._EXTREME_NEGATIVE}setDirect(t,e,i=!1){this.low=t,this.high=e,i&&t>e&&this.setNull()}constructor(t=ut._EXTREME_POSITIVE,e=ut._EXTREME_NEGATIVE){super(),this.low=t,this.high=e,this.setDirect(t,e)}isAlmostEqual(t){return J.isSameCoordinate(this.low,t.low)&&J.isSameCoordinate(this.high,t.high)||this.isNull&&t.isNull}setFrom(t){this.low=t.low,this.high=t.high}setFromJSON(t){if(this.setNull(),Array.isArray(t)){let e;for(e of t)Number.isFinite(e)&&this.extendX(e)}else void 0!==t.low&&Number.isFinite(t.low)&&void 0!==t.high&&Number.isFinite(t.high)&&(this.extendX(t.low),this.extendX(t.high))}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}toJSON(){return this.isNull?new Array:[this.low,this.high]}clone(t){return(t=t||new this.constructor).setDirect(this.low,this.high),t}static createFrom(t,e){return(e=e||new this).setDirect(t.low,t.high),e}static createNull(t){return(t=t||new this).setNull(),t}cloneTranslated(t,e){return(e=e||this.clone()).isNull||(e.low+=t,e.high+=t),e}setX(t){this.low=this.high=t}static createX(t,e){return(e=e||new this).setDirect(t,t),e}setXXUnordered(t,e){t<=e?(this.low=t,this.high=e):(this.low=e,this.high=t)}get isExact01(){return 0===this.low&&1===this.high}static createXX(t,e,i){return(i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i}static createXXOrCorrectToNull(t,e,i){return e<t?gt.createNull(i):((i=i||new this).setDirect(Math.min(t,e),Math.max(t,e)),i)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendX(i);return e}extendArray(t){let e;for(e of t)this.extendX(e)}extendArraySubset(t,e,i){const n=e+i;for(let i=e;i<n;i++)this.extendX(t[i])}get isNull(){return this.high<this.low}get isSinglePoint(){return this.high===this.low}length(){const t=this.high-this.low;return t>0?t:0}fractionToPoint(t){return J.interpolate(this.low,t,this.high)}maxAbs(){return this.isNull?0:Math.max(Math.abs(this.low),Math.abs(this.high))}get isAlmostZeroLength(){return J.isSmallMetricDistance(this.length())}containsX(t){return t>=this.low&&t<=this.high}containsXOpen(t){return t>this.low&&t<this.high}containsRange(t){return t.low>=this.low&&t.high<=this.high}intersectsRange(t){return!(this.low>t.high||t.low>this.high)}intersectRangeXXInPlace(t,e){e<t||e<this.low||t>this.high?this.setNull():(e<this.high&&(this.high=e),t>this.low&&(this.low=t))}distanceToRange(t){return ut.rangeToRangeAbsoluteDistance(this.low,this.high,t.low,t.high)}distanceToX(t){return this.isNull?ut._EXTREME_POSITIVE:ut.coordinateToRangeAbsoluteDistance(t,this.low,this.high)}extendX(t){t<this.low&&(this.low=t),t>this.high&&(this.high=t)}extendRange(t){t.isNull||(this.extendX(t.low),this.extendX(t.high))}extendLow(t){return!!(this.isNull||t<this.low)&&(this.low=t,!0)}extendHigh(t){return!!(this.isNull||t>this.high)&&(this.high=t,!0)}intersect(t,e){return this.intersectsRange(t)?gt.createXXOrCorrectToNull(Math.max(this.low,t.low),Math.min(this.high,t.high),e):gt.createNull(e)}union(t,e){return gt.createXX(Math.min(this.low,t.low),Math.max(this.high,t.high),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low+this.high);this.high=J.interpolate(e,t,this.high),this.low=J.interpolate(e,t,this.low)}}expandInPlace(t){this.setDirect(this.low-t,this.high+t,!0)}clipLinearMapToInterval(t,e,i,n){if(n<i||this.high<this.low)return!1;const s=J.conditionalDivideFraction(i-t,e),r=J.conditionalDivideFraction(n-t,e);return void 0===s||void 0===r?i<=t&&t<=n||(this.setNull(),!1):(s<r?(s>this.low&&(this.low=s),r<this.high&&(this.high=r)):(s<this.high&&(this.high=s),r>this.low&&(this.low=r)),!(this.high<this.low&&(this.setNull(),1)))}}class pt extends ut{low;high;setNull(){this.low.x=ut._EXTREME_POSITIVE,this.low.y=ut._EXTREME_POSITIVE,this.high.x=ut._EXTREME_NEGATIVE,this.high.y=ut._EXTREME_NEGATIVE}static toFloat64Array(t){return Float64Array.of(t.low.x,t.low.y,t.high.x,t.high.y)}toFloat64Array(){return pt.toFloat64Array(this)}static fromFloat64Array(t){if(4!==t.length)throw new Error("invalid array");return new this(t[0],t[1],t[2],t[3])}static fromArrayBuffer(t){return this.fromFloat64Array(new Float64Array(t))}constructor(t=pt._EXTREME_POSITIVE,e=pt._EXTREME_POSITIVE,i=pt._EXTREME_NEGATIVE,n=pt._EXTREME_NEGATIVE){super(),this.low=H.create(t,e),this.high=H.create(i,n)}isAlmostEqual(t){return this.low.isAlmostEqual(t.low)&&this.high.isAlmostEqual(t.high)||this.isNull&&t.isNull}setFrom(t){this.low.set(t.low.x,t.low.y),this.high.set(t.high.x,t.high.y)}static createFrom(t,e){return e?(e.setFrom(t),e):this.createXYXYOrCorrectToNull(t.low.x,t.low.y,t.high.x,t.high.y,e)}setFromJSON(t){if(this.setNull(),Array.isArray(t)){const e=H.create();for(const i of t)e.setFromJSON(i),this.extendPoint(e);return}const e=H.fromJSON(t.low),i=H.fromJSON(t.high);ut.isExtremePoint2d(e)||ut.isExtremePoint2d(i)||(this.extendPoint(e),this.extendPoint(i))}freeze(){return this.low.freeze(),this.high.freeze(),Object.freeze(this)}toJSON(){return this.isNull?[]:[this.low.toJSON(),this.high.toJSON()]}static fromJSON(t){const e=new this;return t&&e.setFromJSON(t),e}setDirect(t,e,i,n,s){this.low.x=t,this.low.y=e,this.high.x=i,this.high.y=n,s&&(this.low.x>this.high.x||this.low.y>this.high.y)&&this.setNull()}clone(t){return(t=t||new this.constructor).setDirect(this.low.x,this.low.y,this.high.x,this.high.y,!1),t}cloneTranslated(t,e){return e=e||new this.constructor,this.isNull||e.setDirect(this.low.x+t.x,this.low.y+t.y,this.high.x+t.x,this.high.y+t.y,!1),e}static createNull(t){return(t=t||new this).setNull(),t}setXY(t,e){this.low.x=this.high.x=t,this.low.y=this.high.y=e}static createXY(t,e,i){return(i=i||new this).setDirect(t,e,t,e,!1),i}static createXYXY(t,e,i,n,s){return(s=s||new this).setDirect(Math.min(t,i),Math.min(e,n),Math.max(t,i),Math.max(e,n),!1),s}static createXYXYXY(t,e,i,n,s,r,o){return(o=o||new this).setDirect(Math.min(t,i,s),Math.min(e,n,r),Math.max(t,i,s),Math.max(e,n,r),!1),o}static createXYXYOrCorrectToNull(t,e,i,n,s){return t>i||e>n?this.createNull(s):((s=s||new this).setDirect(Math.min(t,i),Math.min(e,n),Math.max(t,i),Math.max(e,n),!0),s)}static createArray(t,e){let i;for(i of(e=e||new this,t))e.extendPoint(i);return e}get isNull(){return this.high.x<this.low.x||this.high.y<this.low.y}static isNull(t){return t.high.x<t.low.x||t.high.y<t.low.y}get isSinglePoint(){return this.high.x===this.low.x&&this.high.y===this.low.y}get center(){return this.low.interpolate(.5,this.high)}get xLow(){return this.low.x}get yLow(){return this.low.y}get xHigh(){return this.high.x}get yHigh(){return this.high.y}xLength(){const t=this.high.x-this.low.x;return t>0?t:0}yLength(){const t=this.high.y-this.low.y;return t>0?t:0}diagonal(t){return this.low.vectorTo(this.high,t)}diagonalFractionToPoint(t,e){return this.low.interpolate(t,this.high,e)}fractionToPoint(t,e,i){return this.low.interpolateXY(t,e,this.high,i)}corners3d(t=!1,e=0){return t?[$.create(this.low.x,this.low.y,e),$.create(this.high.x,this.low.y,e),$.create(this.high.x,this.high.y,e),$.create(this.low.x,this.high.y,e),$.create(this.low.x,this.low.y,e)]:[$.create(this.low.x,this.low.y,e),$.create(this.high.x,this.low.y,e),$.create(this.low.x,this.high.y,e),$.create(this.high.x,this.high.y,e)]}maxAbs(){return this.isNull?0:Math.max(this.low.maxAbs(),this.high.maxAbs())}get isAlmostZeroX(){return J.isSmallMetricDistance(this.xLength())}get isAlmostZeroY(){return J.isSmallMetricDistance(this.yLength())}containsXY(t,e){return t>=this.low.x&&e>=this.low.y&&t<=this.high.x&&e<=this.high.y}containsPoint(t){return this.containsXY(t.x,t.y)}containsRange(t){return t.low.x>=this.low.x&&t.low.y>=this.low.y&&t.high.x<=this.high.x&&t.high.y<=this.high.y}intersectsRange(t){return!(this.low.x>t.high.x||this.low.y>t.high.y||t.low.x>this.high.x||t.low.y>this.high.y)}distanceToPoint(t){return this.isNull?pt._EXTREME_POSITIVE:Math.min(J.hypotenuseXY(ut.coordinateToRangeAbsoluteDistance(t.x,this.low.x,this.high.x),ut.coordinateToRangeAbsoluteDistance(t.y,this.low.y,this.high.y)),pt._EXTREME_POSITIVE)}distanceToRange(t){return Math.min(J.hypotenuseXY(ut.rangeToRangeAbsoluteDistance(this.low.x,this.high.x,t.low.x,t.high.x),ut.rangeToRangeAbsoluteDistance(this.low.y,this.high.y,t.low.y,t.high.y)),pt._EXTREME_POSITIVE)}extendXY(t,e){t<this.low.x&&(this.low.x=t),t>this.high.x&&(this.high.x=t),e<this.low.y&&(this.low.y=e),e>this.high.y&&(this.high.y=e)}extendTransformedXY(t,e,i){const n=t.multiplyComponentXYZ(0,e,i,0),s=t.multiplyComponentXYZ(1,e,i,0);this.extendXY(n,s)}extendPoint(t){this.extendXY(t.x,t.y)}extendRange(t){pt.isNull(t)||(this.extendXY(t.low.x,t.low.y),this.extendXY(t.high.x,t.high.y))}intersect(t,e){return this.intersectsRange(t)?pt.createXYXY(Math.max(this.low.x,t.low.x),Math.max(this.low.y,t.low.y),Math.min(this.high.x,t.high.x),Math.min(this.high.y,t.high.y),e):pt.createNull(e)}union(t,e){return this.isNull?pt.createFrom(t,e):pt.isNull(t)?this.clone(e):pt.createXYXY(Math.min(this.low.x,t.low.x),Math.min(this.low.y,t.low.y),Math.max(this.high.x,t.high.x),Math.max(this.high.y,t.high.y),e)}scaleAboutCenterInPlace(t){if(!this.isNull){t=Math.abs(t);const e=.5*(this.low.x+this.high.x),i=.5*(this.low.y+this.high.y);this.high.x=J.interpolate(e,t,this.high.x),this.high.y=J.interpolate(i,t,this.high.y),this.low.x=J.interpolate(e,t,this.low.x),this.low.y=J.interpolate(i,t,this.low.y)}}expandInPlace(t){this.setDirect(this.low.x-t,this.low.y-t,this.high.x+t,this.high.y+t,!0)}worldToLocal(t,e){const i=ut.npcScaleFactor(this.low.x,this.high.x),n=ut.npcScaleFactor(this.low.y,this.high.y);if(0!==i&&0!==n)return H.create((t.x-this.low.x)*i,(t.y-this.low.y)*n,e)}}class mt{_origin;_matrix;constructor(t,e){this._origin=t,this._matrix=e}static _identity;static get identity(){return void 0===this._identity&&(this._identity=mt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this._origin.freeze(),this._matrix.freeze(),Object.freeze(this)}setFrom(t){this._origin.setFrom(t._origin),this._matrix.setFrom(t._matrix)}setIdentity(){this._origin.setZero(),this._matrix.setIdentity()}setFromJSON(t){if(t){if(t instanceof Object&&t.origin&&t.matrix)return this._origin.setFromJSON(t.origin),void this._matrix.setFromJSON(t.matrix);if(J.isArrayOfNumberArray(t,3,4))return this._matrix.setRowValues(t[0][0],t[0][1],t[0][2],t[1][0],t[1][1],t[1][2],t[2][0],t[2][1],t[2][2]),void this._origin.set(t[0][3],t[1][3],t[2][3]);if(J.isNumberArray(t,12))return this._matrix.setRowValues(t[0],t[1],t[2],t[4],t[5],t[6],t[8],t[9],t[10]),void this._origin.set(t[3],t[7],t[11])}this.setIdentity()}isAlmostEqual(t){return this===t||this.origin.isAlmostEqual(t.origin)&&this.matrix.isAlmostEqual(t.matrix)}isAlmostEqualAllowZRotation(t){return this._origin.isAlmostEqual(t._origin)&&this._matrix.isAlmostEqualAllowZRotation(t._matrix)}toRows(){return[[this._matrix.coffs[0],this._matrix.coffs[1],this._matrix.coffs[2],this._origin.x],[this._matrix.coffs[3],this._matrix.coffs[4],this._matrix.coffs[5],this._origin.y],[this._matrix.coffs[6],this._matrix.coffs[7],this._matrix.coffs[8],this._origin.z]]}toJSON(){return this.toRows()}static fromJSON(t){const e=mt.createIdentity();return e.setFromJSON(t),e}clone(t){return t?(t._matrix.setFrom(this._matrix),t._origin.setFrom(this._origin),t):new mt($.createFrom(this._origin),this._matrix.clone())}cloneRigid(t=f.XYZ){const e=xt.createRigidFromMatrix3d(this.matrix,t);if(e)return new mt(this.origin.cloneAsPoint3d(),e)}static createRefs(t,e,i){return t||(t=$.createZero()),i?(i._origin=t,i._matrix=e,i):new mt(t,e)}static createRowValues(t,e,i,n,s,r,o,a,c,l,h,d,u){return u?(u._origin.set(n,a,d),u._matrix.setRowValues(t,e,i,s,r,o,c,l,h),u):new mt($.create(n,a,d),xt.createRowValues(t,e,i,s,r,o,c,l,h))}static createZero(t){return mt.createRowValues(0,0,0,0,0,0,0,0,0,0,0,0,t)}static createTranslationXYZ(t=0,e=0,i=0,n){return mt.createRefs(tt.create(t,e,i),xt.createIdentity(),n)}static createTranslation(t,e){return mt.createRefs(t,xt.createIdentity(),e)}get matrix(){return this._matrix}get origin(){return this._origin}getOrigin(){return $.createFrom(this._origin)}getTranslation(){return tt.createFrom(this._origin)}getMatrix(){return this._matrix.clone()}get isIdentity(){return this._matrix.isIdentity&&this._origin.isAlmostZero}static createIdentity(t){return t?(t._origin.setZero(),t._matrix.setIdentity(),t):mt.createRefs($.createZero(),xt.createIdentity())}static createOriginAndMatrix(t,e,i){return i?(i._origin.setFromPoint3d(t),i._matrix.setFrom(e),i):mt.createRefs(t?t.cloneAsPoint3d():$.createZero(),void 0===e?xt.createIdentity():e.clone(),i)}setOriginAndMatrixColumns(t,e,i,n){void 0!==t&&this._origin.setFrom(t),this._matrix.setColumns(e,i,n)}static createOriginAndMatrixColumns(t,e,i,n,s){return s?s.setOriginAndMatrixColumns(t,e,i,n):s=mt.createRefs(tt.createFrom(t),xt.createColumns(e,i,n)),s}static createRigidFromOriginAndColumns(t,e,i,n,s){const r=xt.createRigidFromColumns(e,i,n,s?._matrix);if(r)return s?(s._origin.setFrom(t),s):mt.createRefs(t?.cloneAsPoint3d(),r)}static createRigidFromOriginAndVector(t,e,i=f.ZXY,n){const s=xt.createRigidHeadsUp(e,i,n?._matrix);if(s)return n?(n._origin.setFrom(t),n):mt.createRefs(t?.cloneAsPoint3d(),s)}static createFixedPointAndMatrix(t,e,i){if(t){const n=xt.xyzMinusMatrixTimesXYZ(t,e,t);return mt.createRefs(n,e.clone(),i)}return mt.createRefs(void 0,e.clone())}static createMatrixPickupPutdown(t,e,i,n){const s=xt.xyzMinusMatrixTimesXYZ(i,t,e);return mt.createRefs(s,t.clone(),n)}static createScaleAboutPoint(t,e,i){const n=xt.createScale(e,e,e),s=xt.xyzMinusMatrixTimesXYZ(t,n,t);return mt.createRefs(s,n,i)}static createFlattenAlongVectorToPlane(t,e,i){const n=xt.createFlattenAlongVectorToPlane(t,i);if(void 0!==n)return mt.createFixedPointAndMatrix(e,n)}multiplyPoint2d(t,e){return xt.xyPlusMatrixTimesXY(this._origin,this._matrix,t,e)}multiplyPoint3d(t,e){return xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t,e)}multiplyXYAndZInPlace(t){return xt.xyzPlusMatrixTimesXYZInPlace(this._origin,this._matrix,t)}multiplyXYZ(t,e,i=0,n){return xt.xyzPlusMatrixTimesCoordinates(this._origin,this._matrix,t,e,i,n)}multiplyComponentXYZ(t,e,i,n=0){const s=this._matrix.coffs,r=3*t;return this.origin.at(t)+s[r]*e+s[r+1]*i+s[r+2]*n}multiplyComponentXYZW(t,e,i,n,s){const r=this._matrix.coffs,o=3*t;return this.origin.at(t)*s+r[o]*e+r[o+1]*i+r[o+2]*n}multiplyXYZW(t,e,i,n,s){return xt.xyzPlusMatrixTimesWeightedCoordinates(this._origin,this._matrix,t,e,i,n,s)}multiplyXYZWToFloat64Array(t,e,i,n,s){return xt.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,n,s)}multiplyXYZToFloat64Array(t,e,i,n){return xt.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin,this._matrix,t,e,i,n)}multiplyTransposeXYZW(t,e,i,n,s){const r=this._matrix.coffs,o=this._origin;return Ot.create(t*r[0]+e*r[3]+i*r[6],t*r[1]+e*r[4]+i*r[7],t*r[2]+e*r[5]+i*r[8],t*o.x+e*o.y+i*o.z+n,s)}multiplyPoint3dArrayInPlace(t){let e;for(e of t)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,e,e)}multiplyPoint3dArrayArrayInPlace(t){for(const e of t)this.multiplyPoint3dArrayInPlace(e)}multiplyInversePoint3d(t,e){return this._matrix.multiplyInverseXYZAsPoint3d(t.x-this._origin.x,t.y-this._origin.y,t.z-this._origin.z,e)}multiplyInversePoint4d(t,e){const i=t.w;return this._matrix.multiplyInverseXYZW(t.x-i*this.origin.x,t.y-i*this.origin.y,t.z-i*this.origin.z,i,e)}multiplyInverseXYZ(t,e,i,n){return this._matrix.multiplyInverseXYZAsPoint3d(t-this._origin.x,e-this._origin.y,i-this._origin.z,n)}computeCachedInverse(t=!0){return this._matrix.computeCachedInverse(t)}static matchArrayLengths(t,e,i){const n=t.length,s=e.length;if(n>s)for(let t=s;t<n;t++)e.push(i());else s>n&&(e.length=n);return n}multiplyInversePoint3dArray(t,e){if(!this._matrix.computeCachedInverse(!0))return;const i=this.origin.x,n=this.origin.y,s=this.origin.z;if(e){const r=mt.matchArrayLengths(t,e,(()=>$.createZero()));for(let o=0;o<r;o++)this._matrix.multiplyInverseXYZAsPoint3d(t[o].x-i,t[o].y-n,t[o].z-s,e[o]);return e}e=[];for(const r of t)e.push(this._matrix.multiplyInverseXYZAsPoint3d(r.x-i,r.y-n,r.z-s));return e}multiplyInversePoint3dArrayInPlace(t){if(!this._matrix.computeCachedInverse(!0))return!1;for(const e of t)this._matrix.multiplyInverseXYZAsPoint3d(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,e);return!0}multiplyPoint2dArray(t,e){if(e){const i=mt.matchArrayLengths(t,e,(()=>H.createZero()));for(let n=0;n<i;n++)xt.xyPlusMatrixTimesXY(this._origin,this._matrix,t[n],e[n]);return e}e=[];for(const i of t)e.push(xt.xyPlusMatrixTimesXY(this._origin,this._matrix,i));return e}multiplyPoint3dArray(t,e){if(e){const i=mt.matchArrayLengths(t,e,(()=>$.createZero()));for(let n=0;n<i;n++)xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t[n],e[n]);return e}e=[];for(const i of t)e.push(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,i));return e}multiplyVector(t,e){return this._matrix.multiplyVector(t,e)}multiplyVectorInPlace(t){this._matrix.multiplyVectorInPlace(t)}multiplyVectorXYZ(t,e,i,n){return this._matrix.multiplyXYZ(t,e,i,n)}setMultiplyTransformTransform(t,e){xt.xyzPlusMatrixTimesXYZ(t._origin,t._matrix,e._origin,this._origin),t._matrix.multiplyMatrixMatrix(e._matrix,this._matrix)}multiplyTransformTransform(t,e){return e?(e.setMultiplyTransformTransform(this,t),e):mt.createRefs(xt.xyzPlusMatrixTimesXYZ(this._origin,this._matrix,t._origin),this._matrix.multiplyMatrixMatrix(t._matrix))}multiplyTransformMatrix3d(t,e){return e?(this._matrix.multiplyMatrixMatrix(t,e._matrix),e._origin.setFrom(this._origin),e):mt.createRefs(this._origin.cloneAsPoint3d(),this._matrix.multiplyMatrixMatrix(t))}multiplyRange(t,e){if(t.isNull)return t.clone(e);const i=t.low.x,n=t.low.y,s=t.low.z,r=t.high.x,o=t.high.y,a=t.high.z;return(e=ft.createNull(e)).extendTransformedXYZ(this,i,n,s),e.extendTransformedXYZ(this,r,n,s),e.extendTransformedXYZ(this,i,o,s),e.extendTransformedXYZ(this,r,o,s),e.extendTransformedXYZ(this,i,n,a),e.extendTransformedXYZ(this,r,n,a),e.extendTransformedXYZ(this,i,o,a),e.extendTransformedXYZ(this,r,o,a),e}inverse(t){const e=this._matrix.inverse(t?t._matrix:void 0);if(e)return t?(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z,t._origin),t):mt.createRefs(e.multiplyXYZ(-this._origin.x,-this._origin.y,-this._origin.z),e)}static initFromRange(t,e,i,n){const s=e.minus(t);0===s.x&&(s.x=1),0===s.y&&(s.y=1),0===s.z&&(s.z=1);const r=new xt;if(i&&(xt.createScale(s.x,s.y,s.z,r),mt.createOriginAndMatrix(t,r,i)),n){const e=new $(-t.x/s.x,-t.y/s.y,-t.z/s.z);xt.createScale(1/s.x,1/s.y,1/s.z,r),mt.createOriginAndMatrix(e,r,n)}}}class _t{static loadMatrix(t,e,i,n,s,r,o,a,c,l){t[0]=e,t[1]=i,t[2]=n,t[3]=s,t[4]=r,t[5]=o,t[6]=a,t[7]=c,t[8]=l}static multiplyMatrixMatrix(t,e,i){return(!i||i.length<9)&&(i=new Float64Array(9)),_t.loadMatrix(i,t[0]*e[0]+t[1]*e[3]+t[2]*e[6],t[0]*e[1]+t[1]*e[4]+t[2]*e[7],t[0]*e[2]+t[1]*e[5]+t[2]*e[8],t[3]*e[0]+t[4]*e[3]+t[5]*e[6],t[3]*e[1]+t[4]*e[4]+t[5]*e[7],t[3]*e[2]+t[4]*e[5]+t[5]*e[8],t[6]*e[0]+t[7]*e[3]+t[8]*e[6],t[6]*e[1]+t[7]*e[4]+t[8]*e[7],t[6]*e[2]+t[7]*e[5]+t[8]*e[8]),i}static multiplyMatrixMatrixTranspose(t,e,i){return(!i||i.length<9)&&(i=new Float64Array(9)),_t.loadMatrix(i,t[0]*e[0]+t[1]*e[1]+t[2]*e[2],t[0]*e[3]+t[1]*e[4]+t[2]*e[5],t[0]*e[6]+t[1]*e[7]+t[2]*e[8],t[3]*e[0]+t[4]*e[1]+t[5]*e[2],t[3]*e[3]+t[4]*e[4]+t[5]*e[5],t[3]*e[6]+t[4]*e[7]+t[5]*e[8],t[6]*e[0]+t[7]*e[1]+t[8]*e[2],t[6]*e[3]+t[7]*e[4]+t[8]*e[5],t[6]*e[6]+t[7]*e[7]+t[8]*e[8]),i}static multiplyMatrixTransposeMatrix(t,e,i){return(!i||i.length<9)&&(i=new Float64Array(9)),_t.loadMatrix(i,t[0]*e[0]+t[3]*e[3]+t[6]*e[6],t[0]*e[1]+t[3]*e[4]+t[6]*e[7],t[0]*e[2]+t[3]*e[5]+t[6]*e[8],t[1]*e[0]+t[4]*e[3]+t[7]*e[6],t[1]*e[1]+t[4]*e[4]+t[7]*e[7],t[1]*e[2]+t[4]*e[5]+t[7]*e[8],t[2]*e[0]+t[5]*e[3]+t[8]*e[6],t[2]*e[1]+t[5]*e[4]+t[8]*e[7],t[2]*e[2]+t[5]*e[5]+t[8]*e[8]),i}static transposeInPlace(t){let e=t[1];t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e}static copyTransposed(t,e){return e===t?_t.transposeInPlace(e):((!e||e.length<9)&&(e=new Float64Array(9)),e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8]),e}static copy(t,e){return e!==t&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8]),e}}!function(t){t[t.unknown=0]="unknown",t[t.inverseStored=1]="inverseStored",t[t.singular=2]="singular"}(y||(y={}));class xt{static useCachedInverse=!0;static numUseCache=0;static numComputeCache=0;coffs;inverseCoffs;inverseState;static _identity;static _productBuffer=new Float64Array(9);static get identity(){return void 0===this._identity&&(this._identity=xt.createIdentity(),this._identity.freeze()),this._identity}freeze(){return this.computeCachedInverse(!0),Object.freeze(this)}constructor(t){this.coffs=t&&t.length>=9?t:new Float64Array(9),this.inverseCoffs=void 0,this.inverseState=y.unknown}toJSON(){return[[this.coffs[0],this.coffs[1],this.coffs[2]],[this.coffs[3],this.coffs[4],this.coffs[5]],[this.coffs[6],this.coffs[7],this.coffs[8]]]}setFromJSON(t){this.inverseCoffs=void 0,t?Array.isArray(t)?J.isArrayOfNumberArray(t,3,3)?this.setRowValues(t[0][0],t[0][1],t[0][2],t[1][0],t[1][1],t[1][2],t[2][0],t[2][1],t[2][2]):9!==t.length?4!==t.length?this.setRowValues(0,0,0,0,0,0,0,0,0):this.setRowValues(t[0],t[1],0,t[2],t[3],0,0,0,1):this.setRowValues(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8]):t instanceof xt&&this.setFrom(t):this.setRowValues(0,0,0,0,0,0,0,0,0)}static fromJSON(t){const e=xt.createIdentity();return e.setFromJSON(t),e}isAlmostEqual(t,e){return J.isDistanceWithinTol(this.maxDiff(t),e)}isAlmostEqualColumn(t,e,i){const n=J.maxAbsXYZ(this.coffs[t]-e.coffs[t],this.coffs[t+3]-e.coffs[t+3],this.coffs[t+6]-e.coffs[t+6]);return J.isDistanceWithinTol(n,i)}isAlmostEqualColumnXYZ(t,e,i,n,s){const r=J.maxAbsXYZ(this.coffs[t]-e,this.coffs[t+3]-i,this.coffs[t+6]-n);return J.isDistanceWithinTol(r,s)}isAlmostEqualAllowZRotation(t,e){if(this.isAlmostEqual(t,e))return!0;if(!this.isAlmostEqualColumn(g.Z,t,e))return!1;const i=this.columnX(),n=this.columnY(),s=this.columnZ(),r=i.signedAngleTo(t.columnX(),s);let o=tt.createRotateVectorAroundVector(i,s,r);return!!(o&&t.isAlmostEqualColumnXYZ(0,o.x,o.y,o.z,e)&&(o=tt.createRotateVectorAroundVector(n,s,r),o&&t.isAlmostEqualColumnXYZ(1,o.x,o.y,o.z,e)))}isExactEqual(t){return 0===this.maxDiff(t)}get isXY(){return 0===this.coffs[2]&&0===this.coffs[5]&&0===this.coffs[6]&&0===this.coffs[7]&&1===this.coffs[8]}static _create(t){return t||new xt}static createRowValues(t,e,i,n,s,r,o,a,c,l){return(l=l||new xt).inverseState=y.unknown,l.coffs[0]=t,l.coffs[1]=e,l.coffs[2]=i,l.coffs[3]=n,l.coffs[4]=s,l.coffs[5]=r,l.coffs[6]=o,l.coffs[7]=a,l.coffs[8]=c,l}static createCapture(t,e){const i=new xt(t);return e&&e.length>=9?(i.inverseCoffs=e,i.inverseState=y.inverseStored):i.inverseState=y.unknown,i}static createColumnsInAxisOrder(t,e,i,n,s){return s||(s=new xt),t===f.YZX?s.setColumns(n,e,i):t===f.ZXY?s.setColumns(i,n,e):t===f.XZY?s.setColumns(e,n,i):t===f.YXZ?s.setColumns(i,e,n):t===f.ZYX?s.setColumns(n,i,e):s.setColumns(e,i,n),s}createInverseCoffsWithZeros(){this.inverseCoffs||(this.inverseState=y.unknown,this.inverseCoffs=new Float64Array(9))}setupInverseTranspose(){const t=this.coffs;this.inverseState=y.inverseStored,this.inverseCoffs=Float64Array.from([t[0],t[3],t[6],t[1],t[4],t[7],t[2],t[5],t[8]])}setRowValues(t,e,i,n,s,r,o,a,c){this.coffs[0]=t,this.coffs[1]=e,this.coffs[2]=i,this.coffs[3]=n,this.coffs[4]=s,this.coffs[5]=r,this.coffs[6]=o,this.coffs[7]=a,this.coffs[8]=c,this.inverseState=y.unknown}setIdentity(){this.setRowValues(1,0,0,0,1,0,0,0,1),this.setupInverseTranspose()}setZero(){this.setRowValues(0,0,0,0,0,0,0,0,0),this.inverseState=y.singular}setFrom(t){if(void 0!==t){if(t!==this){for(let e=0;e<9;e++)this.coffs[e]=t.coffs[e];if(t.inverseState===y.inverseStored&&void 0!==t.inverseCoffs){this.createInverseCoffsWithZeros();for(let e=0;e<9;e++)this.inverseCoffs[e]=t.inverseCoffs[e];this.inverseState=y.inverseStored}else t.inverseState!==y.inverseStored?this.inverseState=t.inverseState:this.inverseState=y.unknown}}else this.setIdentity()}clone(t){return(t=t||new xt).setFrom(this),t}static createZero(){const t=new xt;return t.inverseState=y.singular,t}static createIdentity(t){return(t=t||new xt).setIdentity(),t}static createScale(t,e,i,n){return n?n.setZero():n=new xt,n.coffs[0]=t,n.coffs[4]=e,n.coffs[8]=i,0===t||0===e||0===i?n.inverseState=y.singular:(n.inverseState=y.inverseStored,n.inverseCoffs=Float64Array.from([1/t,0,0,0,1/e,0,0,0,1/i])),n}static createUniformScale(t){return xt.createScale(t,t,t)}static createPerpendicularVectorFavorXYPlane(t,e){const i=t.magnitude()/64;return Math.abs(t.x)<i&&Math.abs(t.y)<i?tt.createCrossProduct(t.x,t.y,t.z,0,-1,0,e):tt.createCrossProduct(0,0,1,t.x,t.y,t.z,e)}static createPerpendicularVectorFavorPlaneContainingZ(t,e){return e=xt.createPerpendicularVectorFavorXYPlane(t,e),t.crossProduct(e,e)}static createShuffledColumns(t,e,i,n,s){const r=xt._create(s);return r.setColumn(J.axisOrderToAxis(n,0),t),r.setColumn(J.axisOrderToAxis(n,1),e),r.setColumn(J.axisOrderToAxis(n,2),i),r}static createRigidFromColumns(t,e,i,n){const s=t.normalize();if(s){const r=s.unitCrossProduct(e);if(r){const e=r.unitCrossProduct(t);if(e){const t=xt.createShuffledColumns(s,e,r,i,n);return t.setupInverseTranspose(),t}}}}static createRigidHeadsUp(t,e=f.ZXY,i){const n=xt.createPerpendicularVectorFavorXYPlane(t),s=xt.createRigidFromColumns(t,n,e,i);return s?(s.setupInverseTranspose(),s):xt.createIdentity(i)}static createRotationAroundVector(t,e,i){const n=e.cos(),s=e.sin(),r=1-n,o=t.normalize();if(o){const t=xt.createRowValues(o.x*o.x*r+n,o.x*o.y*r-s*o.z,o.x*o.z*r+s*o.y,o.y*o.x*r+s*o.z,o.y*o.y*r+n,o.y*o.z*r-s*o.x,o.z*o.x*r-s*o.y,o.z*o.y*r+s*o.x,o.z*o.z*r+n,i);return t.setupInverseTranspose(),t}}static createRotationAroundAxisIndex(t,e,i){const n=e.cos(),s=e.sin();let r;return r=t===g.X?xt.createRowValues(1,0,0,0,n,-s,0,s,n,i):t===g.Y?xt.createRowValues(n,0,s,0,1,0,-s,0,n,i):xt.createRowValues(n,-s,0,s,n,0,0,0,1,i),r.setupInverseTranspose(),r}applyGivensRowOp(t,e,i,n){let s=3*t,r=3*e;const o=s+3;for(;s<o;s++,r++){const t=this.coffs[s],e=this.coffs[r];this.coffs[s]=t*i+e*n,this.coffs[r]=-t*n+e*i}}applyGivensColumnOp(t,e,i,n){const s=t+9;for(;t<s;t+=3,e+=3){const s=this.coffs[t],r=this.coffs[e];this.coffs[t]=s*i+r*n,this.coffs[e]=-s*n+r*i}}static createColumns(t,e,i,n){return xt.createRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z,n)}static createColumnsXYW(t,e,i,n,s,r,o){return xt.createRowValues(t.x,i.x,s.x,t.y,i.y,s.y,e,n,r,o)}static createViewedAxes(t,e,i=0,n=0){const s=t.crossProduct(e);if(s.normalizeInPlace()){const r=xt.createColumns(t,e,s);if(0!==i){let t=Math.sqrt(.5),e=i<0?-t:t;if(1!==Math.abs(i)){const n=G.degreesToRadians(45*i);t=Math.cos(n),e=Math.sin(n)}r.applyGivensColumnOp(2,0,t,e)}if(0!==n){const t=n*Math.atan(Math.sqrt(.5)),e=Math.cos(t),i=Math.sin(t);r.applyGivensColumnOp(1,2,e,-i)}return r}}static createStandardWorldToView(t,e=!1,i){switch(t){case p.Bottom:i=xt.createRowValues(1,0,0,0,-1,0,0,0,-1);break;case p.Left:i=xt.createRowValues(0,-1,0,0,0,1,-1,0,0);break;case p.Right:i=xt.createRowValues(0,1,0,0,0,1,1,0,0);break;case p.Front:i=xt.createRowValues(1,0,0,0,0,1,0,-1,0);break;case p.Back:i=xt.createRowValues(-1,0,0,0,0,1,0,1,0);break;case p.Iso:i=xt.createRowValues(.707106781186548,-.7071067811865476,0,.408248290463863,.408248290463863,.816496580927726,-.577350269189626,-.5773502691896257,.5773502691896257);break;case p.RightIso:i=xt.createRowValues(.707106781186548,.7071067811865476,0,-.408248290463863,.408248290463863,.816496580927726,.577350269189626,-.5773502691896257,.5773502691896257);break;case p.Top:default:i=xt.createIdentity(i)}return e&&i.transposeInPlace(),i}applySymmetricJacobi(t,e,i,n){const s=n.at(t,t),r=n.at(e,e),o=n.at(t,e);if(Math.abs(o)<J.smallFloatingPoint*(s+r))return 0;const a=G.trigValuesToHalfAngleTrigValues(s-r,2*o),c=a.c,l=a.s;return Math.abs(l)<2e-15?0:(n.applyGivensRowOp(t,e,c,l),n.applyGivensColumnOp(t,e,c,l),i.applyGivensColumnOp(t,e,c,l),Math.abs(o))}symmetricEigenvalues(t,e){const i=this.clone();t.setIdentity(),i.coffs[3]=i.coffs[1],i.coffs[6]=i.coffs[2],i.coffs[7]=i.coffs[5];const n=1e-12*this.sumSquares();for(let s=0;s<7;s++)if(this.applySymmetricJacobi(0,1,t,i)+this.applySymmetricJacobi(0,2,t,i)+this.applySymmetricJacobi(1,2,t,i)<n)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}applyFastSymmetricJacobi(t,e,i,n){const s=4*t,r=4*e,o=3*t+e,a=3*e+t,c=3*t+i,l=3*i+t,h=3*e+i,d=3*i+e,u=this.coffs[s],f=this.coffs[r],g=this.coffs[o];if(Math.abs(g)<J.smallFloatingPoint*(u+f))return 0;const p=G.trigValuesToHalfAngleTrigValues(u-f,2*g),m=p.c,_=p.s,x=m*m,y=_*_,v=2*m*_;this.coffs[s]=x*u+v*g+y*f,this.coffs[r]=y*u-v*g+x*f,this.coffs[o]=0,this.coffs[a]=0;const P=this.coffs[c],I=this.coffs[h];return this.coffs[c]=m*P+_*I,this.coffs[h]=-_*P+m*I,this.coffs[l]=this.coffs[c],this.coffs[d]=this.coffs[h],n.applyGivensColumnOp(t,e,m,_),Math.abs(g)}fastSymmetricEigenvalues(t,e){const i=this.clone();t.setIdentity();const n=1e-12*this.sumSquares();for(let s=0;s<7;s++)if(i.applyFastSymmetricJacobi(0,1,2,t)+i.applyFastSymmetricJacobi(0,2,1,t)+i.applyFastSymmetricJacobi(1,2,0,t)<n)return e.set(i.at(0,0),i.at(1,1),i.at(2,2)),!0;return!1}getAxisAndAngleOfRotation(){const t=this.coffs[0]+this.coffs[4]+this.coffs[8],e=this.coffs[3]-this.coffs[1],i=this.coffs[7]-this.coffs[5],n=this.coffs[2]-this.coffs[6],s=(t-1)/2,r=J.hypotenuseXYZ(e,i,n)/2,o=s*s+r*r-1;if(Math.abs(o)>J.smallAngleRadians)return{axis:tt.create(0,0,1),angle:G.createRadians(0),ok:!1};if(Math.abs(r)<J.smallAngleRadians){if(s>0)return{axis:tt.create(0,0,1),angle:G.createRadians(0),ok:!0};const t=this.coffs[0],e=this.coffs[4],i=this.coffs[8];if(J.isAlmostEqualNumber(-1,e)&&J.isAlmostEqualNumber(-1,i))return{axis:tt.create(1,0,0),angle:G.createDegrees(180),ok:!0};if(J.isAlmostEqualNumber(-1,t)&&J.isAlmostEqualNumber(-1,i))return{axis:tt.create(0,1,0),angle:G.createDegrees(180),ok:!0};if(J.isAlmostEqualNumber(-1,t)&&J.isAlmostEqualNumber(-1,e))return{axis:tt.create(0,0,1),angle:G.createDegrees(180),ok:!0};const n=xt.createIdentity(),r=tt.create(0,0,0);if(this.fastSymmetricEigenvalues(n,r)){for(let t=0;t<2;t++){const e=r.at(t);if(J.isAlmostEqualNumber(1,e))return{axis:n.getColumn(t),angle:G.createDegrees(180),ok:!0}}return{axis:tt.create(0,0,1),angle:G.createRadians(0),ok:!1}}return{axis:tt.create(0,0,1),angle:G.createRadians(0),ok:!1}}const a=1/(2*r);return{axis:tt.create(i*a,n*a,e*a),angle:G.createAtan2(r,s),ok:!0}}applyJacobiColumnRotation(t,e,i){const n=this.coffs[t]*this.coffs[t]+this.coffs[t+3]*this.coffs[t+3]+this.coffs[t+6]*this.coffs[t+6],s=this.coffs[e]*this.coffs[e]+this.coffs[e+3]*this.coffs[e+3]+this.coffs[e+6]*this.coffs[e+6],r=this.coffs[t]*this.coffs[e]+this.coffs[t+3]*this.coffs[e+3]+this.coffs[t+6]*this.coffs[e+6],o=G.trigValuesToHalfAngleTrigValues(n-s,2*r),a=o.c,c=o.s;return Math.abs(c)<2e-15?0:(this.applyGivensColumnOp(t,e,a,c),i.applyGivensRowOp(t,e,a,c),Math.abs(r))}factorPerpendicularColumns(t,e){t.setFrom(this),e.setIdentity();const i=1e-12*this.sumSquares();for(let n=0;n<7;n++)if(t.applyJacobiColumnRotation(0,1,e)+t.applyJacobiColumnRotation(0,2,e)+t.applyJacobiColumnRotation(1,2,e)<i)return!0;return!1}factorOrthogonalScaleOrthogonal(t,e,i){const n=xt.createZero();if(!this.factorPerpendicularColumns(n,i))return!1;const s=[];s.push(n.getColumn(0)),s.push(n.getColumn(1)),s.push(n.getColumn(2)),e.set(s[0].magnitude(),s[1].magnitude(),s[2].magnitude()),n.determinant()<0&&(e.z=-e.z);const r=J.smallFloatingPoint,o=Math.abs(e.x)<r,a=Math.abs(e.y)<r,c=Math.abs(e.z)<r;return o||a||c?o||a?o?t.setIdentity():t=xt.createRigidHeadsUp(s[0],f.XYZ,t):(s[0].scaleInPlace(1/e.x),s[1].scaleInPlace(1/e.y),s[2]=s[0].unitCrossProduct(s[1],s[2]),t.setColumns(s[0],s[1],s[2])):t=n.scaleColumns(1/e.x,1/e.y,1/e.z,t),!0}static createPartialRotationVectorToVector(t,e,i,n){let s=t.unitCrossProduct(i);return s?xt.createRotationAroundVector(s,G.createRadians(e*t.planarAngleTo(i,s).radians),n):J.isSmallMetricDistance(t.magnitude())||J.isSmallMetricDistance(i.magnitude())?void 0:t.dotProduct(i)>0?xt.createIdentity(n):(s=xt.createPerpendicularVectorFavorPlaneContainingZ(t,s),xt.createRotationAroundVector(s,G.createRadians(e*Math.PI),n))}static createRotationVectorToVector(t,e,i){return this.createPartialRotationVectorToVector(t,1,e,i)}static create90DegreeRotationAroundAxis(t){if(0===(t=J.cyclic3dAxis(t))){const t=xt.createRowValues(1,0,0,0,0,-1,0,1,0);return t.setupInverseTranspose(),t}if(1===t){const t=xt.createRowValues(0,0,1,0,1,0,-1,0,0);return t.setupInverseTranspose(),t}{const t=xt.createRowValues(0,-1,0,1,0,0,0,0,1);return t.setupInverseTranspose(),t}}columnX(t){return tt.create(this.coffs[0],this.coffs[3],this.coffs[6],t)}columnY(t){return tt.create(this.coffs[1],this.coffs[4],this.coffs[7],t)}columnZ(t){return tt.create(this.coffs[2],this.coffs[5],this.coffs[8],t)}columnXMagnitudeSquared(){return J.hypotenuseSquaredXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitudeSquared(){return J.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitudeSquared(){return J.hypotenuseSquaredXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXMagnitude(){return J.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])}columnYMagnitude(){return J.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])}columnZMagnitude(){return J.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8])}columnXYCrossProductMagnitude(){return J.crossProductMagnitude(this.coffs[0],this.coffs[3],this.coffs[6],this.coffs[1],this.coffs[4],this.coffs[7])}rowXMagnitude(){return J.hypotenuseXYZ(this.coffs[0],this.coffs[1],this.coffs[2])}rowYMagnitude(){return J.hypotenuseXYZ(this.coffs[3],this.coffs[4],this.coffs[5])}rowZMagnitude(){return J.hypotenuseXYZ(this.coffs[6],this.coffs[7],this.coffs[8])}columnXDotColumnY(){return this.coffs[0]*this.coffs[1]+this.coffs[3]*this.coffs[4]+this.coffs[6]*this.coffs[7]}columnXDotColumnZ(){return this.coffs[0]*this.coffs[2]+this.coffs[3]*this.coffs[5]+this.coffs[6]*this.coffs[8]}columnYDotColumnZ(){return this.coffs[1]*this.coffs[2]+this.coffs[4]*this.coffs[5]+this.coffs[7]*this.coffs[8]}columnDotXYZ(t,e,i,n){return this.coffs[t]*e+this.coffs[t+3]*i+this.coffs[t+6]*n}rowX(t){return tt.create(this.coffs[0],this.coffs[1],this.coffs[2],t)}rowY(t){return tt.create(this.coffs[3],this.coffs[4],this.coffs[5],t)}rowZ(t){return tt.create(this.coffs[6],this.coffs[7],this.coffs[8],t)}dotColumnX(t){return t.x*this.coffs[0]+t.y*this.coffs[3]+t.z*this.coffs[6]}dotColumnY(t){return t.x*this.coffs[1]+t.y*this.coffs[4]+t.z*this.coffs[7]}dotColumnZ(t){return t.x*this.coffs[2]+t.y*this.coffs[5]+t.z*this.coffs[8]}dotRowX(t){return t.x*this.coffs[0]+t.y*this.coffs[1]+t.z*this.coffs[2]}dotRowY(t){return t.x*this.coffs[3]+t.y*this.coffs[4]+t.z*this.coffs[5]}dotRowZ(t){return t.x*this.coffs[6]+t.y*this.coffs[7]+t.z*this.coffs[8]}dotRowXXYZ(t,e,i){return t*this.coffs[0]+e*this.coffs[1]+i*this.coffs[2]}dotRowYXYZ(t,e,i){return t*this.coffs[3]+e*this.coffs[4]+i*this.coffs[5]}dotRowZXYZ(t,e,i){return t*this.coffs[6]+e*this.coffs[7]+i*this.coffs[8]}columnZCrossVector(t,e){return J.crossProductXYZXYZ(this.coffs[2],this.coffs[5],this.coffs[8],t.x,t.y,t.z,e)}setColumnsPoint4dXYZ(t,e,i){this.inverseState=y.unknown,this.setRowValues(t.x,e.x,i.x,t.y,e.y,i.y,t.z,e.z,i.z)}setColumn(t,e){const i=J.cyclic3dAxis(t);this.inverseState=y.unknown,e?(this.coffs[i]=e.x,this.coffs[i+3]=e.y,this.coffs[i+6]=e.z):(this.coffs[i]=0,this.coffs[i+3]=0,this.coffs[i+6]=0)}setColumns(t,e,i){this.setColumn(0,t),this.setColumn(1,e),this.setColumn(2,i)}setRow(t,e){const i=3*J.cyclic3dAxis(t);this.coffs[i]=e.x,this.coffs[i+1]=e.y,this.coffs[i+2]=e.z,this.inverseState=y.unknown}getColumn(t,e){const i=J.cyclic3dAxis(t);return tt.create(this.coffs[i],this.coffs[i+3],this.coffs[i+6],e)}getRow(t,e){const i=3*J.cyclic3dAxis(t);return tt.create(this.coffs[i],this.coffs[i+1],this.coffs[i+2],e)}static createRows(t,e,i,n){return xt.createRowValues(t.x,t.y,t.z,e.x,e.y,e.z,i.x,i.y,i.z,n)}static createDirectionalScale(t,e,i){const n=t.normalize();if(n){const t=n.x,s=n.y,r=n.z,o=e-1;return xt.createRowValues(1+o*t*t,o*t*s,o*t*r,o*s*t,1+o*s*s,o*s*r,o*r*t,o*r*s,1+o*r*r,i)}return xt.createUniformScale(e)}static createFlattenAlongVectorToPlane(t,e){const i=xt.createIdentity(),n=t.dotProduct(e),s=J.conditionalDivideCoordinate(1,-n);if(void 0!==s)return i.addScaledOuterProductInPlace(t,e,s),i}multiplyPoint(t,e){const i=t.x,n=t.y,s=t.z;return $.create(this.coffs[0]*i+this.coffs[1]*n+this.coffs[2]*s,this.coffs[3]*i+this.coffs[4]*n+this.coffs[5]*s,this.coffs[6]*i+this.coffs[7]*n+this.coffs[8]*s,e)}multiplyVector(t,e){const i=t.x,n=t.y,s=t.z;return tt.create(this.coffs[0]*i+this.coffs[1]*n+this.coffs[2]*s,this.coffs[3]*i+this.coffs[4]*n+this.coffs[5]*s,this.coffs[6]*i+this.coffs[7]*n+this.coffs[8]*s,e)}multiplyVectorArrayInPlace(t){for(const e of t)e.set(this.coffs[0]*e.x+this.coffs[1]*e.y+this.coffs[2]*e.z,this.coffs[3]*e.x+this.coffs[4]*e.y+this.coffs[5]*e.z,this.coffs[6]*e.x+this.coffs[7]*e.y+this.coffs[8]*e.z)}static xyzMinusMatrixTimesXYZ(t,e,i,n){const s=i.x,r=i.y,o=i.z;return $.create(t.x-(e.coffs[0]*s+e.coffs[1]*r+e.coffs[2]*o),t.y-(e.coffs[3]*s+e.coffs[4]*r+e.coffs[5]*o),t.z-(e.coffs[6]*s+e.coffs[7]*r+e.coffs[8]*o),n)}static xyPlusMatrixTimesXY(t,e,i,n){const s=i.x,r=i.y;return H.create(t.x+e.coffs[0]*s+e.coffs[1]*r,t.y+e.coffs[3]*s+e.coffs[4]*r,n)}static xyzPlusMatrixTimesXYZ(t,e,i,n){const s=i.x,r=i.y,o=i.z;return $.create(t.x+e.coffs[0]*s+e.coffs[1]*r+e.coffs[2]*o,t.y+e.coffs[3]*s+e.coffs[4]*r+e.coffs[5]*o,t.z+e.coffs[6]*s+e.coffs[7]*r+e.coffs[8]*o,n)}static xyzPlusMatrixTimesXYZInPlace(t,e,i){const n=i.x,s=i.y,r=i.z;i.x=t.x+e.coffs[0]*n+e.coffs[1]*s+e.coffs[2]*r,i.y=t.y+e.coffs[3]*n+e.coffs[4]*s+e.coffs[5]*r,i.z=t.z+e.coffs[6]*n+e.coffs[7]*s+e.coffs[8]*r}static xyzPlusMatrixTimesCoordinates(t,e,i,n,s,r){return $.create(t.x+e.coffs[0]*i+e.coffs[1]*n+e.coffs[2]*s,t.y+e.coffs[3]*i+e.coffs[4]*n+e.coffs[5]*s,t.z+e.coffs[6]*i+e.coffs[7]*n+e.coffs[8]*s,r)}static xyzPlusMatrixTimesWeightedCoordinates(t,e,i,n,s,r,o){return Ot.create(e.coffs[0]*i+e.coffs[1]*n+e.coffs[2]*s+t.x*r,e.coffs[3]*i+e.coffs[4]*n+e.coffs[5]*s+t.y*r,e.coffs[6]*i+e.coffs[7]*n+e.coffs[8]*s+t.z*r,r,o)}static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(t,e,i,n,s,r,o){return(!o||o.length<4)&&(o=new Float64Array(4)),o[0]=e.coffs[0]*i+e.coffs[1]*n+e.coffs[2]*s+t.x*r,o[1]=e.coffs[3]*i+e.coffs[4]*n+e.coffs[5]*s+t.y*r,o[2]=e.coffs[6]*i+e.coffs[7]*n+e.coffs[8]*s+t.z*r,o[3]=r,o}static xyzPlusMatrixTimesCoordinatesToFloat64Array(t,e,i,n,s,r){return(!r||r.length<3)&&(r=new Float64Array(3)),r[0]=e.coffs[0]*i+e.coffs[1]*n+e.coffs[2]*s+t.x,r[1]=e.coffs[3]*i+e.coffs[4]*n+e.coffs[5]*s+t.y,r[2]=e.coffs[6]*i+e.coffs[7]*n+e.coffs[8]*s+t.z,r}multiplyTransposeVector(t,e){e=e||new tt;const i=t.x,n=t.y,s=t.z;return e.x=this.coffs[0]*i+this.coffs[3]*n+this.coffs[6]*s,e.y=this.coffs[1]*i+this.coffs[4]*n+this.coffs[7]*s,e.z=this.coffs[2]*i+this.coffs[5]*n+this.coffs[8]*s,e}multiplyXYZ(t,e,i,n){return(n=n||new tt).x=this.coffs[0]*t+this.coffs[1]*e+this.coffs[2]*i,n.y=this.coffs[3]*t+this.coffs[4]*e+this.coffs[5]*i,n.z=this.coffs[6]*t+this.coffs[7]*e+this.coffs[8]*i,n}multiplyXYZtoXYZ(t,e){const i=t.x,n=t.y,s=t.z;return e.x=this.coffs[0]*i+this.coffs[1]*n+this.coffs[2]*s,e.y=this.coffs[3]*i+this.coffs[4]*n+this.coffs[5]*s,e.z=this.coffs[6]*i+this.coffs[7]*n+this.coffs[8]*s,e}multiplyXY(t,e,i){return(i=i||new tt).x=this.coffs[0]*t+this.coffs[1]*e,i.y=this.coffs[3]*t+this.coffs[4]*e,i.z=this.coffs[6]*t+this.coffs[7]*e,i}originPlusMatrixTimesXY(t,e,i,n){return $.create(t.x+this.coffs[0]*e+this.coffs[1]*i,t.y+this.coffs[3]*e+this.coffs[4]*i,t.z+this.coffs[6]*e+this.coffs[7]*i,n)}multiplyVectorInPlace(t){const e=t.x,i=t.y,n=t.z;t.x=this.coffs[0]*e+this.coffs[1]*i+this.coffs[2]*n,t.y=this.coffs[3]*e+this.coffs[4]*i+this.coffs[5]*n,t.z=this.coffs[6]*e+this.coffs[7]*i+this.coffs[8]*n}multiplyTransposeVectorInPlace(t){const e=t.x,i=t.y,n=t.z;t.x=this.coffs[0]*e+this.coffs[3]*i+this.coffs[6]*n,t.y=this.coffs[1]*e+this.coffs[4]*i+this.coffs[7]*n,t.z=this.coffs[2]*e+this.coffs[5]*i+this.coffs[8]*n}multiplyTransposeXYZ(t,e,i,n){return(n=n||new tt).x=this.coffs[0]*t+this.coffs[3]*e+this.coffs[6]*i,n.y=this.coffs[1]*t+this.coffs[4]*e+this.coffs[7]*i,n.z=this.coffs[2]*t+this.coffs[5]*e+this.coffs[8]*i,n}multiplyInverse(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,n=t.y,s=t.z;return tt.create(this.inverseCoffs[0]*i+this.inverseCoffs[1]*n+this.inverseCoffs[2]*s,this.inverseCoffs[3]*i+this.inverseCoffs[4]*n+this.inverseCoffs[5]*s,this.inverseCoffs[6]*i+this.inverseCoffs[7]*n+this.inverseCoffs[8]*s,e)}}multiplyInverseTranspose(t,e){if(this.computeCachedInverse(!0),this.inverseCoffs){const i=t.x,n=t.y,s=t.z;return tt.create(this.inverseCoffs[0]*i+this.inverseCoffs[3]*n+this.inverseCoffs[6]*s,this.inverseCoffs[1]*i+this.inverseCoffs[4]*n+this.inverseCoffs[7]*s,this.inverseCoffs[2]*i+this.inverseCoffs[5]*n+this.inverseCoffs[8]*s,e)}}multiplyInverseXYZAsVector3d(t,e,i,n){if(this.computeCachedInverse(!0),this.inverseCoffs)return tt.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,n)}multiplyInverseXYZW(t,e,i,n,s){if(this.computeCachedInverse(!0),this.inverseCoffs)return Ot.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,n,s)}multiplyInverseXYZAsPoint3d(t,e,i,n){if(this.computeCachedInverse(!0),this.inverseCoffs)return $.create(this.inverseCoffs[0]*t+this.inverseCoffs[1]*e+this.inverseCoffs[2]*i,this.inverseCoffs[3]*t+this.inverseCoffs[4]*e+this.inverseCoffs[5]*i,this.inverseCoffs[6]*t+this.inverseCoffs[7]*e+this.inverseCoffs[8]*i,n)}finishInverseCoffs(t,e,i){e&&i?(this.createInverseCoffsWithZeros(),this.inverseState=y.inverseStored,t(e,i,this.inverseCoffs)):this.inverseState=y.unknown}multiplyMatrixMatrix(t,e){return e=e||new xt,_t.multiplyMatrixMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===y.inverseStored&&t.inverseState===y.inverseStored?e.finishInverseCoffs(((t,e,i)=>_t.multiplyMatrixMatrix(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===y.singular||t.inverseState===y.singular?e.inverseState=y.singular:e.inverseState=y.unknown,e}multiplyMatrixMatrixInverse(t,e){if(t.computeCachedInverse(!0))return e=e||new xt,_t.multiplyMatrixMatrix(this.coffs,t.inverseCoffs,xt._productBuffer),this.inverseState===y.inverseStored?e.finishInverseCoffs(((t,e,i)=>_t.multiplyMatrixMatrix(t,e,i)),t.coffs,this.inverseCoffs):e.inverseState=y.unknown,_t.copy(xt._productBuffer,e.coffs),e}multiplyMatrixInverseMatrix(t,e){if(this.computeCachedInverse(!0))return e=e||new xt,_t.multiplyMatrixMatrix(this.inverseCoffs,t.coffs,xt._productBuffer),t.inverseState===y.inverseStored?e.finishInverseCoffs(((t,e,i)=>_t.multiplyMatrixMatrix(t,e,i)),t.inverseCoffs,this.coffs):e.inverseState=y.unknown,_t.copy(xt._productBuffer,e.coffs),e}multiplyMatrixMatrixTranspose(t,e){return e=e||new xt,_t.multiplyMatrixMatrixTranspose(this.coffs,t.coffs,e.coffs),this.inverseState===y.inverseStored&&t.inverseState===y.inverseStored?e.finishInverseCoffs(((t,e,i)=>_t.multiplyMatrixTransposeMatrix(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===y.singular||t.inverseState===y.singular?e.inverseState=y.singular:e.inverseState=y.unknown,e}multiplyMatrixTransposeMatrix(t,e){return e=e||new xt,_t.multiplyMatrixTransposeMatrix(this.coffs,t.coffs,e.coffs),this.inverseState===y.inverseStored&&t.inverseState===y.inverseStored?e.finishInverseCoffs(((t,e,i)=>_t.multiplyMatrixMatrixTranspose(t,e,i)),t.inverseCoffs,this.inverseCoffs):this.inverseState===y.singular||t.inverseState===y.singular?e.inverseState=y.singular:e.inverseState=y.unknown,e}multiplyMatrixTransform(t,e){return e?(this.multiplyXYZtoXYZ(t.origin,e.origin),this.multiplyMatrixMatrix(t.matrix,e.matrix),e):mt.createRefs(this.multiplyXYZ(t.origin.x,t.origin.y,t.origin.z),this.multiplyMatrixMatrix(t.matrix))}transpose(t){return t||(t=new xt),_t.copyTransposed(this.coffs,t.coffs),void 0!==this.inverseCoffs?(t.inverseState=y.inverseStored,t.inverseCoffs=_t.copyTransposed(this.inverseCoffs,t.inverseCoffs)):(t.inverseState=this.inverseState,t.inverseCoffs=void 0),t}transposeInPlace(){_t.transposeInPlace(this.coffs),this.inverseCoffs&&_t.transposeInPlace(this.inverseCoffs)}inverse(t){if(this.computeCachedInverse(!0))return t===this?(_t.copy(this.coffs,xt._productBuffer),_t.copy(this.inverseCoffs,this.coffs),_t.copy(xt._productBuffer,this.inverseCoffs),t):(void 0===t&&(t=xt.createIdentity()),t.createInverseCoffsWithZeros(),_t.copy(this.coffs,t.inverseCoffs),_t.copy(this.inverseCoffs,t.coffs),t.inverseState=this.inverseState,t)}static rowColumnDot(t,e,i,n){return t[e]*i[n]+t[e+1]*i[n+3]+t[e+2]*i[n+6]}static indexedRowCrossProduct(t,e,i,n,s){n[s]=t[e+1]*t[i+2]-t[e+2]*t[i+1],n[s+3]=t[e+2]*t[i]-t[e]*t[i+2],n[s+6]=t[e]*t[i+1]-t[e+1]*t[i]}indexedColumnCrossProductInPlace(t,e,i){const n=this.coffs;n[i]=n[t+3]*n[e+6]-n[t+6]*n[e+3],n[i+3]=n[t+6]*n[e]-n[t]*n[e+6],n[i+6]=n[t]*n[e+3]-n[t+3]*n[e]}axisOrderCrossProductsInPlace(t){switch(t){case f.XYZ:this.indexedColumnCrossProductInPlace(0,1,2),this.indexedColumnCrossProductInPlace(2,0,1);break;case f.YZX:this.indexedColumnCrossProductInPlace(1,2,0),this.indexedColumnCrossProductInPlace(0,1,2);break;case f.ZXY:this.indexedColumnCrossProductInPlace(2,0,1),this.indexedColumnCrossProductInPlace(1,2,0);break;case f.XZY:this.indexedColumnCrossProductInPlace(0,2,1),this.indexedColumnCrossProductInPlace(1,0,2);break;case f.YXZ:this.indexedColumnCrossProductInPlace(1,0,2),this.indexedColumnCrossProductInPlace(2,1,0);break;case f.ZYX:this.indexedColumnCrossProductInPlace(2,1,0),this.indexedColumnCrossProductInPlace(0,2,1)}}normalizeColumnsInPlace(t){const e=this.columnXMagnitude(),i=this.columnYMagnitude(),n=this.columnZMagnitude();return t&&t.set(e,i,n),!(J.isSmallMetricDistance(e)||J.isSmallMetricDistance(i)||J.isSmallMetricDistance(n)||(this.scaleColumns(1/e,1/i,1/n,this),0))}normalizeRowsInPlace(t){const e=this.rowXMagnitude(),i=this.rowYMagnitude(),n=this.rowZMagnitude();return t&&t.set(e,i,n),!(J.isSmallMetricDistance(e)||J.isSmallMetricDistance(i)||J.isSmallMetricDistance(n)||(this.scaleRows(1/e,1/i,1/n,this),0))}isSingular(){return!this.computeCachedInverse(!0)}markSingular(){this.inverseState=y.singular}computeCachedInverse(t){if(t&&xt.useCachedInverse&&this.inverseState!==y.unknown)return xt.numUseCache++,this.inverseState===y.inverseStored;this.inverseState=y.unknown,this.createInverseCoffsWithZeros();const e=this.coffs,i=this.inverseCoffs;xt.indexedRowCrossProduct(e,3,6,i,0),xt.indexedRowCrossProduct(e,6,0,i,1),xt.indexedRowCrossProduct(e,0,3,i,2),xt.numComputeCache++;const n=xt.rowColumnDot(e,0,i,0);if(0===n)return this.inverseState=y.singular,this.inverseCoffs=void 0,!1;const s=1/n;for(let t=0;t<9;t++)i[t]*=s;return this.inverseState=y.inverseStored,!0}static flatIndexOf(t,e){return 3*J.cyclic3dAxis(t)+J.cyclic3dAxis(e)}indexedColumnWithWeight(t,e,i){return t=J.cyclic3dAxis(t),Ot.create(this.coffs[t],this.coffs[t+3],this.coffs[t+6],e,i)}at(t,e){return this.coffs[xt.flatIndexOf(t,e)]}setAt(t,e,i){this.coffs[xt.flatIndexOf(t,e)]=i,this.inverseState=y.unknown}scale(t,e){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*t,this.coffs[4]*t,this.coffs[5]*t,this.coffs[6]*t,this.coffs[7]*t,this.coffs[8]*t,e)}scaleColumns(t,e,i,n){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*e,this.coffs[2]*i,this.coffs[3]*t,this.coffs[4]*e,this.coffs[5]*i,this.coffs[6]*t,this.coffs[7]*e,this.coffs[8]*i,n)}scaleColumnsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=e,this.coffs[2]*=i,this.coffs[3]*=t,this.coffs[4]*=e,this.coffs[5]*=i,this.coffs[6]*=t,this.coffs[7]*=e,this.coffs[8]*=i,this.inverseState===y.inverseStored&&void 0!==this.inverseCoffs){const n=J.conditionalDivideFraction(1,t),s=J.conditionalDivideFraction(1,e),r=J.conditionalDivideFraction(1,i);void 0!==n&&void 0!==s&&void 0!==r?(this.inverseCoffs[0]*=n,this.inverseCoffs[1]*=n,this.inverseCoffs[2]*=n,this.inverseCoffs[3]*=s,this.inverseCoffs[4]*=s,this.inverseCoffs[5]*=s,this.inverseCoffs[6]*=r,this.inverseCoffs[7]*=r,this.inverseCoffs[8]*=r):this.inverseState=y.singular}}scaleRows(t,e,i,n){return xt.createRowValues(this.coffs[0]*t,this.coffs[1]*t,this.coffs[2]*t,this.coffs[3]*e,this.coffs[4]*e,this.coffs[5]*e,this.coffs[6]*i,this.coffs[7]*i,this.coffs[8]*i,n)}scaleRowsInPlace(t,e,i){if(this.coffs[0]*=t,this.coffs[1]*=t,this.coffs[2]*=t,this.coffs[3]*=e,this.coffs[4]*=e,this.coffs[5]*=e,this.coffs[6]*=i,this.coffs[7]*=i,this.coffs[8]*=i,this.inverseState===y.inverseStored&&void 0!==this.inverseCoffs){const n=J.conditionalDivideFraction(1,t),s=J.conditionalDivideFraction(1,e),r=J.conditionalDivideFraction(1,i);void 0!==n&&void 0!==s&&void 0!==r?(this.inverseCoffs[0]*=n,this.inverseCoffs[1]*=s,this.inverseCoffs[2]*=r,this.inverseCoffs[3]*=n,this.inverseCoffs[4]*=s,this.inverseCoffs[5]*=r,this.inverseCoffs[6]*=n,this.inverseCoffs[7]*=s,this.inverseCoffs[8]*=r):this.inverseState=y.singular}}addScaledInPlace(t,e){for(let i=0;i<9;i++)this.coffs[i]+=e*t.coffs[i];this.inverseState=y.unknown}addScaledOuterProductInPlace(t,e,i){this.coffs[0]+=i*t.x*e.x,this.coffs[1]+=i*t.x*e.y,this.coffs[2]+=i*t.x*e.z,this.coffs[3]+=i*t.y*e.x,this.coffs[4]+=i*t.y*e.y,this.coffs[5]+=i*t.y*e.z,this.coffs[6]+=i*t.z*e.x,this.coffs[7]+=i*t.z*e.y,this.coffs[8]+=i*t.z*e.z,this.inverseState=y.unknown}static createRigidViewAxesZTowardsEye(t,e,i,n){n=xt.createIdentity(n);const s=J.hypotenuseXY(t,e);if(J.isSmallMetricDistance(s))i<0&&n.scaleColumnsInPlace(1,-1,-1);else{const r=t/s,o=e/s;if(n.setRowValues(-o,0,r,r,0,o,0,1,0),0!==i){const r=J.hypotenuseXYZ(t,e,i),o=i/r,a=s/r;n.applyGivensColumnOp(1,2,a,-o)}}return n}determinant(){return this.coffs[0]*this.coffs[4]*this.coffs[8]-this.coffs[0]*this.coffs[5]*this.coffs[7]-this.coffs[1]*this.coffs[3]*this.coffs[8]+this.coffs[1]*this.coffs[5]*this.coffs[6]+this.coffs[2]*this.coffs[3]*this.coffs[7]-this.coffs[2]*this.coffs[4]*this.coffs[6]}conditionNumber(){const t=Math.abs(this.determinant()),e=J.hypotenuseXYZ(this.coffs[0],this.coffs[3],this.coffs[6])+J.hypotenuseXYZ(this.coffs[1],this.coffs[4],this.coffs[7])+J.hypotenuseXYZ(this.coffs[2],this.coffs[5],this.coffs[8]);return J.safeDivideFraction(t,e,0)}sumSquares(){let t=0;for(let e=0;e<9;e++)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonalSquares(){let t=0;for(let e=0;e<9;e+=4)t+=this.coffs[e]*this.coffs[e];return t}sumDiagonal(){return this.coffs[0]+this.coffs[4]+this.coffs[8]}maxAbs(){let t=0;for(let e=0;e<9;e++)t=Math.max(t,Math.abs(this.coffs[e]));return t}maxDiff(t){let e=0;for(let i=0;i<9;i++)e=Math.max(e,Math.abs(this.coffs[i]-t.coffs[i]));return e}get isIdentity(){return this.maxDiff(xt.identity)<J.smallAngleRadians}get isDiagonal(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);return Math.sqrt(i)<=J.smallAngleRadians*(1+Math.sqrt(t))}sumSkewSquares(){return J.hypotenuseSquaredXYZ(this.coffs[1]-this.coffs[3],this.coffs[2]-this.coffs[6],this.coffs[5]-this.coffs[7])}isSymmetric(){const t=this.sumSkewSquares();return Math.sqrt(t)<=J.smallAngleRadians*(1+Math.sqrt(this.sumSquares()))}get hasCachedInverse(){return this.inverseState===y.inverseStored&&void 0!==this.inverseCoffs}get isUpperTriangular(){const t=this.sumSquares(),e=J.hypotenuseSquaredXYZ(this.coffs[3],this.coffs[6],this.coffs[7]);return Math.sqrt(e)<=J.smallAngleRadians*(1+Math.sqrt(t))}get isLowerTriangular(){const t=this.sumSquares(),e=J.hypotenuseSquaredXYZ(this.coffs[1],this.coffs[2],this.coffs[5]);return Math.sqrt(e)<=J.smallAngleRadians*(1+Math.sqrt(t))}sameDiagonalScale(){const t=this.sumSquares(),e=this.sumDiagonalSquares(),i=Math.abs(t-e);if(Math.sqrt(i)<=J.smallAngleRadians*(1+Math.sqrt(t))&&J.isSameCoordinate(this.coffs[0],this.coffs[4])&&J.isSameCoordinate(this.coffs[0],this.coffs[8]))return this.coffs[0]}testPerpendicularUnitRowsAndColumns(){return this.multiplyMatrixMatrixTranspose(this).isIdentity}isRigid(t=!1){return this.testPerpendicularUnitRowsAndColumns()&&(t||this.determinant()>0)}factorRigidWithSignedScale(t){const e=this.multiplyMatrixMatrixTranspose(this).sameDiagonalScale();if(void 0===e||e<=0)return;const i=this.determinant()>0?Math.sqrt(e):-Math.sqrt(e),n=1/i;return{rigidAxes:this.scaleColumns(n,n,n,t),scale:i}}factorRigidSkew(t,e,i=f.XYZ){return xt.createRigidFromMatrix3d(this,i,t)?(t.multiplyMatrixTransposeMatrix(this,e),!0):(t.setIdentity(),e.setFrom(this),!1)}get isSignedPermutation(){let t=0;for(let e=0;e<3;e++)for(let i=0;i<3;i++){const n=this.at(e,i);if(0===n);else{if(1!==n&&-1!==n)return!1;if(t++,0!==this.at(e+1,i)||0!==this.at(e+2,i)||0!==this.at(e,i+1)||0!==this.at(e,i+2))return!1}}return 3===t}makeRigid(t=f.XYZ){const e=this.maxAbs();if(J.isSmallMetricDistance(e))return!1;const i=1/e;return this.scaleColumnsInPlace(i,i,i),this.axisOrderCrossProductsInPlace(t),this.normalizeColumnsInPlace()}static createRigidFromMatrix3d(t,e=f.XYZ,i){if((i=t.clone(i)).makeRigid(e))return i}static createFromQuaternion(t){const e=t.x*t.x,i=t.y*t.y,n=t.z*t.z,s=t.w*t.w,r=e+i+n+s;if(0===r)return xt.createIdentity();{const o=1/r;return xt.createRowValues(o*(s+e-i-n),2*o*(t.w*t.z+t.x*t.y),2*o*(t.x*t.z-t.w*t.y),2*o*(t.x*t.y-t.w*t.z),o*(s-e+i-n),2*o*(t.w*t.x+t.y*t.z),2*o*(t.x*t.z+t.w*t.y),2*o*(t.y*t.z-t.w*t.x),o*(s-e-i+n))}}static computeQuatTerm(t,e,i,n){let s;return n>.5?(s=.5*Math.sqrt(n),e*t<0&&(s=-s)):s=t*i,s}toQuaternion(){const t=Ot.createZero(),e=[[this.coffs[0],this.coffs[3],this.coffs[6]],[this.coffs[1],this.coffs[4],this.coffs[7]],[this.coffs[2],this.coffs[5],this.coffs[8]]],i=e[0][0],n=e[1][1],s=e[2][2],r=[];let o;r[0]=1+i-n-s,r[1]=1-i+n-s,r[2]=1-i-n+s,r[3]=1+i+n+s;let a=0;for(let t=1;t<=3;t++)r[t]>r[a]&&(a=t);return 0===a?(t.x=.5*Math.sqrt(r[0]),o=1/(4*t.x),t.y=xt.computeQuatTerm(e[0][1]+e[1][0],t.x,o,r[1]),t.z=xt.computeQuatTerm(e[0][2]+e[2][0],t.x,o,r[2]),t.w=xt.computeQuatTerm(e[2][1]-e[1][2],t.x,o,r[3])):1===a?(t.y=.5*Math.sqrt(r[1]),o=1/(4*t.y),t.x=xt.computeQuatTerm(e[0][1]+e[1][0],t.y,o,r[0]),t.z=xt.computeQuatTerm(e[1][2]+e[2][1],t.y,o,r[2]),t.w=xt.computeQuatTerm(e[0][2]-e[2][0],t.y,o,r[3])):2===a?(t.z=.5*Math.sqrt(r[2]),o=1/(4*t.z),t.x=xt.computeQuatTerm(e[0][2]+e[2][0],t.z,o,r[0]),t.y=xt.computeQuatTerm(e[1][2]+e[2][1],t.z,o,r[1]),t.w=xt.computeQuatTerm(e[1][0]-e[0][1],t.z,o,r[3])):(t.w=.5*Math.sqrt(r[3]),o=1/(4*t.w),t.x=xt.computeQuatTerm(e[2][1]-e[1][2],t.w,o,r[0]),t.y=xt.computeQuatTerm(e[0][2]-e[2][0],t.w,o,r[1]),t.z=xt.computeQuatTerm(e[1][0]-e[0][1],t.w,o,r[2])),t}}class yt extends et{_origin;_normal;constructor(t,e){super(),this._origin=t,this._normal=e}static _create(t,e,i,n,s,r){return new yt($.create(t,e,i),tt.create(n,s,r))}static createXYPlane(t){return t?yt._create(t.x,t.y,t.z,0,0,1):yt._create(0,0,0,0,0,1)}static createYZPlane(t){return t?yt._create(t.x,t.y,t.z,1,0,0):yt._create(0,0,0,1,0,0)}static createZXPlane(t){return t?yt._create(t.x,t.y,t.z,0,1,0):yt._create(0,0,0,0,1,0)}static create(t,e,i){if(i){if(void 0===e.normalize(i._normal))return;return t.clone(i._origin),i}const n=e.normalize();if(void 0!==n)return new yt(t.clone(),n)}static createFrom(t,e){if(t instanceof yt)return t.clone(e);if(e){if(void 0===t.getUnitNormal(e._normal))return;return t.getAnyPointOnPlane(e._origin),e}const i=t.getUnitNormal();if(void 0===i)return;const n=t.getAnyPointOnPlane();return new yt(n,i)}static createXYZUVW(t,e,i,n,s,r,o){const a=J.hypotenuseXYZ(n,s,r);if(!(a<J.smallMetricDistance))return o?(o._origin.set(t,e,i),o._normal.set(n/a,s/a,r/a),o):new yt($.create(t,e,i),tt.create(n/a,s/a,r/a))}static createOriginAndTargetXY(t,e,i){const n=e.x-t.x,s=e.y-t.y;return this.createXYZUVW(t.x,t.y,0,s,-n,0,i)}static createXYAngle(t,e,i,n){return n?(n._origin.set(t,e,0),n._normal.set(i.cos(),i.sin(),0),n):new yt($.create(t,e,0),tt.create(i.cos(),i.sin()))}static createPointPointVectorInPlane(t,e,i){const n=i.crossProductStartEnd(t,e);if(n.tryNormalizeInPlace())return new yt(t,n)}static createOriginAndTargets(t,e,i){const n=t.crossProductToPoints(e,i);if(n.tryNormalizeInPlace())return new yt(t,n)}static createOriginAndVectors(t,e,i){const n=e.crossProduct(i);if(n.tryNormalizeInPlace())return new yt(t,n)}isAlmostEqual(t){return this._origin.isAlmostEqual(t._origin)&&this._normal.isAlmostEqual(t._normal)}setFromJSON(t){t?(this._origin.setFromJSON(t.origin),this._normal.setFromJSON(t.normal)):(this._origin.set(0,0,0),this._normal.set(0,0,1))}toJSON(){return{origin:this._origin.toJSON(),normal:this._normal.toJSON()}}static fromJSON(t){const e=yt.createXYPlane();return e.setFromJSON(t),e}getOriginRef(){return this._origin}getNormalRef(){return this._normal}getLocalToWorld(){const t=xt.createRigidHeadsUp(this._normal,f.ZXY);return mt.createRefs(this._origin.clone(),t)}getProjectionToPlane(){const t=xt.createIdentity();return t.addScaledOuterProductInPlace(this._normal,this._normal,-1),t.markSingular(),mt.createFixedPointAndMatrix(this._origin,t)}set(t,e){this._origin.setFrom(t),this._normal.setFrom(e)}clone(t){return t?(t.set(this._origin,this._normal),t):new yt(this._origin.clone(),this._normal.clone())}cloneTransformed(t,e=!1){const i=this.clone();if(e){if(t.multiplyInversePoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyTransposeVector(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}else if(t.multiplyPoint3d(i._origin,i._origin),void 0!==t.matrix.multiplyInverseTranspose(i._normal,i._normal)&&i._normal.normalizeInPlace())return i}setFrom(t){this.set(t._origin,t._normal)}altitude(t){return this._normal.dotProductStartEnd(this._origin,t)}altitudeXY(t,e){return(t-this._origin.x)*this._normal.x+(e-this._origin.y)*this._normal.y}normalX(){return this._normal.x}normalY(){return this._normal.y}normalZ(){return this._normal.z}getUnitNormal(t){return this._normal.clone(t)}getAnyPointOnPlane(t){return this._origin.clone(t)}weightedAltitude(t){return this._normal.dotProductStart3dEnd4d(this._origin,t)}altitudeToPoint(t,e){return this._origin.plusScaled(this._normal,t,e)}velocityXYZ(t,e,i){return this._normal.dotProductXYZ(t,e,i)}velocity(t){return this._normal.dotProduct(t)}altitudeXYZ(t,e,i){return this._normal.dotProductStartEndXYZ(this._origin,t,e,i)}altitudeXYZW(t,e,i,n){return this._normal.dotProductStartEndXYZW(this._origin,t,e,i,n)}projectPointToPlane(t,e){return this.projectXYZToPlane(t.x,t.y,t.z,e)}projectXYZToPlane(t,e,i,n){const s=-this._normal.dotProductStartEndXYZ(this._origin,t,e,i);return $.create(t+s*this._normal.x,e+s*this._normal.y,i+s*this._normal.z,n)}isPointInPlane(t,e=J.smallMetricDistance){const i=this._normal.dotProductStartEnd(this._origin,t);return Math.abs(i)<=e}}function vt(t,e){return t?t.clone(e):void 0}!function(t){t[t.isolated=0]="isolated",t[t.isolatedAtVertex=1]="isolatedAtVertex",t[t.intervalStart=10]="intervalStart",t[t.intervalInterior=11]="intervalInterior",t[t.intervalEnd=12]="intervalEnd"}(v||(v={})),function(t){t[t.error=0]="error",t[t.success=1]="success",t[t.stoppedAtBoundary=2]="stoppedAtBoundary"}(P||(P={}));class Pt{curve;ray;fraction;intervalRole;point;vectorInCurveLocationDetail;a;childDetail;curveSearchStatus;fraction1;point1;pointQ;constructor(){this.pointQ=$.createZero(),this.fraction=0,this.point=$.createZero(),this.a=0}setIntervalRole(t){this.intervalRole=t}captureFraction1Point1(t,e){this.fraction1=t,this.point1=e}get hasFraction1(){return void 0!==this.fraction1}get isIsolated(){return void 0===this.intervalRole||this.intervalRole===v.isolated||this.intervalRole===v.isolatedAtVertex}get fractionDelta(){return void 0!==this.fraction1?this.fraction1-this.fraction:0}collapseToEnd(){void 0!==this.fraction1&&(this.fraction=this.fraction1),this.point1&&(this.point=this.point1),this.collapseToStart()}collapseToStart(){this.fraction1=void 0,this.point1=void 0}clone(t){return t===this||((t=t||new Pt).curve=this.curve,t.fraction=this.fraction,t.fraction1=this.fraction1,t.point1=vt(this.point1,t.point1),t.point.setFromPoint3d(this.point),t.vectorInCurveLocationDetail=vt(this.vectorInCurveLocationDetail,t.vectorInCurveLocationDetail),t.a=this.a,t.childDetail=vt(this.childDetail,t.childDetail),t.curveSearchStatus=this.curveSearchStatus),t}setFP(t,e,i,n=0){this.fraction=t,this.point.setFromPoint3d(e),this.vectorInCurveLocationDetail=vt(i,this.vectorInCurveLocationDetail),this.a=n}setFR(t,e,i=0){return this.setFP(t,e.origin,e.direction,i)}setCurve(t){this.curve=t}setDistanceTo(t){this.a=this.point.distance(t)}static create(t,e){return(e=e||new Pt).curve=t,e}static createCurveFractionPoint(t,e,i,n){return(n=n||new Pt).curve=t,n.fraction=e,n.point.setFromPoint3d(i),n.vectorInCurveLocationDetail=void 0,n.a=0,n.childDetail=void 0,n.curveSearchStatus=void 0,n}static createRayFractionPoint(t,e,i,n){return(n=n||new Pt).fraction=e,n.ray=t,n.point.setFromPoint3d(i),n}static createCurveFractionPointDistanceCurveSearchStatus(t,e,i,n,s,r){return(r=r||new Pt).curve=t,r.fraction=e,r.point.setFromPoint3d(i),r.vectorInCurveLocationDetail=void 0,r.a=n,r.childDetail=void 0,r.curveSearchStatus=s,r}static createConditionalMoveSignedDistance(t,e,i,n,s,r){let o=s,a=P.success;return t||J.isIn01(n)||(n<0?(o=-e.curveLengthBetweenFractions(i,0),n=0,a=P.stoppedAtBoundary):n>1&&(n=1,o=e.curveLengthBetweenFractions(i,1),a=P.stoppedAtBoundary)),(r=r||new Pt).curve=e,r.fraction=n,e.fractionToPoint(n,r.point),r.vectorInCurveLocationDetail=void 0,r.a=o,r.childDetail=void 0,r.curveSearchStatus=a,r}static createCurveEvaluatedFraction(t,e,i){return(i=i||new Pt).curve=t,i.fraction=e,t.fractionToPoint(e,i.point),i.vectorInCurveLocationDetail=void 0,i.a=0,i.childDetail=void 0,i.curveSearchStatus=void 0,i}static createCurveEvaluatedFractionPointAndDerivative(t,e,i){(i=i||new Pt).curve=t,i.fraction=e;const n=t.fractionToPointAndDerivative(e);return i.point.setFromPoint3d(n.origin),i.vectorInCurveLocationDetail=n.direction,i.a=0,i.childDetail=void 0,i.curveSearchStatus=void 0,i}static createCurveEvaluatedFractionFraction(t,e,i,n){return(n=n||new Pt).curve=t,n.fraction=e,t.fractionToPoint(e,n.point),n.fraction1=i,n.point1=t.fractionToPoint(i,n.point1),n.vectorInCurveLocationDetail=void 0,n.a=0,n.childDetail=void 0,n.curveSearchStatus=void 0,n}static createCurveFractionPointDistance(t,e,i,n,s){return(s=s||new Pt).curve=t,s.fraction=e,s.point.setFromPoint3d(i),s.vectorInCurveLocationDetail=void 0,s.a=n,s.childDetail=void 0,s.curveSearchStatus=void 0,s}updateIfCloserCurveFractionPointDistance(t,e,i,n){return!(this.a<n||(Pt.createCurveFractionPointDistance(t,e,i,n,this),0))}swapFractionsAndPoints(){if(void 0!==this.fraction1){const t=this.fraction;this.fraction=this.fraction1,this.fraction1=t}if(void 0!==this.point1){const t=this.point;this.point=this.point1,this.point1=t}}inverseInterpolateFraction(t,e=0){const i=J.inverseInterpolate01(this.fraction,this.fraction1,t);return void 0===i?e:i}static chooseSmallerA(t,e){return t?e?t.a<=e.a?t:e:t:e}isSameCurveAndFraction(t){return this.curve===t.curve&&J.isAlmostEqualNumber(this.fraction,t.fraction)}tryTransformInPlace(t){return!(this.curve&&!this.curve.tryTransformInPlace(t)||(this.ray&&this.ray.transformInPlace(t),this.curve?this.curve.fractionToPoint(this.fraction,this.point):t.multiplyXYAndZInPlace(this.point),this.vectorInCurveLocationDetail&&t.multiplyVectorInPlace(this.vectorInCurveLocationDetail),this.childDetail&&this.childDetail!==this&&!this.childDetail.tryTransformInPlace(t)||(this.point1&&(this.curve&&this.fraction1?this.curve.fractionToPoint(this.fraction1,this.point1):t.multiplyXYAndZInPlace(this.point1)),0)))}}!function(t){t[t.Intersection=0]="Intersection",t[t.PerpendicularChord=1]="PerpendicularChord",t[t.CoincidentGeometry=2]="CoincidentGeometry",t[t.ParallelGeometry=3]="ParallelGeometry"}(I||(I={}));class It{detailA;detailB;approachType;constructor(t,e){this.detailA=t||new Pt,this.detailB=e||new Pt}static createCapture(t,e,i){return(i=i||new It).detailA=t,i.detailB=e,i}static createCaptureOptionalReverse(t,e,i,n){return(n=n||new It).detailA=t,n.detailB=e,n}clone(t){return(t=t||new It).detailA=this.detailA.clone(),t.detailB=this.detailB.clone(),t.approachType=this.approachType,t}swapDetails(){const t=this.detailA;this.detailA=this.detailB,this.detailB=t}static removeAdjacentDuplicates(t,e=0){return t.flatMap(((t,i,n)=>i>=e&&i>0&&!t.detailA.hasFraction1&&!t.detailB.hasFraction1&&t.detailA.isSameCurveAndFraction(n[i-1].detailA)&&t.detailB.isSameCurveAndFraction(n[i-1].detailB)?[]:[t]))}tryTransformInPlace(t){return this.detailA.tryTransformInPlace(t)&&this.detailB.tryTransformInPlace(t)}}class St{_radians0;_radians1;get startDegrees(){return G.radiansToDegrees(this._radians0)}get endDegrees(){return G.radiansToDegrees(this._radians1)}get sweepDegrees(){return G.radiansToDegrees(this.sweepRadians)}get startRadians(){return this._radians0}get endRadians(){return this._radians1}get sweepRadians(){return this._radians1-this._radians0}get isEmpty(){return G.isAlmostEqualRadiansNoPeriodShift(0,this.sweepRadians)}get startAngle(){return G.createRadians(this._radians0)}get endAngle(){return G.createRadians(this._radians1)}static create(t){return t instanceof St?t.clone():t instanceof G?new St(0,t.radians):St.create360()}constructor(t=0,e=0){this._radians0=t,this._radians1=e}setStartEndRadians(t=0,e=2*Math.PI){const i=e-t;G.isFullCircleRadians(i)&&(e=t+(i>0?2:-2)*Math.PI),this._radians0=t,this._radians1=e}setStartEndDegrees(t=0,e=360){this.setStartEndRadians(G.degreesToRadians(t),G.degreesToRadians(e))}static createStartEndRadians(t=0,e=2*Math.PI,i){return(i=i||new St).setStartEndRadians(t,e),i}cloneMinusRadians(t){return new St(this._radians0-t,this._radians1-t)}static createStartEndDegrees(t=0,e=360,i){return St.createStartEndRadians(G.degreesToRadians(t),G.degreesToRadians(e),i)}static createStartEnd(t,e,i){return(i=i||new St).setStartEndRadians(t.radians,e.radians),i}static createStartSweepRadians(t=0,e=Math.PI,i){return(i=i||new St).setStartEndRadians(t,t+e),i}static createStartSweepDegrees(t=0,e=360,i){return St.createStartEndRadians(G.degreesToRadians(t),G.degreesToRadians(t+e),i)}static createStartSweep(t,e,i){return St.createStartSweepRadians(t.radians,e.radians,i)}interpolate(t,e){return new St(J.interpolate(this._radians0,t,e._radians0),J.interpolate(this._radians1,t,e._radians1))}setFrom(t){this._radians0=t._radians0,this._radians1=t._radians1}static create360(t){return new St(t=t||0,t+2*Math.PI)}static createFullLatitude(){return St.createStartEndRadians(-.5*Math.PI,.5*Math.PI)}reverseInPlace(){const t=this._radians0;this._radians0=this._radians1,this._radians1=t}cloneComplement(t=!1,e){const i=this.sweepRadians>=0?2:-2;return t?St.createStartEndRadians(this.startRadians,this.endRadians-i*Math.PI,e):St.createStartEndRadians(this.endRadians,this.startRadians+i*Math.PI,e)}capLatitudeInPlace(){const t=.5*Math.PI;this._radians0=J.clampToStartEnd(this._radians0,-t,t),this._radians1=J.clampToStartEnd(this._radians1,-t,t)}clampToFullCircle(t){t=t??new St;const e=J.clampToStartEnd(this.sweepRadians,-G.pi2Radians,G.pi2Radians);return t.setStartEndRadians(this._radians0,this._radians0+e),t}get isCCW(){return this._radians1>=this._radians0}get isFullCircle(){return G.isFullCircleRadians(this.sweepRadians)}get isFullLatitudeSweep(){const t=.5*Math.PI;return G.isAlmostEqualRadiansNoPeriodShift(this._radians0,-t)&&G.isAlmostEqualRadiansNoPeriodShift(this._radians1,t)}clone(){return new St(this._radians0,this._radians1)}fractionToRadians(t){return t<.5?this._radians0+t*this.sweepRadians:this._radians1+(t-1)*this.sweepRadians}fractionToAngle(t){return G.createRadians(this.fractionToRadians(t))}fractionPeriod(){return this.isEmpty?1:G.pi2Radians/Math.abs(this.sweepRadians)}angleToUnboundedFraction(t){return this.isEmpty?1:(t.radians-this._radians0)/this.sweepRadians}static fractionToSignedPeriodicFractionStartEnd(t,e,i,n){const s=i-e;if(G.isAlmostEqualRadiansNoPeriodShift(0,s))return t;if(J.isIn01(t))return t;const r=G.pi2Radians/Math.abs(s);if((t%=r)+r<1&&(t+=r),J.isIn01(t))return t;if(!0===n)return t<0?t:t-r;if(!1===n)return t>1?t:t+r;const o=t<0?t+r:t-r;return(t<0?-t:t-1)<(o<0?-o:o-1)?t:o}fractionToSignedPeriodicFraction(t,e){return St.fractionToSignedPeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}static radiansToPositivePeriodicFractionStartEnd(t,e,i,n=0){const s=J.largeCoordinateResult;let r=this.radiansToSignedPeriodicFractionStartEnd(t,e,i,s);return r===s?n:(r<0&&(r+=G.pi2Radians/Math.abs(i-e)),r)}radiansToPositivePeriodicFraction(t,e=0){return St.radiansToPositivePeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}angleToPositivePeriodicFraction(t,e=0){return this.radiansToPositivePeriodicFraction(t.radians,e)}radiansArrayToPositivePeriodicFractions(t){const e=t.length;for(let i=0;i<e;i++)t.reassign(i,this.radiansToPositivePeriodicFraction(t.atUncheckedIndex(i)))}static radiansToSignedPeriodicFractionStartEnd(t,e,i,n=0){const s=i-e;if(G.isAlmostEqualRadiansNoPeriodShift(0,s))return n;if(G.isAlmostEqualRadiansAllowPeriodShift(e,i)){if(G.isAlmostEqualRadiansNoPeriodShift(t,e))return 0;if(G.isAlmostEqualRadiansNoPeriodShift(t,i))return 1}else{if(G.isAlmostEqualRadiansAllowPeriodShift(t,e))return 0;if(G.isAlmostEqualRadiansAllowPeriodShift(t,i))return 1}const r=(t-e)/s;return this.fractionToSignedPeriodicFractionStartEnd(r,e,i,r<0)}radiansToSignedPeriodicFraction(t,e=0){return St.radiansToSignedPeriodicFractionStartEnd(t,this._radians0,this._radians1,e)}angleToSignedPeriodicFraction(t,e=0){return this.radiansToSignedPeriodicFraction(t.radians,e)}static radiansToSignedFractionStartEnd(t,e,i,n=!1,s=0){const r=J.largeCoordinateResult;let o=this.radiansToSignedPeriodicFractionStartEnd(t,e,i,r);if(o===r)return s;if(n&&o>1||!n&&o<0){let t=G.pi2Radians/Math.abs(i-e);n&&(t=-t),o+=t}return o}radiansToSignedFraction(t,e=!1,i=0){return St.radiansToSignedFractionStartEnd(t,this._radians0,this._radians1,e,i)}angleToSignedFraction(t,e=!1,i=0){return this.radiansToSignedFraction(t.radians,e,i)}static isRadiansInStartEnd(t,e,i,n=!0){return(t-e)*(t-i)<=0||(e===i?n?G.isAlmostEqualRadiansAllowPeriodShift(t,e):G.isAlmostEqualRadiansNoPeriodShift(t,e):!!n&&this.radiansToPositivePeriodicFractionStartEnd(t,e,i,1e3)<=1)}isRadiansInSweep(t,e=!0){return St.isRadiansInStartEnd(t,this.startRadians,this.endRadians,e)}isAngleInSweep(t){return this.isRadiansInSweep(t.radians)}setFromJSON(t){t?t instanceof St?this.setFrom(t):J.isNumberArray(t.degrees,2)?this.setStartEndDegrees(t.degrees[0],t.degrees[1]):J.isNumberArray(t.radians,2)?this.setStartEndRadians(t.radians[0],t.radians[1]):J.isNumberArray(t,2)?this.setStartEndDegrees(t[0],t[1]):this.setStartEndRadians():this.setStartEndRadians()}static fromJSON(t){const e=St.create360();return e.setFromJSON(t),e}toJSON(){return[this.startDegrees,this.endDegrees]}isAlmostEqualAllowPeriodShift(t,e=J.smallAngleRadians){return this.isCCW===t.isCCW&&G.isAlmostEqualRadiansAllowPeriodShift(this._radians0,t._radians0,e)&&G.isAlmostEqualRadiansAllowPeriodShift(this.sweepRadians,t.sweepRadians,e)}isAlmostEqualNoPeriodShift(t,e=J.smallAngleRadians){return G.isAlmostEqualRadiansNoPeriodShift(this._radians0,t._radians0,e)&&G.isAlmostEqualRadiansNoPeriodShift(this.sweepRadians,t.sweepRadians,e)}isAlmostEqual(t){return this.isAlmostEqualNoPeriodShift(t)}}class bt{_data;_inUse;_growthFactor;constructor(t=8,e){this._data=new Float64Array(t),this._inUse=0,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let n=i??0;if(n<0&&(n=0),n>=this._data.length)return{count:0,offset:0};let s=e??t.length;return s>0&&(s>t.length&&(s=t.length),n+s>this._data.length&&(s=this._data.length-n)),s<=0?{count:0,offset:0}:(s===t.length?this._data.set(t,n):t instanceof Float64Array?this._data.set(t.subarray(0,s),n):this._data.set(t.slice(0,s),n),{count:s,offset:n})}static create(t){const e=new bt(t.length);return e.copyData(t),e._inUse=t.length,e}static compare(t,e){return t-e}clone(t=!1){const e=new bt(t?this.capacity():this._inUse);return e.copyData(this._data,this._inUse),e._inUse=this._inUse,e}get length(){return this._inUse}setAtUncheckedIndex(t,e){this._data[t]=e}move(t,e){this._data[e]=this._data[t]}swap(t,e){const i=this._data[t];this._data[t]=this._data[e],this._data[e]=i}push(t){this.ensureCapacity(this._inUse+1),this._data[this._inUse]=t,this._inUse++}pushArray(t){this.ensureCapacity(this._inUse+t.length),this.copyData(t,t.length,this._inUse),this._inUse+=t.length}pushBlockCopy(t,e){t>=0&&t<this._inUse&&e>0&&t+e<=this._inUse&&(this.ensureCapacity(this._inUse+e),this._data.copyWithin(this._inUse,t,t+e),this._inUse+=e)}clear(){this._inUse=0}capacity(){return this._data.length}ensureCapacity(t,e=!0){if(t>this.capacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t),this.copyData(i,this._inUse)}}resize(t,e=0){t>=0&&t<this._inUse?this._inUse=t:t>this._inUse&&(this.ensureCapacity(t,!1),this._data.fill(e,this._inUse),this._inUse=t)}pop(){this._inUse>0&&this._inUse--}atUncheckedIndex(t){return this._data[t]}front(){return this._data[0]}back(){return this._data[this._inUse-1]}reassign(t,e){this._data[t]=e}sort(t=(t,e)=>bt.compare(t,e)){for(let e=0;e<this._inUse;e++)for(let i=e+1;i<this._inUse;i++){const n=this._data[e],s=this._data[i];t(n,s)>0&&(this._data[e]=s,this._data[i]=n)}}restrictToInterval(t,e){const i=this._data,n=i.length;let s=0,r=0;for(let o=0;o<n;o++)r=i[o],r>=t&&r<=e&&(i[s++]=r);this._inUse=s}compressAdjacentDuplicates(t=0){const e=this._data,i=this._inUse;if(0===i)return;let n,s=1,r=e[0];for(let o=1;o<i;o++)n=e[o],Math.abs(n-r)>t&&(e[s++]=n,r=n);this._inUse=s}reverseInPlace(){this._data.reverse()}}class At{coffs;constructor(t=0,e=0,i=0){this.coffs=[t,e,i]}static solveQuadratic(t,e,i){const n=J.conditionalDivideFraction(e,t),s=J.conditionalDivideFraction(i,t);if(void 0!==n&&void 0!==s){const t=n*n-4*s;if(t>0){const e=Math.sqrt(t);return[.5*(-n-e),.5*(-n+e)]}if(t<0)return;const e=-.5*n;return[e,e]}const r=J.conditionalDivideFraction(-i,e);if(void 0!==r)return[r]}addConstant(t){this.coffs[0]+=t}addSquaredLinearTerm(t,e,i=1){this.coffs[0]+=i*(t*t),this.coffs[1]+=i*(2*t*e),this.coffs[2]+=i*(e*e)}realRoots(){const t=At.solveQuadratic(this.coffs[2],this.coffs[1],this.coffs[0]);if(t&&t.length>1&&t[0]>t[1]){const e=t[0];t[0]=t[1],t[1]=e}return t}evaluate(t){return this.coffs[0]+t*(this.coffs[1]+t*this.coffs[2])}evaluateDerivative(t){return this.coffs[1]+2*t*this.coffs[2]}tryGetVertexFactorization(){const t=J.conditionalDivideFraction(-this.coffs[1],2*this.coffs[2]);if(void 0!==t){const e=this.evaluate(t);return{c:this.coffs[2],x0:t,y0:e}}}static fromRootsAndC2(t,e,i=1){return new At(i*t*e,-i*(t+e),i)}}class Ct{static _EQN_EPS=1e-9;static _safeDivideFactor=1e-14;static isZero(t){return Math.abs(t)<this._EQN_EPS}static isSmallRatio(t,e,i=1e-9,n=8e-16){return Math.abs(t)<=i||Math.abs(t)<n*Math.abs(e)}static cbrt(t){return t>0?Math.pow(t,1/3):t<0?-Math.pow(-t,1/3):0}static safeDivide(t,e,i,n=0,s){return Math.abs(i)>this._safeDivideFactor*Math.abs(e)?(t[s]=e/i,!0):(t[s]=n,!1)}static checkRootProximity(t,e){return 0===e?t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):e>0&&e+1<t.length?t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)&&t.atUncheckedIndex(e)<t.atUncheckedIndex(e+1):t.atUncheckedIndex(e)>t.atUncheckedIndex(e-1)}static newtonMethodAdjustment(t,e,i){let n=t[i],s=0;for(let r=i-1;r>=0;r--)s=n+e*s,n=t[r]+e*n;if(Math.abs(s)>=1e-14*(1+Math.abs(e)))return n/s}static improveRoots(t,e,i,n){for(let s=0;s<i.length;s++){let r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(s),e);if(void 0===r||0===r)continue;const o=i.atUncheckedIndex(s);let a=0,c=0;for(;void 0!==r&&0!==r&&a<12;){if(Math.abs(r)<1e-10*(1+Math.abs(i.atUncheckedIndex(s)))){if(++c>1)break}else c=0;const l=i.atUncheckedIndex(s)-r;if(i.reassign(s,l),n&&!this.checkRootProximity(i,s)){i.reassign(s,o);break}r=this.newtonMethodAdjustment(t,i.atUncheckedIndex(s),e),a++}}}static appendSolution(t,e){void 0!==t&&e.push(t)}static append2Solutions(t,e,i){i.push(t),i.push(e)}static appendLinearRoot(t,e,i){Ct.appendSolution(J.conditionalDivideFraction(-t,e),i)}static mostDistantFromMean(t){if(!t||0===t.length)return 0;let e=0;for(let i=0;i<t.length;i++)e+=t.atUncheckedIndex(i);e/=t.length;let i=0,n=t.atUncheckedIndex(0);for(let s=0;s<t.length;s++){const r=Math.abs(t.atUncheckedIndex(s)-e);r>i&&(i=r,n=t.atUncheckedIndex(s))}return n}static appendQuadraticRoots(t,e){const i=J.conditionalDivideFraction(1,t[2]);if(!i)return void this.appendLinearRoot(t[0],t[1],e);const n=.5*t[1]*i,s=n*n-t[0]*i;if(this.isZero(s))this.appendSolution(-n,e);else if(!(s<0)&&s>0){const t=Math.sqrt(s);this.append2Solutions(t-n,-t-n,e)}}static addConstant(t,e){for(let i=0;i<e.length;i++)e.reassign(i,e.atUncheckedIndex(i)+t)}static signedCubeRoot(t){return t>=0?Math.pow(t,1/3):-Math.pow(-t,1/3)}static appendFullCubicSolutions(t,e,i,n,s){const r=(e*e-3*t*i)/(t*t*9),o=-e/(3*t),a=n+o*(i+o*(e+o*t)),c=4*t*t*r*r*r,l=a*a-c;if(l>0){const e=Math.sqrt(l),i=.5/t;s.push(o+this.signedCubeRoot(i*(-a+e))+this.signedCubeRoot(i*(-a-e)))}else if(l<0){let e=Math.sqrt(c);t<0&&(e=-e);const i=Math.acos(-a/e)/3,n=2*Math.sqrt(r),l=2*Math.PI/3;s.push(o+n*Math.cos(i)),s.push(o+n*Math.cos(i+l)),s.push(o+n*Math.cos(i-l))}else{const e=this.signedCubeRoot(.5*a/t),i=o+e;s.push(o-2*e),s.push(i),s.push(i)}}static appendCubicRoots(t,e){void 0!==J.conditionalDivideCoordinate(1,t[3])?(this.appendFullCubicSolutions(t[3],t[2],t[1],t[0],e),this.improveRoots(t,3,e,!1)):this.appendQuadraticRoots(t,e),e.sort()}static appendQuarticRoots(t,e){const i=new Float64Array(4);let n,s;const r=new Float64Array(1);if(!this.safeDivide(r,1,t[4],0,0))return void this.appendCubicRoots(t,e);const o=t[3]*r[0],a=t[2]*r[0],c=t[1]*r[0],l=-.25*o,h=o*o,d=-.375*h+a,u=.125*h*o-.5*o*a+c,f=-.01171875*h*h+.0625*h*a-.25*o*c+t[0]*r[0],g=new bt;if(this.isZero(f))return i[0]=u,i[1]=d,i[2]=0,i[3]=1,this.appendCubicRoots(i,e),e.push(0),void this.addConstant(l,e);{i[0]=.5*f*d-.125*u*u,i[1]=-f,i[2]=-.5*d,i[3]=1,this.appendCubicRoots(i,g);const t=this.mostDistantFromMean(g);if(n=t*t-f,s=2*t-d,this.isSmallRatio(n,f))n=0;else{if(!(n>0))return;n=Math.sqrt(n)}if(this.isSmallRatio(s,d))s=0;else{if(!(s>0))return;s=Math.sqrt(s)}i[0]=t-n,i[1]=u<0?-s:s,i[2]=1,this.appendQuadraticRoots(i,e),i[0]=t+n,i[1]=u<0?s:-s,i[2]=1,this.appendQuadraticRoots(i,e)}this.addConstant(l,e),e.sort(),this.improveRoots(t,4,e,!0)}static appendCosSinRadians(t,e,i,n,s){i&&i.push(t),n&&n.push(e),s&&s.push(Math.atan2(e,t))}static appendImplicitLineUnitCircleIntersections(t,e,i,n,s,r,o=1e-14){let a;const c=e*e+i*i;let l=0;if(a=o<0?0:2*o,c<=0)l=0===t?-2:-1;else{const o=-t/c,h=1-t*t/c;if(h<-a){const a=Math.sqrt(c),h=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,n,s,r),this.appendCosSinRadians(e*h,i*h,n,s,r),l=0}else if(h<a){const a=Math.sqrt(c),h=t<0?1/a:-1/a;this.appendCosSinRadians(o*e,o*i,n,s,r),this.appendCosSinRadians(e*h,i*h,n,s,r),l=1}else{const t=Math.sqrt(h/c),a=o*e,d=o*i;this.appendCosSinRadians(a-t*i,d+t*e,n,s,r),this.appendCosSinRadians(a+t*i,d-t*e,n,s,r),l=2}}return l}}class Tt{static degreeKnownEvaluate(t,e,i){if(e<0)return 0;let n=t[e];for(let s=e-1;s>=0;s--)n=i*n+t[s];return n}static evaluate(t,e){const i=t.length-1;return this.degreeKnownEvaluate(t,i,e)}static accumulate(t,e,i){let n=t.length-1;const s=e.length-1;for(let n=0;n<=s;n++)t[n]+=i*e[n];for(;n>=0&&0===t[n];)n--;return n}static zero(t){for(let e=0;e<t.length;e++)t[e]=0}}class wt{static _smallAngle=1e-11;static S=Float64Array.from([0,2,-2]);static C=Float64Array.from([1,-2]);static W=Float64Array.from([1,-2,2]);static CW=Float64Array.from([1,-4,6,-4]);static SW=Float64Array.from([0,2,-6,8,-4]);static SC=Float64Array.from([0,2,-6,4]);static SS=Float64Array.from([0,0,4,-8,4]);static CC=Float64Array.from([1,-4,4]);static WW=Float64Array.from([1,-4,8,-8,4]);static CCMinusSS=Float64Array.from([1,-4,0,8,-4]);static solveAngles(t,e,i,n){let s,r=Math.abs(i);n.length=0;const o=this._smallAngle;for(let i=0;i<=e;i++)s=Math.abs(t[i]),s>r&&(r=s);const a=o*r;let c=e;for(;c>0&&Math.abs(t[c])<=a;)c--;const l=new bt;if(-1===c);else{if(0===c||(1===c?l.push(-t[0]/t[1]):2===c?Ct.appendQuadraticRoots(t,l):3===c?Ct.appendCubicRoots(t,l):4===c&&Ct.appendQuarticRoots(t,l)),l.length>0)for(let t=0;t<l.length;t++){const e=Tt.evaluate(this.S,l.atUncheckedIndex(t)),i=Tt.evaluate(this.C,l.atUncheckedIndex(t));n.push(Math.atan2(e,i))}c<e&&n.push(-.5*Math.PI)}return n.length>0}static _coefficientRelTol=1e-12;static solveUnitCircleImplicitQuadricIntersection(t,e,i,n,s,r,o){const a=new Float64Array(5);let c;Tt.zero(a),J.hypotenuseXYZ(t,e,i)>wt._coefficientRelTol*J.hypotenuseXYZ(n,s,r)?(Tt.accumulate(a,this.CW,n),Tt.accumulate(a,this.SW,s),Tt.accumulate(a,this.WW,r),Tt.accumulate(a,this.SS,i),Tt.accumulate(a,this.CC,t),Tt.accumulate(a,this.SC,e),c=4):(Tt.accumulate(a,this.C,n),Tt.accumulate(a,this.S,s),Tt.accumulate(a,this.W,r),c=2);const l=Math.max(Math.abs(t),Math.abs(i),Math.abs(e),Math.abs(n),Math.abs(s),Math.abs(r));return this.solveAngles(a,c,l,o)}static solveUnitCircleEllipseIntersection(t,e,i,n,s,r,o,a){a.length=0;const c=i*i+n*n,l=2*(i*s+n*r),h=s*s+r*r,d=2*(i*t+n*e),u=2*(s*t+r*e),f=t*t+e*e-1,g=this.solveUnitCircleImplicitQuadricIntersection(c,l,h,d,u,f,o);for(const c of o){const o=Math.cos(c),l=Math.sin(c),h=t+i*o+s*l,d=e+n*o+r*l;a.push(Math.atan2(d,h))}return g}static solveUnitCircleHomogeneousEllipseIntersection(t,e,i,n,s,r,o,a,c,l,h){h.length=0;const d=n*n+s*s-r*r,u=2*(n*o+s*a-r*c),f=o*o+a*a-c*c,g=2*(n*t+s*e-r*i),p=2*(o*t+a*e-c*i),m=t*t+e*e-i*i,_=this.solveUnitCircleImplicitQuadricIntersection(d,u,f,g,p,m,l);for(const i of l){const r=Math.cos(i),c=Math.sin(i),l=t+n*r+o*c,d=e+s*r+a*c;h.push(Math.atan2(d,l))}return _}}class Et{a;b;c;d;constructor(t,e,i,n){this.a=t,this.b=e,this.c=i,this.d=n}evaluate(t,e){return this.a+this.b*t+e*(this.c+this.d*t)}static createUnitSquareValues(t,e,i,n){return new Et(t,e,e,n-e-i)}static solveBilinearPair(t,e,i,n,s,r,o,a){const c=J.crossProductXYXY(t,s,i,o),l=J.crossProductXYXY(e,r,i,o)+J.crossProductXYXY(t,s,n,a),h=J.crossProductXYXY(e,r,n,a),d=At.solveQuadratic(h,l,c);if(void 0===d)return;const u=[];for(const c of d){const l=J.conditionalDivideFraction(-(t+e*c),i+n*c),h=J.conditionalDivideFraction(-(s+r*c),o+a*c);void 0!==l?u.push(H.create(c,l)):void 0!==h&&u.push(H.create(c,h))}return u}static solvePair(t,e,i,n){return Et.solveBilinearPair(t.a-e,t.b,t.c,t.d,i.a-n,i.b,i.c,i.d)}}class kt{a;cosineCoff;sineCoff;constructor(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}set(t,e,i){this.a=t,this.cosineCoff=e,this.sineCoff=i}evaluateRadians(t){return this.a+this.cosineCoff*Math.cos(t)+this.sineCoff*Math.sin(t)}range(t){const e=J.hypotenuseXY(this.cosineCoff,this.sineCoff);return gt.createXX(this.a-e,this.a+e,t)}rangeInStartEndRadians(t,e,i){if(G.isFullCircleRadians(e-t))return this.range(i);i=gt.createXX(this.evaluateRadians(t),this.evaluateRadians(e),i);const n=Math.atan2(this.sineCoff,this.cosineCoff),s=n+Math.PI;return St.isRadiansInStartEnd(n,t,e)&&i.extendX(this.evaluateRadians(n)),St.isRadiansInStartEnd(s,t,e)&&i.extendX(this.evaluateRadians(s)),i}rangeInSweep(t,e){return this.rangeInStartEndRadians(t.startRadians,t.endRadians,e)}referenceMinMaxRadians(){return Math.atan2(this.sineCoff,this.cosineCoff)}}class Ft{static lineSegment2dXYTransverseIntersectionUnbounded(t,e,i,n,s){const r=e.x-t.x,o=e.y-t.y,a=n.x-i.x,c=n.y-i.y,l=i.x-t.x,h=i.y-t.y,d=J.crossProductXYXY(r,o,a,c),u=J.crossProductXYXY(l,h,a,c),f=J.crossProductXYXY(r,o,l,h),g=J.conditionalDivideFraction(u,d),p=J.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(s.set(g,-p),!0):(s.set(0,0),!1)}static lineSegmentXYUVTransverseIntersectionUnbounded(t,e,i,n,s,r,o,a,c){const l=s-t,h=r-e,d=J.crossProductXYXY(i,n,o,a),u=J.crossProductXYXY(l,h,o,a),f=J.crossProductXYXY(i,n,l,h),g=J.conditionalDivideFraction(u,d),p=J.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(c.set(g,-p),!0):(c.set(0,0),!1)}static lineSegment3dXYTransverseIntersectionUnbounded(t,e,i,n,s){const r=e.x-t.x,o=e.y-t.y,a=n.x-i.x,c=n.y-i.y,l=i.x-t.x,h=i.y-t.y,d=J.crossProductXYXY(r,o,a,c),u=J.crossProductXYXY(l,h,a,c),f=J.crossProductXYXY(r,o,l,h),g=J.conditionalDivideFraction(u,d),p=J.conditionalDivideFraction(f,d);return void 0!==g&&void 0!==p?(s.set(g,-p),!0):(s.set(0,0),!1)}static lineSegment3dHXYTransverseIntersectionUnbounded(t,e,i,n,s){const r=J.tripleProduct(t.x,e.x,i.x,t.y,e.y,i.y,t.w,e.w,i.w),o=J.tripleProduct(t.x,e.x,n.x,t.y,e.y,n.y,t.w,e.w,n.w),a=J.conditionalDivideFraction(-r,o-r);if(void 0!==a){const r=J.tripleProduct(i.x,n.x,t.x,i.y,n.y,t.y,i.w,n.w,t.w),o=J.tripleProduct(i.x,n.x,e.x,i.y,n.y,e.y,i.w,n.w,e.w),c=J.conditionalDivideFraction(-r,o-r);if(void 0!==c)return j.create(c,a,s)}}static lineSegment3dHXYClosestPointUnbounded(t,e,i){const n=e.x*t.w-t.x*e.w,s=e.y*t.w-t.y*e.w,r=J.tripleProduct(t.x,-s,i.x,t.y,n,i.y,t.w,0,i.w),o=J.tripleProduct(e.x,-s,i.x,e.y,n,i.y,e.w,0,i.w);return J.conditionalDivideFraction(-r,o-r)}static lineSegment3dXYClosestPointUnbounded(t,e,i){const n=e.x-t.x,s=e.y-t.y,r=n*n+s*s,o=n*(i.x-t.x)+s*(i.y-t.y);return J.conditionalDivideFraction(o,r)}static lineSegment3dClosestPointUnbounded(t,e,i){const n=e.x-t.x,s=e.y-t.y,r=e.z-t.z,o=n*n+s*s+r*r,a=n*(i.x-t.x)+s*(i.y-t.y)+r*(i.z-t.z);return J.conditionalDivideFraction(a,o)}static lineSegment3dClosestApproachUnbounded(t,e,i,n,s){return this.ray3dXYZUVWClosestApproachUnbounded(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x,i.y,i.z,n.x-i.x,n.y-i.y,n.z-i.z,s)}static ray3dXYZUVWClosestApproachUnbounded(t,e,i,n,s,r,o,a,c,l,h,d,u){const f=o-t,g=a-e,p=c-i,m=J.hypotenuseSquaredXYZ(n,s,r),_=J.hypotenuseSquaredXYZ(l,h,d),x=J.dotProductXYZXYZ(n,s,r,l,h,d),y=J.dotProductXYZXYZ(f,g,p,n,s,r),v=J.dotProductXYZXYZ(f,g,p,l,h,d);return Ft.linearSystem2d(m,-x,x,-_,y,v,u)}static linearSystem2d(t,e,i,n,s,r,o){const a=J.crossProductXYXY(t,i,e,n),c=J.crossProductXYXY(s,r,e,n),l=J.crossProductXYXY(t,i,s,r),h=J.conditionalDivideFraction(c,a),d=J.conditionalDivideFraction(l,a);return void 0!==h&&void 0!==d?(o.set(h,d),!0):(o.set(0,0),!1)}static linearSystem3d(t,e,i,n,s,r,o,a,c,l,h,d,u){const f=J.tripleProduct(t,n,o,e,s,a,i,r,c),g=J.tripleProduct(l,h,d,e,s,a,i,r,c),p=J.tripleProduct(t,n,o,l,h,d,i,r,c),m=J.tripleProduct(t,n,o,e,s,a,l,h,d),_=J.conditionalDivideFraction(g,f),x=J.conditionalDivideFraction(p,f),y=J.conditionalDivideFraction(m,f);if(void 0!==_&&void 0!==x&&void 0!==y)return tt.create(_,x,y,u)}static intersect3Planes(t,e,i,n,s,r,o){return this.linearSystem3d(e.x,e.y,e.z,n.x,n.y,n.z,r.x,r.y,r.z,J.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z),J.dotProductXYZXYZ(i.x,i.y,i.z,n.x,n.y,n.z),J.dotProductXYZXYZ(s.x,s.y,s.z,r.x,r.y,r.z),o)}static eliminateFromPivot(t,e,i,n){const s=t.length;let r=J.conditionalDivideFraction(i[e],t[e]);if(void 0===r)return!1;r*=n;for(let n=e+1;n<s;n++)i[n]+=r*t[n];return!0}static solveBilinearPair(t,e,i,n,s,r,o,a){return Et.solveBilinearPair(t,e,i,n,s,r,o,a)}}class Rt{origin;direction;a;static _workVector0;static _workVector1;static _workVector2;static _workVector3;static _workVector4;static _workMatrix;constructor(t,e){this.origin=t,this.direction=e,this.a=void 0}static _create(t,e,i,n,s,r){return new Rt($.create(t,e,i),tt.create(n,s,r))}static createXAxis(){return Rt._create(0,0,0,1,0,0)}static createYAxis(){return Rt._create(0,0,0,0,1,0)}static createZAxis(){return Rt._create(0,0,0,0,0,1)}static createZero(t){return t?(t.origin.setZero(),t.direction.setZero(),t):new Rt($.createZero(),tt.createZero())}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.direction.isAlmostEqual(t.direction)}dotProductToPoint(t){return this.direction.dotProductStartEnd(this.origin,t)}pointToFraction(t){return J.safeDivideFraction(this.dotProductToPoint(t),this.direction.magnitudeSquared(),0)}projectPointToRay(t){return this.origin.plusScaled(this.direction,this.pointToFraction(t))}isAlmostEqualPointSet(t){if(!this.direction.isParallelTo(t.direction,!0))return!1;let e=this.projectPointToRay(t.origin);return!!t.origin.isAlmostEqualMetric(e)&&(e=t.projectPointToRay(this.origin),!!this.origin.isAlmostEqualMetric(e))}static create(t,e,i){return i?(i.set(t,e),i):new Rt(t.clone(),e.clone())}static createWeightedDerivative(t,e,i){const n=t[3],s=e[3],r=t[0],o=t[1],a=t[2],c=e[0]*n-t[0]*s,l=e[1]*n-t[1]*s,h=e[2]*n-t[2]*s;if(J.isSmallMetricDistance(n))return;const d=1/n,u=d*d;return Rt.createXYZUVW(r*d,o*d,a*d,c*u,l*u,h*u,i)}static createXYZUVW(t,e,i,n,s,r,o){return o?(o.getOriginRef().set(t,e,i),o.getDirectionRef().set(n,s,r),o):new Rt($.create(t,e,i),tt.create(n,s,r))}static createCapture(t,e){return new Rt(t,e)}static createPointVectorNumber(t,e,i,n){return n?(n.origin.setFrom(t),n.direction.setFrom(e),n.a=i,n):((n=new Rt(t.clone(),e.clone())).a=i,n)}static createStartEnd(t,e,i){return i?(i.origin.setFrom(t),i.direction.setStartEnd(t,e),i):new Rt(t.clone(),tt.createStartEnd(t,e))}getOriginRef(){return this.origin}getDirectionRef(){return this.direction}set(t,e){this.origin.setFrom(t),this.direction.setFrom(e)}clone(t){return t?(t.set(this.origin.clone(),this.direction.clone()),t):new Rt(this.origin.clone(),this.direction.clone())}cloneTransformed(t,e){return Rt.create(t.multiplyPoint3d(this.origin,e?.origin),t.multiplyVector(this.direction,e?.direction),e)}cloneInverseTransformed(t,e){if(t.computeCachedInverse(!0))return Rt.create(t.multiplyInversePoint3d(this.origin,e?.origin),t.matrix.multiplyInverseXYZAsVector3d(this.direction.x,this.direction.y,this.direction.z,e?.direction),e)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.direction,this.direction)}setFrom(t){this.set(t.origin,t.direction)}fractionToPoint(t,e){return this.origin.plusScaled(this.direction,t,e)}toRigidZFrame(t){const e=Rt._workMatrix=xt.createRigidHeadsUp(this.direction,f.ZXY,Rt._workMatrix);return mt.createOriginAndMatrix(this.origin,e,t)}setFromJSON(t){if(!t)return this.origin.set(0,0,0),void this.direction.set(0,0,1);this.origin.setFromJSON(t.origin),this.direction.setFromJSON(t.direction)}toJSON(){return{origin:this.origin.toJSON(),direction:this.direction.toJSON()}}static fromJSON(t){const e=Rt.createXAxis();return e.setFromJSON(t),e}trySetDirectionMagnitudeInPlace(t=1){return this.direction.tryNormalizeInPlace()?(this.direction.scaleInPlace(t),!0):(this.direction.setZero(),this.a=0,!1)}tryNormalizeInPlaceWithAreaWeight(t){const e=J.smallMetricDistanceSquared;return this.a=t,!!(Math.abs(t)>e&&this.direction.tryNormalizeInPlace(e))||(this.direction.setZero(),this.a=0,!1)}distance(t){const e=this.direction.magnitudeSquared(),i=this.dotProductToPoint(t),n=J.inverseMetricDistanceSquared(e);return n?Math.sqrt(this.origin.distanceSquared(t)-i*i*n):Math.sqrt(this.origin.distanceSquared(t))}intersectionWithPlane(t,e){const i=tt.createStartEnd(t.getOriginRef(),this.origin),n=this.direction.dotProduct(t.getNormalRef()),s=this.direction.magnitudeSquared(),r=i.dotProduct(t.getNormalRef()),o=J.conditionalDivideFraction(-r,n);if(void 0!==o)return void 0!==J.conditionalDivideFraction(s,n)?(e&&this.origin.plusScaled(this.direction,o,e),o):void 0}intersectionWithRange3d(t,e){if(t.isNull)return gt.createNull(e);const i=gt.createXX(-J.largeCoordinateResult,J.largeCoordinateResult,e);return i.clipLinearMapToInterval(this.origin.x,this.direction.x,t.low.x,t.high.x)&&i.clipLinearMapToInterval(this.origin.y,this.direction.y,t.low.y,t.high.y)&&i.clipLinearMapToInterval(this.origin.z,this.direction.z,t.low.z,t.high.z),i}intersectionWithTriangle(t,e,i,n,s,r){(void 0===n||n<0)&&(n=J.smallMetricDistance),(void 0===s||s<0)&&(s=J.smallFloatingPoint);const o=Rt._workVector0=tt.createStartEnd(t,e,Rt._workVector0),a=Rt._workVector1=tt.createStartEnd(t,i,Rt._workVector1),c=Rt._workVector2=this.direction.crossProduct(a,Rt._workVector2),l=o.dotProduct(c);if(l>=-n&&l<=n)return;const h=1/l,d=Rt._workVector3=tt.createStartEnd(t,this.origin,Rt._workVector3);let u=h*d.dotProduct(c);if(u<0){if(!(u>=-s))return;u=0}else if(u>1){if(!(u<=1+s))return;u=1}const f=Rt._workVector4=d.crossProduct(o,Rt._workVector4);let g=h*this.direction.dotProduct(f);if(g<0){if(!(g>=-s))return;g=0}else if(u+g>1+s)return;const p=h*a.dotProduct(f);return p<-n?void 0:this.origin.plusScaled(this.direction,p,r)}perpendicularPartOfVectorToTarget(t,e){const i=tt.createStartEnd(this.origin,t),n=this.direction.magnitudeSquared(),s=this.direction.dotProductStartEnd(this.origin,t),r=J.safeDivideFraction(s,n,0);return i.plusScaled(this.direction,-r,e)}static closestApproachRay3dRay3d(t,e){const i=j.create();let n,s,r,o,a;Ft.ray3dXYZUVWClosestApproachUnbounded(t.origin.x,t.origin.y,t.origin.z,t.direction.x,t.direction.y,t.direction.z,e.origin.x,e.origin.y,e.origin.z,e.direction.x,e.direction.y,e.direction.z,i)?(n=i.x,s=i.y,r=t.fractionToPoint(n),o=e.fractionToPoint(s),a=r.isAlmostEqualMetric(o)?I.Intersection:I.PerpendicularChord):(s=0,n=t.pointToFraction(e.origin),r=t.fractionToPoint(n),o=e.fractionToPoint(s),a=r.isAlmostEqualMetric(o)?I.CoincidentGeometry:I.ParallelGeometry);const c=It.createCapture(Pt.createRayFractionPoint(t,n,t.fractionToPoint(n)),Pt.createRayFractionPoint(e,s,e.fractionToPoint(s)));return c.approachType=a,c}static interpolatePointAndTangent(t,e,i,n,s){s=s??Rt.createZero();const r=i.x-t.x,o=i.y-t.y,a=i.z-t.z;if(s.direction.set(n*r,n*o,n*a),e<=.5)s.origin.set(t.x+e*r,t.y+e*o,t.z+e*a);else{const t=e-1;s.origin.set(i.x+t*r,i.y+t*o,i.z+t*a)}return s}}class Mt extends et{origin;vectorU;vectorV;constructor(t,e,i){super(),this.origin=t,this.vectorU=e,this.vectorV=i}static createOriginAndVectors(t,e,i,n){return n?(n.origin.setFrom(t),n.vectorU.setFrom(e),n.vectorV.setFrom(i),n):new Mt(t.clone(),e.clone(),i.clone())}clone(t){return void 0!==t&&t.setOriginAndVectors(this.origin,this.vectorU,this.vectorV),new Mt(this.origin.clone(),this.vectorU.clone(),this.vectorV.clone())}static createFrom(t,e){if(t instanceof Mt)return t.clone(e);const i=t.getUnitNormal();if(void 0===i)return;const n=t.getAnyPointOnPlane(),s=xt.createPerpendicularVectorFavorXYPlane(i);if(s.tryNormalizeInPlace()){const t=i.unitCrossProduct(s);if(void 0!==t)return new Mt(n,s,t)}}static createFromTransformColumnsXYAndLengths(t,e,i,n){return n?(n.origin.setFrom(t.getOrigin()),t.matrix.columnX(n.vectorU),t.matrix.columnY(n.vectorV)):n=new Mt(t.getOrigin(),t.matrix.columnX(),t.matrix.columnY()),void 0!==e&&n.vectorU.scaleToLength(e,n.vectorU),void 0!==i&&n.vectorV.scaleToLength(i,n.vectorV),n}static createCapture(t,e,i,n){return n?(n.origin=t,n.vectorU=e,n.vectorV=i,n):new Mt(t,e,i)}setOriginAndVectorsXYZ(t,e,i,n,s,r,o,a,c){return this.origin.set(t,e,i),this.vectorU.set(n,s,r),this.vectorV.set(o,a,c),this}setOriginAndVectors(t,e,i){return this.origin.setFrom(t),this.vectorU.setFrom(e),this.vectorV.setFrom(i),this}static createOriginAndVectorsXYZ(t,e,i,n,s,r,o,a,c,l){return l?l.setOriginAndVectorsXYZ(t,e,i,n,s,r,o,a,c):new Mt($.create(t,e,i),tt.create(n,s,r),tt.create(o,a,c))}static createOriginAndTargets(t,e,i,n){return Mt.createOriginAndVectorsXYZ(t.x,t.y,t.z,e.x-t.x,e.y-t.y,e.z-t.z,i.x-t.x,i.y-t.y,i.z-t.z,n)}static createXYPlane(t){return Mt.createOriginAndVectorsXYZ(0,0,0,1,0,0,0,1,0,t)}static createOriginAndVectorsArrays(t,e,i,n){return Mt.createOriginAndVectorsXYZ(t[0],t[1],t[2],e[0],e[1],e[2],i[0],i[1],i[2],n)}static createOriginAndVectorsWeightedArrays(t,e,i,n){const s=t[3];if(n=Mt.createXYPlane(n),J.isSmallMetricDistance(s))return n;const r=1/s,o=e[3]*r*r,a=i[3]*r*r;return n.origin.set(t[0]*r,t[1]*r,t[2]*r),tt.createAdd2ScaledXYZ(e[0],e[1],e[2],r,t[0],t[1],t[2],-o,n.vectorU),tt.createAdd2ScaledXYZ(i[0],i[1],i[2],r,t[0],t[1],t[2],-a,n.vectorV),n}fractionToPoint(t,e,i){return this.origin.plus2Scaled(this.vectorU,t,this.vectorV,e,i)}fractionToVector(t,e,i){return tt.createAdd2Scaled(this.vectorU,t,this.vectorV,e,i)}setFromJSON(t){t&&t.origin&&t.vectorV?(this.origin.setFromJSON(t.origin),this.vectorU.setFromJSON(t.vectorU),this.vectorV.setFromJSON(t.vectorV)):(this.origin.set(0,0,0),this.vectorU.set(1,0,0),this.vectorV.set(0,1,0))}toJSON(){return{origin:this.origin.toJSON(),vectorU:this.vectorU.toJSON(),vectorV:this.vectorV.toJSON()}}static fromJSON(t){const e=Mt.createXYPlane();return e.setFromJSON(t),e}isAlmostEqual(t){return this.origin.isAlmostEqual(t.origin)&&this.vectorU.isAlmostEqual(t.vectorU)&&this.vectorV.isAlmostEqual(t.vectorV)}normalizeInPlace(){const t=this.vectorU.normalizeInPlace(),e=this.vectorV.normalizeInPlace();return t&&e}getUnitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}unitNormal(t){return this.vectorU.unitCrossProduct(this.vectorV,t)}getAnyPointOnPlane(t){return this.origin.clone(t)}static _workVector;unitNormalRay(t){Mt._workVector||(Mt._workVector=tt.create());const e=this.vectorU.unitCrossProduct(this.vectorV,Mt._workVector);if(void 0!==e)return Rt.create(this.origin,e,t)}toRigidFrame(t){return mt.createRigidFromOriginAndColumns(this.origin,this.vectorU,this.vectorV,f.XYZ,t)}transformInPlace(t){t.multiplyPoint3d(this.origin,this.origin),t.multiplyVector(this.vectorU,this.vectorU),t.multiplyVector(this.vectorV,this.vectorV)}normalX(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.x:0}normalY(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.y:0}normalZ(){const t=this.vectorU.unitCrossProduct(this.vectorV);return void 0!==t?t.z:0}altitude(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:J.dotProductXYZXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,e.x,e.y,e.z)}altitudeXYZ(t,e,i){const n=this.vectorU.unitCrossProduct(this.vectorV);return void 0===n?0:J.dotProductXYZXYZ(t-this.origin.x,e-this.origin.y,i-this.origin.z,n.x,n.y,n.z)}velocity(t){const e=this.vectorU.unitCrossProduct(this.vectorV);return void 0===e?0:J.dotProductXYZXYZ(t.x,t.y,t.z,e.x,e.y,e.z)}velocityXYZ(t,e,i){const n=this.vectorU.unitCrossProduct(this.vectorV);return void 0===n?0:J.dotProductXYZXYZ(t,e,i,n.x,n.y,n.z)}weightedAltitude(t){const e=t.w;return J.tripleProduct(t.x-this.origin.x*e,t.y-this.origin.y*e,t.z-this.origin.z*e,this.vectorU.x,this.vectorU.y,this.vectorU.z,this.vectorV.x,this.vectorV.y,this.vectorV.z)}projectPointToPlane(t,e){return this.projectXYZToPlane(t.x,t.y,t.z,e)}projectXYZToPlane(t,e,i,n){const s=this.vectorU.unitCrossProduct(this.vectorV);if(void 0!==s){const r=-s.dotProductStartEndXYZ(this.origin,t,e,i);return $.create(t+r*s.x,e+r*s.y,i+r*s.z,n)}const r=this.vectorU.magnitudeSquared(),o=this.vectorV.magnitudeSquared();if(r>=o){const s=this.vectorU.dotProductStartEndXYZ(this.origin,t,e,i),o=J.conditionalDivideCoordinate(s,r,0);if(void 0!==o)return $.create(t+o*this.vectorU.x,e+o*this.vectorU.y,i+o*this.vectorU.z,n)}else{const s=this.vectorV.dotProductStartEndXYZ(this.origin,t,e,i),r=J.conditionalDivideCoordinate(s,o,0);if(void 0!==r)return $.create(t+r*this.vectorV.x,e+r*this.vectorV.y,i+r*this.vectorV.z,n)}return this.origin.clone(n)}}function Dt(t,e,i,n,s,r){return r*(t-2*s*e-n*i)}class Ot extends et{xyzw;set(t=0,e=0,i=0,n=0){return this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=n,this}setComponent(t,e){t>=0&&t<4&&(this.xyzw[t]=e)}get x(){return this.xyzw[0]}set x(t){this.xyzw[0]=t}get y(){return this.xyzw[1]}set y(t){this.xyzw[1]=t}get z(){return this.xyzw[2]}set z(t){this.xyzw[2]=t}get w(){return this.xyzw[3]}set w(t){this.xyzw[3]=t}constructor(t=0,e=0,i=0,n=0){super(),this.xyzw=new Float64Array(4),this.xyzw[0]=t,this.xyzw[1]=e,this.xyzw[2]=i,this.xyzw[3]=n}static create(t=0,e=0,i=0,n=0,s){return s?s.set(t,e,i,n):new Ot(t,e,i,n)}static createPlaneFrom(t){return new Ot(t.normalX(),t.normalY(),t.normalZ(),t.altitudeXYZ(0,0,0))}setFrom(t){return this.xyzw[0]=t.xyzw[0],this.xyzw[1]=t.xyzw[1],this.xyzw[2]=t.xyzw[2],this.xyzw[3]=t.xyzw[3],this}clone(t){return t?t.setFrom(this):new Ot(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}setFromJSON(t){J.isNumberArray(t,4)?this.set(t[0],t[1],t[2],t[3]):this.set(0,0,0,0)}static fromJSON(t){const e=new Ot;return e.setFromJSON(t),e}isAlmostEqual(t,e=J.smallMetricDistance){return J.isSameCoordinate(this.x,t.x,e)&&J.isSameCoordinate(this.y,t.y,e)&&J.isSameCoordinate(this.z,t.z,e)&&J.isSameCoordinate(this.w,t.w,e)}isAlmostEqualXYZW(t,e,i,n,s=J.smallMetricDistance){return J.isSameCoordinate(this.x,t,s)&&J.isSameCoordinate(this.y,e,s)&&J.isSameCoordinate(this.z,i,s)&&J.isSameCoordinate(this.w,n,s)}toJSON(){return[this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3]]}distanceXYZW(t){return J.hypotenuseXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}distanceSquaredXYZW(t){return J.hypotenuseSquaredXYZW(t.xyzw[0]-this.xyzw[0],t.xyzw[1]-this.xyzw[1],t.xyzw[2]-this.xyzw[2],t.xyzw[3]-this.xyzw[3])}realDistanceXY(t){const e=this.w,i=t.w;if(!J.isSmallMetricDistance(e)&&!J.isSmallMetricDistance(i))return J.hypotenuseXY(t.xyzw[0]/i-this.xyzw[0]/e,t.xyzw[1]/i-this.xyzw[1]/e)}realDistanceSquaredXY(t){const e=this.w,i=t.w;if(!J.isSmallMetricDistance(e)&&!J.isSmallMetricDistance(i))return J.hypotenuseSquaredXY(t.xyzw[0]/i-this.xyzw[0]/e,t.xyzw[1]/i-this.xyzw[1]/e)}maxDiff(t){return Math.max(Math.abs(t.xyzw[0]-this.xyzw[0]),Math.abs(t.xyzw[1]-this.xyzw[1]),Math.abs(t.xyzw[2]-this.xyzw[2]),Math.abs(t.xyzw[3]-this.xyzw[3]))}maxAbs(){return Math.max(Math.abs(this.xyzw[0]),Math.abs(this.xyzw[1]),Math.abs(this.xyzw[2]),Math.abs(this.xyzw[3]))}magnitudeXYZW(){return J.hypotenuseXYZW(this.xyzw[0],this.xyzw[1],this.xyzw[2],this.xyzw[3])}magnitudeSquaredXYZ(){return J.hypotenuseSquaredXYZ(this.xyzw[0],this.xyzw[1],this.xyzw[2])}minus(t,e){return Ot.create(this.xyzw[0]-t.xyzw[0],this.xyzw[1]-t.xyzw[1],this.xyzw[2]-t.xyzw[2],this.xyzw[3]-t.xyzw[3],e)}crossWeightedMinus(t,e){const i=this.xyzw[3],n=t.xyzw[3];return tt.create(n*this.xyzw[0]-i*t.xyzw[0],n*this.xyzw[1]-i*t.xyzw[1],n*this.xyzw[2]-i*t.xyzw[2],e)}crossWeightedMinusPoint3d(t,e){const i=this.xyzw[3];return tt.create(this.xyzw[0]-i*t.x,this.xyzw[1]-i*t.y,this.xyzw[2]-i*t.z,e)}plus(t,e){return Ot.create(this.xyzw[0]+t.xyzw[0],this.xyzw[1]+t.xyzw[1],this.xyzw[2]+t.xyzw[2],this.xyzw[3]+t.xyzw[3],e)}get isAlmostZero(){return J.isSmallMetricDistance(this.maxAbs())}static createZero(){return new Ot(0,0,0,0)}static createPlanePointPointZ(t,e,i){return Ot.create(t.y*e.w-t.w*e.y,t.w*e.x-t.x*e.w,0,t.x*e.y-t.y*e.x,i)}static createFromPackedXYZ(t,e=0,i){if(e>=0&&e+2<t.length)return Ot.create(t[e],t[e+1],t[e+2],1,i)}static createFromPacked(t,e=0,i){if(e>=0&&e+3<t.length)return Ot.create(t[e],t[e+1],t[e+2],t[e+3],i)}static createFromPackedXYZW(t,e=0,i){return Ot.create(t[e],t[e+1],t[e+2],t[e+3],i)}static createFromPointAndWeight(t,e){return new Ot(t.x,t.y,t.z,e)}static createFromPoint(t){if(t instanceof H)return new Ot(t.x,t.y,0,1);if(t instanceof $)return new Ot(t.x,t.y,t.z,1);if(t instanceof Ot)return t.clone();if(Array.isArray(t)){const e=t.length>0?t[0]:0,i=t.length>1?t[1]:0,n=t.length>2?t[2]:0,s=t.length>3?t[3]:1;return new Ot(e,i,n,s)}const e=t.x,i=t.y,n=t.hasOwnProperty("z")?t.z:0,s=t.hasOwnProperty("w")?t.w:1;return new Ot(e,i,n,s)}plusScaled(t,e,i){return Ot.create(this.xyzw[0]+t.xyzw[0]*e,this.xyzw[1]+t.xyzw[1]*e,this.xyzw[2]+t.xyzw[2]*e,this.xyzw[3]+t.xyzw[3]*e,i)}interpolate(t,e,i){const n=1-t;return Ot.create(this.xyzw[0]*n+e.xyzw[0]*t,this.xyzw[1]*n+e.xyzw[1]*t,this.xyzw[2]*n+e.xyzw[2]*t,this.xyzw[3]*n+e.xyzw[3]*t,i)}plus2Scaled(t,e,i,n,s){return Ot.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*n,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*n,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*n,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*n,s)}plus3Scaled(t,e,i,n,s,r,o){return Ot.create(this.xyzw[0]+t.xyzw[0]*e+i.xyzw[0]*n+s.xyzw[0]*r,this.xyzw[1]+t.xyzw[1]*e+i.xyzw[1]*n+s.xyzw[1]*r,this.xyzw[2]+t.xyzw[2]*e+i.xyzw[2]*n+s.xyzw[2]*r,this.xyzw[3]+t.xyzw[3]*e+i.xyzw[3]*n+s.xyzw[3]*r,o)}static createAdd2Scaled(t,e,i,n,s){return Ot.create(t.xyzw[0]*e+i.xyzw[0]*n,t.xyzw[1]*e+i.xyzw[1]*n,t.xyzw[2]*e+i.xyzw[2]*n,t.xyzw[3]*e+i.xyzw[3]*n,s)}static createAdd3Scaled(t,e,i,n,s,r,o){return Ot.create(t.xyzw[0]*e+i.xyzw[0]*n+s.xyzw[0]*r,t.xyzw[1]*e+i.xyzw[1]*n+s.xyzw[1]*r,t.xyzw[2]*e+i.xyzw[2]*n+s.xyzw[2]*r,t.xyzw[3]*e+i.xyzw[3]*n+s.xyzw[3]*r,o)}dotVectorsToTargets(t,e){return(t.xyzw[0]-this.xyzw[0])*(e.xyzw[0]-this.xyzw[0])+(t.xyzw[1]-this.xyzw[1])*(e.xyzw[1]-this.xyzw[1])+(t.xyzw[2]-this.xyzw[2])*(e.xyzw[2]-this.xyzw[2])+(t.xyzw[3]-this.xyzw[3])*(e.xyzw[3]-this.xyzw[3])}dotProduct(t){return this.xyzw[0]*t.xyzw[0]+this.xyzw[1]*t.xyzw[1]+this.xyzw[2]*t.xyzw[2]+this.xyzw[3]*t.xyzw[3]}dotProductXYZW(t,e,i,n){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]*n}altitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]}altitudeXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i+this.xyzw[3]}weightedAltitude(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z+this.xyzw[3]*t.w}velocity(t){return this.xyzw[0]*t.x+this.xyzw[1]*t.y+this.xyzw[2]*t.z}velocityXYZ(t,e,i){return this.xyzw[0]*t+this.xyzw[1]*e+this.xyzw[2]*i}normalX(){return this.x}normalY(){return this.y}normalZ(){return this.z}static unitX(){return new Ot(1,0,0,0)}static unitY(){return new Ot(0,1,0,0)}static unitZ(){return new Ot(0,0,1,0)}static unitW(){return new Ot(0,0,0,1)}safeDivideOrNull(t,e){if(0!==t)return this.scale(1/t,e)}projectPointToPlane(t,e){return this.projectXYZToPlane(t.x,t.y,t.z,e)}projectXYZToPlane(t,e,i,n){const s=this.altitudeXYZ(t,e,i),r=this.magnitudeSquaredXYZ(),o=J.conditionalDivideCoordinate(-s,r,J.largeFractionResult*J.largeFractionResult);return void 0===o?$.create(t,e,i,n):$.create(t+o*this.x,e+o*this.y,i+o*this.z,n)}scale(t,e){return(e=e||new Ot).xyzw[0]=this.xyzw[0]*t,e.xyzw[1]=this.xyzw[1]*t,e.xyzw[2]=this.xyzw[2]*t,e.xyzw[3]=this.xyzw[3]*t,e}negate(t){return(t=t||new Ot).xyzw[0]=-this.xyzw[0],t.xyzw[1]=-this.xyzw[1],t.xyzw[2]=-this.xyzw[2],t.xyzw[3]=-this.xyzw[3],t}normalizeWeight(t){const e=J.correctSmallFraction(this.xyzw[3]);return t=t||new Ot,this.safeDivideOrNull(e,t)}realPoint(t){const e=J.correctSmallFraction(this.xyzw[3]);if(0===e)return;const i=1/e;return $.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}realPointOrVector(){const t=J.correctSmallFraction(this.xyzw[3]);if(0===t)return tt.create(this.x,this.y,this.z);const e=1/t;return $.create(this.x*e,this.y*e,this.z*e)}static createRealPoint3dDefault000(t,e,i,n,s){const r=J.correctSmallFraction(n),o=0===r?0:1/r;return $.create(t*o,e*o,i*o,s)}static createRealDerivativeRay3dDefault000(t,e,i,n,s,r,o,a,c){const l=J.correctSmallFraction(n),h=0===l?0:1/l,d=h*h;return Rt.createXYZUVW(t*h,e*h,i*h,(s*n-a*t)*d,(r*n-a*e)*d,(o*n-a*i)*d,c)}static createRealDerivativePlane3dByOriginAndVectorsDefault000(t,e,i,n,s,r,o,a,c,l,h,d,u){const f=J.correctSmallFraction(n),g=0===f?0:1/f,p=g*g,m=t*g,_=e*g,x=i*g,y=(s*n-a*t)*p,v=(r*n-a*e)*p,P=(o*n-a*i)*p;return Mt.createOriginAndVectorsXYZ(m,_,x,y,v,P,Dt(c,a,d,m,y,g),Dt(l,a,d,_,v,g),Dt(h,a,d,x,P,g),u)}realPointDefault000(t){const e=J.correctSmallFraction(this.xyzw[3]);if(0===e)return $.create(0,0,0,t);t=t||new $;const i=1/e;return $.create(this.xyzw[0]*i,this.xyzw[1]*i,this.xyzw[2]*i,t)}normalizeXYZW(t){const e=J.correctSmallFraction(this.magnitudeXYZW());return t=t||new Ot,this.safeDivideOrNull(e,t)}static determinantIndexed3X3(t,e,i,n,s,r){return J.tripleProduct(t.xyzw[n],t.xyzw[s],t.xyzw[r],e.xyzw[n],e.xyzw[s],e.xyzw[r],i.xyzw[n],i.xyzw[s],i.xyzw[r])}static perpendicularPoint4dPlane(t,e,i){return Ot.create(Ot.determinantIndexed3X3(t,e,i,1,2,3),-Ot.determinantIndexed3X3(t,e,i,2,3,0),Ot.determinantIndexed3X3(t,e,i,3,0,1),-Ot.determinantIndexed3X3(t,e,i,0,1,2))}toPlane3dByOriginAndUnitNormal(t){return yt.createFrom(this,t)}normalizeQuaternion(){const t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);if(t>0){const e=1/t;this.x*=e,this.y*=e,this.z*=e,this.w*=e}return t}static interpolateQuaternions(t,e,i,n){if(n||(n=new Ot),0===e)return t;if(1===e)return i;if(.5===e)return t.plus(i,n),n.normalizeQuaternion(),n;const s=t.clone(),r=i.clone();let o=t.dotProduct(i);if(o<0&&(r.negate(r),o=-o),o>.9995)return s.interpolate(e,r,n),n.normalizeQuaternion(),n;o<-1?o=-1:o>1&&(o=1);const a=new Ot;r.plusScaled(s,-o,a),a.normalizeQuaternion();const c=Math.acos(o)*e;return Ot.createAdd2Scaled(s,Math.cos(c),a,Math.sin(c))}radiansToPoint4dXYZW(t){const e=this.magnitudeXYZW(),i=t.magnitudeXYZW(),n=this.dotProduct(t),s=J.conditionalDivideFraction(n,e*i);if(void 0!==s)return Math.acos(s)}}class Bt{_coffs;constructor(){this._coffs=new Float64Array(16)}setFrom(t){for(let e=0;e<16;e++)this._coffs[e]=t._coffs[e]}clone(t){if(t===this)return this;void 0===t&&(t=new Bt);for(let e=0;e<16;e++)t._coffs[e]=this._coffs[e];return t}setZero(){for(let t=0;t<16;t++)this._coffs[t]=0}setIdentity(){for(let t=0;t<16;t++)this._coffs[t]=0;this._coffs[0]=this._coffs[5]=this._coffs[10]=this._coffs[15]=1}static is1000(t,e,i,n,s){return Math.abs(t-1)<=s&&Math.abs(e)<=s&&Math.abs(i)<=s&&Math.abs(n)<=s}isIdentity(t=1e-10){return Bt.is1000(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],t)&&Bt.is1000(this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[4],t)&&Bt.is1000(this._coffs[10],this._coffs[11],this._coffs[8],this._coffs[9],t)&&Bt.is1000(this._coffs[15],this._coffs[12],this._coffs[13],this._coffs[14],t)}static createZero(t){return t?(t.setZero(),t):new Bt}static createRowValues(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g,p,m){return(m=m||new Bt)._coffs[0]=t,m._coffs[1]=e,m._coffs[2]=i,m._coffs[3]=n,m._coffs[4]=s,m._coffs[5]=r,m._coffs[6]=o,m._coffs[7]=a,m._coffs[8]=c,m._coffs[9]=l,m._coffs[10]=h,m._coffs[11]=d,m._coffs[12]=u,m._coffs[13]=f,m._coffs[14]=g,m._coffs[15]=p,m}static createRows(t,e,i,n,s){return this.createRowValues(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,i.x,i.y,i.z,i.w,n.x,n.y,n.z,n.w,s)}setOriginAndVectors(t,e,i,n){this._coffs[0]=e.x,this._coffs[1]=i.x,this._coffs[2]=n.x,this._coffs[3]=t.x,this._coffs[4]=e.y,this._coffs[5]=i.y,this._coffs[6]=n.y,this._coffs[7]=t.y,this._coffs[8]=e.z,this._coffs[9]=i.z,this._coffs[10]=n.z,this._coffs[11]=t.z,this._coffs[12]=0,this._coffs[13]=0,this._coffs[14]=0,this._coffs[15]=1}static createTransform(t,e){const i=t.matrix,n=t.origin;return Bt.createRowValues(i.coffs[0],i.coffs[1],i.coffs[2],n.x,i.coffs[3],i.coffs[4],i.coffs[5],n.y,i.coffs[6],i.coffs[7],i.coffs[8],n.z,0,0,0,1,e)}static createIdentity(t){return(t=Bt.createZero(t))._coffs[0]=1,t._coffs[5]=1,t._coffs[10]=1,t._coffs[15]=1,t}static createTranslationXYZ(t,e,i,n){return(n=Bt.createZero(n))._coffs[0]=1,n._coffs[5]=1,n._coffs[10]=1,n._coffs[15]=1,n._coffs[3]=t,n._coffs[7]=e,n._coffs[11]=i,n}plusScaled(t,e,i){i=this.clone(i);for(let n=0;n<16;n++)i._coffs[n]+=e*t._coffs[n];return i}static createTranslationAndScaleXYZ(t,e,i,n,s,r,o){return Bt.createRowValues(n,0,0,t,0,s,0,e,0,0,r,i,0,0,0,1,o)}static createBoxToBox(t,e,i,n,s){const r=e.x-t.x,o=e.y-t.y,a=e.z-t.z,c=n.x-i.x,l=n.y-i.y,h=n.z-i.z,d=J.conditionalDivideFraction(c,r),u=J.conditionalDivideFraction(l,o),f=J.conditionalDivideFraction(h,a);if(void 0!==d&&void 0!==u&&void 0!==f)return Bt.createTranslationAndScaleXYZ(i.x-d*t.x,i.y-u*t.y,i.z-f*t.z,d,u,f,s)}setFromJSON(t){if(J.isArrayOfNumberArray(t,4,4))for(let e=0;e<4;++e)for(let i=0;i<4;++i)this._coffs[4*e+i]=t[e][i];else this.setZero()}maxDiff(t){let e=0;for(let i=0;i<16;i++)e=Math.max(e,Math.abs(this._coffs[i]-t._coffs[i]));return e}maxAbs(){let t=0;for(let e=0;e<16;e++)t=Math.max(t,Math.abs(this._coffs[e]));return t}isAlmostEqual(t){return J.isSmallMetricDistance(this.maxDiff(t))}isExactEqual(t){return 0===this.maxDiff(t)}toJSON(){const t=[];for(let e=0;e<4;++e){const i=4*e;t.push([this._coffs[i],this._coffs[i+1],this._coffs[i+2],this._coffs[i+3]])}return t}static fromJSON(t){const e=new Bt;return e.setFromJSON(t),e}getSteppedPoint(t,e,i){return Ot.create(this._coffs[t],this._coffs[t+e],this._coffs[t+2*e],this._coffs[t+3*e],i)}columnX(){return this.getSteppedPoint(0,4)}columnY(){return this.getSteppedPoint(1,4)}columnZ(){return this.getSteppedPoint(2,4)}columnW(){return this.getSteppedPoint(3,4)}rowX(){return this.getSteppedPoint(0,1)}rowY(){return this.getSteppedPoint(4,1)}rowZ(){return this.getSteppedPoint(8,1)}rowW(){return this.getSteppedPoint(12,1)}get hasPerspective(){return 0!==this._coffs[12]||0!==this._coffs[13]||0!==this._coffs[14]||1!==this._coffs[15]}diagonal(){return this.getSteppedPoint(0,5)}weight(){return this._coffs[15]}matrixPart(){return xt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[8],this._coffs[9],this._coffs[10])}get asTransform(){if(!this.hasPerspective)return mt.createRowValues(this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3],this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7],this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11])}multiplyMatrixMatrix(t,e){e=e&&e!==this&&e!==t?e:new Bt;for(let i=0;i<16;i+=4)for(let n=0;n<4;n++)e._coffs[i+n]=this._coffs[i]*t._coffs[n]+this._coffs[i+1]*t._coffs[n+4]+this._coffs[i+2]*t._coffs[n+8]+this._coffs[i+3]*t._coffs[n+12];return e}multiplyMatrixMatrixTranspose(t,e){e=e&&e!==this&&e!==t?e:new Bt;let i=0;for(let n=0;n<16;n+=4)for(let s=0;s<16;s+=4)e._coffs[i++]=this._coffs[n]*t._coffs[s]+this._coffs[n+1]*t._coffs[s+1]+this._coffs[n+2]*t._coffs[s+2]+this._coffs[n+3]*t._coffs[s+3];return e}multiplyMatrixTransposeMatrix(t,e){e=e&&e!==this&&e!==t?e:new Bt;let i=0;for(let n=0;n<4;n+=1)for(let s=0;s<4;s+=1)e._coffs[i++]=this._coffs[n]*t._coffs[s]+this._coffs[n+4]*t._coffs[s+4]+this._coffs[n+8]*t._coffs[s+8]+this._coffs[n+12]*t._coffs[s+12];return e}cloneTransposed(t){return Bt.createRowValues(this._coffs[0],this._coffs[4],this._coffs[8],this._coffs[12],this._coffs[1],this._coffs[5],this._coffs[9],this._coffs[13],this._coffs[2],this._coffs[6],this._coffs[10],this._coffs[14],this._coffs[3],this._coffs[7],this._coffs[11],this._coffs[15],t)}multiplyXYZW(t,e,i,n,s){return(s=s||Ot.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*n,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*n,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*n,this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*n)}multiplyBlockedFloat64ArrayInPlace(t){const e=t.length;let i,n,s,r;for(let o=0;o+3<e;o+=4)i=t[o],n=t[o+1],s=t[o+2],r=t[o+3],t[o]=this._coffs[0]*i+this._coffs[1]*n+this._coffs[2]*s+this._coffs[3]*r,t[o+1]=this._coffs[4]*i+this._coffs[5]*n+this._coffs[6]*s+this._coffs[7]*r,t[o+2]=this._coffs[8]*i+this._coffs[9]*n+this._coffs[10]*s+this._coffs[11]*r,t[o+3]=this._coffs[12]*i+this._coffs[13]*n+this._coffs[14]*s+this._coffs[15]*r}multiplyPoint3d(t,e,i){return this.multiplyXYZW(t.x,t.y,t.z,e,i)}multiplyPoint3dArray(t,e,i=1){t.forEach(((t,n)=>{e[n]=this.multiplyXYZW(t.x,t.y,t.z,i,e[n])}))}multiplyTransposeXYZW(t,e,i,n,s){return(s=s||Ot.createZero()).set(this._coffs[0]*t+this._coffs[4]*e+this._coffs[8]*i+this._coffs[12]*n,this._coffs[1]*t+this._coffs[5]*e+this._coffs[9]*i+this._coffs[13]*n,this._coffs[2]*t+this._coffs[6]*e+this._coffs[10]*i+this._coffs[14]*n,this._coffs[3]*t+this._coffs[7]*e+this._coffs[11]*i+this._coffs[15]*n)}rowDotColumn(t,e,i){const n=4*t,s=i;return this._coffs[n]*e._coffs[s]+this._coffs[n+1]*e._coffs[s+4]+this._coffs[n+2]*e._coffs[s+8]+this._coffs[n+3]*e._coffs[s+12]}rowDotXYZW(t,e,i,n,s){const r=4*t;return this._coffs[r]*e+this._coffs[r+1]*i+this._coffs[r+2]*n+this._coffs[r+3]*s}rowDotRow(t,e,i){const n=4*t,s=4*i;return this._coffs[n]*e._coffs[s]+this._coffs[n+1]*e._coffs[s+1]+this._coffs[n+2]*e._coffs[s+2]+this._coffs[n+3]*e._coffs[s+3]}columnDotColumn(t,e,i){const n=t,s=i;return this._coffs[n]*e._coffs[s]+this._coffs[n+4]*e._coffs[s+4]+this._coffs[n+8]*e._coffs[s+8]+this._coffs[n+12]*e._coffs[s+12]}columnDotRow(t,e,i){const n=t,s=4*i;return this._coffs[n]*e._coffs[s]+this._coffs[n+4]*e._coffs[s+1]+this._coffs[n+8]*e._coffs[s+2]+this._coffs[n+12]*e._coffs[s+3]}atIJ(t,e){return this._coffs[4*t+e]}setAtIJ(t,e,i){this._coffs[4*t+e]=i}multiplyXYZWQuietRenormalize(t,e,i,n,s){(s=s||$.createZero()).set(this._coffs[0]*t+this._coffs[1]*e+this._coffs[2]*i+this._coffs[3]*n,this._coffs[4]*t+this._coffs[5]*e+this._coffs[6]*i+this._coffs[7]*n,this._coffs[8]*t+this._coffs[9]*e+this._coffs[10]*i+this._coffs[11]*n);const r=this._coffs[12]*t+this._coffs[13]*e+this._coffs[14]*i+this._coffs[15]*n,o=J.conditionalDivideCoordinate(s.x,r),a=J.conditionalDivideCoordinate(s.y,r),c=J.conditionalDivideCoordinate(s.z,r);return void 0!==o&&void 0!==a&&void 0!==c&&(s.x=o,s.y=a,s.z=c),s}multiplyPoint4dArrayQuietRenormalize(t,e){t.forEach(((t,i)=>{e[i]=this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,t.w,e[i])}))}multiplyPoint4d(t,e){return this.multiplyXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyTransposePoint4d(t,e){return this.multiplyTransposeXYZW(t.xyzw[0],t.xyzw[1],t.xyzw[2],t.xyzw[3],e)}multiplyPoint3dQuietNormalize(t,e){return this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,e)}multiplyPoint3dArrayQuietNormalize(t){t.forEach((t=>this.multiplyXYZWQuietRenormalize(t.x,t.y,t.z,1,t)))}addMomentsInPlace(t,e,i,n){this._coffs[0]+=t*t,this._coffs[1]+=t*e,this._coffs[2]+=t*i,this._coffs[3]+=t*n,this._coffs[4]+=e*t,this._coffs[5]+=e*e,this._coffs[6]+=e*i,this._coffs[7]+=e*n,this._coffs[8]+=i*t,this._coffs[9]+=i*e,this._coffs[10]+=i*i,this._coffs[11]+=i*n,this._coffs[12]+=n*t,this._coffs[13]+=n*e,this._coffs[14]+=n*i,this._coffs[15]+=n*n}addScaledInPlace(t,e=1){for(let i=0;i<16;i++)this._coffs[i]+=e*t._coffs[i]}rowOperation(t,e,i,n){if(0===n)return;let s=4*t+i,r=4*e+i;for(let t=i;t<4;t++,s++,r++)this._coffs[r]+=n*this._coffs[s]}determinant(){const t=this._coffs;return J.determinant4x4(t[0],t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8],t[9],t[10],t[11],t[12],t[13],t[14],t[15])}createInverse(t){let e=this.columnX().maxAbs();if(0===e)return;const i=1/e;if(e=this.columnY().maxAbs(),0===e)return;const n=1/e;if(e=this.columnZ().maxAbs(),0===e)return;const s=1/e;if(e=this.columnW().maxAbs(),0===e)return;const r=1/e,o=this.columnX(),a=this.columnY(),c=this.columnZ(),l=this.columnW();o.scale(i,o),a.scale(n,a),c.scale(s,c),l.scale(r,l);const h=Ot.perpendicularPoint4dPlane(a,c,l),d=Ot.perpendicularPoint4dPlane(o,l,c),u=Ot.perpendicularPoint4dPlane(l,o,a),f=Ot.perpendicularPoint4dPlane(c,a,o);t=Bt.createRows(h,d,u,f,t);const g=h.dotProduct(o),p=d.dotProduct(a),m=u.dotProduct(c),_=f.dotProduct(l),x=t.maxAbs();if(g*p>0&&g*m>0&&g*_>0&&void 0!==J.conditionalDivideCoordinate(x,g)){const e=1/g;return t.scaleRowsInPlace(i*e,n*e,s*e,r*e),t}}rowArrays(t){return t?[[t(this._coffs[0]),t(this._coffs[1]),t(this._coffs[2]),t(this._coffs[3])],[t(this._coffs[4]),t(this._coffs[5]),t(this._coffs[6]),t(this._coffs[7])],[t(this._coffs[8]),t(this._coffs[9]),t(this._coffs[10]),t(this._coffs[11])],[t(this._coffs[12]),t(this._coffs[13]),t(this._coffs[14]),t(this._coffs[15])]]:[[this._coffs[0],this._coffs[1],this._coffs[2],this._coffs[3]],[this._coffs[4],this._coffs[5],this._coffs[6],this._coffs[7]],[this._coffs[8],this._coffs[9],this._coffs[10],this._coffs[11]],[this._coffs[12],this._coffs[13],this._coffs[14],this._coffs[15]]]}scaleRowsInPlace(t,e,i,n){for(let e=0;e<4;e++)this._coffs[e]*=t;for(let t=4;t<8;t++)this._coffs[t]*=e;for(let t=8;t<12;t++)this._coffs[t]*=i;for(let t=12;t<16;t++)this._coffs[t]*=n}addScaledOuterProductInPlace(t,e,i){let n=t.x*i;this._coffs[0]+=n*e.x,this._coffs[1]+=n*e.y,this._coffs[2]+=n*e.z,this._coffs[3]+=n*e.w,n=t.y*i,this._coffs[4]+=n*e.x,this._coffs[5]+=n*e.y,this._coffs[6]+=n*e.z,this._coffs[7]+=n*e.w,n=t.z*i,this._coffs[8]+=n*e.x,this._coffs[9]+=n*e.y,this._coffs[10]+=n*e.z,this._coffs[11]+=n*e.w,n=t.w*i,this._coffs[12]+=n*e.x,this._coffs[13]+=n*e.y,this._coffs[14]+=n*e.z,this._coffs[15]+=n*e.w}addTranslationSandwichInPlace(t,e,i,n,s){const r=t._coffs[3],o=t._coffs[7],a=t._coffs[11],c=t._coffs[12],l=t._coffs[13],h=t._coffs[14],d=t._coffs[15],u=e*d,f=i*d,g=n*d;this._coffs[0]+=s*(t._coffs[0]+e*r+c*e+e*u),this._coffs[1]+=s*(t._coffs[1]+i*r+l*e+e*f),this._coffs[2]+=s*(t._coffs[2]+n*r+h*e+e*g),this._coffs[3]+=s*(r+u),this._coffs[4]+=s*(t._coffs[4]+e*o+c*i+i*u),this._coffs[5]+=s*(t._coffs[5]+i*o+l*i+i*f),this._coffs[6]+=s*(t._coffs[6]+n*o+h*i+i*g),this._coffs[7]+=s*(o+f),this._coffs[8]+=s*(t._coffs[8]+e*a+c*n+n*u),this._coffs[9]+=s*(t._coffs[9]+i*a+l*n+n*f),this._coffs[10]+=s*(t._coffs[10]+n*a+h*n+n*g),this._coffs[11]+=s*(a+g),this._coffs[12]+=s*(c+u),this._coffs[13]+=s*(l+f),this._coffs[14]+=s*(h+g),this._coffs[15]+=s*d}multiplyTranslationSandwichInPlace(t,e,i){const n=this._coffs[3],s=this._coffs[7],r=this._coffs[11],o=this._coffs[12],a=this._coffs[13],c=this._coffs[14],l=this._coffs[15],h=t*l,d=e*l,u=i*l;this._coffs[0]+=t*n+o*t+t*h,this._coffs[1]+=e*n+a*t+t*d,this._coffs[2]+=i*n+c*t+t*u,this._coffs[3]+=h,this._coffs[4]+=t*s+o*e+e*h,this._coffs[5]+=e*s+a*e+e*d,this._coffs[6]+=i*s+c*e+e*u,this._coffs[7]+=d,this._coffs[8]+=t*r+o*i+i*h,this._coffs[9]+=e*r+a*i+i*d,this._coffs[10]+=i*r+c*i+i*u,this._coffs[11]+=u,this._coffs[12]+=h,this._coffs[13]+=d,this._coffs[14]+=u}}class Nt{xTest;yTest;u0;v0;u1;v1;numLeftCrossing;numRightCrossing;numHit;constructor(t,e){this.xTest=t,this.yTest=e,this.u0=this.v0=this.u1=this.v1=0,this.numLeftCrossing=this.numRightCrossing=0,this.numHit=0}tryStartEdge(t,e,i,n){return e!==this.yTest&&(this.u0=t-this.xTest,this.v0=e-this.yTest,this.u1=i-this.xTest,this.v1=n-this.yTest,!0)}updateUV01(t,e){return this.u0=this.u1,this.v0=this.v1,this.u1=t,this.v1=e,!0}advance(t,e){const i=t-this.xTest,n=e-this.yTest,s=n*this.v1;if(s>0)return this.updateUV01(i,n);if(s<0){const t=-this.v1/(n-this.v1),e=this.u1+t*(i-this.u1);return 0===e?(this.numHit++,!1):(e>0?this.numRightCrossing++:this.numLeftCrossing++,this.updateUV01(i,n))}return 0===n?0===this.v1?i*this.u1<=0?(this.numHit++,!1):(this.u1=i,this.v1=n,!0):0===i?(this.numHit++,!1):this.updateUV01(i,n):0===this.u1?(this.numHit++,!1):(this.v0*n<0&&(this.u1>0?this.numRightCrossing++:this.numLeftCrossing++),this.updateUV01(i,n))}classifyCounts(){return this.numHit>0?0:1&~this.numLeftCrossing?-1:1}}class Xt{numStroke;curveLength;a0;a1;componentData;primitive;componentIndex;constructor(t,e,i,n,s){this.numStroke=t,this.curveLength=e,this.a0=i,this.a1=n,this.componentData=s}static createWithCurvePrimitive(t,e,i,n,s,r){const o=new Xt(e,i,n,s,r);return o.primitive=t,o}static createWithComponentIndex(t=0,e=0,i=0,n=0,s=0){const r=new Xt(e,i,n,s);return r.componentIndex=t,r}static createWithCurvePrimitiveAndOptionalParent(t,e,i){const n=e?e.a1:0,s=new Xt(0,0,n,n,i);return s.primitive=t,s}addToCountAndLength(t,e){const i=this.a1+e;this.componentData&&this.componentData.push(new Xt(t,e,this.a1,i)),this.numStroke+=t,this.curveLength+=e,this.a1=i}isCompatibleComponentStructure(t,e){if(e&&this.numStroke!==t.numStroke)return!1;if(void 0===this.componentData&&void 0===t.componentData)return!0;if(this.componentData&&t.componentData){if(this.componentData.length!==t.componentData.length)return!1;const i=this.componentData.length;for(let n=0;n<i;n++)if(!this.componentData[n].isCompatibleComponentStructure(t.componentData[n],e))return!1;return!0}return!1}clone(){const t=new Xt(this.numStroke,this.curveLength,this.a0,this.a1);if(this.componentData){t.componentData=[];for(const e of this.componentData)t.componentData.push(e.clone())}return t}fractionToA(t){return J.interpolate(this.a0,t,this.a1)}}class zt{range(t,e){e&&e.setNull();const i=e||ft.createNull();return this.extendRange(i,t),i}tryTranslateInPlace(t,e=0,i=0){return this.tryTransformInPlace(mt.createTranslationXYZ(t,e,i))}get children(){}isAlmostEqual(t){if(this.isSameGeometryClass(t)){const e=this.children,i=t.children;if(e&&i){if(e.length!==i.length)return!1;for(let t=0;t<e.length;t++)if(!e[t].isAlmostEqual(i[t]))return!1;return!0}return!e&&!i}return!1}static areAlmostEqual(t,e){return t instanceof zt&&e instanceof zt?t.isAlmostEqual(e):void 0===t&&void 0===e}}class Lt{static _allRows=[];static getRow(t){const e=Lt._allRows;for(0===e.length&&(e.push(new Float64Array([1])),e.push(new Float64Array([1,1])),e.push(new Float64Array([1,2,1])),e.push(new Float64Array([1,3,3,1])),e.push(new Float64Array([1,4,6,4,1])),e.push(new Float64Array([1,5,10,10,5,1])),e.push(new Float64Array([1,6,15,20,15,6,1])),e.push(new Float64Array([1,7,21,35,35,21,7,1])));e.length<=t;){const t=e.length,i=e[t-1],n=new Float64Array(t+1);n[0]=1;for(let e=1;e<t;e++)n[e]=i[e-1]+i[e];n[t]=1,e.push(n)}return e[t]}static getBezierBasisValues(t,e,i){const n=t-1,s=Lt.getRow(n);(void 0===i||i.length<t)&&(i=new Float64Array(t));for(let e=0;e<t;e++)i[e]=s[e];let r=e;for(let n=1;n<t;n++,r*=e)i[n]*=r;const o=1-e;r=o;for(let e=t-2;e>=0;e--,r*=o)i[e]*=r;return i}static getBezierBasisDerivatives(t,e,i){(void 0===i||i.length<t)&&(i=new Float64Array(t));const n=t-1;(i=this.getBezierBasisValues(t-1,e,i))[t-1]=n*i[t-2];for(let e=t-2;e>0;e--)i[e]=n*(i[e-1]-i[e]);return i[0]=-n*i[0],i}}class Yt{coffs;constructor(t){if(t instanceof Float64Array)this.coffs=t.slice();else if(Array.isArray(t)){this.coffs=new Float64Array(t.length);let e=0;for(const i of t)this.coffs[e++]=i}else this.coffs=new Float64Array(t)}allocateToOrder(t){this.coffs.length!==t?this.coffs=new Float64Array(t):this.coffs.fill(0)}createPeer(){return new Ut(this.order)}get order(){return this.coffs.length}copyFrom(t){if(this.order===t.order)for(let e=0;e<this.coffs.length;e++)this.coffs[e]=t.coffs[e];else this.coffs=t.coffs.slice()}scaleInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]*=t}addInPlace(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}roots(t,e){const i=Ut.create(this);i.addInPlace(-t);const n=Ut.deflateRoots(i);return this.filter01(n,!0)}filter01(t,e=!1){if(!t||!e)return t;let i=!1;for(const e of t)if(J.isIn01(e)){i=!0;break}if(i){const e=[];for(const i of t)J.isIn01(i)&&e.push(i);return e}}zero(){this.coffs.fill(0)}subdivide(t,e,i){const n=this.order;if(e.order!==n||i.order!==n)return!1;const s=1-t;i.copyFrom(this);let r=n-1;for(let o=0;o<n;o++){e.coffs[o]=i.coffs[0];for(let e=0;e<r;e++)i.coffs[e]=s*i.coffs[e]+t*i.coffs[e+1];r--}return!0}static maxAbsDiff(t,e){const i=t.order;if(e.order!==i)return;let n,s=0;for(let r=0;r<i;r++)n=Math.abs(t.coffs[r]-e.coffs[r]),n>s&&(s=n);return s}}class Vt{static accumulateScaledShiftedComponentTimesComponentDelta(t,e,i,n,s,r,o,a){const c=n-1,l=n,h=n+c-1;if(t.length!==h)return;const d=Lt.getRow(l-1),u=Lt.getRow(c-1),f=Lt.getRow(h-1);let g;for(let n=0;n<l;n++){g=s*(o+e[r+n*i])*d[n];for(let s=0,r=a;s<c;s++,r+=i)t[n+s]+=g*u[s]*(e[r+i]-e[r])/f[n+s]}}static scaledComponentSum(t,e,i,n,s,r,o,a){const c=n;if(t.length===c)for(let n=0,l=0;n<c;n++,l+=i)t[n]=r*e[l+s]+a*e[l+o]}static componentDifference(t,e,i,n,s){const r=n-1;if(t.length===r)for(let n=0,o=s;n<r;o+=i,n++)t[n]=e[o+i]-e[o]}static accumulateProduct(t,e,i,n=1){const s=e.length,r=i.length,o=s+r-1;if(t.length!==o)return;let a,c,l;const h=Lt.getRow(s-1),d=Lt.getRow(r-1),u=Lt.getRow(o-1);for(a=0;a<s;a++)for(l=n*h[a]*e[a],c=0;c<r;c++)t[a+c]+=l*d[c]*i[c]/u[a+c]}static accumulateProductWithDifferences(t,e,i,n=1){const s=e.length-1,r=i.length,o=s+r-1;if(t.length!==o)return;let a,c,l;const h=Lt.getRow(s-1),d=Lt.getRow(r-1),u=Lt.getRow(o-1);for(a=0;a<s;a++)for(l=n*h[a]*(e[a+1]-e[a]),c=0;c<r;c++)t[a+c]+=l*d[c]*i[c]/u[a+c]}static univariateDifference(t,e){const i=e.length;if(e.length+1!==i)for(let n=0;n<i;n++)e[n]=t[n+1]-t[n]}static accumulate(t,e,i){if(i.length===e)for(let n=0;n<e;n++)i[n]+=t[n]}}class Ut extends Yt{_order;get order(){return this._order}constructor(t){super(t),this._order=super.order}allocateOrder(t){this._order!==t&&(super.allocateToOrder(t),this._order=t),this.coffs.fill(0)}clone(t=!1){if(t){const t=new Ut(this.order);return t.coffs=this.coffs.slice(0,this.order),t}const e=new Ut(this.coffs.length);return e._order=this._order,e.coffs=this.coffs.slice(),e}static create(t){const e=new Ut(t.order);return e.coffs=t.coffs.slice(),e}static createCoffs(t){return new Ut(t)}static createArraySubset(t,e,i,n){n?n.order!==i&&n.allocateToOrder(i):n=new Ut(i);for(let s=0;s<i;s++)n.coffs[s]=t[e+s];return n}static createProduct(t,e){const i=new Ut(t.order+e.order-1),n=Lt.getRow(t.order-1),s=Lt.getRow(e.order-1),r=Lt.getRow(t.order+e.order-2);for(let o=0;o<t.order;o++){const a=t.coffs[o]*n[o];for(let t=0;t<e.order;t++){const n=e.coffs[t]*s[t],c=o+t,l=r[c];i.coffs[c]+=a*n/l}}return i}addSquaredSquaredBezier(t,e){const i=t.length,n=this.order;if(2*i!==n+1)return!1;const s=Lt.getRow(i-1),r=Lt.getRow(n-1),o=this.coffs;for(let n=0;n<i;n++){const a=t[n]*s[n]*e;for(let e=0;e<i;e++){const i=t[e]*s[e],c=n+e,l=r[c];o[c]+=a*i/l}}return!0}addConstant(t){for(let e=0;e<this.coffs.length;e++)this.coffs[e]+=t}_basisValues;basisFunctions(t,e){this._basisValues=Lt.getBezierBasisValues(this.order,t,this._basisValues),(!e||e.length<this.order)&&(e=new Float64Array(this.order));let i=0;for(const t of this._basisValues)e[i++]=t;return e}static sumWeightedBlocks(t,e,i,n,s){for(let t=0;t<n;t++)s[t]=0;let r,o=0;for(let a=0;a<e;a++){const e=t[a];for(r=0;r<n;r++)s[r]+=e*i[o++]}}sumBasisFunctions(t,e,i,n){return(!n||n.length<i)&&(n=new Float64Array(i)),this._basisValues=Lt.getBezierBasisValues(this.order,t,this._basisValues),Ut.sumWeightedBlocks(this._basisValues,this.order,e,i,n),n}sumBasisFunctionDerivatives(t,e,i,n){return(!n||n.length<i)&&(n=new Float64Array(i)),this._basisValues=Lt.getBezierBasisDerivatives(this.order,t,this._basisValues),Ut.sumWeightedBlocks(this._basisValues,this.order,e,i,n),n}evaluate(t){this._basisValues=Lt.getBezierBasisValues(this.order,t,this._basisValues);let e=0;for(let t=0;t<this.order;t++)e+=this._basisValues[t]*this.coffs[t];return e}deflateLeft(){const t=this.order,e=t-1,i=Lt.getRow(e-1),n=Lt.getRow(t-1);let s;for(let t=0;t<e;t++)s=this.coffs[t+1],this.coffs[t]=s*n[t+1]/i[t];this._order--}deflateRight(){const t=this.order,e=t-1,i=Lt.getRow(e-1),n=Lt.getRow(t-1);let s,r;for(let t=0;t<e;t++)s=this.coffs[t],r=s*n[t]/i[t],this.coffs[t]=r;this._order--}deflateRoot(t){const e=this.order,i=e-1;if(1===e)return this._order=0,this.coffs[0];if(e<1)return this._order=0,0;const n=Lt.getRow(e-1),s=Lt.getRow(i-1),r=-t,o=1-t;let a=0;if(t>.5){let t,c,l=this.coffs[0]/r;this.coffs[0]=l;for(let e=1;e<i;e++)c=this.coffs[e]*n[e],t=(c-l*o)/r,this.coffs[e]=t/s[e],l=t;a=this.coffs[e-1]-l*o}else{let t,c,l=this.coffs[e-1]/o;this.coffs[e-1]=l;for(let i=e-2;i>0;i--)c=this.coffs[i]*n[i],t=(c-l*r)/o,this.coffs[i]=t/s[i-1],l=t;a=this.coffs[0]-l*r;for(let t=0;t<i;t++)this.coffs[t]=this.coffs[t+1]}return this._order=i,a}static _basisBuffer;static _basisBuffer1;runNewton(t,e=1e-11){const i=this.order-1;let n,s,r=0,o=t;const a=this.order,c=this.coffs,l=a-1;for(let t=0;t++<10;){Ut._basisBuffer=Lt.getBezierBasisValues(a,o,Ut._basisBuffer),n=0;for(let t=0;t<a;t++)n+=c[t]*Ut._basisBuffer[t];Ut._basisBuffer1=Lt.getBezierBasisValues(l,o,Ut._basisBuffer1),s=0;for(let t=0;t<l;t++)s+=(c[t+1]-c[t])*Ut._basisBuffer1[t];if(s*=i,Math.abs(n)>10*Math.abs(s))return;const t=n/s;if(Math.abs(t)<e){if(r++,r>=2)return o-t}else r=0;o-=t}}static deflateRoots(t){const e=[],i=t.coffs;let n,s,r,o,a;for(;t.order>1;){const c=t.order;if(0===i[0]){t.deflateLeft(),e.push(0);continue}let l=0,h=0;for(let d=1;d<c;d++)if(n=i[d-1],s=i[d],n*s<=0&&(l++,r=-n/(s-n),o=(d-1+r)/(c-1),a=t.runNewton(o,1e-10),void 0!==a)){e.push(a),t.deflateRoot(a),h++;break}if(!h)return e}return e}}class qt extends Yt{constructor(t=0,e=0){super(2),this.coffs[0]=t,this.coffs[1]=e}clone(){return new qt(this.coffs[0],this.coffs[1])}static solveCoffs(t,e){return J.conditionalDivideFraction(-t,e-t)}basisFunctions(t,e){return(!e||e.length<2)&&(e=new Float64Array(2)),e[0]=1-t,e[1]=t,e}sumBasisFunctions(t,e,i,n){(!n||n.length<i)&&(n=new Float64Array(i));const s=1-t;for(let r=0;r<i;r++)n[r]=s*e[r]+t*e[r+i];return n}sumBasisFunctionDerivatives(t,e,i,n){(!n||n.length<i)&&(n=new Float64Array(i));for(let t=0;t<i;t++)n[t]=e[t+i]-e[t];return n}evaluate(t){return(1-t)*this.coffs[0]+t*this.coffs[1]}solve(t){const e=this.coffs[1]-this.coffs[0];return J.conditionalDivideFraction(t-this.coffs[0],e)}roots(t,e){const i=this.solve(t);if(void 0!==i)return!e||J.isIn01(i)?[i]:void 0}}class Zt{constructor(t=1e-11,e=2,i=15){this._stepSizeTolerance=t,this._successiveConvergenceTarget=e,this._maxIterations=i}_numAccepted=0;_successiveConvergenceTarget;_stepSizeTolerance;_maxIterations;numIterations=0;testConvergence(t){return Math.abs(t)<this._stepSizeTolerance?(this._numAccepted++,this._numAccepted>=this._successiveConvergenceTarget):(this._numAccepted=0,!1)}runIterations(){for(this._numAccepted=0,this.numIterations=0;this.numIterations++<this._maxIterations&&this.computeStep();){if(this.testConvergence(this.currentStepSize())&&this.applyCurrentStep(!0))return!0;this.applyCurrentStep(!1)}return!1}}class Wt{currentF;currentdFdX}class Gt extends Zt{_func;_currentStep;_currentX;_target;constructor(t,e){super(void 0,void 0,e),this._func=t,this.setTarget(0)}setX(t){return this._currentX=t,!0}getX(){return this._currentX}setTarget(t){this._target=t}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=J.conditionalDivideFraction(this._func.currentF-this._target,this._func.currentdFdX);if(void 0!==t)return this._currentStep=t,!0}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class Qt{currentF}class Ht extends Zt{_func;_currentStep;_currentX;derivativeH;constructor(t,e){super(void 0,void 0,e),this._func=t,this.derivativeH=1e-8}setX(t){return this._currentX=t,!0}getX(){return this._currentX}applyCurrentStep(){return this.setX(this._currentX-this._currentStep)}computeStep(){if(this._func.evaluate(this._currentX)){const t=this._func.currentF;if(this._func.evaluate(this._currentX+this.derivativeH)){const e=this._func.currentF,i=J.conditionalDivideFraction(t,(e-t)/this.derivativeH);if(void 0!==i)return this._currentStep=i,!0}}return!1}currentStepSize(){return Math.abs(this._currentStep/(1+Math.abs(this._currentX)))}}class jt{currentF;constructor(){this.currentF=Mt.createXYPlane()}}class Jt extends Zt{_func;_currentStep;_currentUV;constructor(t,e){super(void 0,void 0,e),this._func=t,this._currentStep=j.createZero(),this._currentUV=H.createZero()}setUV(t,e){return this._currentUV.set(t,e),!0}getU(){return this._currentUV.x}getV(){return this._currentUV.y}applyCurrentStep(){return this.setUV(this._currentUV.x-this._currentStep.x,this._currentUV.y-this._currentStep.y)}computeStep(){if(!this._func.evaluate(this._currentUV.x,this._currentUV.y))return!1;const t=this._func.currentF,e=t.vectorU,i=t.vectorV,n=t.origin;return!!Ft.linearSystem2d(e.x,i.x,e.y,i.y,n.x,n.y,this._currentStep)}currentStepSize(){return J.maxAbsXY(this._currentStep.x/(1+Math.abs(this._currentUV.x)),this._currentStep.y/(1+Math.abs(this._currentUV.y)))}}class Kt extends jt{_curveP;_curveQ;_rayP;_rayQ;constructor(t,e){super(),this._curveP=t,this._curveQ=e,this._rayP=Rt.createZero(),this._rayQ=Rt.createZero()}evaluate(t,e){return this._curveP.fractionToPointAndDerivative(t,this._rayP),this._curveQ.fractionToPointAndDerivative(e,this._rayQ),this.currentF.setOriginAndVectorsXYZ(this._rayP.origin.x-this._rayQ.origin.x,this._rayP.origin.y-this._rayQ.origin.y,0,this._rayP.direction.x,this._rayP.direction.y,0,-this._rayQ.direction.x,-this._rayQ.direction.y,0),!0}}class $t extends Wt{_curveP;_pointQ;_planeP;constructor(t,e){super(),this._curveP=t,this._pointQ=e,this._planeP=Mt.createXYPlane()}evaluate(t){this._curveP.fractionToPointAnd2Derivatives(t,this._planeP);const e=this._planeP.origin.x-this._pointQ.x,i=this._planeP.origin.y-this._pointQ.y,n=this._planeP.vectorU.x,s=this._planeP.vectorU.y,r=this._planeP.vectorV.x,o=this._planeP.vectorV.y;return this.currentF=n*e+s*i,this.currentdFdX=r*e+n*n+o*i+s*s,!0}}class te extends jt{_curveP;_curveQ;_planeP;_planeQ;constructor(t,e){super(),this._curveP=t,this._curveQ=e,this._planeP=Mt.createXYPlane(),this._planeQ=Mt.createXYPlane()}evaluate(t,e){this._curveP.fractionToPointAnd2Derivatives(t,this._planeP),this._curveQ.fractionToPointAnd2Derivatives(e,this._planeQ);const i=this._planeP.origin.x-this._planeQ.origin.x,n=this._planeP.origin.y-this._planeQ.origin.y,s=this._planeP.vectorU.x,r=this._planeP.vectorU.y,o=this._planeQ.vectorU.x,a=this._planeQ.vectorU.y,c=this._planeP.vectorV.x,l=this._planeP.vectorV.y,h=this._planeQ.vectorV.x,d=this._planeQ.vectorV.y;return this.currentF.setOriginAndVectorsXYZ(s*i+r*n,o*i+a*n,0,c*i+l*n+s*s+r*r,o*s+a*r,0,-(s*o+r*a),h*i+d*n-o*o-a*a,0),!0}}class ee extends Qt{_parentCurvePrimitive;constructor(){super(),this._parentCurvePrimitive=void 0}startParentCurvePrimitive(t){this._parentCurvePrimitive=t}endParentCurvePrimitive(t){this._parentCurvePrimitive=void 0}}class ie extends ee{_curve;_plane;_intersections;_fractionA=0;_functionA=0;_functionB=0;_fractionB=0;_derivativeB=0;_numThisCurve=0;_ray;_newtonSolver;effectiveCurve(){return this._parentCurvePrimitive?this._parentCurvePrimitive:this._curve}get getDerivativeB(){return this._derivativeB}constructor(t,e){super(),this._plane=t,this._intersections=e,this.startCurvePrimitive(void 0),this._ray=Rt.createZero(),this._newtonSolver=new Ht(this)}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,n){this.startCurvePrimitive(t),e<1&&(e=1);const s=1/e;for(let r=0;r<=e;r++){const e=J.interpolate(i,r*s,n);t.fractionToPointAndDerivative(e,this._ray),this.announcePointTangent(this._ray.origin,e,this._ray.direction)}}announceSegmentInterval(t,e,i,n,s,r){const o=this._plane.altitude(e),a=this._plane.altitude(i);if(o*a>0)return;const c=qt.solveCoffs(o,a);if(void 0!==c){const t=J.interpolate(s,c,r);this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX())}}announceSolutionFraction(t){const e=this.effectiveCurve();e&&(this._ray=e.fractionToPointAndDerivative(t,this._ray),this._intersections.push(Pt.createCurveFractionPoint(e,t,this._ray.origin)))}evaluate(t){const e=this.effectiveCurve();return!!e&&(this.currentF=this._plane.altitude(e.fractionToPoint(t)),!0)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=J.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}evaluateB(t,e,i){this._functionB=this._plane.altitude(t),this._derivativeB=this._plane.velocity(i),this._fractionB=e}announcePointTangent(t,e,i){this.evaluateB(t,e,i),this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}}!function(t){t[t.None=0]="None",t[t.OnTangent=1]="OnTangent",t[t.OnCurve=2]="OnCurve"}(S||(S={}));class ne{static resolveVariantCurveExtendParameterToCurveExtendMode(t,e){return!1===t?S.None:!0===t?S.OnCurve:Array.isArray(t)?t.length>e?t[e]:S.None:t}static correctFraction(t,e){return e<0?ne.resolveVariantCurveExtendParameterToCurveExtendMode(t,0)===S.None&&(e=0):e>1&&ne.resolveVariantCurveExtendParameterToCurveExtendMode(t,1)===S.None&&(e=1),e}static resolveRadiansToValidSweepFraction(t,e,i){let n=i.radiansToSignedPeriodicFraction(e),s=!0;if(!i.isRadiansInSweep(e)){const e=i.fractionPeriod(),r=ne.resolveVariantCurveExtendParameterToCurveExtendMode(t,0),o=ne.resolveVariantCurveExtendParameterToCurveExtendMode(t,1);r!==S.None?o===S.None&&n>1&&(n-=e):o!==S.None?n<0&&(n+=e):(n=J.clamp(n,0,1),s=!1)}return{fraction:n,isValid:s}}static resolveRadiansToSweepFraction(t,e,i){return this.resolveRadiansToValidSweepFraction(t,e,i).fraction}}class se extends ee{_curve;_closestPoint;_spacePoint;_extend;_fractionA=0;_functionA=0;_fractionB=0;_functionB=0;_numThisCurve=0;_workPoint;_workRay;_newtonSolver;constructor(t,e,i){super(),this._spacePoint=t,this._workPoint=$.create(),this._workRay=Rt.createZero(),this._closestPoint=i,this._extend=e??!1,this.startCurvePrimitive(void 0),this._newtonSolver=new Ht(this)}claimResult(){if(this._closestPoint&&(this._newtonSolver.setX(this._closestPoint.fraction),this._curve=this._closestPoint.curve,this._newtonSolver.runIterations())){let t=this._newtonSolver.getX();t=ne.correctFraction(this._extend,t),this.announceSolutionFraction(t)}return this._closestPoint}needPrimaryGeometryForStrokes(){return!0}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,n){this.startCurvePrimitive(t),this.announceSolutionFraction(0),this.announceSolutionFraction(1),e<1&&(e=1);const s=1/e;for(let r=0;r<=e;r++){const e=J.interpolate(i,r*s,n);t.fractionToPointAndDerivative(e,this._workRay),this.announceRay(e,this._workRay)}}announceCandidate(t,e,i){const n=this._spacePoint.distance(i);this._closestPoint&&n>this._closestPoint.a||(this._closestPoint=Pt.createCurveFractionPoint(t,e,i,this._closestPoint),this._closestPoint.a=n,void 0!==this._parentCurvePrimitive&&(this._closestPoint.curve=this._parentCurvePrimitive))}announceSegmentInterval(t,e,i,n,s,r){let o=this._spacePoint.fractionOfProjectionToLine(e,i,0);this._extend?(0!==s&&(o=Math.max(o,0)),1!==r&&(o=Math.min(o,1))):o=J.clampToStartEnd(o,0,1),this._workPoint=e.interpolate(o,i);const a=J.interpolate(s,o,r);this.announceCandidate(t,a,this._workPoint)}searchInterval(){if(!(this._functionA*this._functionB>0)&&(0===this._functionA&&this.announceSolutionFraction(this._fractionA),0===this._functionB&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0)){const t=J.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}announceSolutionFraction(t){this._curve&&this.announceCandidate(this._curve,t,this._curve.fractionToPoint(t))}evaluateFunction(t,e,i){if(t)this._workRay.setFrom(t);else{if(void 0===e||!i)return;this._workRay=i.fractionToPointAndDerivative(e,this._workRay)}return this._workRay.dotProductToPoint(this._spacePoint)}evaluate(t){let e=this._curve;this._parentCurvePrimitive&&(e=this._parentCurvePrimitive);const i=this.evaluateFunction(void 0,t,e);return void 0!==i&&(this.currentF=i,!0)}announceRay(t,e){this._functionB=this.evaluateFunction(e),this._fractionB=t,this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}announcePointTangent(t,e,i){this._workRay.set(t,i),this.announceRay(e,this._workRay)}}class re extends ee{_curve;_announceTangent;_spacePoint;_vectorToEye;_distanceTol;_distanceTolSquared;_fractionA=0;_functionA=0;_fractionB=0;_functionB=0;_numThisCurve=0;_fractionMRU;_curveMRU;_workRay;_workDetail;_newtonSolver;constructor(t,e,i){super(),this._announceTangent=e,this._spacePoint=t,this._vectorToEye=i?.vectorToEye??tt.unitZ(),this._distanceTol=i?.distanceTol??J.smallMetricDistance,this._distanceTolSquared=this._distanceTol*this._distanceTol,this._workRay=Rt.createZero(),this.startCurvePrimitive(void 0),this._newtonSolver=new Ht(this)}needPrimaryGeometryForStrokes(){return!0}startCurvePrimitive(t){this._curve=t,this._fractionA=0,this._numThisCurve=0,this._functionA=0}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,n){this.startCurvePrimitive(t),e<1&&(e=1);const s=1/e;for(let r=0;r<=e;r++){const e=J.interpolate(i,r*s,n);t.fractionToPointAndDerivative(e,this._workRay),this.announceRay(e,this._workRay)}}announceCandidate(t,e,i){this._parentCurvePrimitive&&(t=this._parentCurvePrimitive),this._curveMRU===t&&J.isAlmostEqualOptional(this._fractionMRU,e,J.smallFloatingPoint)||(this._workDetail=Pt.createCurveFractionPoint(t,e,i,this._workDetail),this._announceTangent(this._workDetail),this._fractionMRU=e,this._curveMRU=t)}announceSegmentInterval(t,e,i,n,s,r){let o,a;this._spacePoint.distanceSquared(e)<this._spacePoint.distanceSquared(i)?(o=s,a=e):(o=r,a=i);const c=this.evaluateFunction(void 0,(s+r)/2,t);void 0!==c&&J.isDistanceWithinTol(c,this._distanceTol)&&this.announceCandidate(t,o,a)}searchInterval(){if(J.isDistanceWithinTol(this._functionA,this._distanceTolSquared)&&this.announceSolutionFraction(this._fractionA),J.isDistanceWithinTol(this._functionB,this._distanceTolSquared)&&this.announceSolutionFraction(this._fractionB),this._functionA*this._functionB<0){const t=J.inverseInterpolate(this._fractionA,this._functionA,this._fractionB,this._functionB);t&&(this._newtonSolver.setX(t),this._newtonSolver.runIterations()&&this.announceSolutionFraction(this._newtonSolver.getX()))}}announceSolutionFraction(t){this._curve&&this.announceCandidate(this._curve,t,this._curve.fractionToPoint(t))}evaluateFunction(t,e,i){if(t)this._workRay.setFrom(t);else{if(void 0===e||!i)return;this._workRay=i.fractionToPointAndDerivative(e,this._workRay)}const n=this._vectorToEye.unitCrossProduct(this._workRay.direction);return n?n.dotProductStartEnd(this._workRay.origin,this._spacePoint):void 0}evaluate(t){const e=this._parentCurvePrimitive??this._curve,i=this.evaluateFunction(void 0,t,e);return void 0!==i&&(this.currentF=i,!0)}announceRay(t,e){this._functionB=this.evaluateFunction(e),this._fractionB=t,this._numThisCurve++>0&&this.searchInterval(),this._functionA=this._functionB,this._fractionA=this._fractionB}announcePointTangent(t,e,i){}}class oe{static gaussX1Interval01=new Float64Array([.5]);static gaussW1Interval01=new Float64Array([1]);static gaussX2Interval01=new Float64Array([.21132486540518708,.7886751345948129]);static gaussW2Interval01=new Float64Array([.5,.5]);static gaussX3Interval01=new Float64Array([.1127016653792583,.5,.8872983346207417]);static gaussW3Interval01=new Float64Array([.2777777777777778,.4444444444444444,.2777777777777778]);static gaussX4Interval01=new Float64Array([.06943184420297371,.33000947820757187,.6699905217924281,.9305681557970262]);static gaussW4Interval01=new Float64Array([.17392742256872692,.3260725774312731,.3260725774312731,.17392742256872692]);static gaussX5Interval01=new Float64Array([.04691007703066802,.23076534494715845,.5,.7692346550528415,.9530899229693319]);static gaussW5Interval01=new Float64Array([.11846344252809454,.23931433524968324,.28444444444444444,.23931433524968324,.11846344252809454]);static mapWeights(t,e,i,n,s,r){const o=i.length;for(let a=0;a<o;a++)s[a]=t+e*i[a],r[a]=e*n[a];return o}static setupGauss1(t,e,i,n){return oe.mapWeights(t,e-t,oe.gaussX1Interval01,oe.gaussW1Interval01,i,n)}static setupGauss2(t,e,i,n){return oe.mapWeights(t,e-t,oe.gaussX2Interval01,oe.gaussW2Interval01,i,n)}static setupGauss3(t,e,i,n){return oe.mapWeights(t,e-t,oe.gaussX3Interval01,oe.gaussW3Interval01,i,n)}static setupGauss5(t,e,i,n){return oe.mapWeights(t,e-t,oe.gaussX5Interval01,oe.gaussW5Interval01,i,n)}static setupGauss4(t,e,i,n){return oe.mapWeights(t,e-t,oe.gaussX4Interval01,oe.gaussW4Interval01,i,n)}static sum1(t,e,i,n){let s=0;for(let r=0;r<i;r++)s+=e[r]*n(t[r]);return s}static doGaussIntegral(t,e,i,n,s=5){const r=new ae(s);n<1&&(n=1);const o=1/n;let a=0;for(let s=1;s<=n;s++){const c=J.interpolate(t,(s-1)*o,e),l=s===n?e:J.interpolate(t,s*o,e),h=r.mapXAndW(c,l);for(let t=0;t<h;t++)a+=r.gaussW[t]*i(r.gaussX[t])}return a}}class ae{gaussX;gaussW;mapXAndWFunction;mapXAndW(t,e){return this.mapXAndWFunction(t,e,this.gaussX,this.gaussW)}constructor(t){switch(this.gaussX=new Float64Array(7),this.gaussW=new Float64Array(7),(t>5||t<1)&&(t=5),t){case 1:this.mapXAndWFunction=(t,e,i,n)=>oe.setupGauss1(t,e,i,n);break;case 2:this.mapXAndWFunction=(t,e,i,n)=>oe.setupGauss2(t,e,i,n);break;case 3:this.mapXAndWFunction=(t,e,i,n)=>oe.setupGauss3(t,e,i,n);break;case 4:this.mapXAndWFunction=(t,e,i,n)=>oe.setupGauss4(t,e,i,n);break;default:this.mapXAndWFunction=(t,e,i,n)=>oe.setupGauss5(t,e,i,n)}}}class ce{_curve;_summedLength;_ray;_fraction0;_fraction1;_gaussMapper;tangentMagnitude(t){return this._ray=this._curve.fractionToPointAndDerivative(t,this._ray),this._ray.direction.magnitude()}get getFraction0(){return this._fraction0}get getFraction1(){return this._fraction1}getSum(){return this._summedLength}constructor(t=0,e=1,i=5){this.startCurvePrimitive(void 0),this._summedLength=0,this._ray=Rt.createZero(),t<e?(this._fraction0=t,this._fraction1=e):(this._fraction0=e,this._fraction1=t),this._gaussMapper=new ae(i)}startCurvePrimitive(t){this._curve=t}startParentCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(){}announceIntervalForUniformStepStrokes(t,e,i,n){const s=gt.createXX(i,n);if(s.intersectRangeXXInPlace(this._fraction0,this._fraction1),!s.isNull){this.startCurvePrimitive(t),e<1&&(e=1);const i=1/e;for(let t=1;t<=e;t++){const n=s.fractionToPoint((t-1)*i),r=t===e?s.high:s.fractionToPoint(t*i),o=this._gaussMapper.mapXAndW(n,r);for(let t=0;t<o;t++)this._summedLength+=this._gaussMapper.gaussW[t]*this.tangentMagnitude(this._gaussMapper.gaussX[t])}}}announceSegmentInterval(t,e,i,n,s,r){const o=e.distance(i);if(this._fraction0<=s&&r<=this._fraction1)this._summedLength+=o;else{const t=gt.createXX(s,r);t.intersectRangeXXInPlace(this._fraction0,this._fraction1),t.isNull||(this._summedLength+=o*t.length()/(r-s))}}announcePointTangent(t,e,i){}}class le extends zt{geometryCategory="curvePrimitive";constructor(){super()}strokeData;startCut;endCut;parent;fractionToPointAndUnitTangent(t,e){const i=this.fractionToPointAndDerivative(t,e);return i.trySetDirectionMagnitudeInPlace(1),i}fractionToCurvature(t){const e=this.fractionToPointAnd2Derivatives(t),i=e.vectorU.crossProduct(e.vectorV).magnitude(),n=e.vectorU.magnitude();return J.conditionalDivideFraction(i,n*n*n)}fractionToFrenetFrame(t,e){const i=this.fractionToPointAnd2Derivatives(t);if(!i)return;let n=xt.createRigidFromColumns(i.vectorU,i.vectorV,f.XYZ);if(n)return mt.createRefs(i.origin,n,e);const s=xt.createPerpendicularVectorFavorXYPlane(i.vectorU,i.vectorV);return n=xt.createRigidFromColumns(i.vectorU,s,f.XYZ),n?mt.createRefs(i.origin,n,e):void 0}fractionToSignedXYRadiusOfCurvature(t){const e=this.fractionToPointAnd2Derivatives(t);if(!e)return 0;const i=e.vectorU.crossProductXY(e.vectorV),n=e.vectorU.magnitude();if(0===n)return 0;const s=J.conditionalDivideCoordinate(n*n*n,i);return void 0!==s?s:0}fractionAndDistanceToPointOnTangent(t,e){return this.fractionToPointAndUnitTangent(t).fractionToPoint(e)}curveLength(){const t=new ce;return this.emitStrokableParts(t),t.getSum()}curveLengthBetweenFractions(t,e){if(t===e)return 0;if(void 0!==this.getFractionToDistanceScale()){const i=this.curveLength();return Math.abs((e-t)*i)}const i=new ce(t,e);return this.emitStrokableParts(i),Math.abs(i.getSum())}rangeBetweenFractions(t,e,i){return this.rangeBetweenFractionsByClone(t,e,i)}rangeBetweenFractionsByClone(t,e,i){if(t===e)return ft.create(this.fractionToPoint(t));const n=this.clonePartialCurve(t,e);return n?n.range(i):ft.createNull()}rangeBetweenFractionsByCount(t,e,i,n,s=0){const r=ft.createNull(),o=$.create();r.extendPoint(this.startPoint(o)),r.extendPoint(this.endPoint(o));const a=(t,e,i)=>{let s=t;for(let t=0;t<i;t++,s+=e)this.fractionToPoint(s,o),n?r.extendTransformedPoint(n,o):r.extendPoint(o)},c=i-2;if(c>0){const i=1/(c+1)*(e-t);a(t+i,i,c)}if(s>0){const i=r.clone(),n=c+1,o=.5/n*2*(e-t);a(t+.5*o,o,n),r.extendWhenLarger(i,s)}return r}curveLengthWithFixedIntervalCountQuadrature(t,e,i,n=5){if(t>e){const i=t;t=e,e=i}const s=new ce(t,e,n);return s.announceIntervalForUniformStepStrokes(this,i,t,e),Math.abs(s.getSum())}moveSignedDistanceFromFraction(t,e,i,n){if(void 0!==this.getFractionToDistanceScale()){const s=this.curveLength(),r=J.conditionalDivideFraction(e,s);return void 0===r?Pt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,P.error):Pt.createConditionalMoveSignedDistance(i,this,t,t+r,e,n)}return this.moveSignedDistanceFromFractionGeneric(t,e,i,n)}moveSignedDistanceFromFractionGeneric(t,e,i,n){let s;if(0===e)return Pt.createCurveEvaluatedFraction(this,t,n);if(e>0){if(s=1,t>=1){const i=.9;e+=this.curveLengthBetweenFractions(i,t),t=i}}else if(s=0,t<=0){const i=.1;e-=this.curveLengthBetweenFractions(t,i),t=i}const r=this.curveLengthBetweenFractions(t,s),o=Math.abs(e);if(r<o&&!i)return Pt.createConditionalMoveSignedDistance(i,this,t,s,e,n);const a=J.conditionalDivideCoordinate(o,r);if(void 0===a)return(n=Pt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=P.error,n;const c=e<0?-1:1;let l=J.interpolate(t,a,s),h=t,d=0;const u=1e-12*r;let f=0;const g=Rt.createXAxis();for(let t=0;t<10;t++){const t=d+(l>h?c:-c)*this.curveLengthBetweenFractions(h,l),e=o-t;if(Math.abs(e)<u){if(f++,f>1)break}else f=0;if(this.fractionToPointAndDerivative(l,g),h=l,l=h+c*e/g.direction.magnitude(),h===l){f=100;break}d=t}return f>1?Pt.createConditionalMoveSignedDistance(i,this,t,l,e,n):((n=Pt.createCurveEvaluatedFraction(this,t,n)).curveSearchStatus=P.error,n)}get isExtensibleFractionSpace(){return!1}closestPoint(t,e,i){const n=new se(t,e,i);return this.emitStrokableParts(n),n.claimResult()}emitTangents(t,e,i){const n=new re(t,e,i);this.emitStrokableParts(n,i?.strokeOptions)}allTangents(t,e){const i=[];return this.emitTangents(t,(t=>i.push(t.clone())),e),0===i.length?void 0:i}closestTangent(t,e){const i=e?.hintPoint??t;let n;e?.vectorToEye&&!e.vectorToEye.isExactEqual({x:0,y:0,z:1})&&(n=xt.createRigidViewAxesZTowardsEye(e.vectorToEye.x,e.vectorToEye.y,e.vectorToEye.z));let s,r=J.largeCoordinateResult;return this.emitTangents(t,(t=>{const e=(o=t.point,n?.multiplyTransposeXYZ(i.x-o.x,i.y-o.y,i.z-o.z).magnitudeSquaredXY()??o.distanceSquaredXY(i));var o;(!s||e<r)&&(s=t.clone(s),r=e)}),e),s}announceClipIntervals(t,e){return!1}clonePartialCurve(t,e){}getFractionToDistanceScale(){}appendPlaneIntersectionPoints(t,e){const i=new ie(t,e),n=e.length;return this.emitStrokableParts(i),e.length-n}static snapAndRestrictDetails(t,e=!0,i=!1,n=J.smallAngleRadians,s=J.smallMetricDistance){const r=t.length;let o=0;const a=$.create(),c=$.create();let l;for(let h=0;h<r;h++){l=void 0;const r=t[h];let d=r.fraction,u=e||J.isIn01(d);r.curve&&(r.curve.startPoint(a),r.curve.endPoint(c)),n>0&&(Math.abs(d)<n&&(d=0,u=!0,r.intervalRole=v.isolatedAtVertex,l=a),Math.abs(d-1)<n&&(d=1,u=!0,r.intervalRole=v.isolatedAtVertex,l=c,r.curve&&(l=r.curve.startPoint(c)))),s>0&&void 0!==r.curve&&(r.point.distance(a)<=s?(d=0,r.intervalRole=v.isolatedAtVertex,l=a):r.point.distance(c)<=s&&(d=1,r.intervalRole=v.isolatedAtVertex,l=c)),u&&(i&&(r.fraction=d,void 0!==l&&r.point.setFrom(l)),o<h&&(t[o]=r),o++)}o<r&&(t.length=o)}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.computeStrokeCountForOptions(t),n=this.curveLength();le.installStrokeCountMap(this,Xt.createWithCurvePrimitive(this,i,n,0,n),e)}addMappedStrokesToLineString3D(t,e){const i=e.numPoints();if(t.primitive&&t.primitive===this&&t.numStroke>0)for(let i=0;i<=t.numStroke;i++){const n=i/t.numStroke;e.appendFractionToPoint(this,n)}return e.numPoints()-i}static installStrokeCountMap(t,e,i){i&&i.addToCountAndLength(e.numStroke,e.curveLength),t.strokeData=e}collectCurvePrimitivesGo(t,e,i=!1){t.push(this)}collectCurvePrimitives(t,e=!1,i=!1){const n=void 0===t?[]:t;return this.collectCurvePrimitivesGo(n,e,i),n}projectedParameterRange(t,e){}}class he extends st{data;constructor(t){super(),this.data=t}isValidIndex(t){return this.isIndexValid(t)}getPoint3dAtCheckedPointIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return $.create(i.x,i.y,i.z,e)}}getPoint3dAtUncheckedPointIndex(t,e){const i=this.data[t];return $.create(i.x,i.y,i.z,e)}getVector3dAtCheckedVectorIndex(t,e){if(this.isValidIndex(t)){const i=this.data[t];return tt.create(i.x,i.y,i.z,e)}}getXAtUncheckedPointIndex(t){return this.data[t].x}getYAtUncheckedPointIndex(t){return this.data[t].y}getZAtUncheckedPointIndex(t){return this.data[t].z}vectorIndexIndex(t,e,i){if(this.isValidIndex(t)&&this.isValidIndex(e))return tt.createStartEnd(this.data[t],this.data[e],i)}vectorXYAndZIndex(t,e,i){if(this.isValidIndex(e))return tt.createStartEnd(t,this.data[e],i)}crossProductXYAndZIndexIndex(t,e,i,n){if(this.isValidIndex(e)&&this.isValidIndex(i))return tt.createCrossProductToPoints(t,this.data[e],this.data[i],n)}crossProductIndexIndexIndex(t,e,i,n){if(this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i))return tt.createCrossProductToPoints(this.data[t],this.data[e],this.data[i],n)}accumulateCrossProductIndexIndexIndex(t,e,i,n){const s=this.data;this.isValidIndex(t)&&this.isValidIndex(e)&&this.isValidIndex(i)&&n.addCrossProductToTargetsInPlace(s[t].x,s[t].y,s[t].z,s[e].x,s[e].y,s[e].z,s[i].x,s[i].y,s[i].z)}accumulateScaledXYZ(t,e,i){if(this.isValidIndex(t)){const n=this.data[t];i.x+=e*n.x,i.y+=e*n.y,i.z+=e*n.z}}get length(){return this.data.length}push(t){this.data.push(t.clone())}pushXYZ(t,e,i){this.data.push($.create(void 0===t?0:t,void 0===e?0:e,void 0===i?0:i))}back(t){if(this.data.length>0)return this.data[this.data.length-1].clone(t)}front(t){if(this.data.length>0)return this.data[0].clone(t)}pop(){this.data.length>0&&this.data.pop()}clear(){this.data.length=0}reverseInPlace(){this.data.reverse()}distanceSquaredIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distanceSquared(this.data[e])}distanceIndexIndex(t,e){const i=this.data.length;if(t>=0&&t<i&&e>=0&&e<i)return this.data[t].distance(this.data[e])}cyclicIndex(t){return t%this.data.length}}function de(t,e,i){if(void 0!==e){const n=e*i;if(n>=0&&n<=t)return n}return t}class ue{static preciseSum(t){const e=t.length;if(0===e)return 0;let i,n,s=t[0],r=0;for(let o=1;o<e;o++)i=t[o]-r,n=s+i,r=n-s-i,s=n;return s}static isExactEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}return void 0===t&&void 0===e}static isAlmostEqual(t,e,i=J.smallMetricDistance){if(t&&e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(Math.abs(t[n]-e[n])>i)return!1;return!0}return void 0===t&&void 0===e}static sum(t){let e=0;for(const i of t)e+=i;return e}static isCoordinateInArray(t,e){if(e)for(const i of e)if(J.isSameCoordinate(t,i))return!0;return!1}static maxAbsArray(t){const e=t.length;if(0===e)return 0;let i=Math.abs(t[0]);for(let n=1;n<e;n++){const e=Math.abs(t[n]);i<e&&(i=e)}return i}static maxAbsTwo(t,e){return(t=Math.abs(t))>(e=Math.abs(e))?t:e}static maxAbsDiff(t,e){let i=0;const n=Math.min(t.length,e.length);for(let s=0;s<n;s++)i=Math.max(i,Math.abs(t[s]-e[s]));return i}static maxAbsDiffFloat64(t,e){let i=0;const n=Math.min(t.length,e.length);for(let s=0;s<n;s++)i=Math.max(i,Math.abs(t[s]-e[s]));return i}static createArrayWithMaxStepSize(t,e,i){if(t===e)return[t];const n=e-t,s=Math.max(1,Math.floor(Math.abs(n/i))),r=[];r.push(t);for(let e=1;e<s;e++)r.push(t+e/s*n);return r.push(e),r}static create(t){const e=[];for(const i of t)e.push(i);return e}static copy2d(t){const e=[];for(const i of t){const t=[];for(const e of i)t.push(e);e.push(t)}return e}static copy3d(t){const e=[];for(const i of t){const t=[];for(const e of i){const i=[];for(const t of e)i.push(t);t.push(i)}e.push(t)}return e}static unpack2d(t,e){if(!(e<1))return fe.unpackNumbersToNestedArrays(t,e)}static unpack3d(t,e,i){if(!(i<1||e<1))return fe.unpackNumbersToNestedArraysIJK(t,i,e)}static pack(t){const e=t.length;let i=0,n=0,s=0;e>0&&(s=e,Array.isArray(t[0])&&(i=t[0].length,i>0&&(s*=i,Array.isArray(t[0][0])&&(n=t[0][0].length,n>0&&(s*=n)))));const r=new Float64Array(s);if(n>0){const s=t;for(let t=0,o=0;t<e;++t)for(let e=0;e<i;++e)for(let i=0;i<n;++i)r[o++]=s[t][e][i]}else if(i>0){const n=t;for(let t=0,s=0;t<e;++t)for(let e=0;e<i;++e)r[s++]=n[t][e]}else if(e>0){const i=t;for(let t=0,n=0;t<e;++t)r[n++]=i[t]}return r}static cloneWithStartAndEndMultiplicity(t,e,i){const n=[];if(void 0===t||0===t.length)return n;let s=1;const r=t[0],o=t[t.length-1];for(;s<t.length&&t[s]===r;)s++;let a=1;const c=t.length-1;for(;c-a>=0&&t[c-a]===o;)a++;for(let t=0;t<e;t++)n.push(r);for(let e=s;e+a<t.length;e++)n.push(t[e]);for(let t=0;t<i;t++)n.push(o);return n}static linearCombination(t,e){const i=Math.min(t.length,e.length);let n=0;for(let s=0;s<i;++s)n+=e[s]*t[s];return n}static linearCombinationOfColors(t,e){const i=Math.min(t.length,e.length),n=[0,0,0,0];for(let s=0,r=0;s<4;++s,r+=8){for(let o=0;o<i;++o){const i=J.clamp(e[o],0,1),a=t[o]>>>r&255;n[s]+=i*a}n[s]=(255&Math.floor(n[s]))<<r}return n[0]|n[1]|n[2]|n[3]}static searchStrictlyIncreasingNumbers(t,e){const i=t.length-1;if(i<=0||e<0||e>=t[i])return;let n=Math.floor(e*i/t[i]);for(;t[n]>e;)n--;for(;t[n+1]<=e;)n++;return n}}Ot.create();class fe{static packToFloat64Array(t,e){const i=3*t.length;(!e||e.length<i)&&(e=new Float64Array(i));let n=0;for(const i of t)e[n++]=i.x,e[n++]=i.y,e[n++]=i.z;return e}static packToNumberArray(t,e){const i=3*t.length;e||(e=Array(i)),e.length=i;let n=0;for(const i of t)e[n++]=i.x,e[n++]=i.y,e[n++]=i.z;return e}static evaluateTrilinearWeights(t,e,i,n,s,r,o){t[0]=e*n*r,t[1]=i*n*r,t[2]=e*s*r,t[3]=i*s*r,t[4]=e*n*o,t[5]=i*n*o,t[6]=e*s*o,t[7]=i*s*o}static sumWeightedX(t,e){let i=0;const n=t.length;for(let s=0;s<n;s++)i+=t[s]*e[s].x;return i}static sumWeightedY(t,e){let i=0;const n=t.length;for(let s=0;s<n;s++)i+=t[s]*e[s].y;return i}static sumWeightedZ(t,e){let i=0;const n=t.length;for(let s=0;s<n;s++)i+=t[s]*e[s].z;return i}static _weightUVW=new Float64Array(8);static _weightDU=new Float64Array(8);static _weightDV=new Float64Array(8);static _weightDW=new Float64Array(8);static evaluateTrilinearPoint(t,e,i,n,s){let r;s||(s=$.create(0,0,0)),this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-n,n);for(let e=0;e<8;e++)r=this._weightUVW[e],s.x+=r*t[e].x,s.y+=r*t[e].y,s.z+=r*t[e].z;return s}static evaluateTrilinearDerivativeTransform(t,e,i,n,s){return this.evaluateTrilinearWeights(this._weightUVW,1-e,e,1-i,i,1-n,n),this.evaluateTrilinearWeights(this._weightDU,-1,1,1-i,i,1-n,n),this.evaluateTrilinearWeights(this._weightDV,1-e,e,-1,1,1-n,n),this.evaluateTrilinearWeights(this._weightDW,1-e,e,1-i,i,-1,1),mt.createRowValues(this.sumWeightedX(this._weightDU,t),this.sumWeightedX(this._weightDV,t),this.sumWeightedX(this._weightDW,t),this.sumWeightedX(this._weightUVW,t),this.sumWeightedY(this._weightDU,t),this.sumWeightedY(this._weightDV,t),this.sumWeightedY(this._weightDW,t),this.sumWeightedY(this._weightUVW,t),this.sumWeightedZ(this._weightDU,t),this.sumWeightedZ(this._weightDV,t),this.sumWeightedZ(this._weightDW,t),this.sumWeightedZ(this._weightUVW,t),s)}static unpackNumbersToPoint3dArray(t){const e=[];for(let i=0;i+2<t.length;i+=3)e.push($.create(t[i],t[i+1],t[i+2]));return e}static unpackNumbersToNestedArrays(t,e){const i=[],n=t.length;let s=0,r=0;for(;s<n;){const o=[];for(r=s+e,r>n&&(r=n);s<r;s++)o.push(t[s]);i.push(o)}return i}static unpackNumbersToNestedArraysIJK(t,e,i){const n=[],s=t.length;let r,o=0,a=0;for(;o<s;){const c=[];for(r=o+e*i;o<r;){const i=[];for(a=o+e,a>s&&(a=s);o<a;o++)i.push(t[o]);c.push(i)}n.push(c)}return n}static multiplyInPlace(t,e){const i=$.create(),n=e.length;for(let s=0;s+2<n;s+=3)t.multiplyXYZ(e[s],e[s+1],e[s+2],i),e[s]=i.x,e[s+1]=i.y,e[s+2]=i.z}static isAlmostEqual(t,e,i=J.smallMetricDistance){if(t&&e){if(t instanceof Float64Array&&e instanceof Float64Array){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!J.isSameCoordinate(t[n],e[n],i))return!1}else if(Array.isArray(t)&&Array.isArray(e)){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(!t[n].isAlmostEqual(e[n],i))return!1}else{const n=t instanceof Float64Array?e:t,s=t instanceof Float64Array?t:e;if(s.length!==3*n.length)return!1;for(let t=0;t<n.length;++t)if(!J.isSameCoordinate(n[t].x,s[3*t],i)||!J.isSameCoordinate(n[t].y,s[3*t+1],i)||!J.isSameCoordinate(n[t].z,s[3*t+2],i))return!1}return!0}return void 0===t&&void 0===e}static centroid(t,e){if(t instanceof nt){e=$.create(0,0,0,e);const i=$.create();if(t.length>0){for(let n=0;n<t.length;n++)t.getPoint3dAtCheckedPointIndex(n,i),e.x+=i.x,e.y+=i.y,e.z+=i.z;e.scaleInPlace(1/t.length)}return e}const i=new he(t);return this.centroid(i)}static indexOfMostDistantPoint(t,e,i){if(0===t.length)return;let n,s=-1,r=-1;for(let o=0;o<t.length;o++)n=e.distance(t[o]),n>s&&(e.vectorTo(t[o],i),s=n,r=o);return r}static indexOfPointWithMaxCrossProductMagnitude(t,e,i,n){if(0===t.length)return;let s,r,o=-1,a=-1;for(let c=0;c<t.length;c++)r=e.vectorTo(t[c],r),s=r.crossProductMagnitude(i),s>o&&(n.setFrom(r),o=s,a=c);return a}static closestPointIndex(t,e){let i,n=-1,s=Number.MAX_VALUE;const r=e.x,o=e.y,a=e.z;for(let e=0;e<t.length;e++)i=J.distanceXYZXYZ(r,o,a,t[e].x,t[e].y,t[e].z),i<s&&(n=e,s=i);return n}static isCloseToPlane(t,e,i=J.smallMetricDistance){if(Array.isArray(t)){let n;for(n of t)if(Math.abs(e.altitude(n))>i)return!1}else if(t instanceof Float64Array){const n=t.length;for(let s=0;s+2<n;s+=3)if(Math.abs(e.altitudeXYZ(t[s],t[s+1],t[s+2]))>i)return!1}return!0}static sumEdgeLengths(t,e=!1,i){let n=0;if(Array.isArray(t)){const s=de(t.length,i,1)-1;for(let e=0;e<s;e++)n+=t[e].distance(t[e+1]);e&&s>0&&(n+=t[0].distance(t[s]))}else if(t instanceof Float64Array){const s=de(t.length,i,3);let r=0;for(;r+5<s;r+=3)n+=J.hypotenuseXYZ(t[r+3]-t[r],t[r+4]-t[r+1],t[r+5]-t[r+2]);e&&r>=3&&(n+=J.hypotenuseXYZ(t[0]-t[r],t[1]-t[r+1],t[2]-t[r+2]))}return n}static countNonDuplicates(t,e=J.smallMetricDistance){let i=t.length;for(;i>1&&t[0].isAlmostEqual(t[i-1],e);)i--;for(let n=0;n+1<i;n++)if(t[n].isAlmostEqual(t[n+1],e))return 0;return i}static clonePoint3dArray(t){const e=[];if(0===t.length)return e;if(t instanceof Float64Array){for(let i=0;i+2<t.length;i+=3)e.push($.create(t[i],t[i+1],t[i+2]));return e}for(const i of t)Array.isArray(i)?e.push($.create(i[0],i[1],i[2])):e.push($.create(i.x,i.y,i.z));return e}static clonePoint2dArray(t){return t.map((t=>H.create(t.x,t.y)))}static cloneWithMaxEdgeLength(t,e){if(0===t.length)return[];const i=[t[0]];for(let n=1;n<t.length;n++){const s=t[n-1].distance(t[n]),r=J.stepCount(e,s,1);for(let e=1;e<r;e++)i.push(t[n-1].interpolate(e/r,t[n]));i.push(t[n])}return i}static xyzToArray(t,e,i){return[t,e,i]}static cloneDeepJSONNumberArrays(t){const e=new ht(((t,e,i)=>this.xyzToArray(t,e,i)));return dt.streamXYZ(t,e),e.claimResult()}static cloneXYZPropsAsNumberArray(t){const e=[];for(const i of t)if(i instanceof $)e.push([i.x,i.y,i.z]);else if(Array.isArray(i)){const t=i.length>0?i[0]:0,n=i.length>1?i[1]:0,s=i.length>2?i[2]:0;e.push([t,n,s])}else{const t=void 0!==i.x?i.x:0,n=void 0!==i.y?i.y:0,s=void 0!==i.z?i.z:0;e.push([t,n,s])}return e}static cloneXYZPropsAsFloat64Array(t){const e=new Float64Array(3*t.length);let i=0;for(const n of t)n instanceof $?(e[i++]=n.x,e[i++]=n.y,e[i++]=n.z):Array.isArray(n)?(e[i++]=n.length>0?n[0]:0,e[i++]=n.length>1?n[1]:0,e[i++]=n.length>2?n[2]:0):(e[i++]=void 0!==n.x?n.x:0,e[i++]=void 0!==n.y?n.y:0,e[i++]=void 0!==n.z?n.z:0);return e}static cloneDeepXYZPoint3dArrays(t){const e=new ht(((t,e,i)=>$.create(t,e,i)));return dt.streamXYZ(t,e),e.claimResult()}static distanceIndexedPointBToSegmentAC(t,e,i,n,s){const r=tt.createStartEnd(t[e],t[n]),o=tt.createStartEnd(t[e],t[i]),a=r.dotProduct(r),c=r.dotProduct(o),l=J.conditionalDivideFraction(c,a);if(void 0===l)return o.magnitude();if(!s){if(l>1)return t[i].distance(t[n]);if(l<0)return o.magnitude()}const h=o.magnitudeSquared()-l*l*a;return h<=0?0:Math.sqrt(h)}static computeConvexHullXY(t,e,i,n=!1){e.length=0,i.length=0;let s=t.length;const r=t.slice(0,s);if(r.sort(((t,e)=>J.lexicalXYLessThan(t,e))),s<3){for(const t of r)e.push(t);return void(n&&r.length>0&&e.push(r[0]))}e.push(r[0]),e.push(r[1]);let o=0;for(let t=2;t<s;t++){const i=r[t];let n=e.length-1;for(;n>=1&&e[n-1].crossProductToPointsXY(e[n],i)<=0;)r[o++]=e[n],n--,e.pop();e.push(i)}const a=e.length-1;r.length=o,r.push(e[0]),r.sort(((t,e)=>J.lexicalXYLessThan(t,e))),s=r.length,e.push(r[s-1]);for(let t=s-1;t-- >0;){const n=r[t];let s=e.length-1;for(;s>a&&e[s-1].crossProductToPointsXY(e[s],n)<=0;)i.push(e[s]),s--,e.pop();t>0&&e.push(n)}n&&e.push(e[0])}static minMaxPoints(t){if(0===t.length)return;const e={minXPoint:t[0].clone(),maxXPoint:t[0].clone(),minYPoint:t[0].clone(),maxYPoint:t[0].clone()};let i;for(let n=1;n<t.length;n++)i=t[n],i.x<e.minXPoint.x&&e.minXPoint.setFromPoint3d(i),i.x>e.maxXPoint.x&&e.maxXPoint.setFromPoint3d(i),i.y<e.minYPoint.y&&e.minYPoint.setFromPoint3d(i),i.y>e.maxYPoint.y&&e.maxYPoint.setFromPoint3d(i);return e}}class ge{static decomposeLU(t,e,i){const n=t-1,s=Math.floor(e/2);let r;for(let t=0;t<=n;t++){const o=Math.min(n,t+s);for(let n=t;n<=o;n++){r=0;for(let o=Math.max(0,n-s);o<t;o++)r+=i[t*e+o-t+s]*i[o*e+n-o+s];i[t*e+n-t+s]-=r}for(let n=t+1;n<=o;n++){r=0;for(let o=Math.max(0,n-s);o<t;o++)r+=i[n*e+o-n+s]*i[o*e+t-o+s];if(Math.abs(i[t*e+s])<1e-9)return!1;i[n*e+t-n+s]=(i[n*e+t-n+s]-r)/i[t*e+s]}}return!0}static arrayAddScaledBlock(t,e,i,n){const s=t.length;let r=s*i;for(let i=0;i<s;i++,r++)t[i]+=e[r]*n}static blockAssignBlockMinusArray(t,e,i,n,s){const r=s.length;let o=e*r,a=n*r;for(let e=0;e<r;e++,a++,o++)t[o]=i[a]-s[e]}static blockSumOfScaledBlockScaledArray(t,e,i,n,s,r,o){const a=r.length;let c=e*a,l=n*a;for(let e=0;e<a;e++,l++,c++)t[c]=i[l]*s+r[e]*o}static solveBandedSystemMultipleRHS(t,e,i,n,s){if(!this.decomposeLU(t,e,i))return;const r=t-1,o=Math.floor(e/2),a=new Float64Array(n),c=new Float64Array(n*t),l=new Float64Array(n*t);for(let t=0;t<=r;t++){a.fill(0);for(let n=Math.max(0,t-o);n<t;n++)this.arrayAddScaledBlock(a,c,n,i[t*e+n-t+o]);this.blockAssignBlockMinusArray(c,t,s,t,a)}for(let t=r;t>=0;t--){const n=J.conditionalDivideCoordinate(1,i[t*e+o]);if(void 0===n)return;a.fill(0);const s=Math.min(r,t+o);for(let n=t+1;n<=s;n++)this.arrayAddScaledBlock(a,l,n,i[t*e+n-t+o]);this.blockSumOfScaledBlockScaledArray(l,t,c,t,n,a,-n)}return l}static multiplyBandedTimesFull(t,e,i,n,s){const r=new Float64Array(s.length),o=Math.floor(e/2);let a,c,l,h;for(let d=0;d<t;d++){c=d-o,c<0&&(c=0),l=d+o+1,l>t&&(l=t),h=o+d*(e-1);for(let t=0;t<n;t++){a=0;for(let e=c;e<l;e++)a+=i[h+e]*s[e*n+t];r[d*n+t]=a}}return r}}!function(t){t[t.None=0]="None",t[t.OpenByAddingControlPoints=1]="OpenByAddingControlPoints",t[t.OpenByRemovingKnots=2]="OpenByRemovingKnots"}(b||(b={}));class pe{knots;degree;_knot0;_knot1;_wrapMode;static knotTolerance=1e-9;get leftKnot(){return this._knot0}get rightKnot(){return this._knot1}get leftKnotIndex(){return this.degree-1}get rightKnotIndex(){return this.knots.length-this.degree}get wrappable(){return void 0===this._wrapMode?b.None:this._wrapMode}set wrappable(t){this._wrapMode=t}get numSpans(){return this.rightKnotIndex-this.leftKnotIndex}constructor(t,e,i){if(this.degree=e,this._wrapMode=i,this._knot0=0,this._knot1=1,Array.isArray(t))this.knots=new Float64Array(t.length),this.setKnots(t),this.setupFixedValues();else if(t instanceof Float64Array)this.knots=t.slice(),this.setupFixedValues();else{const e=t;this.knots=new Float64Array(e)}}clone(){return new pe(this.knots,this.degree,this.wrappable)}setupFixedValues(){this.degree>0&&this.knots.length>this.degree&&(this._knot0=this.knots[this.degree-1],this._knot1=this.knots[this.knots.length-this.degree])}get knotLength01(){return this._knot1-this._knot0}testClosable(t){void 0===t&&(t=this.wrappable);const e=this.degree,i=this.leftKnotIndex,n=this.rightKnotIndex;if(t===b.OpenByAddingControlPoints){const t=this.rightKnot-this.leftKnot,s=n-i;for(let n=0;n<i+e;n++){const e=n+s;if(Math.abs(this.knots[n]+t-this.knots[e])>=pe.knotTolerance)return!1}return!0}if(t===b.OpenByRemovingKnots){const t=e-1,s=this.leftKnot,r=this.rightKnot;for(let e=0;e<t;e++){if(Math.abs(s-this.knots[i-e-1])>=pe.knotTolerance)return!1;if(Math.abs(r-this.knots[n+e+1])>=pe.knotTolerance)return!1}return!0}return!1}isAlmostEqual(t){return this.degree===t.degree&&ue.isAlmostEqual(this.knots,t.knots,pe.knotTolerance)}getKnotMultiplicity(t){let e=0;for(const i of this.knots)if(Math.abs(i-t)<pe.knotTolerance)++e;else if(t<i)break;return e}getKnotMultiplicityAtIndex(t){let e=0;if(t>=0&&t<this.knots.length){const i=this.knots[t];++e;for(let n=t-1;n>=0;--n){const t=this.knots[n];if(Math.abs(t-i)<pe.knotTolerance)++e;else if(i>t)break}for(let n=t+1;n<this.knots.length;++n){const t=this.knots[n];if(Math.abs(t-i)<pe.knotTolerance)++e;else if(i<t)break}}return e}normalize(){if(this.knotLength01<pe.knotTolerance)return!1;const t=1/this.knotLength01,e=this.leftKnot;for(let i=0;i<this.knots.length;++i)this.knots[i]=(this.knots[i]-e)*t;for(let t=this.rightKnotIndex-1;t>this.leftKnotIndex&&this.knots[t]===this.knots[this.rightKnotIndex];--t)this.knots[t]=1;for(let t=this.rightKnotIndex+1;t<this.knots.length&&this.knots[t]===this.knots[this.rightKnotIndex];++t)this.knots[t]=1;return this.knots[this.rightKnotIndex]=1,this.setupFixedValues(),!0}setKnots(t,e){const i=e?t.length-2:t.length;if(i!==this.knots.length&&(this.knots=new Float64Array(i)),e)for(let e=1;e+1<t.length;e++)this.knots[e-1]=t[e];else for(let e=0;e<t.length;e++)this.knots[e]=t[e];this.setupFixedValues()}setKnotsCapture(t){this.knots=t,this.setupFixedValues()}static createUniformClamped(t,e,i,n){const s=new pe(t+e-1,e);let r=0;for(let t=0;t<e;t++)s.knots[r++]=i;const o=1/(t-e);for(let a=1;a+e<t;a++)s.knots[r++]=i+a*o*(n-i);for(let t=0;t<e;t++)s.knots[r++]=n;return s.setupFixedValues(),s}static createUniformWrapped(t,e,i,n){const s=new pe(t+2*e-1,e),r=1/t;for(let o=1-e,a=0;o<t+e;o++,a++)s.knots[a]=J.interpolate(i,o*r,n);return s.setupFixedValues(),s}static create(t,e,i){const n=i?t.length-2:t.length,s=new pe(n,e);return s.setKnots(t,i),s}grevilleKnot(t){if(t<0)return this.leftKnot;if(t>this.rightKnotIndex)return this.rightKnot;let e=0;for(let i=t=Math.floor(t);i<t+this.degree;i++)e+=this.knots[i];return e/this.degree}createBasisArray(){return new Float64Array(this.degree+1)}baseKnotFractionToKnot(t,e){const i=this.knots[t];return i+(e=J.clamp(e,0,1))*(this.knots[t+1]-i)}spanFractionToKnot(t,e){const i=this.spanIndexToLeftKnotIndex(t);return e=J.clamp(e,0,1),this.knots[i]+e*(this.knots[i+1]-this.knots[i])}spanFractionToFraction(t,e){return(this.spanFractionToKnot(t,e)-this.leftKnot)/(this.rightKnot-this.leftKnot)}fractionToKnot(t){return t=J.clamp(t,0,1),J.interpolate(this.knots[this.degree-1],t,this.knots[this.knots.length-this.degree])}isKnotInValidSpan(t,e){const i=t>=this.degree-1&&t+this.degree<this.knots.length,n=this.knots[t]<=e&&e<=this.knots[t+1];return i&&n}evaluateBasisFunctions(t,e,i){if(i.length<this.degree+1)return!1;if(i[0]=1,this.degree<1)return!0;const n=this.knots[t],s=this.knots[t+1];if(i[1]=(e-n)/(s-n),i[0]=1-i[1],this.degree<2)return!0;for(let n=1;n<this.degree;n++){let s=t-n,r=t+1,o=0;for(let t=0;t<=n;t++){const n=this.knots[s++],a=(e-n)/(this.knots[r++]-n),c=i[t]*a,l=i[t]*(1-a);i[t]=o+l,o=c}i[n+1]=o}return!0}evaluateBasisFunctions1(t,e,i,n,s){if(i.length<this.degree+1)return!1;if(n.length<this.degree+1)return!1;if(s&&s.length<this.degree+1)return!1;if(i[0]=1,n[0]=0,this.degree<1)return!0;const r=this.knots[t];let o=1/(this.knots[t+1]-r);if(i[1]=(e-r)*o,i[0]=1-i[1],n[0]=-o,n[1]=o,s&&(s[0]=0,s[1]=0),this.degree<2)return!0;for(let r=1;r<this.degree;r++){let a=t-r,c=a+r+1,l=0,h=0,d=0;for(let t=0;t<=r;t++){const r=this.knots[a++];o=1/(this.knots[c++]-r);const u=(e-r)*o,f=1-u,g=i[t]*u,p=i[t]*f,m=n[t]*u+i[t]*o,_=n[t]*f-i[t]*o,x=2*n[t]*o;if(i[t]=l+p,n[t]=h+_,l=g,h=m,s){const e=s[t]*u+x,i=s[t]*f-x;s[t]=d+i,d=e}}i[r+1]=l,n[r+1]=h,s&&(s[r+1]=d)}return!0}knotToLeftKnotIndex(t){for(let e=this.leftKnotIndex;e<this.rightKnotIndex;++e)if(t<this.knots[e+1])return e;for(let t=this.rightKnotIndex;t>this.leftKnotIndex;--t)if(this.knots[t]-this.knots[t-1]>=pe.knotTolerance)return t-1;return this.rightKnotIndex-1}spanIndexToLeftKnotIndex(t){const e=this.degree;return t<=0?e-1:Math.min(t+e-1,this.knots.length-e-1)}spanIndexToSpanLength(t){const e=this.spanIndexToLeftKnotIndex(t);return this.knots[e+1]-this.knots[e]}isIndexOfRealSpan(t){return t>=0&&t<this.numSpans&&!J.isSmallMetricDistance(this.spanIndexToSpanLength(t))}reflectKnots(){const t=this.leftKnot,e=this.rightKnot,i=this.knots.length;for(let n=0;n<i;n++)this.knots[n]=t+(e-this.knots[n]);this.knots.reverse()}static copyKnots(t,e,i,n){const s=i&&n===b.OpenByAddingControlPoints,r=e-1,o=t.length-e,a=t[r],c=t[o]-a,l=[];i&&(s?l.push(t[o-e]-c):l.push(t[0]));for(const e of t)l.push(e);return i&&(s?l.push(t[r+e]+c):l.push(t[t.length-1])),l}copyKnots(t){const e=t&&this.testClosable()?this.wrappable:void 0;return pe.copyKnots(this.knots,this.degree,t,e)}}class me{static createThroughPoints(t,e){const i=t.length;if(e>i||e<2)return;const n=e-1,s=1+2*n,r=new Float64Array(s*i),o=new Float64Array(e),a=new rt,c=pe.createUniformClamped(i,e-1,0,1),l=$.create();for(let h=0;h<i;h++){const d=c.grevilleKnot(h),u=c.knotToLeftKnotIndex(d);c.evaluateBasisFunctions(u,d,o);let f=0;for(let t=1;t<e;t++)o[t]>o[f]&&(f=t);const g=n-f,p=h*s;for(let t=0;t<e;t++){const e=h-n+g+t;p+e>=0&&e<i&&(r[p+g+t]=o[t])}t instanceof nt?a.push(t.getPoint3dAtUncheckedPointIndex(h,l)):a.push(t[h].clone())}const h=ge.solveBandedSystemMultipleRHS(i,s,r,3,a.float64Data());return h?Ye.create(h,c.knots,e):void 0}static createThroughPointsC2Cubic(t){const e=t.clone();if(!this.C2CubicFit.validateOptions(e))return;const i=this.C2CubicFit.constructPoles(e);if(void 0===i)return;const n=this.C2CubicFit.convertFitParamsToCubicKnotVector(e.knots,e.closed);if(void 0===n)return;const s=Ye.create(i,n,e.order);return e.closed&&s?.setWrappable(b.OpenByAddingControlPoints),s}}!function(t){t.C2CubicFit=class{static normalizeKnots(t){if(void 0===t||t.length<2)return t=void 0,!1;const e=pe.create(t,1,!1);if(!e.normalize())return t=void 0,!1;for(let i=0;i<t.length;++i)t[i]=e.knots[i];return!0}static constructChordLengthParameters(t){if(t.length<2)return;const e=[0];for(let i=1;i<t.length;++i)e[i]=e[i-1]+t[i].distance(t[i-1]);return this.normalizeKnots(e)?e:void 0}static constructUniformParameters(t){if(t<2)return;const e=pe.createUniformClamped(t+2,3,0,1),i=[];for(let t=e.leftKnotIndex;t<=e.rightKnotIndex;++t)i.push(e.knots[t]);return i}static removeDuplicateFitPoints(t){void 0!==t.knots&&t.knots.length!==t.fitPoints.length&&(t.knots=void 0);const e=new he(t.fitPoints).findOrderedDuplicates(void 0,!0);if(e.length>0){let i=0;for(let n=0,s=0;n<t.fitPoints.length;++n)s<e.length&&n===e[s]?++s:(t.fitPoints[i]=t.fitPoints[n],t.knots&&(t.knots[i]=t.knots[n]),++i);t.fitPoints.splice(i),t.knots&&t.knots.splice(i)}return!0}static constructFitParametersFromPoints(t,e,i){let n;return!e&&i||(n=this.constructChordLengthParameters(t)),void 0===n&&(n=this.constructUniformParameters(t.length)),n}static constructFitParameters(t){return void 0===t.knots&&(t.knots=this.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed)),t.knots?.length===t.fitPoints.length}static computeAlphaBetaGamma(t,e,i,n,s,r,o,a){let c=1/(a+o+r);t[n]=r*r*c,e[n]=r*(a+o)*c,c=1/(o+r+s),e[n]+=o*(r+s)*c,i[n]=o*o*c,c=1/(o+r),t[n]*=c,e[n]*=c,i[n]*=c}static setUpSystem2Points(t,e,i){return 2===t.length&&2===e.length&&2===i.length&&(t[0]=t[1]=i[0]=i[1]=0,e[0]=e[1]=1,!0)}static setUpSystem3Points(t,e,i,n,s,r){if(void 0===n.knots)return!1;if(3!==t.length||3!==e.length||3!==i.length)return!1;if(3!==n.knots.length||3!==n.fitPoints.length)return!1;let o=0,a=0,c=0,l=0,h=0,d=0;return s?(t[0]=0,a=n.knots[1]-n.knots[0],o=n.knots[2]-n.knots[1],h=a+o,d=1/h,e[0]=(a+h)*d,i[0]=-a*d):(t[0]=i[0]=0,e[0]=1),c=n.knots[1]-n.knots[0],a=n.knots[2]-n.knots[1],d=1/(c+a),d*=d,t[1]=a*a*d,e[1]=a*c*2*d,i[1]=c*c*d,r?(c=n.knots[2]-n.knots[1],l=n.knots[1]-n.knots[0],h=l+c,d=1/h,t[2]=-c*d,e[2]=(c+h)*d,i[2]=0):(t[2]=i[2]=0,e[2]=1),!0}static setUpSystem4PointsOrMore(t,e,i,n,s,r){if(void 0===n.knots)return!1;if(t.length!==e.length||t.length!==i.length||t.length!==n.knots.length)return!1;if(n.knots.length!==n.fitPoints.length)return!1;const o=n.fitPoints.length-1,a=o-1;let c=0,l=0,h=0,d=0,u=0,f=0;n.closed?(l=n.knots[1]-n.knots[0],d=n.knots[a]-n.knots[a-1],h=n.knots[a+1]-n.knots[a],c=n.knots[2]-n.knots[1],this.computeAlphaBetaGamma(t,e,i,0,c,l,h,d),d=h,h=l,l=n.knots[2]-n.knots[1],c=n.knots[3]-n.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,l,h,d),c=h,l=n.knots[a+1]-n.knots[a],d=n.knots[a-1]-n.knots[a-2],h=n.knots[a]-n.knots[a-1],this.computeAlphaBetaGamma(t,e,i,a,c,l,h,d)):(s?(t[0]=0,l=n.knots[1]-n.knots[0],c=n.knots[2]-n.knots[1],u=l+c,f=1/u,e[0]=(l+u)*f,i[0]=-l*f):(t[0]=i[0]=0,e[0]=1),l=n.knots[2]-n.knots[1],h=n.knots[1]-n.knots[0],d=0,c=n.knots[3]-n.knots[2],this.computeAlphaBetaGamma(t,e,i,1,c,l,h,d),l=n.knots[a+1]-n.knots[a],h=n.knots[a]-n.knots[a-1],d=n.knots[a-1]-n.knots[a-2],c=0,this.computeAlphaBetaGamma(t,e,i,a,c,l,h,d),r?(h=n.knots[o]-n.knots[o-1],d=n.knots[o-1]-n.knots[o-2],u=d+h,f=1/u,t[o]=-h*f,e[o]=(h+u)*f,i[o]=0):(t[o]=i[o]=0,e[o]=1));for(let s=2;s<a;++s)l=n.knots[s+1]-n.knots[s],d=n.knots[s-1]-n.knots[s-2],h=n.knots[s]-n.knots[s-1],c=n.knots[s+2]-n.knots[s+1],this.computeAlphaBetaGamma(t,e,i,s,c,l,h,d);return!0}static setUpSystem(t,e,i,n){let s=!1,r=!1;n.isNaturalTangents&&!n.closed&&(s=void 0===n.startTangent,r=void 0===n.endTangent);let o=!1;return 2===n.fitPoints.length?o=this.setUpSystem2Points(t,e,i):3===n.fitPoints.length?o=this.setUpSystem3Points(t,e,i,n,s,r):4<=n.fitPoints.length&&(o=this.setUpSystem4PointsOrMore(t,e,i,n,s,r)),o}static setBesselEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;if(void 0===e.knots)return!1;const n=1/3,s=e.fitPoints.length-1;if(1===s)return i?t[0].interpolate(n,t[3],t[1]):t[3].interpolate(n,t[0],t[2]),!0;if(2===s){const s=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),r=1-s,o=t[2].plus2Scaled(t[0],-s*s,t[4],-r*r);return i?$.createAdd2Scaled(o,1/(2*s),t[0],s).interpolate(n,t[0],t[1]):$.createAdd2Scaled(o,1/(2*r),t[4],r).interpolate(n,t[4],t[3]),!0}if(i){const i=(e.knots[2]-e.knots[1])/(e.knots[2]-e.knots[0]),s=1-i,r=t[2].plus2Scaled(t[0],-i*i,t[3],-s*s);$.createAdd2Scaled(r,1/(2*i),t[0],i).interpolate(n,t[0],t[1])}else{const i=(e.knots[s]-e.knots[s-1])/(e.knots[s]-e.knots[s-2]),r=1-i,o=t[s].plus2Scaled(t[s-1],-i*i,t[s+2],-r*r);$.createAdd2Scaled(o,1/(2*r),t[s+2],r).interpolate(n,t[s+2],t[s+1])}return!0}static setNaturalEndCondition(t,e,i){return t.length===e.fitPoints.length+2&&(1==e.fitPoints.length-1?this.setBesselEndCondition(t,e,i):(i?t[1]=t[0]:t[t.length-2]=t[t.length-1],!0))}static setChordLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const n=i?e.startTangent:e.endTangent;if(void 0===n)return!1;let s=0,r=0,o=0;const a=e.fitPoints.length-1;1===a?i?(s=0,r=1,o=3):(s=3,r=2,o=0):i?(s=0,r=1,o=2):(s=a+2,r=a+1,o=a);const c=t[o].distance(t[s]);return t[s].plusScaled(n,c/3,t[r]),!0}static setBesselLengthScaledEndCondition(t,e,i){if(t.length!==e.fitPoints.length+2)return!1;const n=i?e.startTangent:e.endTangent;if(void 0===n)return!1;if(!this.setBesselEndCondition(t,e,i))return!1;const s=e.fitPoints.length-1,r=i?0:s+2,o=i?1:s+1;return t[r].plusScaled(n,t[r].distance(t[o]),t[o]),!0}static setPhysicallyClosedEndCondition(t,e){const i=e.fitPoints.length-1;if(!e.isColinearTangents||i<=2||void 0!==e.startTangent&&void 0!==e.endTangent||e.isNaturalTangents||!t[0].isAlmostEqual(t[i+2]))return!0;if(void 0!==e.startTangent){const e=tt.createStartEnd(t[1],t[0]).normalize();if(void 0!==e){const n=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,n,t[i+1])}}else if(void 0!==e.endTangent){const e=tt.createStartEnd(t[i+1],t[i+2]).normalize();if(void 0!==e){const i=t[0].distance(t[1]);t[0].plusScaled(e,i,t[1])}}else{const e=tt.createStartEnd(t[i+1],t[1]).normalize();if(void 0!==e){const n=t[0].distance(t[1]);t[0].plusScaled(e,n,t[1]);const s=t[i+2].distance(t[i+1]);t[i+2].plusScaled(e,-s,t[i+1])}}return!0}static setEndConditions(t,e){if(t.length!==e.fitPoints.length)return!1;const i=$.createZero(),n=$.createZero();t.splice(1,0,i),t.splice(t.length-1,0,n);let s=!1;return s=void 0===e.startTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!0):this.setBesselEndCondition(t,e,!0):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!0):this.setBesselLengthScaledEndCondition(t,e,!0),s=void 0===e.endTangent?e.isNaturalTangents?this.setNaturalEndCondition(t,e,!1):this.setBesselEndCondition(t,e,!1):e.isChordLenTangents?this.setChordLengthScaledEndCondition(t,e,!1):this.setBesselLengthScaledEndCondition(t,e,!1),s&&(s=this.setPhysicallyClosedEndCondition(t,e)),s}static solveNearTridiagonal(t,e,i,n){if(e.length!==i.length||e.length!==n.length||e.length!==t.length)return;const s=[],r=t.length-1,o=t.slice(0,-1);let a=0;for(let t=1;t<r;++t){if(void 0===(a=J.conditionalDivideFraction(-e[t],i[t-1])))return;i[t]+=a*n[t-1],e[t]=a*e[t-1],o[t].addScaledInPlace(o[t-1],a)}if(void 0!==(a=J.conditionalDivideFraction(1,i[r-1]+e[r-1]))){n[r-1]*=a,o[r-1].scaleInPlace(a);for(let t=r-2;t>=0;--t){if(void 0===(a=J.conditionalDivideFraction(1,i[t])))return;$.createScale(o[t].plus2Scaled(o[t+1],-n[t],o[r-1],-e[t]),a,o[t]),n[t]=-(n[t]*n[t+1]+e[t]*n[r-1])*a}if(void 0!==(a=J.conditionalDivideFraction(1,1+n[0]))){s.push($.createScale(o[0],a));for(let t=1;t<r;++t)s.push(o[t].plusScaled(s[0],-n[t]));return s}}}static validateOptions(t){if(t.order=4,t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!0),!this.removeDuplicateFitPoints(t))return!1;let e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1]);if(3===t.fitPoints.length&&e&&(t.fitPoints.pop(),void 0!==t.knots&&t.knots.pop(),e=t.fitPoints[0].isAlmostEqual(t.fitPoints[t.fitPoints.length-1])),t.fitPoints.length<=2){if(e)return!1;t.closed=!1}return t.closed&&(e||(t.fitPoints.push(t.fitPoints[0].clone()),void 0!==t.knots&&t.knots.push(t.knots[t.knots.length-1]+(t.knots[t.knots.length-1]-t.knots[0])/(t.knots.length-1))),t.fitPoints.length<=4&&(t.closed=!1)),!(t.fitPoints.length<2||(void 0!==t.startTangent&&(t.startTangent.isAlmostZero?t.startTangent=void 0:t.startTangent.normalizeInPlace()),void 0!==t.endTangent&&(t.endTangent.isAlmostZero?t.endTangent=void 0:t.endTangent.normalizeInPlace()),0))}static convertCubicKnotVectorToFitParams(t,e,i){let n=t?.slice();if(void 0!==n){const t=n.length-e;switch(t){case 0:break;case 4:case 6:for(let e=0;e<t/2;++e)n.pop(),n.shift();break;default:n=void 0}i&&!this.normalizeKnots(n)&&(n=void 0)}return n}static convertFitParamsToCubicKnotVector(t,e,i){const n=t?.slice();if(void 0!==n){const t=i?6:4;if(e){const e=n.length-2;for(let i=2;i<=t;i+=2)n.unshift(n[e]-1),n.push(1+n[i])}else for(let e=0;e<t/2;++e)n.unshift(0),n.push(1)}return n}static convertToJsonKnots(t){void 0!==t.knots?(t.knots=this.convertCubicKnotVectorToFitParams(t.knots,t.fitPoints.length,!1),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0)):(t.knots=this.constructFitParametersFromPoints(fe.clonePoint3dArray(t.fitPoints),t.isChordLenKnots,t.closed),t.knots=this.convertFitParamsToCubicKnotVector(t.knots,t.closed,!0))}static constructPoles(t){if(!this.constructFitParameters(t)||void 0===t.knots)return;const e=t.fitPoints.length,i=Array(e),n=Array(e),s=Array(e);if(!this.setUpSystem(i,n,s,t))return;let r=[];if(t.closed){if(void 0!==(r=this.solveNearTridiagonal(t.fitPoints,i,n,s))&&r.length>2){r.unshift(r.pop());for(let e=0;e<t.order-1;++e)r.push(r[e].clone())}}else{const o=t.fitPoints.slice();if(!this.setEndConditions(o,t))return;if(o.length!==e+2)return;const a=new Float64Array(3*e),c=new Float64Array(3*e);for(let t=0,r=0,l=0;t<e;++t)a[r++]=i[t],a[r++]=n[t],a[r++]=s[t],c[l++]=o[t+1].x,c[l++]=o[t+1].y,c[l++]=o[t+1].z;const l=ge.solveBandedSystemMultipleRHS(e,3,a,3,c);if(void 0===l)return;r=new Float64Array(3+l.length+3);let h=0;r[h++]=t.fitPoints[0].x,r[h++]=t.fitPoints[0].y,r[h++]=t.fitPoints[0].z;for(let t=0;t<l.length;)r[h++]=l[t++];r[h++]=t.fitPoints[t.fitPoints.length-1].x,r[h++]=t.fitPoints[t.fitPoints.length-1].y,r[h++]=t.fitPoints[t.fitPoints.length-1].z}return r}}}(me||(me={}));class _e extends le{dispatchToGeometryHandler(t){return this._proxyCurve.dispatchToGeometryHandler(t)}_proxyCurve;constructor(t){super(),this._proxyCurve=t}get proxyCurve(){return this._proxyCurve}computeStrokeCountForOptions(t){return this._proxyCurve.computeStrokeCountForOptions(t)}emitStrokableParts(t,e){this._proxyCurve.emitStrokableParts(t,e)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}clonePartialCurve(t,e){return this._proxyCurve.clonePartialCurve(t,e)}emitStrokes(t,e){this._proxyCurve.emitStrokes(t,e)}extendRange(t,e){this._proxyCurve.extendRange(t,e)}range(t,e){return this._proxyCurve.range(t,e)}fractionToPoint(t,e){return this._proxyCurve.fractionToPoint(t,e)}fractionToPointAndDerivative(t,e){return this._proxyCurve.fractionToPointAndDerivative(t,e)}fractionToPointAnd2Derivatives(t,e){return this._proxyCurve.fractionToPointAnd2Derivatives(t,e)}isInPlane(t){return this._proxyCurve.isInPlane(t)}quickLength(){return this._proxyCurve.quickLength()}constructOffsetXY(t){return this._proxyCurve.constructOffsetXY(t)}projectedParameterRange(t,e){return this._proxyCurve.projectedParameterRange(t,e)}}class xe{constructor(t,e){this._fitPoints=t||[],this._knots=e}_order;_closed;_isChordLenKnots;_isColinearTangents;_isChordLenTangents;_isNaturalTangents;_startTangent;_endTangent;_fitPoints;_knots;get order(){return J.resolveNumber(this._order,4)}set order(t){this._order=t}get closed(){return J.resolveValue(this._closed,!1)}set closed(t){this._closed=t}get isChordLenKnots(){return J.resolveNumber(this._isChordLenKnots,0)}set isChordLenKnots(t){this._isChordLenKnots=t}get isColinearTangents(){return J.resolveNumber(this._isColinearTangents,0)}set isColinearTangents(t){this._isColinearTangents=t}get isChordLenTangents(){return J.resolveNumber(this._isChordLenTangents,0)}set isChordLenTangents(t){this._isChordLenTangents=t}get isNaturalTangents(){return J.resolveNumber(this._isNaturalTangents,0)}set isNaturalTangents(t){this._isNaturalTangents=t}get startTangent(){return this._startTangent}set startTangent(t){this._startTangent=t}get endTangent(){return this._endTangent}set endTangent(t){this._endTangent=t}get fitPoints(){return this._fitPoints}set fitPoints(t){this._fitPoints=t}get knots(){return this._knots}set knots(t){this._knots=t}captureOptionalProps(t,e,i,n,s,r,o,a){this._order=J.resolveToUndefined(t,0),this._closed=J.resolveToUndefined(e,!1),this._isChordLenKnots=J.resolveToUndefined(i,0),this._isColinearTangents=J.resolveToUndefined(n,0),this._isChordLenTangents=J.resolveToUndefined(s,0),this._isNaturalTangents=J.resolveToUndefined(r,0),this._startTangent=o,this._endTangent=a}cloneAsInterpolationCurve3dProps(){const t={fitPoints:fe.cloneDeepJSONNumberArrays(this.fitPoints),knots:this._knots?.slice()};return void 0!==this._order&&(t.order=this._order),void 0!==this._closed&&(t.closed=this._closed),void 0!==this._isChordLenKnots&&(t.isChordLenKnots=this._isChordLenKnots),void 0!==this._isColinearTangents&&(t.isColinearTangents=this._isColinearTangents),void 0!==this._isChordLenTangents&&(t.isChordLenTangents=this._isChordLenTangents),void 0!==this._isNaturalTangents&&(t.isNaturalTangents=this._isNaturalTangents),void 0!==this._startTangent&&(t.startTangent=this._startTangent?.toArray()),void 0!==this._endTangent&&(t.endTangent=this._endTangent?.toArray()),t}clone(){const t=new xe(fe.clonePoint3dArray(this.fitPoints),this.knots?.slice());return t._order=this.order,t._closed=this.closed,t._isChordLenKnots=this.isChordLenKnots,t._isColinearTangents=this.isColinearTangents,t._isChordLenTangents=this.isChordLenTangents,t._isNaturalTangents=this.isNaturalTangents,t._startTangent=this._startTangent?.clone(),t._endTangent=this._endTangent?.clone(),t}static create(t){const e=new xe(fe.clonePoint3dArray(t.fitPoints),t.knots?.slice());return e._order=t.order,e._closed=t.closed,e._isChordLenKnots=t.isChordLenKnots,e._isColinearTangents=t.isColinearTangents,e._isChordLenTangents=t.isChordLenTangents,e._isNaturalTangents=t.isNaturalTangents,e._startTangent=t.startTangent?tt.fromJSON(t.startTangent):void 0,e._endTangent=t.endTangent?tt.fromJSON(t.endTangent):void 0,e}static areAlmostEqualAllow000AsUndefined(t,e){return void 0!==t&&0===t.maxAbs()&&(t=void 0),void 0!==e&&0===e.maxAbs()&&(e=void 0),void 0!==t&&void 0!==e?t.isAlmostEqual(e):void 0===t&&void 0===e}static areAlmostEqual(t,e){if(void 0===t&&void 0===e)return!0;if(void 0!==t&&void 0!==e&&J.areEqualAllowUndefined(t.order,e.order)&&J.areEqualAllowUndefined(t.closed,e.closed)&&J.areEqualAllowUndefined(t.isChordLenKnots,e.isChordLenKnots)&&J.areEqualAllowUndefined(t.isColinearTangents,e.isColinearTangents)&&J.areEqualAllowUndefined(t.isNaturalTangents,e.isNaturalTangents)&&this.areAlmostEqualAllow000AsUndefined(t.startTangent,e.startTangent)&&this.areAlmostEqualAllow000AsUndefined(t.endTangent,e.endTangent)&&J.almostEqualArrays(t.fitPoints,e.fitPoints,((t,e)=>t.isAlmostEqual(e)))){if(J.almostEqualNumberArrays(t.knots,e.knots,((t,e)=>t===e)))return!0;if(void 0===t.knots&&void 0===e.knots)return!0;let i=t.knots,n=e.knots;return void 0===t.knots?i=me.C2CubicFit.constructFitParametersFromPoints(t.fitPoints,t.isChordLenKnots,t.closed):void 0===e.knots&&(n=me.C2CubicFit.constructFitParametersFromPoints(e.fitPoints,e.isChordLenKnots,e.closed)),i=me.C2CubicFit.convertCubicKnotVectorToFitParams(i,t.fitPoints.length,!1),n=me.C2CubicFit.convertCubicKnotVectorToFitParams(n,e.fitPoints.length,!1),J.almostEqualNumberArrays(i,n,((t,e)=>J.isAlmostEqualNumber(t,e)))}return!1}reverseInPlace(){this.fitPoints.reverse(),this.knots&&this.knots.reverse();const t=this._startTangent;this._startTangent=this.endTangent,this._endTangent=t}}class ye extends _e{curvePrimitiveType="interpolationCurve";_options;constructor(t,e){super(e),this._options=t}dispatchToGeometryHandler(t){let e=t.handleInterpolationCurve3d(this);return void 0===e&&(e=this._proxyCurve.dispatchToGeometryHandler(t)),e}static create(t){let e;return e=t instanceof xe?t.clone():xe.create(t),ye.createCapture(e)}static createCapture(t){const e=Ye.createFromInterpolationCurve3dOptions(t);if(e)return new ye(t,e)}copyFitPointsFloat64Array(){return fe.cloneXYZPropsAsFloat64Array(this._options.fitPoints)}toJSON(){return this._options.cloneAsInterpolationCurve3dProps()}cloneProps(){return this._options.cloneAsInterpolationCurve3dProps()}get options(){return this._options}reverseInPlace(){this._proxyCurve.reverseInPlace(),this._options.reverseInPlace()}tryTransformInPlace(t){const e=this._proxyCurve.tryTransformInPlace(t);return e&&(t.multiplyPoint3dArrayInPlace(this._options.fitPoints),this._options.startTangent&&t.multiplyVectorInPlace(this._options.startTangent),this._options.endTangent&&t.multiplyVectorInPlace(this._options.endTangent)),e}clone(){return new ye(this._options.clone(),this._proxyCurve.clone())}isAlmostEqual(t){return t instanceof ye&&xe.areAlmostEqual(this._options,t._options)}isSameGeometryClass(t){return t instanceof ye}}class ve{_offsetDistance;_fitOptions;_p0=$.createZero();_p1=$.createZero();_v0=tt.createZero();_v1=tt.createZero();_r0=Rt.createZero();constructor(t,e){this._offsetDistance=e,this._fitOptions=new xe;const i=t.fractionToPointAndUnitTangent(0,this._r0).direction.clone(),n=t.fractionToPointAndUnitTangent(1,this._r0).direction.negate();this._fitOptions.startTangent=i,this._fitOptions.endTangent=n,(this._fitOptions.closed=t.startPoint(this._p0).isAlmostEqual(t.endPoint(this._p1))&&i.isParallelTo(n,!0))&&(this._fitOptions.isChordLenKnots=1)}pushOffsetPoint(t,e){J.isSmallMetricDistance(e.x)&&J.isSmallMetricDistance(e.y)||this._fitOptions.fitPoints.push(t.plusScaled(e.unitPerpendicularXY(this._v0),this._offsetDistance))}needPrimaryGeometryForStrokes(){return!0}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,n){for(let s=0;s<=e;++s){const r=J.interpolate(i,s/e,n),o=t.fractionToPointAndDerivative(r,this._r0);this.pushOffsetPoint(o.origin,o.direction)}}announceSegmentInterval(t,e,i,n,s,r){if(n>0){const t=tt.createStartEnd(e,i,this._v1);for(let s=0;s<=n;++s)this.pushOffsetPoint(e.interpolate(s/n,i,this._p0),t)}}announcePointTangent(t,e,i){this.pushOffsetPoint(t,i)}claimResult(){return me.createThroughPointsC2Cubic(this._fitOptions)}}class Pe{handleCurveCollection(t){}handlePath(t){return this.handleCurveCollection(t)}handleLoop(t){return this.handleCurveCollection(t)}handleParityRegion(t){return this.handleCurveCollection(t)}handleUnionRegion(t){return this.handleCurveCollection(t)}handleBagOfCurves(t){return this.handleCurveCollection(t)}handleCurveChainWithDistanceIndex(t){return this.handlePath(t.path)}}class Ie extends Pe{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleCurveCollection(t){}handleCurveChainWithDistanceIndex(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handlePath(t){}handleLoop(t){}handleParityRegion(t){}handleUnionRegion(t){}handleBagOfCurves(t){}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class Se extends Pe{handleLineSegment3d(t){}handleLineString3d(t){}handleArc3d(t){}handleBSplineCurve3d(t){}handleInterpolationCurve3d(t){}handleAkimaCurve3d(t){}handleBSplineCurve3dH(t){}handleBSplineSurface3d(t){}handleCoordinateXYZ(t){}handleBSplineSurface3dH(t){}handleIndexedPolyface(t){}handleTransitionSpiral(t){}handleChildren(t){const e=t.children;if(e)for(const t of e)t.dispatchToGeometryHandler(this)}handleCurveCollection(t){return this.handleChildren(t)}handleSphere(t){}handleCone(t){}handleBox(t){}handleTorusPipe(t){}handleLinearSweep(t){}handleRotationalSweep(t){}handleRuledSweep(t){}handlePointString3d(t){}handleBezierCurve3d(t){}handleBezierCurve3dH(t){}}class be{chordTol;angleTol;maxEdgeLength;needConvexFacets;minStrokesPerPrimitive;shouldTriangulate=!1;_needNormals;_needTwoSided;_needParams;get needParams(){return void 0!==this._needParams&&this._needParams}set needParams(t){this._needParams=t}get needNormals(){return void 0!==this._needNormals&&this._needNormals}set needNormals(t){this._needNormals=t}get needTwoSided(){return void 0===this._needTwoSided||this._needTwoSided}set needTwoSided(t){this._needTwoSided=t}needColors;defaultCircleStrokes=16;get hasAngleTol(){return void 0!==this.angleTol&&Math.abs(this.angleTol.radians)>0}get hasChordTol(){return void 0!==this.chordTol&&this.chordTol>0}get hasMaxEdgeLength(){return void 0!==this.maxEdgeLength&&this.maxEdgeLength>0}_maximizeConvexFacets;get maximizeConvexFacets(){return this._maximizeConvexFacets??!1}set maximizeConvexFacets(t){this._maximizeConvexFacets=t,t&&(this.shouldTriangulate=t)}clone(){const t=new be;return t.chordTol=this.chordTol,t.angleTol=this.angleTol?.clone(),t.maxEdgeLength=this.maxEdgeLength,t.minStrokesPerPrimitive=this.minStrokesPerPrimitive,t.shouldTriangulate=this.shouldTriangulate,t._needNormals=this._needNormals,t._needTwoSided=this._needTwoSided,t._needParams=this._needParams,t.needColors=this.needColors,t.defaultCircleStrokes=this.defaultCircleStrokes,t._maximizeConvexFacets=this._maximizeConvexFacets,t}applyMaxEdgeLength(t,e){return e=Math.abs(e),this.maxEdgeLength&&this.maxEdgeLength>0&&t*this.maxEdgeLength<e&&(t=J.stepCount(this.maxEdgeLength,e,t)),t}applyAngleTol(t,e,i){return be.applyAngleTol(this,t,e,i)}static applyAngleTol(t,e,i,n){i=Math.abs(i);let s=n||Math.PI/8;return t&&t.angleTol&&t.angleTol.radians>0&&(s=t.angleTol.radians),e*s<i&&(e=J.stepCount(s,i,e)),e}static applyMaxEdgeLength(t,e,i){return i<0&&(i=-i),e<1&&(e=1),t&&t.maxEdgeLength&&t.maxEdgeLength*e<i&&(e=J.stepCount(t.maxEdgeLength,i,e)),e}applyTolerancesToArc(t,e=2*Math.PI){let i=1;return i=this.applyAngleTol(i,e,.25*Math.PI),i=this.applyMaxEdgeLength(i,e*t),i=this.applyChordTol(i,t,e),i=this.applyMinStrokesPerPrimitive(i),i}applyChordTol(t,e,i){if(this.chordTol&&this.chordTol>0&&this.chordTol<e){const n=this.chordTol,s=2*Math.acos(1-n/e);t=J.stepCount(s,i,t)}return t}applyChordTolToLengthAndRadians(t,e,i){if(this.chordTol&&this.chordTol>0){const n=J.conditionalDivideFraction(e,i);if(void 0!==n)return this.applyChordTol(t,n,i)}return t}applyMinStrokesPerPrimitive(t){return void 0!==this.minStrokesPerPrimitive&&Number.isFinite(this.minStrokesPerPrimitive)&&this.minStrokesPerPrimitive>t&&(t=this.minStrokesPerPrimitive),t}static createForCurves(){const t=new be;return t.angleTol=G.createDegrees(15),t}static createForFacets(){const t=new be;return t.angleTol=G.createDegrees(22.5),t}}class Ae{minArcDegrees=180;maxChamferTurnDegrees=91;allowSharpestCorners=!1;leftOffsetDistance=0;preserveEllipticalArcs=!1;constructor(t,e=180,i=91,n=!1,s=!1){this.leftOffsetDistance=t,this.minArcDegrees=e,this.maxChamferTurnDegrees=i,this.preserveEllipticalArcs=n,this.allowSharpestCorners=s}clone(){return new Ae(this.leftOffsetDistance,this.minArcDegrees,this.maxChamferTurnDegrees,this.preserveEllipticalArcs,this.allowSharpestCorners)}setFrom(t){this.leftOffsetDistance=t.leftOffsetDistance,this.minArcDegrees=t.minArcDegrees,this.maxChamferTurnDegrees=t.maxChamferTurnDegrees,this.preserveEllipticalArcs=t.preserveEllipticalArcs,this.allowSharpestCorners=t.allowSharpestCorners}static create(t){return t instanceof Ae?t:new Ae(t)}needArc(t){return Math.abs(t.degrees)>=this.minArcDegrees-J.smallAngleDegrees}numChamferPoints(t){const e=Math.abs(t.degrees);let i=120;this.allowSharpestCorners&&(i=this.maxChamferTurnDegrees);const n=J.clamp(this.maxChamferTurnDegrees,10,i);return e<=n+J.smallAngleDegrees?1:Math.ceil(e/n)}}class Ce{jointOptions;strokeOptions;constructor(t,e){this.jointOptions=Ae.create(t),this.strokeOptions=void 0!==e?e:be.createForCurves()}get minArcDegrees(){return this.jointOptions.minArcDegrees}set minArcDegrees(t){this.jointOptions.minArcDegrees=t}get maxChamferTurnDegrees(){return this.jointOptions.maxChamferTurnDegrees}set maxChamferTurnDegrees(t){this.jointOptions.maxChamferTurnDegrees=t}get allowSharpestCorners(){return this.jointOptions.allowSharpestCorners}set allowSharpestCorners(t){this.jointOptions.allowSharpestCorners=t}get leftOffsetDistance(){return this.jointOptions.leftOffsetDistance}set leftOffsetDistance(t){this.jointOptions.leftOffsetDistance=t}get preserveEllipticalArcs(){return this.jointOptions.preserveEllipticalArcs}set preserveEllipticalArcs(t){this.jointOptions.preserveEllipticalArcs=t}static create(t){return t instanceof Ce?t:new Ce(t)}static getOffsetDistance(t){return"number"==typeof t?t:t.leftOffsetDistance}clone(){return new Ce(this.jointOptions.clone(),this.strokeOptions.clone())}}class Te extends le{curvePrimitiveType="lineSegment";isSameGeometryClass(t){return t instanceof Te}_point0;_point1;get point0Ref(){return this._point0}get point1Ref(){return this._point1}get isExtensibleFractionSpace(){return!0}constructor(t,e){super(),this._point0=t,this._point1=e}setRefs(t,e){this._point0=t,this._point1=e}set(t,e){this._point0=t.clone(),this._point1=e.clone()}setFrom(t){this._point0.setFrom(t._point0),this._point1.setFrom(t._point1)}startPoint(t){return t?(t.setFrom(this._point0),t):this._point0.clone()}endPoint(t){return t?(t.setFrom(this._point1),t):this._point1.clone()}fractionToPointAndDerivative(t,e){return(e=e||Rt.createZero()).direction.setStartEnd(this._point0,this._point1),this._point0.interpolate(t,this._point1,e.origin),e}fractionToPointAnd2Derivatives(t,e){return(e=e||Mt.createXYPlane()).vectorU.setStartEnd(this._point0,this._point1),e.vectorV.set(0,0,0),this._point0.interpolate(t,this._point1,e.origin),e}clone(){return Te.create(this._point0,this._point1)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(t,e,i){return i?(i.set(t,e),i):new Te(t.clone(),e.clone())}static createCapture(t,e){return new Te(t,e)}static createXYXY(t,e,i,n,s=0,r){return r?(r._point0.set(t,e,s),r._point1.set(i,n,s),r):new Te($.create(t,e,s),$.create(i,n,s))}static createXYZXYZ(t,e,i,n,s,r,o){return o?(o._point0.set(t,e,i),o._point1.set(n,s,r),o):new Te($.create(t,e,i),$.create(n,s,r))}fractionToPoint(t,e){return this._point0.interpolate(t,this._point1,e)}curveLength(){return this._point0.distance(this._point1)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._point0.distance(this._point1)}quickLength(){return this.curveLength()}closestPoint(t,e,i){let n=t.fractionOfProjectionToLine(this._point0,this._point1,0);return n=ne.correctFraction(e,n),(i=Pt.create(this,i)).fraction=n,this._point0.interpolate(n,this._point1,i.point),i.vectorInCurveLocationDetail=void 0,i.a=i.point.distance(t),i}static closestApproach(t,e,i,n,s){const r=j.create();if(void 0===s&&(s=It.createCapture(Pt.create(),Pt.create())),Ft.lineSegment3dClosestApproachUnbounded(t._point0,t._point1,i._point0,i._point1,r)){const o=ne.correctFraction(e,r.x),a=ne.correctFraction(n,r.y);if(o===r.x&&a===r.y)return Pt.createCurveEvaluatedFraction(t,o,s.detailA),Pt.createCurveEvaluatedFraction(i,a,s.detailB),s.detailA.a=s.detailB.a=s.detailA.point.distance(s.detailB.point),s;if(o!==r.x&&a!==r.y){const r=o<.5?t._point0:t._point1,c=a<.5?i._point0:i._point1;i.closestPoint(r,n,s.detailB),t.closestPoint(c,e,s.detailA),s.detailA.a<=s.detailB.a?Pt.createCurveFractionPoint(i,a,c,s.detailB):Pt.createCurveFractionPoint(t,o,r,s.detailA)}else if(a!==r.y){const n=a<.5?i._point0:i._point1;t.closestPoint(n,e,s.detailA),s.detailB.setCurve(i),s.detailB.point.setFrom(n),s.detailB.fraction=a}else{const e=o<.5?t._point0:t._point1;i.closestPoint(e,n,s.detailB),s.detailA.setCurve(t),s.detailA.point.setFrom(e),s.detailA.fraction=o}return s.detailA.a=s.detailB.a=s.detailA.point.distance(s.detailB.point),s}const o=[t.closestPoint(i._point0,e),t.closestPoint(i._point1,e),i.closestPoint(t._point0,n),i.closestPoint(t._point1,n)];let a=o[0].a,c=0;for(let t=1;t<4;t++)o[t].a<a&&(c=t,a=o[t].a);return 0===c?(o[0].clone(s.detailA),Pt.createCurveEvaluatedFraction(i,0,s.detailB),s.detailB.a=s.detailA.a):1===c?(o[1].clone(s.detailA),Pt.createCurveEvaluatedFraction(i,1,s.detailB),s.detailB.a=s.detailA.a):2===c?(o[2].clone(s.detailB),Pt.createCurveEvaluatedFraction(t,0,s.detailA),s.detailA.a=s.detailB.a):(o[3].clone(s.detailB),Pt.createCurveEvaluatedFraction(t,1,s.detailA),s.detailA.a=s.detailB.a),s}reverseInPlace(){const t=this._point0;this._point0=this._point1,this._point1=t}tryTransformInPlace(t){return this._point0=t.multiplyPoint3d(this._point0,this._point0),this._point1=t.multiplyPoint3d(this._point1,this._point1),!0}isInPlane(t){return J.isSmallMetricDistance(t.altitude(this._point0))&&J.isSmallMetricDistance(t.altitude(this._point1))}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._point0),n=t.altitude(this._point1),s=qt.solveCoffs(i,n);let r=0;if(void 0!==s){r++;const t=Pt.createCurveFractionPoint(this,s,this.fractionToPoint(s));t.intervalRole=v.isolated,e.push(t)}return r}extendRange(t,e){e?(t.extendTransformedPoint(e,this._point0),t.extendTransformedPoint(e,this._point1)):(t.extendPoint(this._point0),t.extendPoint(this._point1))}setFromJSON(t){if(!t)return this._point0.set(0,0,0),void this._point1.set(1,0,0);t.startPoint&&t.endPoint?(this._point0.setFromJSON(t.startPoint),this._point1.setFromJSON(t.endPoint)):Array.isArray(t)&&t.length>1&&(this._point0.setFromJSON(t[0]),this._point1.setFromJSON(t[1]))}getFractionToDistanceScale(){return this.curveLength()}toJSON(){return[this._point0.toJSON(),this._point1.toJSON()]}static fromJSON(t){const e=new Te($.createZero(),$.create());return e.setFromJSON(t),e}isAlmostEqual(t){if(t instanceof Te){const e=t;return this._point0.isAlmostEqual(e._point0)&&this._point1.isAlmostEqual(e._point1)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1)}emitStrokableParts(t,e){t.startCurvePrimitive(this);const i=this.computeStrokeCountForOptions(e);t.announceSegmentInterval(this,this._point0,this._point1,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e=1;return t&&(t.maxEdgeLength&&(e=t.applyMaxEdgeLength(e,this.curveLength())),e=t.applyMinStrokesPerPrimitive(e)),e}dispatchToGeometryHandler(t){return t.handleLineSegment3d(this)}announceClipIntervals(t,e){return t.announceClippedSegmentIntervals(0,1,this._point0,this._point1,e?(t,i)=>e(t,i,this):void 0)}clonePartialCurve(t,e){return Te.create(this.fractionToPoint(t),this.fractionToPoint(e))}rangeBetweenFractions(t,e,i){if(!i){const i=ft.create();return i.extendInterpolated(this._point0,t,this._point1),i.extendInterpolated(this._point0,e,this._point1),i}const n=this.fractionToPoint(t),s=this.fractionToPoint(e);return i&&(i.multiplyPoint3d(n,n),i.multiplyPoint3d(s,s)),ft.create(n,s)}constructOffsetXY(t){const e=tt.createStartEnd(this._point0,this._point1);if(e.normalizeInPlace()){e.rotate90CCWXY(e);const i=Ce.getOffsetDistance(t);return Te.create(this._point0.plusScaled(e,i),this._point1.plusScaled(e,i))}}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}}class we{static _workPoint;getXAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,we._workPoint);return void 0===we._workPoint&&(we._workPoint=e),e?e.x:0}getYAtUncheckedPointIndex(t){const e=this.getPoint2dAtCheckedPointIndex(t,we._workPoint);return void 0===we._workPoint&&(we._workPoint=e),e?e.y:0}linearCombination(t,e){const i=Math.min(this.length,t.length),n=e instanceof j?j.createZero(e):H.createZero(e);for(let e=0;e<i;++e)n.x+=t[e]*this.getXAtUncheckedPointIndex(e),n.y+=t[e]*this.getYAtUncheckedPointIndex(e);return n}}class Ee extends we{_data;_xyInUse;_xyCapacity;_growthFactor;constructor(t=8,e){super(),this._data=new Float64Array(2*t),this._xyInUse=0,this._xyCapacity=t,this._growthFactor=void 0!==e&&e>=1?e:1.5}copyData(t,e,i){let n=void 0!==i?2*i:0;if(n<0&&(n=0),n>=this._data.length)return{count:0,offset:0};let s=void 0!==e?2*e:t.length;return s>0&&(s>t.length&&(s=t.length),n+s>this._data.length&&(s=this._data.length-n),s%2!=0&&(s-=s%2)),s<=0?{count:0,offset:0}:(s===t.length?this._data.set(t,n):t instanceof Float64Array?this._data.set(t.subarray(0,s),n):this._data.set(t.slice(0,s),n),{count:s/2,offset:n/2})}get length(){return this._xyInUse}set length(t){this.resize(t,!0)}get float64Length(){return 2*this._xyInUse}float64Data(){return this._data}ensureCapacity(t,e=!0){if(t>this._xyCapacity){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(2*t),this.copyData(i,this._xyInUse),this._xyCapacity=t}}resize(t,e){t>=0&&t<this._xyInUse?this._xyInUse=t:t>this._xyInUse&&(this.ensureCapacity(t,!1),e&&this._data.fill(0,2*this._xyInUse),this._xyInUse=t)}clone(){const t=new Ee(this.length);return t.copyData(this._data,this.length),t._xyInUse=this.length,t}static create(t,e){if(e)e.clear();else{const i="number"==typeof t[0]?t.length/2:t.length;e=new Ee(i)}return e.pushFrom(t),e}static createArrayOfGrowableXYZArray(t){return rt.createArrayOfGrowableXYZArray(t)}push(t){this.pushXY(t.x,t.y)}pushAll(t){this.ensureCapacity(this._xyInUse+t.length,!1);for(const e of t)this.push(e)}pushAllXYAndZ(t){if(this.ensureCapacity(this._xyInUse+t.length,!1),t instanceof rt){const e=t.float64Data(),i=3*t.length;for(let t=0;t+2<i;t+=3)this.pushXY(e[t],e[t+1])}else for(const e of t)this.pushXY(e.x,e.y)}pushFrom(t){if(t instanceof $)this.pushXY(t.x,t.y);else if(t instanceof rt)this.pushAllXYAndZ(t);else if(t instanceof H)this.pushXY(t.x,t.y);else if(J.isNumberArray(t,3)||t instanceof Float64Array){const e=Math.trunc(t.length/2);this.ensureCapacity(this._xyInUse+e,!1),this.copyData(t,e,this._xyInUse),this._xyInUse+=e}else if(J.isNumberArray(t,2))this.pushXY(t[0],t[1]);else if(Array.isArray(t))for(const e of t)this.pushFrom(e);else if($.isXAndY(t))this.pushXY(t.x,t.y);else if(t instanceof we){const e=t.length;this.ensureCapacity(this._xyInUse+e,!1);for(let i=0;i<e;i++)this.pushXY(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i))}}pushWrap(t){if(this._xyInUse>=t){this.ensureCapacity(this._xyInUse+t,!1);for(let e=0;e<t;e++){const t=2*e;this.pushXY(this._data[t],this._data[t+1])}}}pushXY(t,e){this.ensureCapacity(this._xyInUse+1);const i=2*this._xyInUse;this._data[i]=t,this._data[i+1]=e,this._xyInUse++}pop(){this._xyInUse>0&&this._xyInUse--}isIndexValid(t){return!(t>=this._xyInUse||t<0)}clear(){this._xyInUse=0}getPoint2dAtUncheckedPointIndex(t,e){const i=2*t;return H.create(this._data[i],this._data[i+1],e)}getXAtUncheckedPointIndex(t){return this._data[2*t]}getYAtUncheckedPointIndex(t){return this._data[2*t+1]}getPoint2dArray(){const t=2*this._xyInUse,e=[],i=this._data;for(let n=0;n<t;n+=2)e.push(H.create(i[n],i[n+1]));return e}getPoint2dAtCheckedPointIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return H.create(this._data[i],this._data[i+1],e)}}getVector2dAtCheckedVectorIndex(t,e){if(this.isIndexValid(t)){const i=2*t;return j.create(this._data[i],this._data[i+1],e)}}transferFromGrowableXYArray(t,e,i){if(this.isIndexValid(t)&&e.isIndexValid(i)){const n=2*t,s=2*i;return this._data[n]=e._data[s],this._data[n+1]=e._data[s+1],!0}return!1}pushFromGrowableXYArray(t,e){if(void 0===e){const e=t.length;return this.ensureCapacity(this.length+e,!1),this.copyData(t._data,e,this.length),this._xyInUse+=e,e}if(t.isIndexValid(e)){const i=2*e;return this.pushXY(t._data[i],t._data[i+1]),1}return 0}pushInterpolatedFromGrowableXYArray(t,e,i,n){if(t.isIndexValid(e)&&t.isIndexValid(n)){const s=1-i,r=t._data;e*=2,n*=2,this.pushXY(s*r[e]+i*r[n],s*r[e+1]+i*r[n+1])}}static createFromGrowableXYZArray(t,e,i){const n=t.length;if(i?(i.ensureCapacity(n,!1),i.clear()):i=new Ee(n),e){const s=t.float64Data(),r=3*n;let o,a,c;for(let t=0;t<r;t+=3)o=s[t],a=s[t+1],c=s[t+2],i.pushXY(e.multiplyComponentXYZ(0,o,a,c),e.multiplyComponentXYZ(1,o,a,c))}else i.pushAllXYAndZ(t);return i}front(t){if(0!==this._xyInUse)return this.getPoint2dAtUncheckedPointIndex(0,t)}back(t){if(!(this._xyInUse<1))return this.getPoint2dAtUncheckedPointIndex(this._xyInUse-1,t)}setAtCheckedPointIndex(t,e){if(!this.isIndexValid(t))return!1;const i=2*t;return this._data[i]=e.x,this._data[i+1]=e.y,!0}setXYAtCheckedPointIndex(t,e,i){if(!this.isIndexValid(t))return!1;const n=2*t;return this._data[n]=e,this._data[n+1]=i,!0}getPoint3dArray(t=0){const e=2*this._xyInUse,i=[],n=this._data;for(let s=0;s<e;s+=2)i.push($.create(n[s],n[s+1],t));return i}reverseInPlace(){const t=this.length;let e,i,n;const s=this._data;for(let r=0,o=t-1;r<o;r++,o--)e=2*r,i=2*o,n=s[e],s[e]=s[i],s[i]=n,e++,i++,n=s[e],s[e]=s[i],s[i]=n}multiplyTransformInPlace(t){const e=this._data,i=this.float64Length,n=t.matrix.coffs,s=t.origin,r=s.x,o=s.y;let a=0,c=0;for(let t=0;t+1<i;t+=2)a=e[t],c=e[t+1],e[t]=n[0]*a+n[1]*c+r,e[t+1]=n[3]*a+n[4]*c+o}multiplyMatrix3dInPlace(t){const e=this._data,i=this.float64Length,n=t.coffs;let s=0,r=0;for(let t=0;t+1<i;t+=2)s=e[t],r=e[t+1],e[t]=n[0]*s+n[1]*r,e[t+1]=n[3]*s+n[4]*r}tryTransformInverseInPlace(t){const e=this._data,i=this.float64Length,n=t.matrix;n.computeCachedInverse(!0);const s=n.inverseCoffs;if(!s)return!1;const r=t.origin,o=r.x,a=r.y;let c=0,l=0;for(let t=0;t+1<i;t+=2)c=e[t]-o,l=e[t+1]-a,e[t]=s[0]*c+s[1]*l,e[t+1]=s[3]*c+s[4]*l;return!0}extendRange(t,e){const i=this.float64Length,n=this._data;if(e)for(let s=0;s+1<i;s+=2)t.extendTransformedXY(e,n[s],n[s+1]);else for(let e=0;e+1<i;e+=2)t.extendXY(n[e],n[e+1])}sumLengths(){let t=0;const e=2*(this._xyInUse-1),i=this._data;for(let n=0;n<e;n+=2)t+=J.hypotenuseXY(i[n+2]-i[n],i[n+3]-i[n+1]);return t}scaleInPlace(t){if(this._data){const e=this.float64Length;for(let i=0;i<e;i++)this._data[i]=this._data[i]*t}}interpolate(t,e,i,n){if(this.isIndexValid(t)&&this.isIndexValid(i)){const s=1-e,r=this._data;return t*=2,i*=2,H.create(s*r[t]+e*r[i],s*r[t+1]+e*r[i+1],n)}}areaXY(){let t=0;const e=2*this._xyInUse;if(e>4){const i=this._data[e-2],n=this._data[e-1];let s=this._data[0]-i,r=this._data[1]-n,o=0,a=0;for(let c=2;c<e;c+=2,s=o,r=a)o=this._data[c]-i,a=this._data[c+1]-n,t+=J.crossProductXYXY(s,r,o,a)}return.5*t}vectorIndexIndex(t,e,i){if(!this.isIndexValid(t)||!this.isIndexValid(e))return;const n=this._data;return t*=2,e*=2,j.create(n[e]-n[t],n[e+1]-n[t+1],i)}vectorXAndYIndex(t,e,i){if(this.isIndexValid(e)){const n=this._data;return e*=2,j.create(n[e]-t.x,n[e+1]-t.y,i)}}crossProductIndexIndexIndex(t,e,i){if(this.isIndexValid(t)&&this.isIndexValid(e)&&this.isIndexValid(i)){const n=2*t,s=2*e,r=2*i,o=this._data;return J.crossProductXYXY(o[s]-o[n],o[s+1]-o[n+1],o[r]-o[n],o[r+1]-o[n+1])}}crossProductXAndYIndexIndex(t,e,i){if(this.isIndexValid(e)&&this.isIndexValid(i)){const n=2*e,s=2*i,r=this._data;return J.crossProductXYXY(r[n]-t.x,r[n+1]-t.y,r[s]-t.x,r[s+1]-t.y)}}distance(t,e){if(this.isIndexValid(t)&&this.isIndexValid(e)){const i=2*t,n=2*e;return J.hypotenuseXY(this._data[n]-this._data[i],this._data[n+1]-this._data[i+1])}}distanceIndexToPoint(t,e){if(this.isIndexValid(t)){const i=2*t;return J.hypotenuseXY(e.x-this._data[i],e.y-this._data[i+1])}}static isAlmostEqual(t,e){if(t&&e){if(t.length!==e.length)return!1;for(let i=0;i<t.length;i++)if(!t.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(e.getPoint2dAtUncheckedPointIndex(i)))return!1;return!0}return!t&&!e}sortIndicesLexical(){const t=this._xyInUse,e=new Uint32Array(t);for(let i=0;i<t;i++)e[i]=i;return e.sort(((t,e)=>this.compareLexicalBlock(t,e))),e}compareLexicalBlock(t,e){let i=0,n=0;for(let s=0;s<2;s++){if(i=this._data[2*t+s],n=this._data[2*e+s],i>n)return 1;if(i<n)return-1}return t-e}component(t,e){return this._data[2*t+e]}isAlmostEqual(t,e=J.smallMetricDistance){const i=this._xyInUse;if(t._xyInUse!==i)return!1;const n=this._data,s=t._data;for(let t=0;t<2*i;t++)if(Math.abs(n[t]-s[t])>e)return!1;return!0}}function ke(t,e,i,n,s,r,o){const a=t.length;if(n>0){for(let n=i;n+1<a;n++)if(t.vectorIndexIndex(n,n+1,o),e.crossProduct(o,o),o.normalizeInPlace())return r.addScaledInPlace(o,s),r.isAlmostEqualXYZ(0,0,0,J.smallFraction)&&o.scale(-s,r),!0}else{i+1>=a&&(i=a-2);for(let n=i;n>=0;n--)if(t.vectorIndexIndex(n,n+1,o),o.crossProduct(e,o),o.normalizeInPlace())return r.addScaledInPlace(o,s),r.isAlmostEqualXYZ(0,0,0,J.smallFraction)&&o.scale(-s,r),!0}return!1}class Fe extends le{curvePrimitiveType="lineString";static _workPointA=$.create();static _workPointB=$.create();static _workPointC=$.create();static _workRay=Rt.createXAxis();isSameGeometryClass(t){return t instanceof Fe}get isExtensibleFractionSpace(){return!0}_points;_fractions;_uvParams;_derivatives;_surfaceNormals;_pointIndices;_uvIndices;_normalIndices;get points(){return this._points.getPoint3dArray()}get packedPoints(){return this._points}get fractions(){return this._fractions}get packedDerivatives(){return this._derivatives}get packedUVParams(){return this._uvParams}get packedSurfaceNormals(){return this._surfaceNormals}get normalIndices(){return this._normalIndices}get paramIndices(){return this._uvIndices}get pointIndices(){return this._pointIndices}constructor(t){super(),this._points=t||new rt}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static create(...t){const e=new Fe;return e.addPoints(t),e}static createCapture(t){return new Fe(t)}static createXY(t,e,i=!1){const n=new Fe,s=n._points;for(const i of t)s.pushXYZ(i.x,i.y,e);if(i&&t.length>1){const t=s.distanceIndexIndex(0,s.length-1);if(void 0!==t&&0!==t&&J.isSameCoordinate(0,t)){s.pop();const t=s.front();s.push(t)}}return n}addPoints(...t){this._points.pushFrom(t)}addSteppedPoints(t,e,i,n){this._points.addSteppedPoints(t,e,i,n)}addPoint(t){this._points.push(t)}addPointXYZ(t,e,i=0){this._points.pushXYZ(t,e,i)}addFraction(t){this._fractions||(this._fractions=new bt),this._fractions.push(t)}ensureEmptyFractions(){const t=this.numPoints();return this._fractions?(this._fractions.clear(),this._fractions.ensureCapacity(t),this._fractions):(this._fractions=new bt(t),this._fractions)}ensureEmptyUVParams(){const t=this.numPoints();return this._uvParams?(this._uvParams.clear(),this._uvParams.ensureCapacity(t),this._uvParams):(this._uvParams=new Ee(t),this._uvParams)}ensureEmptySurfaceNormals(){const t=this.numPoints();return this._surfaceNormals?(this._surfaceNormals.clear(),this._surfaceNormals.ensureCapacity(t),this._surfaceNormals):(this._surfaceNormals=new rt(t),this._surfaceNormals)}ensureEmptyDerivatives(){const t=this.numPoints();return this._derivatives?(this._derivatives.clear(),this._derivatives.ensureCapacity(t),this._derivatives):(this._derivatives=new rt(t),this._derivatives)}ensureEmptyNormalIndices(){const t=this.numPoints();return this._normalIndices?(this._normalIndices.clear(),this._normalIndices.ensureCapacity(t),this._normalIndices):(this._normalIndices=new bt(t),this._normalIndices)}ensureEmptyUVIndices(){const t=this.numPoints();return this._uvIndices?(this._uvIndices.clear(),this._uvIndices.ensureCapacity(t),this._uvIndices):(this._uvIndices=new bt(t),this._uvIndices)}ensureEmptyPointIndices(){const t=this.numPoints();return this._pointIndices?(this._pointIndices.clear(),this._pointIndices.ensureCapacity(t),this._pointIndices):(this._pointIndices=new bt(t),this._pointIndices)}addUVParam(t){this._uvParams||(this._uvParams=new Ee),this._uvParams.pushXY(t.x,t.y)}addUVParamAsUV(t,e){this._uvParams||(this._uvParams=new Ee),this._uvParams.pushXY(t,e)}addDerivative(t){this._derivatives||(this._derivatives=new rt),this._derivatives.push(t)}addSurfaceNormal(t){this._surfaceNormals||(this._surfaceNormals=new rt),this._surfaceNormals.push(t)}addClosurePoint(){const t=this._points.distanceIndexIndex(0,this._points.length-1);void 0===t||J.isSameCoordinate(t,0)||this._points.pushWrap(1)}popPoint(){this._points.pop()}computeUVFromXYZTransform(t){this._uvParams=Ee.createFromGrowableXYZArray(this._points,t)}static createRectangleXY(t,e,i,n=!0){const s=Fe.create(),r=t.x,o=t.x+e,a=t.y,c=t.y+i,l=t.z;return s.addPointXYZ(r,a,l),s.addPointXYZ(o,a,l),s.addPointXYZ(o,c,l),s.addPointXYZ(r,c,l),n&&s.addClosurePoint(),s}static createRegularPolygonXY(t,e,i,n=!0){e<3&&(e=3);const s=Fe.create(),r=n?0:-1,o=Math.PI/e;let a,c,l;n||(i/=Math.cos(o));for(let n=0;n<e;n++)l=(r+2*n)*o,a=G.cleanupTrigValue(Math.cos(l)),c=G.cleanupTrigValue(Math.sin(l)),s.addPointXYZ(t.x+i*a,t.y+i*c,t.z);return s.addClosurePoint(),s}setFrom(t){this._points=t._points.clone(this._points),t._derivatives?this._derivatives=t._derivatives.clone(this._derivatives):this._derivatives=void 0,t._fractions?this._fractions=t._fractions.clone(!1):this._fractions=void 0,t._surfaceNormals?this._surfaceNormals=t._surfaceNormals.clone(this._surfaceNormals):this._surfaceNormals=void 0,t._uvParams?this._uvParams=t._uvParams.clone():this._uvParams=void 0}static createPoints(t){const e=new Fe;let i;for(i of t)e._points.push(i);return e}static createIndexedPoints(t,e,i=!1){const n=new Fe;for(const i of e)n._points.push(t[i]);return i&&e.length>1&&n._points.push(t[e[0]]),n}static createFloat64Array(t){const e=new Fe;for(let i=0;i+3<=t.length;i+=3)e._points.push($.create(t[i],t[i+1],t[i+2]));return e}clone(){const t=new Fe;return t.setFrom(this),t}setFromJSON(t){if(this._points.clear(),Array.isArray(t)){let e;for(e of t)this._points.push($.fromJSON(e))}}toJSON(){const t=[];let e=0;for(;this._points.isIndexValid(e);)t.push(this._points.getPoint3dAtUncheckedPointIndex(e).toJSON()),e++;return t}static fromJSON(t){const e=new Fe;return e.setFromJSON(t),e}fractionToPoint(t,e){const i=this._points.length;if(0===i)return $.createZero();if(1===i)return $.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0),e);const n=1/(i-1);if(t<=n)return this._points.interpolate(0,t/n,1,e);if(t+n>=1)return this._points.interpolate(i-1,(1-t)/n,i-2,e);const s=Math.floor(t/n);return this._points.interpolate(s,(t-s*n)/n,s+1,e)}fractionToPointAndDerivative(t,e){e=e||Rt.createZero();const i=this._points.length;if(i<=1)return e.direction.setZero(),1===i?e.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0)):e.origin.setZero(),e;const n=1/(i-1);if(t<=n)return e=e||Rt.createZero(),this._points.interpolate(0,t/n,1,e.origin),this._points.vectorIndexIndex(0,1,e.direction),e.direction.scaleInPlace(1/n),e;if(t+n>=1)return e=e||Rt.createZero(),this._points.interpolate(i-2,1-(1-t)/n,i-1,e.origin),this._points.vectorIndexIndex(i-2,i-1,e.direction),e.direction.scaleInPlace(1/n),e;e=e||Rt.createZero();const s=Math.floor(t/n),r=(t-s*n)/n;return this._points.interpolate(s,r,s+1,e.origin),this._points.vectorIndexIndex(s,s+1,e.direction),e.direction.scaleInPlace(1/n),e}fractionToPointAnd2Derivatives(t,e){const i=this.fractionToPointAndDerivative(t);return Mt.createCapture(i.origin,i.direction,tt.createZero(),e)}static mapLocalToGlobalFraction(t,e,i){return i<1?0:(t+e)/i}segmentIndexAndLocalFractionToGlobalFraction(t,e){return Fe.mapLocalToGlobalFraction(t,e,this._points.length-1)}static mapGlobalToLocalFraction(t,e){if(e<1)return{index:0,fraction:0};const i=t*e;let n;return n=t<=0?0:t>=1?e-1:Math.floor(i),{index:n,fraction:i-n}}globalFractionToSegmentIndexAndLocalFraction(t){return Fe.mapGlobalToLocalFraction(t,this._points.length-1)}fractionToFrenetFrame(t,e){const i=this._points.length;if(i<=1)return 1===i?mt.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0),e):mt.createIdentity(e);if(2===i)return mt.createRefs(this._points.interpolate(0,t,1),xt.createRigidHeadsUp(this._points.vectorIndexIndex(0,1),f.XYZ));const n=i-1,s=1/n;let r=0,o=0;t<=s?(o=t/s,r=0):t+s>=1?(r=i-2,o=1-(1-t)/s):(r=Math.floor(t/s),o=t*n-r);const a=this._points.interpolate(r,o,r+1),c=this._points.vectorIndexIndex(r,r+1),l=tt.create(),h=tt.create();0===r?ke(this._points,c,r+1,1,1,l,h):r+2>=i?ke(this._points,c,r-1,-1,1,l,h):(ke(this._points,c,r-1,-1,1-o,l,h),ke(this._points,c,r+1,1,o,l,h));const d=xt.createRigidFromColumns(l,c,f.ZXY);return d?mt.createOriginAndMatrix(a,d,e):mt.createTranslation(a,e)}startPoint(){return 0===this._points.length?$.createZero():this._points.getPoint3dAtUncheckedPointIndex(0)}pointAt(t,e){if(this._points.isIndexValid(t))return this._points.getPoint3dAtUncheckedPointIndex(t,e)}vectorBetween(t,e,i){return this._points.vectorIndexIndex(t,e,i)}derivativeAt(t,e){if(this._derivatives&&this._derivatives.isIndexValid(t))return this._derivatives.getVector3dAtCheckedVectorIndex(t,e)}surfaceNormalAt(t,e){if(this._surfaceNormals&&this._surfaceNormals.isIndexValid(t))return this._surfaceNormals.getVector3dAtCheckedVectorIndex(t,e)}numPoints(){return this._points.length}numEdges(){return this._points.length>0?this._points.length-1:0}endPoint(){return 0===this._points.length?$.createZero():this._points.getPoint3dAtUncheckedPointIndex(this._points.length-1)}reverseInPlace(){if(this._points.length>=2){if(this._points.reverseInPlace(),this._fractions){this._fractions.reverseInPlace();for(let t=0;t<this._fractions.length;++t)this._fractions.reassign(t,1-this._fractions.atUncheckedIndex(t))}this._uvParams&&this._uvParams.reverseInPlace(),this._derivatives&&(this._derivatives.reverseInPlace(),this._derivatives.scaleInPlace(-1)),this._surfaceNormals&&this._surfaceNormals.reverseInPlace(),this._pointIndices&&this._pointIndices.reverseInPlace(),this._uvIndices&&this._uvIndices.reverseInPlace(),this._normalIndices&&this._normalIndices.reverseInPlace()}}tryTransformInPlace(t){return this._points.multiplyTransformInPlace(t),this._derivatives&&this._derivatives.multiplyMatrix3dInPlace(t.matrix),this._surfaceNormals&&this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),!0}curveLength(){return this._points.sumLengths()}curveLengthBetweenFractions(t,e){const i=this._points.length-1;if(e===t||i<1)return 0;if(e<t)return this.curveLengthBetweenFractions(e,t);const n=t*i,s=e*i,r=Math.max(1,Math.ceil(n)),o=Math.min(Math.floor(s),i-1),a=r-n,c=s-o;if(r>o)return Math.abs(s-n)*this._points.distanceIndexIndex(r-1,r);{let t=a*this._points.distanceIndexIndex(r-1,r)+c*this._points.distanceIndexIndex(o,o+1);for(let e=r;e<o;e++)t+=this._points.distanceIndexIndex(e,e+1);return t}}rangeBetweenFractions(t,e,i){const n=ft.create();if(this.points.length<1)return n;if(e<t)return this.rangeBetweenFractions(e,t,i);const s=this._points.length-1,r=t*s,o=Math.max(0,Math.floor(r)),a=r-o,c=$.create();if(this._points.interpolate(o,a,o+1,c),n.extendPoint(c,i),e===t)return n;const l=e*s,h=Math.min(Math.floor(l),s-1),d=l-h;this._points.interpolate(h,d,h+1,c),n.extendPoint(c,i);for(let t=o+1;t<=h;t++)this._points.getPoint3dAtUncheckedPointIndex(t,c),n.extendPoint(c,i);return n}moveSignedDistanceFromFraction(t,e,i,n){const s=this._points.length-1,r=t*s;let o=J.restrictToInterval(Math.floor(r),0,s-1);const a=r-o,c=this._points.interpolate(o,a,o+1,Fe._workPointA),l=Fe._workPointB,h=new Re(c,t,e);if(e>0){for(;o<=s;)if(o++,this._points.getPoint3dAtCheckedPointIndex(o,l),h.announcePoint(l,o/s))return Pt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,P.success,n);return i&&h.announceExtrapolation(this._points,s-1,s,(s-1)/s,1),Pt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,h.distanceStatus(),n)}for(a<=0&&o--;o>=0;o--)if(this._points.getPoint3dAtCheckedPointIndex(o,l),h.announcePoint(l,o/s))return Pt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,e,P.success,n);return i&&h.announceExtrapolation(this._points,1,0,1/s,0),Pt.createCurveFractionPointDistanceCurveSearchStatus(this,h.fraction0,h.point0,-h.distance0,h.distanceStatus(),n)}quickLength(){return this.curveLength()}quickUnitNormal(t){let e=Math.floor(this._points.length/3);if(e<1&&(e=1),(t=this._points.crossProductIndexIndexIndex(0,e,e+e))&&t.normalizeInPlace())return t}closestPoint(t,e,i){i=Pt.create(this,i);const n=ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),s=ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,1),r=this._points.length;if(r>0){const e=r-1;if(i.setFP(1,this._points.getPoint3dAtUncheckedPointIndex(e),void 0),i.setDistanceTo(t),r>1){let o=0,a=0;for(let c=1;c<r;c++)o=t.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(c-1),this._points.getPoint3dAtUncheckedPointIndex(c)),o<0?(!n||c>1)&&(o=0):o>1&&(!s||c<e)&&(o=1),this._points.getPoint3dAtUncheckedPointIndex(c-1).interpolate(o,this._points.getPoint3dAtUncheckedPointIndex(c),i.pointQ),a=i.pointQ.distance(t),a<i.a&&i.setFP(this.segmentIndexAndLocalFractionToGlobalFraction(c-1,o),i.pointQ,void 0,a)}}return i}isInPlane(t){return this._points.isCloseToPlane(t,J.smallMetricDistance)}static pushVertexHit(t,e,i,n,s){const r=Pt.createCurveFractionPoint(i,n,s);t.push(r),0===e?r.setIntervalRole(v.isolatedAtVertex):1===e?(t[t.length-2].setIntervalRole(v.intervalStart),r.setIntervalRole(v.intervalEnd)):(t[t.length-2].setIntervalRole(v.intervalInterior),r.setIntervalRole(v.intervalEnd))}appendPlaneIntersectionPoints(t,e){if(this._points.length<1)return 0;const i=e.length,n=this._points.length,s=1===n?1:n-1,r=Fe._workPointA,o=Fe._workPointB,a=Fe._workPointC;this._points.getPoint3dAtUncheckedPointIndex(0,r);let c=0,l=0,h=0,d=0;for(let i=0;i<this._points.length;i++,r.setFrom(o),h=c)if(this._points.getPoint3dAtUncheckedPointIndex(i,o),c=J.correctSmallMetricDistance(t.altitude(o)),0===c)Fe.pushVertexHit(e,l++,this,i/s,o);else if(h*c<0){d=h/(h-c),r.interpolate(d,o,a);const t=Pt.createCurveFractionPoint(this,(i-1+d)/s,a);t.setIntervalRole(v.isolated),e.push(t),l=0}return e.length-i}extendRange(t,e){this._points.extendRange(t,e)}isAlmostEqual(t){return t instanceof Fe&&!!rt.isAlmostEqual(this._points,t._points)}appendStrokePoint(t,e){const i=this._points.length;let n=!0;const s=void 0!==e&&void 0!==this._fractions;i>0&&(s&&J.isSmallRelative(e-this._fractions.back())&&(n=!1),t.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(i-1))&&(n=!1)),n&&(this._points.push(t),s&&this.addFraction(e))}removeDuplicatePoints(t=J.smallMetricDistance){const e=this._points.length;if(e<2)return;let i=1;for(let n=1;n<e;n++){const e=this._points.distanceIndexIndex(n,i-1);void 0!==e&&e>t&&(this._points.moveIndexToIndex(n,i),void 0!==this._fractions&&this._fractions.setAtUncheckedIndex(i,this._fractions.atUncheckedIndex(n)),this._derivatives&&this._derivatives.moveIndexToIndex(n,i),i++)}this._points.resize(i),this._fractions&&this._fractions.resize(i),this._derivatives&&this._derivatives.resize(i)}appendFractionToPoint(t,e){let i,n;const s=this._points.length;this._derivatives?(i=t.fractionToPointAndDerivative(e,Fe._workRay),n=i.origin):n=t.fractionToPoint(e,Fe._workPointA),s>0&&n.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(s-1))||(i&&this._derivatives?.push(i.direction),this._fractions&&this._fractions.push(e),this._points.push(n))}clear(){this._points.clear(),this._fractions&&this._fractions.clear(),this._derivatives&&this._derivatives.clear()}static createForStrokes(t=0,e){const i=Fe.create();return t>0&&i._points.ensureCapacity(t),e&&(e.needParams&&(i._fractions=new bt(t),i._uvParams=new Ee(t)),e.needNormals&&(i._derivatives=new rt(t),i._surfaceNormals=new rt(t))),i}appendFractionalStrokePoints(t,e,i=0,n=1,s=!0){let r=1,o=e-1;if(s&&(r=0,o=e),e>=1){const s=(n-i)/e;for(let e=r;e<=o;e++)this.appendFractionToPoint(t,i+e*s)}}appendInterpolatedStrokePoints(t,e,i,n){if(n&&this.appendStrokePoint(e,0),t>1){const n=1/t;for(let s=1;s<t;s++){const t=s*n;this.appendStrokePoint(e.interpolate(t,i),t)}}n&&this.appendStrokePoint(i,1)}emitStrokes(t,e){const i=this._points.length,n=Fe._workPointA,s=Fe._workPointB;if(i>0)if(e&&e.hasMaxEdgeLength){t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));for(let r=1;r<i;r++){this._points.getPoint3dAtUncheckedPointIndex(r-1,n),this._points.getPoint3dAtUncheckedPointIndex(r,s);const i=e.applyMaxEdgeLength(1,n.distance(s));i>1&&t.appendInterpolatedStrokePoints(i,n,s,!1),t.appendStrokePoint(s)}}else for(let e=0;e<i;e++)t.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(e))}emitStrokableParts(t,e){const i=this._points.length;if(t.startCurvePrimitive(this),i>1){const n=1/(i-1);if(e&&e.hasMaxEdgeLength)for(let s=1;s<i;s++){const i=e.applyMaxEdgeLength(1,this._points.getPoint3dAtUncheckedPointIndex(s-1).distance(this._points.getPoint3dAtUncheckedPointIndex(s)));t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(s-1),this._points.getPoint3dAtUncheckedPointIndex(s),i,(s-1)*n,s*n)}else for(let e=1;e<i;e++)t.announceSegmentInterval(this,this._points.getPoint3dAtUncheckedPointIndex(e-1),this._points.getPoint3dAtUncheckedPointIndex(e),1,(e-1)*n,e*n)}t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){const e=this._points.length;let i=e-1;if(t&&t.hasMaxEdgeLength){i=0;for(let n=1;n<e;n++)i+=t.applyMaxEdgeLength(1,this._points.distanceIndexIndex(n-1,n))}return i}computeAndAttachRecursiveStrokeCounts(t,e){const i=this._points.length,n=void 0!==t&&t.hasMaxEdgeLength,s=Xt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=1;e<i;e++){const i=this._points.distanceIndexIndex(e-1,e),r=n?t.applyMaxEdgeLength(1,i):1;s.addToCountAndLength(r,i)}le.installStrokeCountMap(this,s,e)}dispatchToGeometryHandler(t){return t.handleLineString3d(this)}announceClipIntervals(t,e){const i=this._points.length;if(i<2)return!1;let n=0,s=1;const r=(t,i)=>{e&&e(J.interpolate(n,t,s),J.interpolate(n,i,s),this)},o=Fe._workPointA,a=Fe._workPointB;this._points.getPoint3dAtUncheckedPointIndex(0,o);let c=!1;for(let e=1;e<i;e++,o.setFrom(a),n=s)this._points.getPoint3dAtUncheckedPointIndex(e,a),s=e/(i-1),t.announceClippedSegmentIntervals(0,1,o,a,r)&&(c=!0);return c}static _indexPoint=$.create();addResolvedPoint(t,e,i){const n=this._points.length;if(0!==n){if(1===n)return this._points.getPoint3dAtUncheckedPointIndex(0,Fe._indexPoint),void i.push(Fe._indexPoint);t<0&&(t=0),t>n-2&&(t=n-2,e+=1),this._points.interpolate(t,e,t+1,Fe._indexPoint),i.push(Fe._indexPoint)}}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i&&i.reverseInPlace(),i}const i=this._points.length;if(i<2)return this.clone();let n,s;i>2&&this.isPhysicallyClosed&&(t<0&&(t=0),e>1&&(e=1));const r=this.globalFractionToSegmentIndexAndLocalFraction(t),o=this.globalFractionToSegmentIndexAndLocalFraction(e);n=t<0?1:0<=t&&t<=1?J.isSmallRelative(1-r.fraction)?r.index+2:r.index+1:i,s=e<0?-1:0<=e&&e<=1?J.isSmallRelative(o.fraction)?o.index-1:o.index:i-2;const a=Fe.create();this.addResolvedPoint(r.index,r.fraction,a._points);for(let t=n;t<=s;t++)this._points.isIndexValid(t)&&(this._points.getPoint3dAtUncheckedPointIndex(t,Fe._workPointA),a._points.push(Fe._workPointA));return this.addResolvedPoint(o.index,o.fraction,a._points),a}getIndexedSegment(t,e){if(t>=0&&t+1<this._points.length)return Te.create(this._points.getPoint3dAtCheckedPointIndex(t),this._points.getPoint3dAtCheckedPointIndex(t+1),e)}get isPhysicallyClosed(){return this._points.length>0&&J.isSmallMetricDistance(this._points.distanceIndexIndex(0,this._points.length-1))}addMappedStrokesToLineString3D(t,e){const i=e.numPoints(),n=void 0!==e._fractions,s=void 0!==e._derivatives,r=this._points,o=Fe._workPointA,a=Fe._workPointB,c=Fe._workPointC,l=r.length;if(t.primitive&&t.primitive===this&&t.componentData&&t.componentData.length+1===l){r.getPoint3dAtUncheckedPointIndex(0,o);for(let i=0;i+1<l;i++,o.setFromPoint3d(a)){r.getPoint3dAtUncheckedPointIndex(i+1,a);const l=t.componentData[i],h=l.numStroke,d=o.vectorTo(a);d.scale(h);for(let t=0;t<=h;t++){const i=t/h,r=l.fractionToA(i);e.addPoint(o.interpolate(i,a,c)),n&&e._fractions.push(r),s&&e._derivatives.push(d)}}}return e.numPoints()-i}static createArrayOfLineString3d(t){const e=new ct;dt.streamXYZ(t,e);const i=e.claimArrayOfGrowableXYZArray(),n=[];if(void 0!==i)for(const t of i)n.push(Fe.createCapture(t));return n}collectCurvePrimitivesGo(t,e,i=!1){if(i){let e;for(let i=0;void 0!==(e=this.getIndexedSegment(i));i++)t.push(e)}else t.push(this)}constructOffsetXY(t){const e=Ce.create(t),i=[];for(const t of this.collectCurvePrimitives(void 0,!0,!0)){const n=t.constructOffsetXY(e);void 0!==n&&(n instanceof le?i.push(n):Array.isArray(n)&&n.forEach((t=>i.push(t))))}return i}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}static convertLocalToGlobalDetail(t,e,i,n,s){return t.childDetail=t.clone(s),t.childDetail.a=e,t.fraction=this.mapLocalToGlobalFraction(e,t.fraction,i),t.curve=n,t}}class Re{distance0;point0;fraction0;targetDistance;constructor(t,e,i){this.point0=t,this.distance0=0,this.targetDistance=Math.abs(i),this.fraction0=e}distanceStatus(){return J.isSameCoordinate(this.distance0,this.targetDistance)?P.success:P.stoppedAtBoundary}announcePoint(t,e){const i=this.point0.distance(t),n=this.distance0+i;if(n<this.targetDistance&&!J.isSameCoordinate(n,this.targetDistance))return this.point0.setFromPoint3d(t),this.distance0=n,this.fraction0=e,!1;const s=this.targetDistance-this.distance0,r=J.safeDivideFraction(s,i,0);return this.point0.interpolate(r,t,this.point0),this.fraction0=J.interpolate(this.fraction0,r,e),this.distance0=this.targetDistance,!0}announceExtrapolation(t,e,i,n,s){const r=this.targetDistance-this.distance0,o=t.distanceIndexIndex(e,i);if(!o)return!1;const a=J.conditionalDivideFraction(r,o);return void 0!==a&&(t.interpolate(i,-a,e,this.point0),this.distance0=this.targetDistance,this.fraction0=J.interpolate(s,-a,n),!0)}}class Me extends Se{plane;range;lowPoint;highPoint;constructor(t){super(),this.plane=t,this.range=gt.createNull(),this.resetRange()}resetRange(){this.range.setNull()}announcePoint(t){const e=this.plane.altitude(t);this.range.extendLow(e)&&(this.lowPoint=t.clone(this.lowPoint)),this.range.extendHigh(e)&&(this.highPoint=t.clone(this.highPoint))}announcePoints(t){for(let e=0;e<t.length;e++){const i=t.evaluateUncheckedIndexPlaneAltitude(e,this.plane);this.range.extendLow(i)&&(this.lowPoint=t.getPoint3dAtUncheckedPointIndex(e,this.lowPoint)),this.range.extendHigh(i)&&(this.highPoint=t.getPoint3dAtUncheckedPointIndex(e,this.highPoint))}}static createCapture(t){return new Me(t)}handleLineSegment3d(t){this.announcePoint(t.point0Ref),this.announcePoint(t.point1Ref)}handleLineString3d(t){this.announcePoints(t.packedPoints)}_strokeOptions;initStrokeOptions(){void 0===this._strokeOptions&&(this._strokeOptions=new be,this._strokeOptions.angleTol=G.createDegrees(1))}handleBSplineCurve3d(t){this.initStrokeOptions();const e=Fe.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}handleBSplineCurve3dH(t){this.initStrokeOptions();const e=Fe.create();t.emitStrokes(e,this._strokeOptions),this.handleLineString3d(e)}_sineCosinePolynomial;_workPoint;handleArc3d(t){this._sineCosinePolynomial=t.getPlaneAltitudeSineCosinePolynomial(this.plane,this._sineCosinePolynomial);let e=this._sineCosinePolynomial.referenceMinMaxRadians();t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),e+=Math.PI,t.sweep.isRadiansInSweep(e)&&this.announcePoint(this._workPoint=t.radiansToPoint(e,this._workPoint)),this.announcePoint(this._workPoint=t.startPoint(this._workPoint)),this.announcePoint(this._workPoint=t.endPoint(this._workPoint))}static findExtremesInDirection(t,e){const i=e instanceof Rt?e.origin:$.createZero(),n=e instanceof Rt?e.direction:e,s=yt.create(i,n);if(s){const e=new Me(s);if(t instanceof zt)t.dispatchToGeometryHandler(e);else if(t instanceof rt)e.announcePoints(t);else for(const i of t)e.announcePoint(i);return e}}static findExtremePointsInDirection(t,e,i){const n=this.findExtremesInDirection(t,e);if(n&&n.highPoint&&n.lowPoint)return Te.create(n.lowPoint,n.highPoint,i)}static findExtremeAltitudesInDirection(t,e,i){const n=this.findExtremesInDirection(t,e);if(n&&!n.range.isNull)return gt.createFrom(n.range,i)}static findExtremeFractionsAlongDirection(t,e,i){const n=this.findExtremeAltitudesInDirection(t,e,i);if(void 0!==n){const t=e instanceof tt?e.magnitude():e.direction.magnitude(),i=J.conditionalDivideCoordinate(1,t);if(void 0!==i)return n.low*=i,n.high*=i,n}}}class De{x0;x1;constructor(t,e){this.x0=t,this.x1=e}set(t,e){this.x0=t,this.x1=e}shift(t){this.x0+=t,this.x1+=t}static create(t=0,e=1,i){return i?(i.set(t,e),i):new De(t,e)}setFrom(t){this.x0=t.x0,this.x1=t.x1}clone(){return new De(this.x0,this.x1)}get isIn01(){return J.isIn01(this.x0)&&J.isIn01(this.x1)}fractionToPoint(t){return J.interpolate(this.x0,t,this.x1)}signedDelta(){return this.x1-this.x0}absoluteDelta(){return Math.abs(this.x1-this.x0)}reverseInPlace(){const t=this.x0;this.x0=this.x1,this.x1=t}reverseIfNeededForDeltaSign(t=1){t*(this.x1-this.x0)<0&&this.reverseInPlace()}isAlmostEqual(t){return J.isSameCoordinate(this.x0,t.x0)&&J.isSameCoordinate(this.x1,t.x1)}get isExact01(){return 0===this.x0&&1===this.x1}get isExact01Reversed(){return 1===this.x0&&0===this.x1}clipBy01FunctionValuesPositive(t,e){const i=e-t,n=t+this.x0*i,s=t+this.x1*i,r=s-n;if(n>0){if(s>=0)return!0;const t=-n/r;return this.x1=this.x0+t*(this.x1-this.x0),!0}if(n<0){if(s<0)return!1;const t=-n/r;return this.x0=this.x0+t*(this.x1-this.x0),!0}return s>0}clampDirectedTo01(t=!0,e=!0,i=!1){let n=this.x0,s=this.x1;if(s>n){if(n<0&&t&&(n=0),s>1&&e&&(s=1),n>s||n===s&&!i)return!1}else if(n>1&&e&&(n=1),s<0&&t&&(s=0),n<s||n===s&&!i)return!1;return this.set(n,s),!0}}class Oe{_packedData;_order;_blockSize;_basis;constructor(t,e){this._blockSize=t,this._order=Math.floor(e.length/t),this._packedData=e,this._basis=new Ut(this._order)}clonePolygon(t){const e=this._packedData.length;if(!t||t.length!==e)return this._packedData.slice();for(let i=0;i<e;i++)t[i]=this._packedData[i];return t}get order(){return this._order}get packedData(){return this._packedData}static create(t){if(!(t.length<1)){if(t[0]instanceof $){const e=new Float64Array(3*t.length);let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y,e[i++]=n.z;return new Oe(3,e)}if(t[0]instanceof Ot){const e=new Float64Array(4*t.length);let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y,e[i++]=n.z,e[i++]=n.w;return new Oe(4,e)}if(t[0]instanceof H){const e=new Float64Array(2*t.length);let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y;return new Oe(2,e)}}}evaluate(t,e){return this._basis.sumBasisFunctions(t,this._packedData,this._blockSize,e)}evaluateDerivative(t,e){return this._basis.sumBasisFunctionDerivatives(t,this._packedData,this._blockSize,e)}getPolygonPoint(t,e){if((!e||e.length<this._blockSize)&&(e=new Float64Array(this._blockSize)),t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)e[t]=this._packedData[i+t];return e}}setPolygonPoint(t,e){if(t>=0&&t<this._order){const i=this._blockSize*t;for(let t=0;t<this._blockSize;t++)this._packedData[i+t]=e[t]}}loadSpanPoles(t,e){let i=e*this._blockSize;for(let e=0;e<this._packedData.length;e++)this._packedData[e]=t[i++]}loadSpanPolesWithWeight(t,e,i,n){let s=0;const r=this._order;let o=i*e;for(let i=0;i<r;i++){for(let i=0;i<e;i++)this._packedData[s++]=t[o++];this._packedData[s++]=n}}unpackToJsonArrays(){return fe.unpackNumbersToNestedArrays(this._packedData,this._blockSize)}isAlmostEqual(t){if(t instanceof Oe){if(this._blockSize!==t._blockSize)return!1;if(this._order!==t._order)return!1;if(this._packedData.length!==t._packedData.length)return!1;for(let e=0;e<this._packedData.length;e++)if(!J.isSameCoordinate(this._packedData[e],t._packedData[e]))return!1;return!0}return!1}reverseInPlace(){const t=this._blockSize;let e,i,n;for(e=0,i=(this._order-1)*t;e<i;e+=t,i-=t)for(let s=0;s<t;s++)n=this._packedData[e+s],this._packedData[e+s]=this._packedData[i+s],this._packedData[i+s]=n}interpolatePoleInPlace(t,e,i){let n=t*this._blockSize,s=i*this._blockSize;const r=this._packedData;for(let t=0;t<this._blockSize;t++,n++,s++)r[n]+=e*(r[s]-r[n])}saturateInPlace(t,e){const i=t.degree,n=e+i-1,s=n+1;if(e<0||e>=t.numSpans)return!1;const r=t.knots,o=r[n],a=r[s];if(this.setInterval(o,a),a<=o+pe.knotTolerance)return!1;for(let t=i-1;t>0;t--){let e=n-t;if(r[e]<o){let i=s;for(let n=0;n<t;n++,e++,i++){const t=r[e],s=(o-t)/(r[i]-t);this.interpolatePoleInPlace(n,s,n+1)}}}for(let t=i-1;t>0;t--){let e=s+t;if(r[e]>a)for(let n=0;n<t;n++,e--){const t=r[e],s=(a-t)/(o-t);this.interpolatePoleInPlace(i-n,s,i-n-1)}}return!0}static saturate1dInPlace(t,e,i){const n=e.degree,s=i+n-1,r=s+1;if(i<0||i>=e.numSpans)return!1;const o=e.knots,a=o[s],c=o[r];if(c<=a+pe.knotTolerance)return!1;for(let e=n-1;e>0;e--){let i=s-e;if(o[i]<a){let n=r;for(let s=0;s<e;s++,i++,n++){const e=o[i],r=(a-e)/(o[n]-e);t[s]=t[s]+r*(t[s+1]-t[s])}}}for(let e=n-1;e>0;e--){let i,s=r+e;if(o[s]>c)for(let r=0;r<e;r++,s--){const e=o[s],l=(c-e)/(a-e);i=n-r,t[i]+=l*(t[i-1]-t[i])}}return!0}subdivideInPlaceKeepLeft(t){if(J.isAlmostEqualNumber(t,1))return!0;if(J.isAlmostEqualNumber(t,0))return!1;const e=1-t,i=this.order;for(let t=1;t<i;t++)for(let n=i-1;n>=t;n--)this.interpolatePoleInPlace(n,e,n-1);return!0}subdivideInPlaceKeepRight(t){if(J.isAlmostEqualNumber(t,0))return!0;if(J.isAlmostEqualNumber(t,1))return!1;const e=this.order;for(let i=1;i<e;i++)for(let n=0;n+i<e;n++)this.interpolatePoleInPlace(n,t,n+1);return!0}subdivideToIntervalInPlace(t,e){return!J.isAlmostEqualNumber(t,e)&&(e<t?(this.subdivideToIntervalInPlace(e,t),this.reverseInPlace(),!0):(this.subdivideInPlaceKeepLeft(e),this.subdivideInPlaceKeepRight(t/e),!0))}interval;setInterval(t,e){this.interval=De.create(t,e,this.interval)}fractionToParentFraction(t){return this.interval?this.interval.fractionToPoint(t):t}}class Be extends le{curvePrimitiveType="bezierCurve";_polygon;_workData0;_workData1;_workPoint0;_workPoint1;constructor(t,e){super(),this._polygon=new Oe(t,e),this._workPoint0=$.create(),this._workPoint1=$.create(),this._workData0=new Float64Array(t),this._workData1=new Float64Array(t)}reverseInPlace(){this._polygon.reverseInPlace()}saturateInPlace(t,e){const i=this._polygon.saturateInPlace(t,e);return i&&this.setInterval(t.spanFractionToFraction(e,0),t.spanFractionToFraction(e,1)),i}get degree(){return this._polygon.order-1}get order(){return this._polygon.order}get numPoles(){return this._polygon.order}setInterval(t,e){this._polygon.setInterval(t,e)}fractionToParentFraction(t){return this._polygon.fractionToParentFraction(t)}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e),n=1/i;for(let e=0;e<=i;e++){const i=e*n;this.fractionToPoint(i,this._workPoint0),t.appendStrokePoint(this._workPoint0)}}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.announceIntervalForUniformStepStrokes(this,i,0,1)}copyPolesAsJsonArray(){return this._polygon.unpackToJsonArrays()}isInPlane(t){let e=this._workPoint0;for(let i=0;;i++){if(e=this.getPolePoint3d(i,e),!e)return!0;if(!t.isPointInPlane(e))break}return!1}polygonLength(){if(!this.getPolePoint3d(0,this._workPoint0))return 0;let t=0,e=0;for(;this.getPolePoint3d(++t,this._workPoint1);)e+=this._workPoint0.distance(this._workPoint1),this._workPoint0.setFrom(this._workPoint1);return e}startPoint(){return this.getPolePoint3d(0)}endPoint(){return this.getPolePoint3d(this.order-1)}quickLength(){return this.polygonLength()}_workBezier;_workCoffsA;_workCoffsB;allocateAndZeroBezierWorkData(t,e,i){t>0&&(void 0!==this._workBezier&&this._workBezier.order===t?this._workBezier.zero():this._workBezier=new Ut(t)),e>0&&(void 0!==this._workCoffsA&&this._workCoffsA.length===e?this._workCoffsA.fill(0):this._workCoffsA=new Float64Array(e)),i>0&&(void 0!==this._workCoffsB&&this._workCoffsB.length===i?this._workCoffsB.fill(0):this._workCoffsB=new Float64Array(i))}computeStrokeCountForOptions(t){this.getPolePoint3d(0,this._workPoint0),this.getPolePoint3d(1,this._workPoint1);let e=1;if(this._workPoint0&&this._workPoint1){let i,n,s,r=this._workPoint1.x-this._workPoint0.x,o=this._workPoint1.y-this._workPoint0.y,a=this._workPoint1.z-this._workPoint0.z,c=0,l=J.hypotenuseXYZ(r,o,a);this._workPoint1.setFromPoint3d(this._workPoint0);let h,d=l,u=l,f=0;for(let t=2;this.getPolePoint3d(t,this._workPoint1);t++)i=this._workPoint1.x-this._workPoint0.x,n=this._workPoint1.y-this._workPoint0.y,s=this._workPoint1.z-this._workPoint0.z,h=G.radiansBetweenVectorsXYZ(r,o,a,i,n,s),c+=h,f=J.maxAbsXY(h,f),l=J.hypotenuseXYZ(i,n,s),d+=l,u=J.maxXY(u,l),r=i,o=n,a=s,this._workPoint0.setFrom(this._workPoint1);const g=u*this.degree,p=Math.sqrt(g*d);let m=f*(this.degree-1);this.degree<3&&(m*=3);const _=Math.sqrt(m*c),x=this.degree;e=be.applyAngleTol(t,be.applyMaxEdgeLength(t,x,p),_,.1),t&&(e=t.applyChordTolToLengthAndRadians(e,d,m))}return e}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}constructOffsetXY(t){const e=Ce.create(t),i=new ve(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}clonePartialCurve(t,e){const i=this.clone();return i._polygon.subdivideToIntervalInPlace(t,e),i}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}}class Ne extends Be{isSameGeometryClass(t){return t instanceof Ne}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZToFloat64Array(e[0],e[1],e[2],e),this._polygon.setPolygonPoint(i,e);return!0}_workRay0;_workRay1;getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return $.create(i[0],i[1],i[2],e)}getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Ot.create(i[0],i[1],i[2],1,e)}constructor(t){super(3,t),this._workRay0=Rt.createXAxis(),this._workRay1=Rt.createXAxis()}copyPointsAsLineString(){const t=Fe.create();for(let e=0;e<this._polygon.order;e++)t.addPoint(this.getPolePoint3d(e));return t}static create(t){if(t.length<1)return;const e=new Float64Array(3*t.length);if(t[0]instanceof $){let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y,e[i++]=n.z;return new Ne(e)}if(t[0]instanceof H){let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y,e[i++]=0;return new Ne(e)}}static createOrder(t){const e=new Float64Array(3*t);return new Ne(e)}loadSpanPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new Ne(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),$.create(this._workData0[0],this._workData0[1],this._workData0[2],e)}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),Rt.createXYZUVW(this._workData0[0],this._workData0[1],this._workData0[2],this._workData1[0],this._workData1[1],this._workData1[2],e)}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Mt.createXYPlane());const n=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(n.origin),e.vectorU.setFrom(n.direction);const s=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return tt.createAdd2Scaled(s.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof Ne&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3d(this)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(i-1,i,0);const n=this._workBezier,s=this._workCoffsA;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const r=this._polygon.packedData;for(let o=0;o<3;o++){for(let t=0,n=0;t<i;t++,n+=3)s[t]=e.multiplyComponentXYZ(o,r[n],r[n+1],r[n+2]);Vt.univariateDifference(s,n.coffs);const a=n.roots(0,!0);if(a&&a.length>0)for(const i of a)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(i-1,0,0);const e=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let n=0;n<3;n++){Vt.componentDifference(e.coffs,this._polygon.packedData,3,i,n);const s=e.roots(0,!0);if(s)for(const e of s)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class Xe extends Be{isSameGeometryClass(t){return t instanceof Xe}tryTransformInPlace(t){const e=this._workData0;for(let i=0;i<this._polygon.order;i++)this._polygon.getPolygonPoint(i,e),t.multiplyXYZWToFloat64Array(e[0],e[1],e[2],e[3],e),this._polygon.setPolygonPoint(i,e);return!0}tryMultiplyMatrix4dInPlace(t){t.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData)}_workRay0;_workRay1;getPolePoint4d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return Ot.create(i[0],i[1],i[2],i[3],e)}getPolePoint3d(t,e){const i=this._polygon.getPolygonPoint(t,this._workData0);if(i)return $.createFromPackedXYZW(i,0,e)}isUnitWeight(t){void 0===t&&(t=J.smallAngleRadians);const e=1-t,i=1+t,n=this._polygon.packedData,s=n.length;let r;for(let t=3;t<s;t+=4)if(r=n[t],r<e||r>i)return!1;return!0}constructor(t){super(4,t),this._workRay0=Rt.createXAxis(),this._workRay1=Rt.createXAxis()}static create(t){if(t.length<1)return;const e=new Float64Array(4*t.length);if(t[0]instanceof $){let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y,e[i++]=n.z,e[i++]=1;return new Xe(e)}if(t[0]instanceof Ot){let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y,e[i++]=n.z,e[i++]=n.w;return new Xe(e)}if(t[0]instanceof H){let i=0;for(const n of t)e[i++]=n.x,e[i++]=n.y,e[i++]=0,e[i++]=1;return new Xe(e)}}static createOrder(t){const e=new Float64Array(4*t);return new Xe(e)}loadSpan3dPolesWithWeight(t,e,i){this._polygon.loadSpanPolesWithWeight(t,3,e,i)}loadSpan4dPoles(t,e){this._polygon.loadSpanPoles(t,e)}clone(){return new Xe(this._polygon.clonePolygon())}fractionToPoint(t,e){return this._polygon.evaluate(t,this._workData0),(e=$.createFromPackedXYZW(this._workData0,0,e))||$.createZero()}fractionToPoint4d(t,e){return this._polygon.evaluate(t,this._workData0),(e=Ot.createFromPacked(this._workData0,0,e))||Ot.createZero()}fractionToPointAndDerivative(t,e){return this._polygon.evaluate(t,this._workData0),this._polygon.evaluateDerivative(t,this._workData1),(e=Rt.createWeightedDerivative(this._workData0,this._workData1,e))||Rt.createXAxis()}fractionToPointAnd2Derivatives(t,e){const i=1/2e-8;e||(e=Mt.createXYPlane());const n=this.fractionToPointAndDerivative(t,this._workRay0);e.origin.setFrom(n.origin),e.vectorU.setFrom(n.direction);const s=this.fractionToPointAndDerivative(t-1e-8,this._workRay0),r=this.fractionToPointAndDerivative(t+1e-8,this._workRay1);return tt.createAdd2Scaled(s.direction,-i,r.direction,i,e.vectorV),e}isAlmostEqual(t){return t instanceof Xe&&this._polygon.isAlmostEqual(t._polygon)}dispatchToGeometryHandler(t){return t.handleBezierCurve3dH(this)}poleProductsXYZW(t,e,i,n,s){const r=this.numPoles,o=this._polygon.packedData;for(let a=0,c=0;a<r;a++,c+=4)t[a]=e*o[c]+i*o[c+1]+n*o[c+2]+s*o[c+3]}updateClosestPointByTruePerpendicular(t,e,i=!1,n=!1){let s,r=0;if(this.isUnitWeight()){const e=2*this.order-2;this.allocateAndZeroBezierWorkData(e,0,0);const i=this._workBezier;Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,0,-t.x,0),Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,1,-t.y,1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(i.coffs,this._polygon.packedData,4,this.order,1,2,-t.z,2),s=i.roots(0,!0)}else{const e=this.order,i=2*this.order-2,n=e+i-1;this.allocateAndZeroBezierWorkData(n,e,i);const r=this._workBezier,o=this._workCoffsA,a=this._workCoffsB,c=this._polygon.packedData;for(let i=0;i<3;i++){for(let t=0;t<o.length;t++)o[t]=0;for(let t=0;t<a.length;t++)a[t]=0;Vt.scaledComponentSum(o,c,4,e,3,t.at(i),i,-1),Vt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,1,3,0,i),Vt.accumulateScaledShiftedComponentTimesComponentDelta(a,c,4,e,-1,i,0,3),Vt.accumulateProduct(r.coffs,o,a)}s=r.roots(0,!0)}if(s)for(const i of s){const n=this.fractionToPoint(i),s=n.distance(t);r+=e.updateIfCloserCurveFractionPointDistance(this,i,n,s)?1:0}return i&&(r+=this.updateDetailAtFraction(e,0,t)?1:0),n&&(r+=this.updateDetailAtFraction(e,1,t)?1:0),r>0}updateDetailAtFraction(t,e,i){const n=this.fractionToPoint(e),s=n.distance(i);return t.updateIfCloserCurveFractionPointDistance(this,e,n,s)}extendRange(t,e){const i=this.order;if(e){this.allocateAndZeroBezierWorkData(2*i-2,i,i);const n=this._workCoffsA,s=this._workCoffsB,r=this._workBezier;this.getPolePoint3d(0,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0);const o=this._polygon.packedData;let a;for(let c=0;c<3;c++){r.zero();for(let t=0,r=0;t<i;t++,r+=4)a=o[r+3],n[t]=e.multiplyComponentXYZW(c,o[r],o[r+1],o[r+2],a),s[t]=a;Vt.accumulateProductWithDifferences(r.coffs,n,s,1),Vt.accumulateProductWithDifferences(r.coffs,s,n,-1);const l=r.roots(0,!0);if(l&&l.length>0)for(const i of l)this.fractionToPoint(i,this._workPoint0),t.extendTransformedPoint(e,this._workPoint0)}}else{this.allocateAndZeroBezierWorkData(2*i-2,0,0);const e=this._workBezier,n=this._polygon.packedData;this.getPolePoint3d(0,this._workPoint0),t.extend(this._workPoint0),this.getPolePoint3d(i-1,this._workPoint0),t.extend(this._workPoint0);for(let s=0;s<3;s++){e.zero(),Vt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,n,4,i,1,s,0,3),Vt.accumulateScaledShiftedComponentTimesComponentDelta(e.coffs,n,4,i,-1,3,0,s);const r=e.roots(0,!0);if(r)for(const e of r)this.fractionToPoint(e,this._workPoint0),t.extend(this._workPoint0)}}}}class ze{knots;packedData;poleLength;get degree(){return this.knots.degree}get order(){return this.knots.degree+1}get numSpan(){return this.numPoles-this.knots.degree}get numPoles(){return this.packedData.length/this.poleLength}getPoint3dPole(t,e){return $.createFromPacked(this.packedData,t,e)}basisBuffer;basisBuffer1;basisBuffer2;poleBuffer;poleBuffer1;poleBuffer2;constructor(t,e,i,n){this.knots=n,this.packedData=new Float64Array(t*e),this.poleLength=e,this.basisBuffer=new Float64Array(i),this.basisBuffer1=new Float64Array(i),this.basisBuffer2=new Float64Array(i),this.poleBuffer=new Float64Array(e),this.poleBuffer1=new Float64Array(e),this.poleBuffer2=new Float64Array(e)}static create(t,e,i,n){return new ze(t,e,i,n)}spanFractionToKnot(t,e){return this.knots.spanFractionToKnot(t,e)}evaluateBasisFunctionsInSpan(t,e,i,n,s){t<0&&(t=0),t>=this.numSpan&&(t=this.numSpan-1);const r=t+this.degree-1,o=this.knots.baseKnotFractionToKnot(r,e);return n?this.knots.evaluateBasisFunctions1(r,o,i,n,s):this.knots.evaluateBasisFunctions(r,o,i)}sumPoleBufferForSpan(t){this.poleBuffer.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer)for(let i=0;i<this.poleLength;i++)this.poleBuffer[i]+=t*this.packedData[e++]}sumPoleBuffer1ForSpan(t){this.poleBuffer1.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer1)for(let i=0;i<this.poleLength;i++)this.poleBuffer1[i]+=t*this.packedData[e++]}sumPoleBuffer2ForSpan(t){this.poleBuffer2.fill(0);let e=t*this.poleLength;for(const t of this.basisBuffer2)for(let i=0;i<this.poleLength;i++)this.poleBuffer2[i]+=t*this.packedData[e++]}evaluateBuffersInSpan(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer),this.sumPoleBufferForSpan(t)}evaluateBuffersInSpan1(t,e){this.evaluateBasisFunctionsInSpan(t,e,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(t),this.sumPoleBuffer1ForSpan(t)}evaluateBuffersAtKnot(t,e=0){const i=this.knots.knotToLeftKnotIndex(t);e<1?(this.knots.evaluateBasisFunctions(i,t,this.basisBuffer),this.sumPoleBufferForSpan(i-this.degree+1)):1===e?(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1)):(this.knots.evaluateBasisFunctions1(i,t,this.basisBuffer,this.basisBuffer1,this.basisBuffer2),this.sumPoleBufferForSpan(i-this.degree+1),this.sumPoleBuffer1ForSpan(i-this.degree+1),this.sumPoleBuffer2ForSpan(i-this.degree+1))}reverseInPlace(){const t=this.poleLength,e=this.packedData;for(let i=0,n=t*(this.numPoles-1);i<n;i+=t,n-=t)for(let s=0;s<t;s++)[e[i+s],e[n+s]]=[e[n+s],e[i+s]];this.knots.reflectKnots()}testCloseablePolygon(t){return this.testClosablePolygon(t)}testClosablePolygon(t){void 0===t&&(t=this.knots.wrappable);let e=0;if(t===b.OpenByAddingControlPoints)e=this.degree;else{if(t!==b.OpenByRemovingKnots)return!1;e=1}const i=this.poleLength,n=(this.numPoles-e)*i,s=e*i;for(let t=0;t<s;t++)if(!J.isSameCoordinate(this.packedData[t],this.packedData[t+n]))return!1;return!0}addKnot(t,e){if(t<this.knots.leftKnot||t>this.knots.rightKnot)return!1;let i=this.knots.knotToLeftKnotIndex(t);if(Math.abs(t-this.knots.knots[i])<pe.knotTolerance)t=this.knots.knots[i];else if(Math.abs(t-this.knots.knots[i+1])<pe.knotTolerance){if(i+=this.knots.getKnotMultiplicityAtIndex(i+1),i>this.knots.rightKnotIndex)return!0;t=this.knots.knots[i]}const n=Math.min(e,this.degree)-this.knots.getKnotMultiplicity(t);if(n<=0)return!0;let s=this.knots.knots.length;const r=new Float64Array(s+n);for(let t=0;t<s;++t)r[t]=this.knots.knots[t];let o=this.numPoles;const a=new Float64Array(this.packedData.length+n*this.poleLength);for(let t=0;t<this.packedData.length;++t)a[t]=this.packedData[t];const c=new Float64Array(this.degree*this.poleLength);for(let e=0;e<n;++e){let e=0;const n=i-this.degree+2;for(let i=n;i<n+this.degree;++i){const n=(t-r[i-1])/(r[i+this.degree-1]-r[i-1]);for(let t=i*this.poleLength;t<(i+1)*this.poleLength;++t)c[e++]=J.interpolate(a[t-this.poleLength],n,a[t])}a.copyWithin((n+this.degree)*this.poleLength,(n+this.degree-1)*this.poleLength,o*this.poleLength);let l=n*this.poleLength;for(const t of c)a[l++]=t;r.copyWithin(i+2,i+1,s),r[i+1]=t,++i,++s,++o}return this.knots.setKnotsCapture(r),this.packedData=a,!0}}class Le extends le{curvePrimitiveType="bsplineCurve";_bcurve;_definitionData;set definitionData(t){this._definitionData=t}get definitionData(){return this._definitionData}constructor(t,e,i,n){super(),this._bcurve=ze.create(e,t,i,n)}get degree(){return this._bcurve.degree}get order(){return this._bcurve.order}get numSpan(){return this._bcurve.numSpan}get numPoles(){return this._bcurve.numPoles}get polesRef(){return this._bcurve.packedData}get knotsRef(){return this._bcurve.knots.knots}get poleDimension(){return this._bcurve.poleLength}copyKnots(t){return this._bcurve.knots.copyKnots(t)}getWrappable(){return this._bcurve.knots.wrappable}setWrappable(t){this._bcurve.knots.wrappable=t}get isClosableCurve(){const t=this._bcurve.knots.wrappable;return t===b.None?b.None:this._bcurve.knots.testClosable(t)&&this._bcurve.testClosablePolygon(t)?t:b.None}fractionToPoint(t,e){return this.knotToPoint(this._bcurve.knots.fractionToKnot(t),e)}fractionToPointAndDerivative(t,e){const i=this._bcurve.knots.fractionToKnot(t);return(e=this.knotToPointAndDerivative(i,e)).direction.scaleInPlace(this._bcurve.knots.knotLength01),e}fractionToPointAnd2Derivatives(t,e){const i=this._bcurve.knots.fractionToKnot(t);e=this.knotToPointAnd2Derivatives(i,e);const n=this._bcurve.knots.knotLength01;return e.vectorU.scaleInPlace(n),e.vectorV.scaleInPlace(n*n),e}startPoint(){return this.evaluatePointInSpan(0,0)}endPoint(){return this.evaluatePointInSpan(this.numSpan-1,1)}reverseInPlace(){this._bcurve.reverseInPlace()}collectBezierSpans(t){const e=[],i=this.numSpan;for(let n=0;n<i;n++)if(this._bcurve.knots.isIndexOfRealSpan(n)){const i=this.getSaturatedBezierSpan3dOr3dH(n,t);i&&e.push(i)}return e}poleIndexToDataIndex(t){if(t>=0&&t<this.numPoles)return t*this._bcurve.poleLength}closestPoint(t,e,i){const n=this.fractionToPoint(0);let s;i=Pt.createCurveFractionPointDistance(this,0,n,n.distance(t),i);const r=this.numSpan;for(let e=0;e<r;e++)this._bcurve.knots.isIndexOfRealSpan(e)&&(s=this.getSaturatedBezierSpan3dOr3dH(e,!0,s),s&&s.updateClosestPointByTruePerpendicular(t,i,!1,!0)&&(i.curve=this,i.fraction=s.fractionToParentFraction(i.fraction)));return i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}clonePartialCurve(t,e){const i=this.clone(),n=i._bcurve.knots.knots.length;let s=i._bcurve.knots.fractionToKnot(t),r=i._bcurve.knots.fractionToKnot(e);if(i._bcurve.addKnot(s,i.degree),i._bcurve.addKnot(r,i.degree),n===i._bcurve.knots.knots.length)return i;s>r&&([s,r]=[r,s]);const o=i._bcurve.knots.knotToLeftKnotIndex(s)-i.degree+1,a=o*i._bcurve.poleLength,c=i._bcurve.knots.knotToLeftKnotIndex(r);let l=c-i._bcurve.knots.getKnotMultiplicityAtIndex(c)+1;i._bcurve.knots.knots[c]<r&&(l=c+1);const h=(l+1)*i._bcurve.poleLength,d=l+i.degree;return i._bcurve.knots.setKnotsCapture(i._bcurve.knots.knots.slice(o,d)),i._bcurve.packedData=i._bcurve.packedData.slice(a,h),i.setWrappable(b.None),i}appendPlaneIntersectionPoints(t,e){const i=this.numPoles,n=this.order,s=new Float64Array(i),r=this.numSpan,o=Ot.create(),a=gt.createNull();for(let e=0;e<i;e++)s[e]=t.weightedAltitude(this.getPolePoint4d(e,o)),a.extendX(s[e]);let c,l=0,h=-1e3;if(a.containsX(0))for(let t=0;t<r;t++)if(this._bcurve.knots.isIndexOfRealSpan(t)&&(a.setNull(),a.extendArraySubset(s,t,n),a.containsX(0))){c=Ut.createArraySubset(s,t,n,c),Oe.saturate1dInPlace(c.coffs,this._bcurve.knots,t);const i=c.roots(0,!0);if(i)for(const n of i){l++;const i=this._bcurve.knots.spanFractionToFraction(t,n);if(!J.isAlmostEqualNumber(i,h)){const t=Pt.createCurveEvaluatedFraction(this,i);t.intervalRole=v.isolated,e.push(t),h=i}}}return l}constructOffsetXY(t){const e=Ce.create(t),i=new ve(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}}class Ye extends Le{_workBezier;initializeWorkBezier(){return void 0===this._workBezier&&(this._workBezier=Ne.createOrder(this.order)),this._workBezier}constructor(t,e,i){super(3,t,e,i)}isSameGeometryClass(t){return t instanceof Ye}tryTransformInPlace(t){return fe.multiplyInPlace(t,this._bcurve.packedData),!0}getPolePoint3d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return $.create(t[i],t[i+1],t[i+2],e)}}getPolePoint4d(t,e){const i=this.poleIndexToDataIndex(t);if(void 0!==i){const t=this._bcurve.packedData;return Ot.create(t[i],t[i+1],t[i+2],1,e)}}spanFractionToKnot(t,e){return this._bcurve.spanFractionToKnot(t,e)}copyPoints(){return fe.unpackNumbersToNestedArrays(this._bcurve.packedData,3)}copyPointsFloat64Array(){return this._bcurve.packedData.slice()}copyKnots(t){return this._bcurve.knots.copyKnots(t)}static createUniformKnots(t,e){const i=t instanceof Float64Array?t.length/3:t.length;if(e<2||i<e)return;const n=pe.createUniformClamped(i,e-1,0,1),s=new Ye(i,e,n);if(t instanceof Float64Array)for(let e=0;e<3*i;e++)s._bcurve.packedData[e]=t[e];else if(t instanceof rt)s._bcurve.packedData=t.float64Data().slice(0,3*i);else{let e=0;for(const i of t)s._bcurve.packedData[e++]=i.x,s._bcurve.packedData[e++]=i.y,s._bcurve.packedData[e++]=i.z}return s}static createPeriodicUniformKnots(t,e){if(e<2)return;let i=t instanceof Float64Array?t.length/3:t.length;if(i<2)return;const n=$.createZero(),s=$.createZero();let r=!1;do{t instanceof Float64Array?(n.set(t[0],t[1],t[2]),s.set(t[3*i-3],t[3*i-2],t[3*i-1])):t instanceof rt?(t.getPoint3dAtUncheckedPointIndex(0,n),t.getPoint3dAtUncheckedPointIndex(i-1,s)):(n.setFromPoint3d(t[0]),s.setFromPoint3d(t[i-1])),(r=n.isAlmostEqual(s))&&--i}while(r&&i>1);if(i<e)return;const o=e-1,a=i,c=pe.createUniformWrapped(a,o,0,1);c.wrappable=b.OpenByAddingControlPoints;const l=new Ye(i+o,e,c);if(t instanceof Float64Array){let e=0;for(let n=0;n<3*i;n++)l._bcurve.packedData[e++]=t[n];for(let i=0;i<3*o;i++)l._bcurve.packedData[e++]=t[i]}else if(t instanceof rt){let e=0;for(let n=0;n<3*i;n++)l._bcurve.packedData[e++]=t.float64Data()[n];for(let i=0;i<3*o;i++)l._bcurve.packedData[e++]=t.float64Data()[i]}else{let e=0;for(let n=0;n<i;n++)l._bcurve.packedData[e++]=t[n].x,l._bcurve.packedData[e++]=t[n].y,l._bcurve.packedData[e++]=t[n].z;for(let i=0;i<o;i++)l._bcurve.packedData[e++]=t[i].x,l._bcurve.packedData[e++]=t[i].y,l._bcurve.packedData[e++]=t[i].z}return l}static createFromInterpolationCurve3dOptions(t){return me.createThroughPointsC2Cubic(t)}static createFromAkimaCurve3dOptions(t){return me.createThroughPoints(t.fitPoints,4)}static create(t,e,i){if(i<2)return;let n=t.length;if(t instanceof Float64Array&&(n=Math.floor(n/3)),n<i)return;const s=e.length,r=n+i===s;if(!r&&n+i!==s+2)return;const o=pe.create(e,i-1,r),a=new Ye(n,i,o);let c=0;if(t instanceof Float64Array)for(const e of t)a._bcurve.packedData[c++]=e;else if(t[0]instanceof $)for(const e of t)a._bcurve.packedData[c++]=e.x,a._bcurve.packedData[c++]=e.y,a._bcurve.packedData[c++]=e.z;else{if(!Array.isArray(t[0])||3!==t[0].length)return;for(const e of t)for(const t of e)a._bcurve.packedData[c++]=t}return a}clone(){const t=this._bcurve.knots.clone(),e=new Ye(this.numPoles,this.order,t);return e._bcurve.packedData=this._bcurve.packedData.slice(),e}evaluatePointInSpan(t,e){return this._bcurve.evaluateBuffersInSpan(t,e),$.createFrom(this._bcurve.poleBuffer)}evaluatePointAndDerivativeInSpan(t,e){return this._bcurve.evaluateBuffersInSpan1(t,e),Rt.createCapture($.createFrom(this._bcurve.poleBuffer),tt.createFrom(this._bcurve.poleBuffer1))}knotToPoint(t,e){return this._bcurve.evaluateBuffersAtKnot(t),$.createFrom(this._bcurve.poleBuffer,e)}knotToPointAndDerivative(t,e){return this._bcurve.evaluateBuffersAtKnot(t,1),e?(e.origin.setFrom(this._bcurve.poleBuffer),e.direction.setFrom(this._bcurve.poleBuffer1),e):Rt.createCapture($.createFrom(this._bcurve.poleBuffer),tt.createFrom(this._bcurve.poleBuffer1))}knotToPointAnd2Derivatives(t,e){return this._bcurve.evaluateBuffersAtKnot(t,2),Mt.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0],this._bcurve.poleBuffer[1],this._bcurve.poleBuffer[2],this._bcurve.poleBuffer1[0],this._bcurve.poleBuffer1[1],this._bcurve.poleBuffer1[2],this._bcurve.poleBuffer2[0],this._bcurve.poleBuffer2[1],this._bcurve.poleBuffer2[2],e)}isAlmostEqual(t){return t instanceof Ye&&this._bcurve.knots.isAlmostEqual(t._bcurve.knots)&&fe.isAlmostEqual(this._bcurve.packedData,t._bcurve.packedData)}isInPlane(t){return fe.isCloseToPlane(this._bcurve.packedData,t)}quickLength(){return fe.sumEdgeLengths(this._bcurve.packedData)}emitStrokableParts(t,e){const i=this.initializeWorkBezier(),n=this.numSpan;let s;for(let r=0;r<n;r++){const n=this.getSaturatedBezierSpan3dOr3dH(r,!1,i);n&&(s=n.computeStrokeCountForOptions(e),t.announceBezierCurve?t.announceBezierCurve(n,s,this,r,this._bcurve.knots.spanFractionToFraction(r,0),this._bcurve.knots.spanFractionToFraction(r,1)):t.announceIntervalForUniformStepStrokes(this,s,this._bcurve.knots.spanFractionToFraction(r,0),this._bcurve.knots.spanFractionToFraction(r,1)))}}computeStrokeCountForOptions(t){const e=this.initializeWorkBezier(),i=this.numSpan;let n=0;for(let s=0;s<i;s++){const i=this.getSaturatedBezierSpan3d(s,e);i&&(n+=i.computeStrokeCountForOptions(t))}return n}computeAndAttachRecursiveStrokeCounts(t,e){const i=this.initializeWorkBezier(),n=this.numSpan,s=Xt.createWithCurvePrimitiveAndOptionalParent(this,e,[]);for(let e=0;e<n;e++)if(this.getSaturatedBezierSpan3d(e,i)){const e=i.curveLength(),n=i.computeStrokeCountForOptions(t);s.addToCountAndLength(n,e)}le.installStrokeCountMap(this,s,e)}emitStrokes(t,e){const i=this.initializeWorkBezier(),n=this.numSpan;for(let s=0;s<n;s++){const n=this.getSaturatedBezierSpan3d(s,i);n&&n.emitStrokes(t,e)}}get isClosable(){return this.isClosableCurve}getSaturatedBezierSpan3dOr3dH(t,e,i){return e?this.getSaturatedBezierSpan3dH(t,i):this.getSaturatedBezierSpan3d(t,i)}getSaturatedBezierSpan3d(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof Ne&&e.order===i||(e=Ne.createOrder(i));const n=e;return n.loadSpanPoles(this._bcurve.packedData,t),n.saturateInPlace(this._bcurve.knots,t)?n:void 0}getSaturatedBezierSpan3dH(t,e){if(t<0||t>=this.numSpan)return;const i=this.order;void 0!==e&&e instanceof Xe&&e.order===i||(e=Xe.createOrder(i));const n=e;return n.loadSpan3dPolesWithWeight(this._bcurve.packedData,t,1),n.saturateInPlace(this._bcurve.knots,t)?n:void 0}dispatchToGeometryHandler(t){return t.handleBSplineCurve3d(this)}extendRange(t,e){const i=this._bcurve.packedData,n=i.length-2;if(e)for(let s=0;s<n;s+=3)t.extendTransformedXYZ(e,i[s],i[s+1],i[s+2]);else for(let e=0;e<n;e+=3)t.extendXYZ(i[e],i[e+1],i[e+2])}}class Ve{static oneMillimeter=.001;static oneCentimeter=.01;static oneMeter=1;static oneKilometer=1e3;static diameterOfEarth=12742*Ve.oneKilometer;static circumferenceOfEarth=40075*Ve.oneKilometer;static earthRadiusWGS84={polar:6356752.3142,equator:6378137}}class Ue{_array;constructor(t,e=V){this._array=new W(t,!1,e)}get size(){return this._array.length}has(t){return-1!==this._array.indexOf(t)}[Symbol.iterator](){return this._array[Symbol.iterator]()}}class qe extends Ue{constructor(t,e=V){super(t,e)}clear(){this._array.clear()}add(t){return this._array.insert(t),this}delete(t){return-1!==this._array.remove(t)}}class Ze{constructor(){}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceLoop(t,e=-1){let i=0;for(const e of t.children)this.announceCurvePrimitive(e,i++)}announceParityRegion(t,e=-1){let i=0;for(const e of t.children)this.announceLoop(e,i++)}announceUnionRegion(t,e=-1){let i=0;for(const e of t.children)e.announceToCurveProcessor(this,i++)}announceBagOfCurves(t,e=-1){for(const e of t.children)e instanceof le?this.announceCurvePrimitive(e):e.announceToCurveProcessor(this)}}class We extends Ze{_stack;constructor(){super(),this._stack=[]}enter(t){this._stack.push(t)}leave(){return this._stack.pop()}announceUnexpected(t,e){}announceCurvePrimitive(t,e=-1){}announcePath(t,e=-1){this.enter(t),super.announcePath(t,e),this.leave()}announceLoop(t,e=-1){this.enter(t),super.announceLoop(t,e),this.leave()}announceParityRegion(t,e=-1){this.enter(t);let i=0;for(const e of t.children)this.announceLoop(e,i++);this.leave()}announceUnionRegion(t,e=-1){this.enter(t),super.announceUnionRegion(t,e),this.leave()}announceBagOfCurves(t,e=-1){this.enter(t);let i=0;for(const e of t.children)e instanceof le?this.announceCurvePrimitive(e,i++):e.announceToCurveProcessor(this);this.leave()}}class Ge extends We{_result;_transform;constructor(t){super(),this._transform=t,this._result=void 0}static clone(t,e){const i=new Ge(e);return t.announceToCurveProcessor(i),i._result}enter(t){t instanceof $e&&super.enter(t.cloneEmptyPeer())}leave(){const t=super.leave();return t&&(0===this._stack.length?this._result=t:this._stack[this._stack.length-1].tryAddChild(t)),t}doClone(t){return this._transform?t.cloneTransformed(this._transform):t.clone()}announceCurvePrimitive(t,e){const i=this.doClone(t);if(void 0!==i&&this._stack.length>0){const t=this._stack[this._stack.length-1];if(t instanceof ti||t instanceof ei)if(Array.isArray(i))for(const e of i)t.tryAddChild(e);else t.tryAddChild(i)}}}class Qe extends Ge{constructor(){super(void 0)}doClone(t){if(t instanceof Fe&&t.numPoints()>1){const e=t.packedPoints,i=e.length,n=[];for(let t=0;t+1<i;t++)n.push(Te.createCapture(e.getPoint3dAtUncheckedPointIndex(t),e.getPoint3dAtUncheckedPointIndex(t+1)));return n}return t.clone()}static clone(t){const e=new Qe;return t.announceToCurveProcessor(e),e._result}}class He extends We{numLineSegment;numLineString;numOther;constructor(){super(),this.numLineSegment=0,this.numLineString=0,this.numOther=0}static hasNonLinearPrimitives(t){const e=new He;return t.announceToCurveProcessor(e),e.numOther>0}announceCurvePrimitive(t,e){t instanceof Te?this.numLineSegment++:t instanceof Fe?this.numLineString++:this.numOther++}}class je extends We{maxGap;constructor(){super(),this.maxGap=0}static maxGap(t){const e=new je;return t.announceToCurveProcessor(e),e.maxGap}announceCurvePrimitive(t,e){if(this._stack.length>0){const i=this._stack[this._stack.length-1];if(i instanceof ti){const n=i.cyclicCurvePrimitive(e+1);void 0!==t&&void 0!==n&&(this.maxGap=Math.max(this.maxGap,t.endPoint().distance(n.startPoint())))}}}}class Je extends Ze{_sum;constructor(){super(),this._sum=0}static sumLengths(t){const e=new Je;return t.announceToCurveProcessor(e),e._sum}announceCurvePrimitive(t,e){this._sum+=t.curveLength()}}class Ke extends Ze{numFail;numOK;transform;constructor(t){super(),this.numFail=0,this.numOK=0,this.transform=t}static tryTransformInPlace(t,e){const i=new Ke(e);return t.announceToCurveProcessor(i),0===i.numFail}announceCurvePrimitive(t,e){t.tryTransformInPlace(this.transform)?this.numOK++:this.numFail++}}class $e extends zt{geometryCategory="curveCollection";isInner=!1;sumLengths(){return Je.sumLengths(this)}closestPoint(t,e=!1,i){let n;const s=new Pt;if(void 0!==this.children)for(const e of this.children)e.closestPoint(t,!1,s)&&(n=i=Pt.chooseSmallerA(n,s).clone(i));return n}reverseInPlace(){for(const t of this.children)t.reverseInPlace()}maxGap(){return je.maxGap(this)}checkForNonLinearPrimitives(){return He.hasNonLinearPrimitives(this)}tryTransformInPlace(t){return Ke.tryTransformInPlace(this,t)}clone(){return Ge.clone(this)}cloneTransformed(t){return Ge.clone(this,t)}cloneWithExpandedLineStrings(){return Qe.clone(this)}collectCurvePrimitivesGo(t,e,i=!1){if(this.children)for(const n of this.children)(n instanceof le||n instanceof $e)&&n.collectCurvePrimitivesGo(t,e,i)}collectCurvePrimitives(t,e=!1,i=!1){const n=void 0===t?[]:t;return this.collectCurvePrimitivesGo(n,e,i),n}get isAnyRegionType(){return 2===this.dgnBoundaryType()||4===this.dgnBoundaryType()||5===this.dgnBoundaryType()}isAnyRegion(){return this.isAnyRegionType}get isOpenPath(){return 1===this.dgnBoundaryType()}isPath(){return this.isOpenPath}get isClosedPath(){return 2===this.dgnBoundaryType()}isLoop(){return this.isClosedPath}extendRange(t,e){const i=this.children;if(i)for(const n of i)n.extendRange(t,e)}static createCurveLocationDetailOnAnyCurvePrimitive(t,e=.5){if(t){if(t instanceof le)return Pt.createCurveEvaluatedFraction(t,e);if(t instanceof $e&&void 0!==t.children)for(const i of t.children){const t=this.createCurveLocationDetailOnAnyCurvePrimitive(i,e);if(t)return t}}}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}findParentOfDescendant(t){for(const e of this.children){if(e===t)return this;if(e instanceof $e){const i=e.findParentOfDescendant(t);if(i)return i}}}}class ti extends $e{_curves;constructor(){super(),this._curves=[]}get children(){return this._curves}startPoint(t){const e=this.getChild(0);return e?e.fractionToPoint(0,t):void 0}endPoint(t){const e=this.getChild(this._curves.length-1);return e?e.fractionToPoint(1,t):void 0}startPointAndDerivative(t){const e=this.getChild(0);return e?e.fractionToPointAndDerivative(0,t):void 0}endPointAndDerivative(t){const e=this.getChild(this._curves.length-1);return e?e.fractionToPointAndDerivative(1,t):void 0}cyclicCurvePrimitive(t,e=!0){const i=this.children.length;if(0!==i){if(t>=0&&t<i)return this.children[t];if(e){const e=J.modulo(t,i);return this.children[e]}}}getPackedStrokes(t){const e=this.cloneStroked(t);if(e instanceof ti){const t=e.children;if(1===t.length){const e=t[0];if(e instanceof Fe)return e.packedPoints}}}tryAddChild(t){return!!(t&&t instanceof le)&&(this._curves.push(t),!0)}getChild(t){if(t<this._curves.length)return this._curves[t]}extendRange(t,e){for(const i of this._curves)i.extendRange(t,e)}reverseChildrenInPlace(){for(const t of this._curves)t.reverseInPlace();this._curves.reverse()}reverseInPlace(){this.reverseChildrenInPlace()}childIndex(t,e){for(let e=0;e<this._curves.length;e++)if(this._curves[e]===t)return e;if(e)for(let e=0;e<this._curves.length;e++){const i=this._curves[e];if(i instanceof _e&&i.proxyCurve===t)return e}}primitiveIndexAndFractionToCurveLocationDetailPointAndDerivative(t,e,i=!1,n){const s=this.cyclicCurvePrimitive(t,i);if(s)return Pt.createCurveEvaluatedFractionPointAndDerivative(s,e,n)}}class ei extends $e{curveCollectionType="bagOfCurves";isSameGeometryClass(t){return t instanceof ei}_children;constructor(){super(),this._children=[]}get children(){return this._children}static create(...t){const e=new ei;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 0}announceToCurveProcessor(t,e=-1){return t.announceBagOfCurves(this,e)}cloneStroked(t){const e=new ei;let i;for(i of this.children)if(i instanceof le){const n=Fe.create();i.emitStrokes(n,t),n&&e.children.push(n)}else if(i instanceof $e){const n=i.cloneStroked(t);n&&e.children.push(n)}return e}closestPoint(t,e=!1,i){let n;const s=new Pt;if(void 0!==this.children)for(const r of this.children)r.closestPoint(t,e,s)&&(n=i=Pt.chooseSmallerA(n,s).clone(i));return n}cloneEmptyPeer(){return new ei}tryAddChild(t){return t&&this._children.push(t),!0}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleBagOfCurves(this)}}class ii extends ti{curveCollectionType="path";isSameGeometryClass(t){return t instanceof ii}announceToCurveProcessor(t,e=-1){return t.announcePath(this,e)}constructor(){super()}static create(...t){const e=new ii;for(const i of t)i instanceof ri?e.children.push(...i.path.children):i instanceof le?e.children.push(i):Array.isArray(i)&&i.length>0&&i[0]instanceof $&&e.children.push(Fe.create(i));return e}static createArray(t){return this.create(...t)}cloneStroked(t){const e=Fe.create();for(const i of this.children)i.emitStrokes(e,t);return ii.create(e)}closestPoint(t,e=!1,i){let n;const s=new Pt;if(void 0!==this.children)for(let r=0;r<this.children.length;r++){const o=this.children[r],a=0===r?ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,0):S.None,c=r===this.children.length-1?ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,1):S.None;o.closestPoint(t,[a,c],s)&&(n=i=Pt.chooseSmallerA(n,s).clone(i))}return n}dgnBoundaryType(){return 1}cloneEmptyPeer(){return new ii}dispatchToGeometryHandler(t){return t.handlePath(this)}}class ni{chainDistance0;chainDistance1;childFraction0;childFraction1;childCurve;range;a;constructor(t,e,i,n,s,r){this.childFraction0=t,this.childFraction1=e,this.chainDistance0=i,this.chainDistance1=n,this.childCurve=s,this.range=r,this.a=0}containsChainDistance(t){return t>=this.chainDistance0&&t<=this.chainDistance1}quickMinDistanceToChildCurve(t){if(this.range)return this.range.distanceToPoint(t);const e=this.childCurve.closestPoint(t,!1);return e?e.a:0}static collectSortedQuickMinDistances(t,e){const i=[];for(const n of t)n.a=n.quickMinDistanceToChildCurve(e),i.push(n);return i.sort(((t,e)=>t.a-e.a)),i}containsChildCurveAndChildFraction(t,e){return this.childCurve===t&&e>=this.childFraction0&&e<=this.childFraction1}chainDistanceToInterpolatedChildFraction(t){return J.inverseInterpolate(this.childFraction0,this.chainDistance0,this.childFraction1,this.chainDistance1,t,this.childFraction0)}chainDistanceToAccurateChildFraction(t,e){return this.childCurve.moveSignedDistanceFromFraction(this.childFraction0,t-this.chainDistance0,e??!1).fraction}fractionScaleFactor(t){return t*(this.childFraction1-this.childFraction0)/(this.chainDistance1-this.chainDistance0)}reverseFractionsAndDistances(t){const e=this.childFraction0,i=this.childFraction1,n=this.chainDistance0,s=this.chainDistance1;this.childFraction0=1-i,this.childFraction1=1-e,this.chainDistance0=t-s,this.chainDistance1=t-n}childFractionToChainDistance(t){let e=this.childCurve.curveLengthBetweenFractions(this.childFraction0,t);return t<this.childFraction0&&(e=-e),this.chainDistance0+e}}class si{_fragments;_accumulatedDistance;constructor(){this._accumulatedDistance=0,this._fragments=[]}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endParentCurvePrimitive(t){}endCurvePrimitive(t){}announcePointTangent(t,e,i){}announceSegmentInterval(t,e,i,n,s,r){const o=e.clone(),a=i.clone();let c=this._accumulatedDistance;if(n<=1)this._accumulatedDistance+=e.distance(i),this._fragments.push(new ni(s,r,c,this._accumulatedDistance,t,ft.create(o,a)));else{let l;for(let h=1,d=s;h<=n;h++,d=l)l=J.interpolate(s,h/n,r),e.interpolate(l,i,a),c=this._accumulatedDistance,this._accumulatedDistance+=Math.abs(l-d)*e.distance(i),this._fragments.push(new ni(d,l,c,this._accumulatedDistance,t,ft.create(o,a))),o.setFrom(a)}}announceIntervalForUniformStepStrokes(t,e,i,n){let s,r,o;for(let a=1,c=i;a<=e;a++,c=s){s=J.interpolate(i,a/e,n),r=t.curveLengthBetweenFractions(c,s),o=this._accumulatedDistance,this._accumulatedDistance+=r;const l=t.rangeBetweenFractions(c,s);this._fragments.push(new ni(c,s,o,this._accumulatedDistance,t,l))}}needPrimaryGeometryForStrokes(){return!0}static createPathFragmentIndex(t,e){const i=new si;for(const n of t.children)n.emitStrokableParts(i,e);return i._fragments}}class ri extends le{curvePrimitiveType="curveChainWithDistanceIndex";_path;_fragments;_totalLength;static _numCalls=0;static _numTested=0;static _numAssigned=0;static _numCandidate=0;isSameGeometryClass(t){return t instanceof ri}constructor(t,e){super(),this._path=t instanceof ii?t:ii.create(...t.children),this._fragments=e,this._totalLength=e.length>0?e[e.length-1].chainDistance1:0}cloneTransformed(t,e){const i=this._path.clone();if(i.tryTransformInPlace(t))return ri.createCapture(i,e)}get path(){return this._path}get fragments(){return this._fragments}clone(t){const e=this._path.clone();return ri.createCapture(e,t)}clonePartialCurve(t,e,i){const n=t instanceof Pt,s=e instanceof Pt;let r=n?t.fraction:t,o=s?e.fraction:e;if(r===o)return;const a=r>o;a&&([r,o]=[o,r]);const c=r*this._totalLength,l=o*this._totalLength,h=this.chainDistanceToFragment(c,!0);if(void 0===h)return;const d=this.chainDistanceToFragment(l,!0);if(void 0===d)return;const u=this._path.childIndex(h.childCurve,!0);if(void 0===u)return;const f=this._path.childIndex(d.childCurve,!0);if(void 0===f)return;const g=n&&t.childDetail?t.childDetail.fraction:h.chainDistanceToAccurateChildFraction(c,!0),p=s&&e.childDetail?e.childDetail.fraction:d.chainDistanceToAccurateChildFraction(l,!0),m=ii.create(),_=(t,e,i,n)=>{if(e===i)return!1;let s;return 0===e&&1===i?(s=t.clone(),n&&s.reverseInPlace()):s=n?t.clonePartialCurve(i,e):t.clonePartialCurve(e,i),!!s&&(m.children.push(s),!0)};if(h.childCurve===d.childCurve)return _(h.childCurve,g,p,a)?ri.createCapture(m,i):void 0;_(this._path.children[u],g,1,a);for(let t=u+1;t<f;t++)_(this._path.children[t],0,1,a);return _(this._path.children[f],0,p,a),a&&m.children.reverse(),ri.createCapture(m,i)}isInPlane(t){for(const e of this._path.children)if(!e.isInPlane(t))return!1;return!0}startPoint(t){const e=this._path.cyclicCurvePrimitive(0);return e?e.startPoint(t):$.createZero(t)}endPoint(t){const e=this._path.cyclicCurvePrimitive(-1);return e?e.endPoint(t):$.createZero(t)}emitStrokes(t,e){for(const i of this._path.children)i.emitStrokes(t,e)}emitStrokableParts(t,e){for(const i of this._path.children)i.emitStrokableParts(t,e)}computeStrokeCountForOptions(t){let e=0;for(const i of this._path.children)e+=i.computeStrokeCountForOptions(t);return e}collectCurvePrimitivesGo(t,e=!1,i=!1){if(e)for(const n of this._path.children)n.collectCurvePrimitivesGo(t,e,i);else t.push(this)}computeAndAttachRecursiveStrokeCounts(t,e){const i=Xt.createWithCurvePrimitiveAndOptionalParent(this,e);for(const e of this._path.children)e.computeAndAttachRecursiveStrokeCounts(t,i);le.installStrokeCountMap(this,i,e)}dispatchToGeometryHandler(t){return t.handleCurveChainWithDistanceIndex(this)}extendRange(t,e){this._path.extendRange(t,e)}curveLengthBetweenFractions(t,e){return Math.abs(e-t)*this._totalLength}static flattenNestedChains(t){if(-1===t.children.findIndex((t=>t instanceof ri)))return t;const e=t.clone(),i=e.children.flatMap((t=>t instanceof ri?t.path.children:[t]));return e.children.splice(0,1/0,...i),e}static createCapture(t,e){t=this.flattenNestedChains(t);const i=si.createPathFragmentIndex(t,e);return new ri(t,i)}chainDistanceToFragment(t,e=!1){const i=this.chainDistanceToFragmentIndex(t,e);if(void 0!==i)return this._fragments[i]}chainDistanceToFragmentIndex(t,e=!1){const i=this._fragments.length,n=this._fragments;if(i>0){if(t<0)return e?0:void 0;if(t>this._totalLength)return e?i-1:void 0;for(let e=0;e<i;e++)if(n[e].containsChainDistance(t))return e}}chainDistanceToChainFraction(t){return t/this._totalLength}curveAndChildFractionToFragment(t,e){const i=this._fragments.length,n=this._fragments;if(i>0){if(e<0)return n[0];if(e>1)return n[i-1];for(const i of n)if(i.containsChildCurveAndChildFraction(t,e))return i}}curveLength(){return this._totalLength}quickLength(){return this._totalLength}fractionToPoint(t,e){const i=t*this._totalLength,n=this.chainDistanceToFragment(i,!0);if(n){const t=n.chainDistanceToAccurateChildFraction(i,!0);return n.childCurve.fractionToPoint(t,e)}return this._fragments[0].childCurve.fractionToPoint(0,e)}fractionToPointAndDerivative(t,e){const i=t*this._totalLength,n=this.chainDistanceToFragment(i,!0),s=n.chainDistanceToAccurateChildFraction(i,!0);e=n.childCurve.fractionToPointAndDerivative(s,e);const r=this._totalLength/e.direction.magnitude();return e.direction.scaleInPlace(r),e}fractionToPointAndUnitTangent(t,e){const i=t*this._totalLength,n=this.chainDistanceToFragment(i,!0),s=n.chainDistanceToAccurateChildFraction(i,!0);return(e=n.childCurve.fractionToPointAndDerivative(s,e)).direction.normalizeInPlace(),e}fractionToPointAnd2Derivatives(t,e){const i=t*this._totalLength,n=this.chainDistanceToFragment(i,!0),s=n.chainDistanceToAccurateChildFraction(i,!0);if(!(e=n.childCurve.fractionToPointAnd2Derivatives(s,e)))return;const r=e.vectorU.magnitude(),o=r*r,a=e.vectorU.dotProduct(e.vectorV);e.vectorV.addScaledInPlace(e.vectorU,-a/o);const c=this._totalLength/r;return e.vectorU.scaleInPlace(c),e.vectorV.scaleInPlace(c*c),e}tryTransformInPlace(t){let e=0;for(const i of this._path.children)i.tryTransformInPlace(t)||e++;return 0===e}reverseInPlace(){this._path.reverseChildrenInPlace();for(const t of this._fragments)t.reverseFractionsAndDistances(this._totalLength);this._fragments.reverse()}isAlmostEqual(t){return t instanceof ri&&J.isSameCoordinate(this._totalLength,t._totalLength)&&this._path.isAlmostEqual(t._path)}moveSignedDistanceFromFraction(t,e,i,n){const s=t*this._totalLength+e,r=this.chainDistanceToFragment(s,!0),o=r.childCurve.moveSignedDistanceFromFraction(r.childFraction0,s-r.chainDistance0,i,n?.childDetail),a=t+e/this._totalLength,c=Pt.createConditionalMoveSignedDistance(i,this,t,a,e,n);return c.childDetail=o,c}static getClosestPointTestCounts(t=!0){const e={numCalls:this._numCalls,numTested:this._numTested,numAssigned:this._numAssigned,numCandidate:this._numCandidate};return t&&(this._numTested=this._numAssigned=this._numCandidate=0),e}closestPoint(t,e,i){let n,s=Number.MAX_VALUE;if(1===this.path.children.length)n=this.path.children[0].closestPoint(t,e);else{const i=ni.collectSortedQuickMinDistances(this._fragments,t),r=[ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),S.None],o=[S.None,ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,1)],a=this._fragments[0],c=this._fragments[this._fragments.length-1];let l;ri._numCalls++,ri._numCandidate+=i.length;for(const e of i){if(e.a>s)break;ri._numTested++,l=e.childCurve.closestPoint(t,e===a?r:e===c&&o,l),l&&l.a<s&&(s=l.a,n=l.clone(n),ri._numAssigned++)}}if(n)return this.computeChainDetail(n,i)}constructOffsetXY(t){const e=Ce.create(t),i=[];for(const t of this.collectCurvePrimitives(void 0,!0,!0)){const n=t.constructOffsetXY(e);void 0!==n&&(n instanceof le?i.push(n):Array.isArray(n)&&n.forEach((t=>i.push(t))))}return i}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}computeChainDetail(t,e){if(!t.curve)return;const i=this.curveAndChildFractionToFragment(t.curve,t.fraction);if(i){const n=i.childFractionToChainDistance(t.fraction),s=this.chainDistanceToChainFraction(n),r=Pt.createCurveFractionPoint(this,s,t.point,e);return r.childDetail=t,r.a=t.a,r}}static convertChildDetailToChainDetail(t,e,i,n,s){for(let s=e;s<t.length;++s){const e=t[s];if(i){const t=i.computeChainDetail(e.detailA);t&&(e.detailA=t)}if(n){const t=n.computeChainDetail(e.detailB);t&&(e.detailB=t)}}return s&&(t=It.removeAdjacentDuplicates(t,e)),t}}class oi extends ti{curveCollectionType="loop";isInner=!1;isSameGeometryClass(t){return t instanceof oi}constructor(){super()}static create(...t){const e=new oi;for(const i of t)i instanceof ri?e.children.push(...i.path.children):e.children.push(i);return e}static createArray(t){return this.create(...t)}static createPolygon(t){const e=Fe.create(t);return e.addClosurePoint(),oi.create(e)}cloneStroked(t){const e=Fe.create();for(const i of this.children)i.emitStrokes(e,t);return e.removeDuplicatePoints(),e.isPhysicallyClosed&&(e.popPoint(),e.addClosurePoint()),oi.create(e)}dgnBoundaryType(){return 2}announceToCurveProcessor(t,e=-1){return t.announceLoop(this,e)}cloneEmptyPeer(){return new oi}dispatchToGeometryHandler(t){return t.handleLoop(this)}}class ai{loopA;curveA;loopB;curveB;constructor(t,e,i,n){this.loopA=t,this.curveA=e,this.loopB=i,this.curveB=n}setA(t,e){this.loopA=t,this.curveA=e}setB(t,e){this.loopB=t,this.curveB=e}}class ci extends Se{_geometryB;setGeometryB(t){this._geometryB=t}_maxDistanceToAccept;_maxDistanceSquared;_results;static _workPointAA0=$.create();static _workPointAA1=$.create();static _workPointBB0=$.create();static _workPointBB1=$.create();static _workPointB=$.create();constructor(t){super(),this.setGeometryB(t),this._maxDistanceSquared=J.smallMetricDistanceSquared,this._results=[]}set maxDistanceToAccept(t){this._maxDistanceToAccept=t,void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0&&(this._maxDistanceSquared=this._maxDistanceToAccept*this._maxDistanceToAccept)}get maxDistanceToAccept(){return this._maxDistanceToAccept}get isMaxDistanceSet(){return void 0!==this._maxDistanceToAccept&&this._maxDistanceToAccept>0}resetGeometry(t){this.setGeometryB(t)}acceptFraction(t,e=1e-12){return!(t<-e||t>1+e)}grabPairedResults(t=!1){const e=this._results;return t&&(this._results=[]),e}testAndRecordPointPairApproach(t,e,i,n,s,r,o){if(i.distanceSquaredXY(r)<this._maxDistanceSquared){const a=Pt.createCurveFractionPoint(t,e,i),c=Pt.createCurveFractionPoint(n,s,r),l=It.createCapture(a,c);o&&l.swapDetails(),this._results.push(l)}}recordPointWithLocalFractions(t,e,i,n,s,r,o,a,c,l){let h,d,u,f;const g=void 0!==l&&l.detailA.hasFraction1&&l.detailB.hasFraction1;g?(h=J.interpolate(i,l.detailA.fraction,n),d=J.interpolate(o,l.detailB.fraction,a),u=J.interpolate(i,l.detailA.fraction1,n),f=J.interpolate(o,l.detailB.fraction1,a)):(h=u=J.interpolate(i,t,n),d=f=J.interpolate(o,s,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(i.isSameCurveAndFraction({curve:e,fraction:h})&&t.isSameCurveAndFraction({curve:r,fraction:d}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:h})&&i.isSameCurveAndFraction({curve:r,fraction:d}))return}const m=Pt.createCurveFractionPoint(e,h,e.fractionToPoint(h)),_=Pt.createCurveFractionPoint(r,d,r.fractionToPoint(d));if(g)m.captureFraction1Point1(u,e.fractionToPoint(u)),_.captureFraction1Point1(f,r.fractionToPoint(f));else{if(m.point.distanceSquaredXY(_.point)>this._maxDistanceSquared)return;m.setIntervalRole(v.isolated),_.setIntervalRole(v.isolated)}c?this._results.push(new It(_,m)):this._results.push(new It(m,_))}capturePairWithLocalFractions(t,e,i,n,s,r,o,a){const c=J.interpolate(i,t.detailA.fraction,n),l=J.interpolate(r,t.detailB.fraction,o),h=this._results.length;if(h>0){const t=this._results[h-1].detailA,i=this._results[h-1].detailB;if(a){if(i.isSameCurveAndFraction({curve:e,fraction:c})&&t.isSameCurveAndFraction({curve:s,fraction:l}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:c})&&i.isSameCurveAndFraction({curve:s,fraction:l}))return}Pt.createCurveEvaluatedFraction(e,c,t.detailA),Pt.createCurveEvaluatedFraction(s,l,t.detailB),t.detailA.setIntervalRole(v.isolated),t.detailB.setIntervalRole(v.isolated),a&&t.swapDetails(),this._results.push(t)}recordPairs(t,e,i,n){if(void 0!==i)for(const s of i)this.recordPointWithLocalFractions(s.detailA.fraction,t,0,1,s.detailB.fraction,e,0,1,n,s)}captureDetailPair(t,e,i){t&&e&&(i?this._results.push(It.createCapture(e,t)):this._results.push(It.createCapture(t,e)))}static updatePointToSegmentDistance(t,e,i,n,s,r,o){let a=!1;s<0?s=0:s>1&&(s=1),this._workPointB=i.interpolate(s,n,this._workPointB);const c=this._workPointB.distanceSquaredXY(e);return c<=Math.min(r,o.detailA.a)&&(o.detailA.setFP(t,e,void 0,c),o.detailB.setFP(s,this._workPointB,void 0,c),a=!0),a}static segmentSegmentBoundedApproach(t,e,i,n,s){const r=e.x-t.x,o=e.y-t.y,a=n.x-i.x,c=n.y-i.y,l=i.x-t.x,h=i.y-t.y,d=n.x-t.x,u=n.y-t.y,f=i.x-e.x,g=i.y-e.y,p=J.crossProductXYXY(r,o,l,h),m=J.crossProductXYXY(r,o,d,u),_=-J.crossProductXYXY(a,c,l,h),x=-J.crossProductXYXY(a,c,f,g);if(p*m<0&&_*x<0){const s=-_/(x-_),r=-p/(m-p);return It.createCapture(Pt.createCurveFractionPoint(void 0,s,t.interpolate(s,e)),Pt.createCurveFractionPoint(void 0,r,i.interpolate(r,n)))}const y=new It;y.detailA.a=2*s;let v=!1;const P=J.hypotenuseSquaredXY(r,o);if(p*p<=s*P){const n=J.dotProductXYXY(r,o,l,h)/P;this.updatePointToSegmentDistance(0,i,t,e,n,s,y)&&(v=!0)}if(m*m<=s*P){const i=J.dotProductXYXY(r,o,d,u)/P;this.updatePointToSegmentDistance(1,n,t,e,i,s,y)&&(v=!0)}const I=J.hypotenuseSquaredXY(a,c);if(_*_<=s*I){const e=-J.dotProductXYXY(a,c,l,h)/I;this.updatePointToSegmentDistance(0,t,i,n,e,s,y)&&(v=!1)}if(x*x<=s*I){const t=-J.dotProductXYXY(a,c,f,g)/I;this.updatePointToSegmentDistance(1,e,i,n,t,s,y)&&(v=!1)}if(!(y.detailA.a>s))return v&&y.swapDetails(),y}testAndRecordFractionalPairApproach(t,e,i,n,s,r,o,a,c){const l=t.fractionToPoint(e),h=t.fractionToPoint(i),d=s.fractionToPoint(r),u=s.fractionToPoint(o);this.testAndRecordPointPairApproach(t,e,l,s,r,d,c),this.testAndRecordPointPairApproach(t,i,h,s,r,d,c),this.testAndRecordPointPairApproach(t,e,l,s,o,u,c),this.testAndRecordPointPairApproach(t,i,h,s,o,u,c),a&&(this.testAndRecordProjection(t,e,l,s,r,o,c),this.testAndRecordProjection(t,i,h,s,r,o,c)),n&&(this.testAndRecordProjection(s,r,d,t,e,i,!c),this.testAndRecordProjection(s,o,u,t,e,i,!c))}getPointCurveClosestApproachXYNewton(t,e){const i=[.2,.4,.6,.8],n=new $t(t,e),s=new Gt(n,100);let r,o,a=J.largeCoordinateResult;for(const n of i)if(s.setX(n),s.runIterations()){const i=s.getX();if(this.acceptFraction(i)){const n=t.fractionToPoint(i),s=n.distanceSquaredXY(e);s<a&&(a=s,r=i,o=n)}}if(r&&o)return Pt.createCurveFractionPoint(t,r,o)}testAndRecordProjection(t,e,i,n,s,r,o){let a;if(n instanceof Fe){const t=n.globalFractionToSegmentIndexAndLocalFraction(s<=r?s:r),e=t.fraction<.999999?t.index:t.index+1,o=n.getIndexedSegment(e);o&&(a=this.getPointCurveClosestApproachXYNewton(o,i))&&Fe.convertLocalToGlobalDetail(a,e,n.numEdges(),n)}else a=this.getPointCurveClosestApproachXYNewton(n,i);a&&J.restrictToInterval(a.fraction,s,r)===a.fraction&&this.testAndRecordPointPairApproach(t,e,i,n,a.fraction,a.point,o)}computeSegmentSegment3D(t,e,i,n,s,r,o,a,c,l,h){const d=ci.segmentSegmentBoundedApproach(e,n,o,c,this._maxDistanceSquared);d&&(d.detailA.setCurve(t),d.detailB.setCurve(r),this.capturePairWithLocalFractions(d,t,i,s,r,a,l,h))}dispatchSegmentSegment(t,e,i,n,s,r,o,a,c,l,h){this.computeSegmentSegment3D(t,e,i,n,s,r,o,a,c,l,h)}allPerpendicularsSegmentArcBounded(t,e,i,n,s,r,o=!1){const a=r.vector0.crossProductStartEndXY(e,n),c=r.vector90.crossProductStartEndXY(e,n),l=Math.atan2(c,a);for(const a of[l,l+Math.PI]){const c=r.radiansToPoint(a),l=r.sweep.radiansToSignedPeriodicFraction(a);if(this.acceptFraction(l)){const a=Ft.lineSegment3dXYClosestPointUnbounded(e,n,c);void 0!==a&&this.acceptFraction(a)&&this.recordPointWithLocalFractions(a,t,i,s,l,r,0,1,o)}}}dispatchSegmentArc(t,e,i,n,s,r,o){let a=!1;const c=r.toTransformedVectors(),l=e,h=n,d=J.tripleProductXYW(l,1,h,1,c.center,1),u=J.tripleProductXYW(l,1,h,1,c.vector0,0),f=J.tripleProductXYW(l,1,h,1,c.vector90,0),g=new bt(2),p=new bt(2),m=new bt(2),_=Ct.appendImplicitLineUnitCircleIntersections(d,u,f,g,p,m);for(let e=0;e<_;e++){const n=c.center.plus2Scaled(c.vector0,g.atUncheckedIndex(e),c.vector90,p.atUncheckedIndex(e)),d=c.sweep.radiansToSignedPeriodicFraction(m.atUncheckedIndex(e)),u=Ft.lineSegment3dXYClosestPointUnbounded(l,h,n);void 0!==u&&this.acceptFraction(u)&&this.acceptFraction(d)&&(this.recordPointWithLocalFractions(u,t,i,s,d,r,0,1,o),a=!0)}a||(this.testAndRecordFractionalPairApproach(t,i,s,!0,r,0,1,!0,o),this.allPerpendicularsSegmentArcBounded(t,e,i,n,s,r,o))}allPerpendicularsArcArcBounded(t,e,i=!1){const n=new te(t,e),s=new Jt(n,100);for(let n=.05;n<1;n+=.1)for(let r=.05;r<1;r+=.1)if(s.setUV(n,r),s.runIterations()){const n=s.getU(),r=s.getV();this.acceptFraction(n)&&this.acceptFraction(r)&&this.recordPointWithLocalFractions(n,t,0,1,r,e,0,1,i)}}dispatchArcArc(t,e,i){const n=t.range(),s=e.range();n.expandInPlace(this._maxDistanceToAccept),s.intersectsRangeXY(n)&&(this.testAndRecordFractionalPairApproach(t,0,1,!0,e,0,1,!0,i),this.allPerpendicularsArcArcBounded(t,e,i))}dispatchArcBsplineCurve3d(t,e,i){const n=Fe.create();e.emitStrokes(n),this.computeArcLineString(t,n,i)}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const n=Fe.create();t.emitStrokes(n);const s=Fe.create();e.emitStrokes(s),this.computeLineStringLineString(n,s,i)}dispatchLineStringBSplineCurve(t,e,i){const n=Fe.create();e.emitStrokes(n),this.computeLineStringLineString(t,n,i)}dispatchSegmentBsplineCurve(t,e,i){const n=Fe.create();e.emitStrokes(n),this.computeSegmentLineString(t,n,i)}computeSegmentLineString(t,e,i){const n=e.numPoints(),s=J.safeDivideFraction(1,n-1,0),r=t.point0Ref,o=t.point1Ref,a=ci._workPointBB0,c=ci._workPointBB1;for(let l=0;l<n-1;++l){const h=l*s,d=l+1===n-1?1:(l+1)*s;e.packedPoints.getPoint3dAtUncheckedPointIndex(l,a),e.packedPoints.getPoint3dAtUncheckedPointIndex(l+1,c),this.dispatchSegmentSegment(t,r,0,o,1,e,a,h,c,d,i)}}computeArcLineString(t,e,i){const n=t.range(),s=e.range();if(n.expandInPlace(this._maxDistanceToAccept),!s.intersectsRangeXY(n))return;const r=ci._workPointBB0,o=ci._workPointBB1,a=e.numPoints();if(a>1){const n=1/(a-1);let s,c;s=0,e.pointAt(0,r);for(let l=1;l<a;l++,r.setFrom(o),s=c)e.pointAt(l,o),c=l*n,this.dispatchSegmentArc(e,r,s,o,c,t,!i)}}dispatchCurveCollection(t,e){const i=this._geometryB;if(i&&i.children&&i instanceof $e){for(const n of i.children)this.resetGeometry(n),e(t);this._geometryB=i}}dispatchCurveChainWithDistanceIndex(t,e){if(!(this._geometryB&&this._geometryB instanceof ri))return;const i=this._results.length,n=this._geometryB;for(const i of n.path.children)this.resetGeometry(i),e(t);this.resetGeometry(n),this._results=ri.convertChildDetailToChainDetail(this._results,i,void 0,n,!0)}handleLineSegment3d(t){if(this._geometryB instanceof Te){const e=this._geometryB;this.dispatchSegmentSegment(t,t.point0Ref,0,t.point1Ref,1,e,e.point0Ref,0,e.point1Ref,1,!1)}else this._geometryB instanceof Fe?this.computeSegmentLineString(t,this._geometryB,!1):this._geometryB instanceof Si?this.dispatchSegmentArc(t,t.point0Ref,0,t.point1Ref,1,this._geometryB,!1):this._geometryB instanceof Ye?this.dispatchSegmentBsplineCurve(t,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleLineSegment3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineSegment3d.bind(this))}classifyBitsPointRangeXY(t,e,i){let n=0;return t<i.low.x?n=1:t>i.high.x&&(n=2),e<i.low.y?n|=4:e>i.high.y&&(n|=8),n}computeLineStringLineString(t,e,i){const n=t.range(),s=e.range();if(n.expandInPlace(this._maxDistanceToAccept),!s.intersectsRangeXY(n))return;let r,o;const a=ft.createNull(),c=ci._workPointAA0,l=ci._workPointAA1,h=ci._workPointBB0,d=ci._workPointBB1,u=t.numPoints(),f=e.numPoints();if(u>1&&f>1){const n=1/(u-1),g=1/(f-1);let p,m,_,x=0;t.pointAt(0,c);for(let y=1;y<u;y++,c.setFrom(l),x=p)if(p=y*n,m=0,t.pointAt(y,l),a.setNull(),a.extendPoint(c),a.extendPoint(l),a.expandInPlace(this._maxDistanceToAccept),a.intersectsRangeXY(s)){e.pointAt(0,h),r=this.classifyBitsPointRangeXY(h.x,h.y,a);for(let n=1;n<f;n++,h.setFrom(d),m=_,r=o)e.pointAt(n,d),o=this.classifyBitsPointRangeXY(d.x,d.y,a),_=n*g,r&o||this.dispatchSegmentSegment(t,c,x,l,p,e,h,m,d,_,i)}}}handleLineString3d(t){if(this._geometryB instanceof Fe){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof Te?this.computeSegmentLineString(this._geometryB,t,!0):this._geometryB instanceof Si?this.computeArcLineString(this._geometryB,t,!0):this._geometryB instanceof Ye?this.dispatchLineStringBSplineCurve(t,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleLineString3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineString3d.bind(this))}handleArc3d(t){this._geometryB instanceof Te?this.dispatchSegmentArc(this._geometryB,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,t,!0):this._geometryB instanceof Fe?this.computeArcLineString(t,this._geometryB,!1):this._geometryB instanceof Si?this.dispatchArcArc(t,this._geometryB,!1):this._geometryB instanceof Ye?this.dispatchArcBsplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleArc3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleArc3d.bind(this))}handleBSplineCurve3d(t){this._geometryB instanceof Te?this.dispatchSegmentBsplineCurve(this._geometryB,t,!0):this._geometryB instanceof Fe?this.dispatchLineStringBSplineCurve(this._geometryB,t,!0):this._geometryB instanceof Si?this.dispatchArcBsplineCurve3d(this._geometryB,t,!0):this._geometryB instanceof Le?this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(t){super.handleCurveChainWithDistanceIndex(t),this._results=ri.convertChildDetailToChainDetail(this._results,0,t,void 0,!0)}handleBSplineCurve3dH(t){}}function li(t,e){return J.isAlmostEqualNumber(t,e,J.smallFraction)?0:t<e?-1:1}function hi(t,e){return J.isAlmostEqualNumber(t,e,J.smallFraction)?0:t<e?1:-1}class di{_quadrant;_fractions;_interpolateStartTangent;_interpolateEndTangent;_averageAdded;constructor(t,e,i,n){this._quadrant=t,this._fractions=e,this._interpolateStartTangent=i,this._interpolateEndTangent=n,this._averageAdded=!1}static create(t,e=[],i=!0,n=!0){return new di(t,e,i,n)}get quadrant(){return this._quadrant}get fractions(){return this._fractions}set fractions(t){this._fractions=t}get interpolateStartTangent(){return this._interpolateStartTangent}set interpolateStartTangent(t){this._interpolateStartTangent=t}get interpolateEndTangent(){return this._interpolateEndTangent}set interpolateEndTangent(t){this._interpolateEndTangent=t}get averageAdded(){return 3===this._fractions.length&&this._averageAdded}set averageAdded(t){this._averageAdded=t}static getQuadrantRadians(t,e){return St.isRadiansInStartEnd(t,0,G.piOver2Radians)&&St.isRadiansInStartEnd(e,0,G.piOver2Radians)?{quadrant:1,angle0:0,angle1:G.piOver2Radians}:St.isRadiansInStartEnd(t,G.piOver2Radians,G.piRadians)&&St.isRadiansInStartEnd(e,G.piOver2Radians,G.piRadians)?{quadrant:2,angle0:G.piOver2Radians,angle1:G.piRadians}:St.isRadiansInStartEnd(t,G.piRadians,G.pi3Over2Radians)&&St.isRadiansInStartEnd(e,G.piRadians,G.pi3Over2Radians)?{quadrant:3,angle0:G.piRadians,angle1:G.pi3Over2Radians}:St.isRadiansInStartEnd(t,G.pi3Over2Radians,G.pi2Radians)&&St.isRadiansInStartEnd(e,G.pi3Over2Radians,G.pi2Radians)?{quadrant:4,angle0:G.pi3Over2Radians,angle1:G.pi2Radians}:void 0}static getQ1FractionalRange(t){const e=.5*Math.PI;let i=t.radiansToSignedPeriodicFraction(0),n=t.radiansToSignedPeriodicFraction(e);return t.isCCW||([i,n]=[n,i]),n<i&&(n+=1),gt.createXX(i,n)}reverse(){this._fractions.reverse(),[this._interpolateStartTangent,this._interpolateEndTangent]=[this._interpolateEndTangent,this._interpolateStartTangent]}}class ui{announceQuadrantBegin(t,e){return!0}announceArc(t,e,i,n){}announceQuadrantEnd(t,e){}}class fi extends ui{_ellipticalArc;_maxPerpendicular;constructor(t){super(),this._ellipticalArc=t,this._maxPerpendicular=void 0}static create(t){return new fi(t)}get ellipticalArc(){return this._ellipticalArc}static computePrimitiveErrorXY(t,e,i,n){const s=new ci;s.maxDistanceToAccept=t.quickLength()/2;const r=void 0!==i&&void 0!==n,o=r?e.clonePartialCurve(i,n):e;let a;s.allPerpendicularsArcArcBounded(t,o);for(const t of s.grabPairedResults()){if(J.isAlmostEqualEitherNumber(t.detailA.fraction,0,1,J.smallFraction))continue;if(J.isAlmostEqualEitherNumber(t.detailB.fraction,0,1,J.smallFraction))continue;const s=t.detailA.point.distanceXY(t.detailB.point);(!a||a.detailA.a<s)&&(r&&(t.detailB.fraction=J.interpolate(i,t.detailB.fraction,n),t.detailB.setCurve(e)),t.detailA.a=t.detailB.a=s,a=t)}return a}get maxPerpendicular(){return this._maxPerpendicular}set maxPerpendicular(t){this._maxPerpendicular=t}updateMaxPerpendicular(t,e,i){const n=fi.computePrimitiveErrorXY(t,this.ellipticalArc,e,i);n&&(!this.maxPerpendicular||this.maxPerpendicular.detailA.a<n.detailA.a)&&(this.maxPerpendicular=n)}announceArc(t,e,i,n){this.updateMaxPerpendicular(t,i,n)}}class gi extends ui{_fullEllipseXY;_f;_bracket0;_bracket1;_error0;_error1;constructor(t,e,i,n){super(),this._fullEllipseXY=t,this._bracket0=e,this._f=i,this._bracket1=n,this._error0=this._error1=J.largeCoordinateResult}static create(t,e,i,n){return new gi(t,e,i,n)}get fullEllipseXY(){return this._fullEllipseXY}get f(){return this._f}get isConverged(){return!!J.isSmallMetricDistance(this._error0-this._error1)||!!J.isSmallRelative(this._bracket0-this._bracket1)}announceQuadrantBegin(t,e){return t.quadrant,4===t.fractions.length||3===t.fractions.length&&t.interpolateStartTangent,this._error0=this._error1=J.largeCoordinateResult,!0}announceArc(t,e,i,n){if(J.isAlmostEqualEitherNumber(this.f,i,n,0)){const e=fi.computePrimitiveErrorXY(t,this.fullEllipseXY,i,n);e&&(this.f===n?this._error0=e.detailA.a:this._error1=e.detailA.a)}}announceQuadrantEnd(t,e){if(J.isLargeCoordinateResult(this._error0)||J.isLargeCoordinateResult(this._error1))return;if(this.isConverged)return;const i=t.fractions.length;this._error0<this._error1?this._bracket0=this._f:this._bracket1=this._f,this._f=t.fractions[i-2]=J.interpolate(this._bracket0,.5,this._bracket1)}}class pi extends ui{_fullEllipseXY;_fractionRangeQ1;_refinement;_maxError;_originalRefinementCount;static _maxIters=50;constructor(t,e){super(),this._fullEllipseXY=t,this._fractionRangeQ1=di.getQ1FractionalRange(t.sweep),this._maxError=e>0?e:Ii.defaultMaxError,this._originalRefinementCount=0}static create(t,e){return new pi(t,e)}get fullEllipseXY(){return this._fullEllipseXY}get isRefined(){return void 0!==this._refinement&&0!==this._refinement.length&&this._originalRefinementCount<this._refinement.length}announceQuadrantBegin(t,e){t.quadrant,this._refinement=new W(e?hi:li,!1);for(const e of t.fractions)this._fractionRangeQ1.containsX(e)&&this._refinement.insert(e);return 2<=(this._originalRefinementCount=this._refinement.length)}getPreviousFraction(t){if(void 0===this._refinement)return;const e=this._refinement.indexOf(t);return e>=1?this._refinement.get(e-1):void 0}announceArc(t,e,i,n){if(void 0===this._refinement)return;if(this._originalRefinementCount>2){const e=fi.computePrimitiveErrorXY(t,this.fullEllipseXY,i,n);if(!e||e.detailA.a<=this._maxError)return}const s=J.interpolate(i,.5,n),r=J.isAlmostEqualEitherNumber(i,this._fractionRangeQ1.low,this._fractionRangeQ1.high,0),o=J.isAlmostEqualEitherNumber(n,this._fractionRangeQ1.low,this._fractionRangeQ1.high,0);r||void 0!==e||(e=this.getPreviousFraction(i));const a=void 0===e?[i,s,n]:[e,i,s,n],c=[di.create(1,a,r,o)],l=gi.create(this.fullEllipseXY,i,s,n);let h=0;do{Pi.processQuadrantFractions(this.fullEllipseXY,c,l)}while(h++<pi._maxIters&&!l.isConverged);this._refinement.insert(l.f)}announceQuadrantEnd(t,e){this._refinement&&(t.fractions=[...this._refinement])}getRefinedInteriorQ1Angles(t){if(t?t.length=0:t=[],this._refinement)for(const e of this._refinement)this._fractionRangeQ1.containsXOpen(e)&&t.push(this.fullEllipseXY.sweep.fractionToRadians(e));return t}}class mi{_context;_options;constructor(t,e){this._context=t,this._options=e}static create(t,e){return new mi(t,e)}computeRadiansStrictlyInsideQuadrant1(t){if(t||(t=[]),this._context.isValidEllipticalArc){const e=G.piOver2Radians/(this._options.numSamplesInQuadrant-1);for(let i=1;i<this._options.numSamplesInQuadrant-1;++i)t.push(i*e)}return t}}class _i{_context;_options;_xMag2;_yMag2;_curvatureRange;constructor(t,e){this._context=t,this._options=e,this._xMag2=t.ellipticalArc.matrixRef.columnXMagnitudeSquared(),this._yMag2=t.ellipticalArc.matrixRef.columnYMagnitudeSquared(),this._curvatureRange=gt.createXX(Math.sqrt(this._xMag2)/this._yMag2,Math.sqrt(this._yMag2)/this._xMag2)}static create(t,e){return new _i(t,e)}curvatureToRadians(t){if(!this._curvatureRange.containsX(t))return;const e=Math.cbrt(this._xMag2*this._yMag2/(t*t)),i=Math.sqrt(Math.abs((e-this._xMag2)/(this._yMag2-this._xMag2)));return Math.acos(i)}computeRadiansStrictlyInsideQuadrant1(t){if(t||(t=[]),this._context.isValidEllipticalArc){const e=1/(this._options.numSamplesInQuadrant-1);for(let i=1;i<this._options.numSamplesInQuadrant-1;++i){const n=this._options.remapFunction(i*e),s=(1-n)*this._curvatureRange.low+n*this._curvatureRange.high,r=this.curvatureToRadians(s);void 0!==r&&t.push(r)}}return t}}class xi extends _i{constructor(t,e){super(t,e.clone()),this._options.remapFunction=t=>t}static create(t,e){return new xi(t,e)}}class yi{_context;_options;_fullEllipseXY;constructor(t,e){this._context=t,this._options=e,this._fullEllipseXY=t.cloneLocalArc(!0)??Si.createUnitCircle()}static create(t,e){return new yi(t,e)}get fullEllipseXY(){return this._fullEllipseXY}computeRadiansStrictlyInsideQuadrant1(t){if(!this._context.isValidEllipticalArc)return[];const e=di.getQ1FractionalRange(this.fullEllipseXY.sweep),i=[di.create(1,[e.low,e.high],!0,!0)],n=pi.create(this.fullEllipseXY,this._options.maxError);do{Pi.processQuadrantFractions(this.fullEllipseXY,i,n)}while(n.isRefined);return n.getRefinedInteriorQ1Angles(t)}}class vi extends ui{_chain;_quadrantChain;constructor(t,e){super(),this._chain=t.sweep.isFullCircle&&!e?oi.create():ii.create()}static create(t,e=!1){return new vi(t,e)}get chain(){return this._chain.children.length>0?this._chain:void 0}announceQuadrantBegin(t,e){return this._quadrantChain=void 0,!0}announceArc(t,e,i,n){this._quadrantChain||(this._quadrantChain=ii.create()),this._quadrantChain.tryAddChild(t)}announceQuadrantEnd(t,e){if(this._quadrantChain){e&&this._quadrantChain.reverseChildrenInPlace();for(const t of this._quadrantChain.children)this._chain.tryAddChild(t)}}}class Pi{_ellipticalArc;_localToWorld;_isValidEllipticalArc;static workPt0=$.createZero();static workPt1=$.createZero();static workPt2=$.createZero();static workRay=Rt.createZero();constructor(t){this._isValidEllipticalArc=!1;const e=t.toScaledMatrix3d();if(this._ellipticalArc=Si.createScaledXYColumns(e.center,e.axes,e.r0,e.r90,e.sweep),this._localToWorld=mt.createRefs(e.center,e.axes),this._localToWorld.matrix.isSingular())return;if(this._ellipticalArc.sweep.isEmpty)return;const i=t.matrixRef.columnXMagnitudeSquared(),n=t.matrixRef.columnYMagnitudeSquared();J.isSmallMetricDistanceSquared(i)||J.isSmallMetricDistanceSquared(n)||J.isSameCoordinateSquared(i,n)||(this._isValidEllipticalArc=!0)}static create(t){return new Pi(t)}get ellipticalArc(){return this._ellipticalArc}get localToWorld(){return this._localToWorld}get isValidEllipticalArc(){return this._isValidEllipticalArc}cloneLocalArc(t){if(!this.isValidEllipticalArc)return;const e=this.localToWorld.inverse();if(!e)return;const i=this.ellipticalArc.cloneTransformed(e);if(t){let t=2*Math.PI;i.sweep.isCCW||(t=-t),i.sweep.setStartEndRadians(i.sweep.startRadians,i.sweep.startRadians+t)}return i}static processQuadrantFractions(t,e,i){const n=this.workPt0,s=this.workPt1,r=this.workPt2,o=this.workRay,a=(t,e,i)=>{const n=Si.createCircularStartTangentEnd(t.origin,t.direction,e);if(n instanceof Si)return i&&n.reverseInPlace(),n},c=(e,n)=>{t.fractionToPointAndDerivative(e,o),t.fractionToPoint(n,s),e>n&&o.direction.scaleInPlace(-1);const r=a(o,s,!1);r&&i.announceArc(r,void 0,e,n)},l=(e,o,a)=>{let c=e;i.getPreviousFraction&&(c=i.getPreviousFraction(o)??e),t.fractionToPoint(c,n),t.fractionToPoint(o,s),t.fractionToPoint(a,r);const l=((t,e,i)=>{const n=Si.createCircularStartMiddleEnd(t,e,i);if(!(n instanceof Si))return;const s=n.vector0.signedAngleTo(tt.createStartEnd(n.center,e),n.matrixRef.columnZ());return n.sweep.setStartEndRadians(s.radians,n.sweep.endRadians),n})(n,s,r);l&&i.announceArc(l,c,o,a)},h=(e,s)=>{t.fractionToPoint(e,n),t.fractionToPointAndDerivative(s,o),s>e&&o.direction.scaleInPlace(-1);const r=a(o,n,!0);r&&i.announceArc(r,void 0,e,s)},d=e=>{if(!e.interpolateStartTangent&&!e.interpolateEndTangent)return!1;const i=e.fractions.length;if(i<2)return!1;const n=t.vector0.magnitudeSquared()>t.vector90.magnitudeSquared()?2===e.quadrant||4===e.quadrant:1===e.quadrant||3===e.quadrant,s=!(e.fractions[0]>e.fractions[i-1])&&n===t.sweep.isCCW;return s&&e.reverse(),s};for(const t of e){const e=t.fractions.length;if(e<2)continue;const n=d(t);if(i.announceQuadrantBegin(t,n)){t.interpolateStartTangent&&c(t.fractions[0],t.fractions[1]);for(let i=0;i+2<e-1;++i)l(t.fractions[i],t.fractions[i+1],t.fractions[i+2]);e>2&&(t.interpolateEndTangent?h(t.fractions[e-2],t.fractions[e-1]):l(t.fractions[e-3],t.fractions[e-2],t.fractions[e-1])),i.announceQuadrantEnd(t,n),n&&t.reverse()}}}computeApproximationError(t){const e=this.cloneLocalArc();if(!e)return;const i=fi.create(e);Pi.processQuadrantFractions(e,t,i);const n=i.maxPerpendicular;return n&&n.tryTransformInPlace(this.localToWorld)?n:void 0}computeSampleFractions(t,e=!1){if(!this.isValidEllipticalArc)return[];const i=(t,e)=>J.isAlmostEqualNumber(t,e,J.smallAngleRadians)?0:t<e?-1:1,n=(t,e)=>J.isAlmostEqualNumber(t,e,J.smallAngleRadians)?0:t<e?1:-1,s=(t,e)=>li(t.fractions[t.fractions.length-1],e.fractions[0])<=0?-1:li(e.fractions[e.fractions.length-1],t.fractions[0])<=0?1:0,r=(t,e)=>{const i=e.isRadiansInSweep(t,!0);if(i){const i=e.radiansToSignedPeriodicFraction(t);J.isIn01(i)&&(t=e.fractionToRadians(i))}return{angle:t,inSweep:i}},o=(t,e,i,n,s)=>{if(void 0===n&&(n=0),void 0===s&&(s=1),n>s)return o(t,e,i,s,n);const r=i.radiansToSignedPeriodicFraction(e);return r<n-J.smallFraction||s+J.smallFraction<r?void 0:(J.restrictToInterval(r,0,1),t.add(r),r)},a=(t,e,i,n)=>{if(e>i)return a(t,i,e,n);if(G.isAlmostEqualRadiansNoPeriodShift(e,i))return;const s=di.getQuadrantRadians(e,i);if(void 0===s)return;const r=new qe(li),c=o(r,e,n),l=o(r,i,n);if(void 0===c||void 0===l)return;for(const e of t){let t=e;2===s.quadrant?t=G.piRadians-t:3===s.quadrant?t=G.piRadians+t:4===s.quadrant&&(t=G.pi2Radians-t),o(r,t,n,c,l)}const h=di.create(s.quadrant,[...r]);return 2===h.fractions.length&&(h.fractions.splice(1,0,J.interpolate(h.fractions[0],.5,h.fractions[1])),h.averageAdded=!0),h},c=[];switch(t.sampleMethod){case A.UniformParameter:mi.create(this,t).computeRadiansStrictlyInsideQuadrant1(c);break;case A.UniformCurvature:xi.create(this,t).computeRadiansStrictlyInsideQuadrant1(c);break;case A.NonUniformCurvature:_i.create(this,t).computeRadiansStrictlyInsideQuadrant1(c);break;case A.AdaptiveSubdivision:yi.create(this,t).computeRadiansStrictlyInsideQuadrant1(c)}return e?((t,e)=>{const o=new qe(e.isCCW?i:n);o.add(e.endRadians);for(const t of[0,G.piOver2Radians,G.piRadians,G.pi3Over2Radians,G.pi2Radians]){const i=r(t,e);i.inSweep&&o.add(i.angle)}const c=new qe(s);let l=e.startRadians;for(const i of o){const n=a(t,l,i,e);n&&c.add(n),l=i}return[...c]})(c,this.ellipticalArc.sweep):((t,e)=>{const i=new qe(li);i.add(0),i.add(1);for(const t of[0,G.piOver2Radians,G.piRadians,G.pi3Over2Radians])o(i,t,e);for(const n of t)for(const t of[n,G.piRadians-n,G.piRadians+n,G.pi2Radians-n])o(i,t,e);return[...i]})(c,this.ellipticalArc.sweep)}constructCircularArcChainApproximation(t){if(!this.isValidEllipticalArc)return;t||(t=Ii.create());const e=this.computeSampleFractions(t,!0),i=vi.create(this.ellipticalArc,t.forcePath);return Pi.processQuadrantFractions(this.ellipticalArc,e,i),i.chain}}!function(t){t[t.UniformParameter=0]="UniformParameter",t[t.UniformCurvature=1]="UniformCurvature",t[t.NonUniformCurvature=2]="NonUniformCurvature",t[t.AdaptiveSubdivision=3]="AdaptiveSubdivision"}(A||(A={}));class Ii{_sampleMethod;_numSamplesInQuadrant;_maxError;_remapFunction;_forcePath;static defaultMaxError=Ve.oneCentimeter;constructor(t,e,i,n,s){this._sampleMethod=t,this._numSamplesInQuadrant=e,this._maxError=i,this._remapFunction=n,this._forcePath=s}static create(t=A.AdaptiveSubdivision,e=4,i=this.defaultMaxError,n=t=>t*t,s=!1){return e<2&&(e=2),i<=0&&(i=this.defaultMaxError),new Ii(t,e,i,n,s)}clone(){return new Ii(this.sampleMethod,this.numSamplesInQuadrant,this.maxError,this.remapFunction,this.forcePath)}get sampleMethod(){return this._sampleMethod}set sampleMethod(t){this._sampleMethod=t}get numSamplesInQuadrant(){return this._numSamplesInQuadrant}set numSamplesInQuadrant(t){this._numSamplesInQuadrant=t}get maxError(){return this._maxError}set maxError(t){this._maxError=t}get remapFunction(){return this._remapFunction}set remapFunction(t){this._remapFunction=t}get forcePath(){return this._forcePath}set forcePath(t){this._forcePath=t}}class Si extends le{curvePrimitiveType="arc";isSameGeometryClass(t){return t instanceof Si}_center;_matrix;_sweep;static _workPointA=$.create();static _workPointB=$.create();static _workPointC=$.create();static _workVectorU=tt.create();static _workVectorV=tt.create();static _workVectorW=tt.create();get center(){return this._center.clone()}set center(t){this._center.setFrom(t)}get centerRef(){return this._center}get vector0(){return this._matrix.columnX()}get vector90(){return this._matrix.columnY()}binormalVector(t){const e=this.fractionToPointAnd2Derivatives(0);return e.vectorU.crossProduct(e.vectorV,t)}get perpendicularVector(){return this._matrix.columnZ()}matrixClone(){return this._matrix.clone()}get matrixRef(){return this._matrix}get sweep(){return this._sweep}set sweep(t){this._sweep.setFrom(t)}get isExtensibleFractionSpace(){return!0}constructor(t,e,i){super(),this._center=t,this._matrix=e,this._sweep=i.clampToFullCircle(i)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}setRefs(t,e,i){this._center=t,this._matrix=e,this._sweep=i}set(t,e,i){this.setRefs(t.clone(),e.clone(),i?i.clone():St.create360())}setFrom(t){this._center.setFrom(t._center),this._matrix.setFrom(t._matrix),this._sweep.setFrom(t._sweep)}clone(){return new Si(this._center.clone(),this._matrix.clone(),this._sweep.clone())}static createRefs(t,e,i,n){return n?(n.setRefs(t,e,i),n):new Si(t,e,i)}static createScaledXYColumns(t,e,i,n,s,r){const o=e.columnX(),a=e.columnY();return Si.create(t,o.scale(i,o),a.scale(n,a),s,r)}static createCenterNormalRadius(t,e,i,n){const s=xt.createRigidHeadsUp(e);return Si.createScaledXYColumns(t,s,i,i,void 0,n)}static create(t,e,i,n,s){const r=e.unitCrossProductWithDefault(i,0,0,0),o=xt.createColumns(e,i,r);return Si.createRefs(void 0!==t?t.clone():$.create(0,0,0),o,n?n.clone():St.create360(),s)}static createStartMiddleEnd(t,e,i,n,s){const r=$.createAdd2Scaled(t,.5,i,.5),o=tt.createStartEnd(r,t),a=tt.createStartEnd(r,e),c=o.dotProduct(a),l=o.magnitudeSquared();if(Math.abs(c)>=l)return;const h=o.crossProduct(a).unitCrossProductWithDefault(o,0,0,0),d=a.dotProduct(h),u=J.safeDivideFraction(l*d,Math.sqrt(l*l-c*c),0);return J.isSmallMetricDistanceSquared(u)?void 0:(h.scaleInPlace(u),Si.create(r,o,h,n,s))}static createCircularStartTangentEnd(t,e,i,n){const s=tt.createStartEnd(t,i),r=xt.createRigidFromColumns(e,s,f.XYZ);if(void 0!==r){const i=s.dotProduct(s),o=r.dotColumnY(s),a=J.conditionalDivideCoordinate(i,2*o);if(void 0!==a){const i=r.columnY();i.scaleInPlace(-a);const o=r.columnX();o.scaleInPlace(a);const c=i.plus(s);let l=i.angleTo(c).radians;e.dotProduct(c)<0&&(l=2*Math.PI-l);const h=t.plusScaled(i,-1),d=St.createStartEndRadians(0,l);return Si.create(h,i,o,d,n)}}return Te.create(t,i)}static createCircularStartTangentRadius(t,e,i,n,s){void 0===n&&(n=tt.unitZ());const r=n.unitCrossProduct(e);if(void 0===r)return;const o=t.plusScaled(r,i);r.scaleInPlace(-i);const a=e.scaleToLength(Math.abs(i));return Si.create(o,r,a,St.create(s))}static createCircularStartEndRadius(t,e,i,n){const s=.25*t.distanceSquared(e),r=i*i;if(r<s)return;const o=Math.sqrt(r-s),a=tt.createZero(this._workVectorU),c=tt.createZero(this._workVectorV);if(n instanceof $?t.crossProductToPoints(n,e,a):a.setFrom(n),!a.normalizeInPlace()||!a.crossProductStartEnd(t,e,c).scaleToLength(o,c))return;const l=$.createZero();t.interpolate(.5,e,l).addInPlace(c);const h=tt.createStartEnd(l,t,this._workVectorW),d=tt.createStartEnd(l,e,this._workVectorV),u=St.create(h.signedAngleTo(d,a)),f=a.crossProduct(h,this._workVectorV);return Si.createRefs(l,xt.createColumns(h,f,a),u)}cloneAtZ(t){return void 0===t&&(t=this._center.z),Si.createXYZXYZXYZ(this._center.x,this._center.y,t,this._matrix.coffs[0],this._matrix.coffs[3],0,this._matrix.coffs[1],this._matrix.coffs[4],0,this._sweep)}static createXYZXYZXYZ(t,e,i,n,s,r,o,a,c,l,h){return Si.create($.create(t,e,i),tt.create(n,s,r),tt.create(o,a,c),l,h)}quickEccentricity(){const t=this._matrix.columnXMagnitude(),e=this._matrix.columnYMagnitude(),i=this._matrix.columnXYCrossProductMagnitude(),n=J.maxXY(t,e);return i/(n*n)}static createCircularStartMiddleEnd(t,e,i,n){const s=tt.createStartEnd(t,e),r=tt.createStartEnd(t,i),o=s.magnitudeSquared(),a=r.magnitudeSquared(),c=s.sizedCrossProduct(r,Math.sqrt(Math.sqrt(o*a)));if(c){const e=Ft.linearSystem3d(c.x,c.y,c.z,s.x,s.y,s.z,r.x,r.y,r.z,0,.5*o,.5*a);if(e){const s=$.create(t.x,t.y,t.z).plus(e),r=tt.createStartEnd(s,t),o=tt.createRotateVectorAroundVector(r,c,G.createDegrees(90));if(o){const t=tt.createStartEnd(s,i),e=r.signedAngleTo(t,c);return e.radians<0&&e.addMultipleOf2PiInPlace(1),Si.create(s,r,o,St.createStartEndRadians(0,e.radians),n)}}}return Fe.create(t,e,i)}getFractionToDistanceScale(){const t=this.circularRadius();if(void 0!==t)return Math.abs(t*this._sweep.sweepRadians)}fractionToPoint(t,e){const i=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,Math.cos(i),Math.sin(i),e)}fractionAndRadialFractionToPoint(t,e,i){const n=this._sweep.fractionToRadians(t);return this._matrix.originPlusMatrixTimesXY(this._center,e*Math.cos(n),e*Math.sin(n),i)}fractionToPointAndDerivative(t,e){return(e=this.radiansToPointAndDerivative(this._sweep.fractionToRadians(t),e)).direction.scaleInPlace(this._sweep.sweepRadians),e}fractionToPointAnd2Derivatives(t,e){const i=this._sweep.fractionToRadians(t);e||(e=Mt.createXYPlane());const n=Math.cos(i),s=Math.sin(i);this._matrix.originPlusMatrixTimesXY(this._center,n,s,e.origin);const r=this._sweep.sweepRadians;this._matrix.multiplyXY(-r*s,r*n,e.vectorU);const o=r*r;return this._matrix.multiplyXY(-o*n,-o*s,e.vectorV),e}radiansToPointAndDerivative(t,e){e=e||Rt.createZero();const i=Math.cos(t),n=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,n,e.origin),this._matrix.multiplyXY(-n,i,e.direction),e}radiansToPoint(t,e){e=e||$.create();const i=Math.cos(t),n=Math.sin(t);return this._matrix.originPlusMatrixTimesXY(this._center,i,n,e),e}radiansToRotatedBasis(t,e){e=e||Mt.createXYPlane();const i=Math.cos(t),n=Math.sin(t);return e.origin.setFromPoint3d(this.center),this._matrix.multiplyXY(i,n,e.vectorU),this._matrix.multiplyXY(-n,i,e.vectorV),e}angleToPointAndDerivative(t,e){e=e||Rt.createZero();const i=t.cos(),n=t.sin();return this._matrix.originPlusMatrixTimesXY(this._center,i,n,e.origin),this._matrix.multiplyXY(-n,i,e.direction),e}startPoint(t){return this.fractionToPoint(0,t)}endPoint(t){return this.fractionToPoint(1,t)}curveLength(){return this.curveLengthBetweenFractions(0,1)}static quadratureGuassCount=5;static quadratureGaussCount=5;static quadratureIntervalAngleDegrees=10;curveLengthBetweenFractions(t,e){const i=this.getFractionToDistanceScale();if(void 0!==i)return i*Math.abs(e-t);let n=t,s=e;t>e&&(n=e,s=t);const r=(s-n)*this._sweep.sweepDegrees;let o=this.quickEccentricity();o<1e-5&&(o=1e-5);let a=Math.ceil(r/(o*Si.quadratureIntervalAngleDegrees));return a>400&&(a=400),a<1&&(a=1),super.curveLengthWithFixedIntervalCountQuadrature(n,s,a,Si.quadratureGaussCount)}quickLength(){const t=Math.abs(this._sweep.sweepRadians);let e=Math.ceil(4*t/Math.PI);e<1&&(e=1),e<4?e+=3:e<6&&(e+=2);const i=Si._workPointA,n=Si._workPointB;let s=0;this.fractionToPoint(0,i);for(let t=1;t<=e;t++)this.fractionToPoint(t/e,n),s+=i.distance(n),i.setFromPoint3d(n);const r=t/e;return s*(r/(2*Math.sin(.5*r)))}moveSignedDistanceFromFraction(t,e,i,n){if(!this.isCircular)return super.moveSignedDistanceFromFractionGeneric(t,e,i,n);const s=this.curveLength(),r=J.conditionalDivideFraction(e,s);return void 0===r?Pt.createCurveFractionPointDistanceCurveSearchStatus(this,t,this.fractionToPoint(t),0,P.error):Pt.createConditionalMoveSignedDistance(i,this,t,t+r,e,n)}allPerpendicularAngles(t,e=!0,i=!1){const n=[],s=t.vectorTo(this.center),r=this._matrix.columnXMagnitudeSquared(),o=this._matrix.columnXDotColumnY(),a=this._matrix.columnYMagnitudeSquared();return wt.solveUnitCircleImplicitQuadricIntersection(o,a-r,-o,this._matrix.dotColumnY(s),-this._matrix.dotColumnX(s),0,n),i&&(n.push(this.sweep.startRadians),n.push(this.sweep.endRadians)),n}closestPoint(t,e,i){i=Pt.create(this,i);const n=this.allPerpendicularAngles(t,!0,!0);let s=ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,0),r=ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,1);this._sweep.isFullCircle&&(s=S.None,r=S.None),s!==S.None&&r!==S.None&&(n.push(this._sweep.startRadians),n.push(this._sweep.endRadians));const o=Rt.createZero();if(0===n.length)i.setFR(0,this.radiansToPointAndDerivative(this._sweep.startRadians,o)),i.a=t.distance(i.point);else{let s=Number.MAX_VALUE,r=0;for(const a of n){const n=ne.resolveRadiansToSweepFraction(e,a,this.sweep);void 0!==n&&(this.fractionToPointAndDerivative(n,o),r=t.distance(o.origin),r<s&&(s=r,i.setFR(n,o),i.a=r))}}return i}emitTangents(t,e,i){const n=tt.createStartEnd(this.centerRef,t);let s;if(s=i?.vectorToEye?xt.createColumns(this.matrixRef.getColumn(0),this.matrixRef.getColumn(1),i.vectorToEye).multiplyInverse(n):this.matrixRef.multiplyInverse(n),void 0!==s&&void 0!==s){const t=s.magnitudeSquaredXY();if(t>=1){const n=Math.sqrt(t-1),r=Math.atan2(s.y,s.x),o=Math.atan2(n,1),a=J.isSmallAngleRadians(o)?[r]:[r+o,r-o];for(const t of a){const n=ne.resolveRadiansToValidSweepFraction(i?.extend??!1,t,this.sweep);n.isValid&&e(Pt.createCurveFractionPoint(this,n.fraction,this.fractionToPoint(n.fraction)))}}}}reverseInPlace(){this._sweep.reverseInPlace()}tryTransformInPlace(t){return this._center=t.multiplyPoint3d(this._center,this._center),this._matrix=t.matrix.multiplyMatrixMatrix(this._matrix,this._matrix),this.setVector0Vector90(this._matrix.columnX(),this._matrix.columnY()),!0}isInPlane(t){const e=t.getNormalRef();return J.isSmallMetricDistance(t.altitude(this._center))&&J.isSmallMetricDistance(this._matrix.dotColumnX(e))&&J.isSmallMetricDistance(this._matrix.dotColumnY(e))}get isCircular(){const t=this._matrix.columnXMagnitudeSquared(),e=this._matrix.columnYMagnitudeSquared(),i=this._matrix.columnXDotColumnY();return G.isPerpendicularDotSet(t,e,i)&&J.isSameCoordinateSquared(t,e)}circularRadiusXY(){const t=this._matrix.at(0,0),e=this._matrix.at(1,0),i=this._matrix.at(0,1),n=this._matrix.at(1,1),s=J.dotProductXYXY(t,e,t,e),r=J.dotProductXYXY(i,n,i,n),o=J.dotProductXYXY(t,e,i,n);if(G.isPerpendicularDotSet(s,r,o)&&J.isSameCoordinateSquared(s,r))return J.hypotenuseXY(t,e)}circularRadius(){return this.isCircular?this._matrix.columnXMagnitude():void 0}maxVectorLength(){return Math.max(this._matrix.columnXMagnitude(),this._matrix.columnYMagnitude())}appendPlaneIntersectionPoints(t,e){const i=t.altitude(this._center),n=this._matrix.coffs,s=t.velocityXYZ(n[0],n[3],n[6]),r=t.velocityXYZ(n[1],n[4],n[7]),o=J.solveTrigForm(i,s,r);let a=0;if(void 0!==o){let t;for(t of(a=o.length,o)){const i=Math.atan2(t.y,t.x),n=this._sweep.radiansToPositivePeriodicFraction(i),s=Pt.createCurveFractionPoint(this,n,this.fractionToPoint(n));s.intervalRole=v.isolated,(G.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.startRadians)||G.isAlmostEqualRadiansAllowPeriodShift(i,this._sweep.endRadians))&&(s.intervalRole=v.isolatedAtVertex),e.push(s)}}return a}extendRange(t,e){this.extendRangeInSweep(t,this._sweep,e)}extendRangeInSweep(t,e,i){const n=new kt(0,0,0),s=this._center.clone(Si._workPointA),r=this._matrix.columnX(Si._workVectorU),o=this._matrix.columnY(Si._workVectorV);i&&(i.multiplyPoint3d(s,s),i.multiplyVector(r,r),i.multiplyVector(o,o));const a=Si._workPointB,c=Si._workPointC,l=gt.createNull();for(let t=0;t<3;t++)n.set(s.at(t),r.at(t),o.at(t)),n.rangeInSweep(e,l),a.setAt(t,l.low),c.setAt(t,l.high);t.extend(a),t.extend(c)}rangeBetweenFractions(t,e,i){const n=St.createStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),s=ft.create();return this.extendRangeInSweep(s,n,i),s}getPlaneAltitudeSineCosinePolynomial(t,e){return e||(e=new kt(0,0,0)),e.set(t.altitude(this._center),t.velocityXYZ(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[6]),t.velocityXYZ(this._matrix.coffs[1],this._matrix.coffs[4],this._matrix.coffs[7])),e}static createUnitCircle(){return Si.createRefs($.create(0,0,0),xt.createIdentity(),St.create360())}static createXY(t,e,i=St.create360()){return new Si(t.clone(),xt.createScale(e,e,1),i.clone())}static createXYEllipse(t,e,i,n=St.create360()){return new Si(t.clone(),xt.createScale(e,i,1),n.clone())}setVector0Vector90(t,e){this._matrix.setColumns(t,e,t.unitCrossProductWithDefault(e,0,0,0))}toScaledMatrix3d(){const t=G.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(),this._matrix.columnYMagnitudeSquared(),this._matrix.columnXDotColumnY(),!0),e=this._matrix.multiplyXY(t.c,t.s),i=this._matrix.multiplyXY(-t.s,t.c),n=xt.createRigidFromColumns(e,i,f.XYZ);return{center:this._center.clone(),axes:n||xt.createIdentity(),r0:e.magnitude(),r90:i.magnitude(),sweep:this.sweep.cloneMinusRadians(t.radians)}}toVectors(){return{center:this.center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep.clone()}}toTransformedVectors(t){return t?{center:t.multiplyPoint3d(this._center),vector0:t.multiplyVector(this._matrix.columnX()),vector90:t.multiplyVector(this._matrix.columnY()),sweep:this.sweep.clone()}:{center:this._center.clone(),vector0:this._matrix.columnX(),vector90:this._matrix.columnY(),sweep:this.sweep.clone()}}toTransformedPoint4d(t){return{center:t.multiplyPoint3d(this._center,1),vector0:t.multiplyPoint3d(this._matrix.columnX(),0),vector90:t.multiplyPoint3d(this._matrix.columnY(),0),sweep:this.sweep.clone()}}setFromJSON(t){if(t&&t.center&&t.vector0&&t.vector90&&t.sweep){this._center.setFromJSON(t.center);const e=tt.create(),i=tt.create();e.setFromJSON(t.vector0),i.setFromJSON(t.vector90),this.setVector0Vector90(e,i),this._sweep.setFromJSON(t.sweep)}else this._center.set(0,0,0),this._matrix.setFrom(xt.identity),this._sweep.setStartEndRadians()}toJSON(){return{center:this._center.toJSON(),sweep:this._sweep.toJSON(),vector0:this._matrix.columnX().toJSON(),vector90:this._matrix.columnY().toJSON()}}isAlmostEqual(t,e=J.smallMetricDistance,i=J.smallAngleRadians){if(t instanceof Si){const n=t;return this._center.isAlmostEqual(n._center,e)&&this._matrix.isAlmostEqual(n._matrix,e)&&this._sweep.isAlmostEqualAllowPeriodShift(n._sweep,i)}return!1}emitStrokes(t,e){const i=this.computeStrokeCountForOptions(e);t.appendFractionalStrokePoints(this,i,0,1,!0)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startCurvePrimitive(this),t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=this.maxVectorLength();e=t.applyTolerancesToArc(i,this._sweep.sweepRadians)}else e=be.applyAngleTol(void 0,1,this._sweep.sweepRadians);return e}dispatchToGeometryHandler(t){return t.handleArc3d(this)}clonePartialCurve(t,e){if(e<t){const i=this.clonePartialCurve(e,t);return i.reverseInPlace(),i}const i=this.clone();return i.sweep.setStartEndRadians(this.sweep.fractionToRadians(t),this.sweep.fractionToRadians(e)),i}cloneInRotatedBasis(t){const e=t.cos(),i=t.sin(),n=this._matrix.multiplyXY(e,i),s=this._matrix.multiplyXY(-i,e),r=St.createStartEndRadians(this._sweep.startRadians-t.radians,this._sweep.endRadians-t.radians);return Si.create(this._center.clone(),n,s,r)}cloneAxisAligned(){const t=yt.create(this.center,this.perpendicularVector.crossProduct(tt.unitX()));if(!t)return;const e=[];if(2!==this.appendPlaneIntersectionPoints(t,e))return;const i=t.getNormalRef().dotProduct(this.perpendicularVector.crossProductStartEnd(this.center,e[0].point))>0?0:1,n=this.sweep.fractionToAngle(e[i].fraction),s=this.cloneInRotatedBasis(n);if(this.perpendicularVector.dotProduct(tt.unitZ())<-J.smallAngleRadians){if(this.matrixRef.isSingular())return;const t=xt.createRowValues(1,0,0,0,-1,0,0,0,-1);s.matrixRef.multiplyMatrixMatrix(t,s.matrixRef),s.sweep.setStartEndDegrees(-s.sweep.startDegrees,-s.sweep.endDegrees)}return s}announceClipIntervals(t,e){return t.announceClippedArcIntervals(this,e)}otherArcAsLocalVectors(t){const e=this._matrix.multiplyInverseXYZAsPoint3d(t.center.x-this.center.x,t.center.y-this.center.y,t.center.z-this.center.z),i=this._matrix.multiplyInverse(t.vector0),n=this._matrix.multiplyInverse(t.vector90);if(e&&i&&n)return{center:e,vector0:i,vector90:n,sweep:this.sweep.clone()}}static createFilletArc(t,e,i,n){const s=tt.createStartEnd(e,t),r=tt.createStartEnd(e,i),o=s.magnitude(),a=r.magnitude();if(s.normalizeInPlace()&&r.normalizeInPlace()){const t=s.plus(r);if(t.normalizeInPlace()){const i=r.minus(s),c=i.magnitude(),l=.5*c;if(!J.isSmallAngleRadians(l)){const s=l/Math.sqrt(1-l*l),r=Math.acos(l),h=n/l,d=n/s,u=d/o,f=d/a,g=e.plusScaled(t,h);return t.scaleInPlace(-n),i.scaleInPlace(n/c),{arc:Si.create(g,t,i,St.createStartEndRadians(-r,r)),fraction10:u,fraction12:f,point:e.clone()}}}}return{fraction10:0,fraction12:0,point:e.clone()}}scaleAboutCenterInPlace(t){this._matrix.scaleColumnsInPlace(t,t,1)}areaToChordXY(t,e){let i=J.crossProductXYXY(this._matrix.coffs[0],this._matrix.coffs[3],this._matrix.coffs[1],this._matrix.coffs[4]);const n=this._sweep.fractionToRadians(t),s=.5*(this._sweep.fractionToRadians(e)-n);return s<0&&(i=-i),(s-Math.cos(s)*Math.sin(s))*i}constructOffsetXY(t){const e=Ce.create(t);if(this.isCircular||e.preserveEllipticalArcs){const t=this.cloneAtZ(),i=t.sweep.sweepRadians*t.matrixRef.coffs[8]>=0?1:-1,n=t.matrixRef.columnXMagnitude(),s=n-i*e.leftOffsetDistance,r=this.isCircular?n:t.matrixRef.columnYMagnitude(),o=this.isCircular?s:r-i*e.leftOffsetDistance;if(!J.isSmallMetricDistance(s)&&n*s>0&&(this.isCircular||!J.isSmallMetricDistance(o)&&r*o>0)){const e=s/n,i=this.isCircular?e:o/r,a=t.matrixClone();return a.scaleColumnsInPlace(e,i,1),Si.createRefs(t.center.clone(),a,t.sweep.clone())}return}const i=new ve(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}constructCircularArcChainApproximation(t){t||(t=Ii.create());const e=Pi.create(this).constructCircularArcChainApproximation(t);return!e&&this.isCircular?this.sweep.isFullCircle&&t.forcePath?ii.create(this):this:e}}class bi{_origin;_vector0;_vector1;_vector2;static _workMatrix;static _workVector0;static _workVector1;static _workPoint;areStronglyIndependentVectors(t,e,i=J.smallAngleRadians){return void 0!==t&&void 0!==e&&t.smallerUnorientedRadiansTo(e)>i}clear(){this._origin=void 0,this._vector0=void 0,this._vector1=void 0,this._vector2=void 0}constructor(){this.clear()}getValidatedFrame(t=!1,e){if(this._origin&&this._vector0&&this._vector1){const i=(t,e)=>bi._workMatrix=xt.createRigidFromColumns(t,e,f.XYZ,bi._workMatrix);if(t){if(this._vector2){const t=i(this._vector0,this._vector1);if(t)return this._vector0.tripleProduct(this._vector1,this._vector2)<0&&t.scaleColumns(1,1,-1),mt.createOriginAndMatrix(this._origin,t,e);const n=this._vector2;this._vector1=this._vector2=void 0,this.announceVector(n)}}else{const t=i(this._vector0,this._vector1);if(t)return mt.createOriginAndMatrix(this._origin,t,e);this._vector1=this._vector2=void 0}}}applyDefaultUpVector(t){t&&this._vector0&&!this._vector1&&!t.isParallelTo(this._vector0)&&(this._vector1=t.crossProduct(this._vector0))}get hasOrigin(){return void 0!==this._origin}savedVectorCount(){return this._vector0?this._vector1?this._vector2?3:2:1:0}announcePoint(t){return this._origin?this._origin.isAlmostEqual(t)?this.savedVectorCount():this.announceVector(this._origin.vectorTo(t)):(this._origin=t.clone(),this.savedVectorCount())}announceVector(t){if(t.isAlmostZero)return this.savedVectorCount();if(!this._vector0)return this._vector0=t.clone(this._vector0),1;if(!this._vector1)return this.areStronglyIndependentVectors(t,this._vector0,1e-5)?(this._vector1=t.clone(this._vector1),2):1;if(!this._vector2){const e=this._vector0.unitCrossProduct(this._vector1);return e&&!J.isSameCoordinate(0,e.dotProduct(t))?(this._vector2=t.clone(this._vector2),3):2}return 3}announce(t){if(!(this.savedVectorCount()>1)&&void 0!==t)if(t instanceof $)this.announcePoint(t);else if(t instanceof tt)this.announceVector(t);else if(Array.isArray(t))for(const e of t){if(this.savedVectorCount()>1)break;this.announce(e)}else if(t instanceof le)if(t instanceof Te)this.announcePoint(t.startPoint()),this.announcePoint(t.endPoint());else if(t instanceof Si){const e=t.fractionToPointAnd2Derivatives(0);this.announcePoint(e.origin),this.announceVector(e.vectorU),this.announceVector(e.vectorV)}else if(t instanceof Fe){for(const e of t.points)if(this.announcePoint(e),this.savedVectorCount()>1)break}else if(t instanceof Ye){const e=$.create();for(let i=0;this.savedVectorCount()<2&&t.getPolePoint3d(i,e)instanceof $;i++)this.announcePoint(e)}else if(t instanceof ye){const e=$.create();for(let i=0;this.savedVectorCount()<2&&i<t.options.fitPoints.length;i++)e.setFrom(t.options.fitPoints[i]),this.announcePoint(e)}else{const e=t.fractionToFrenetFrame(0);void 0!==e&&(this.announcePoint(e.getOrigin()),this.announceVector(e.matrix.getColumn(0)),this.announceVector(e.matrix.getColumn(1)))}else if(t instanceof $e){if(t.children)for(const e of t.children)if(this.announce(e),this.savedVectorCount()>1)break}else if(t instanceof rt){const e=$.create();for(let i=0;this.savedVectorCount()<2&&t.getPoint3dAtCheckedPointIndex(i,e)instanceof $;i++)this.announcePoint(e)}else t.hasOwnProperty("x")&&t.hasOwnProperty("y")&&t.hasOwnProperty("z")&&this.announcePoint($.create(t.x,t.y,t.z))}static createRightHandedFrame(t,...e){let i=e.length>0&&e[e.length-1]instanceof mt?e.pop():void 0;const n=e=>(t&&e.matrix.dotColumnZ(t)<0&&e.matrix.scaleColumnsInPlace(1,-1,-1),e),s=new bi;for(const r of e)if(s.announce(r),s.applyDefaultUpVector(t),i=s.getValidatedFrame(!1,i))return n(i);const r=(t,e)=>t.fractionToFrenetFrame(0,e);for(const t of e)if(t instanceof le){if(i=r(t,i))return n(i)}else if(t instanceof $e){const e=t.collectCurvePrimitives();for(const t of e)if(i=r(t,i))return n(i)}}static createRightHandedLocalToWorld(...t){return this.createRightHandedFrame(void 0,t)}static createFrameToDistantPoints(t,e){if(t.length>2){const i=t[0],n=bi._workVector0??tt.create();fe.indexOfMostDistantPoint(t,t[0],n);const s=bi._workVector1??tt.create();fe.indexOfPointWithMaxCrossProductMagnitude(t,i,n,s);const r=bi._workMatrix=xt.createRigidFromColumns(n,s,f.XYZ,bi._workMatrix);if(r)return mt.createOriginAndMatrix(i,r,e)}}static createFrameWithCCWPolygon(t,e){if(t.length>2){const i=zr.centroidAreaNormal(t);if(i)return i.toRigidZFrame(e)}}static createLocalToWorldTransformInRange(t,e=m.NonUniformRangeContainment,i=0,n=0,s=0,r=1,o){if(t.isNull)return mt.createIdentity(o);let a=1,c=1,l=1;e===m.LongestRangeDirection?a=c=l=J.correctSmallMetricDistance(t.maxLength(),r):e===m.NonUniformRangeContainment&&(a=J.correctSmallMetricDistance(t.xLength(),r)*J.maxAbsDiff(i,0,1),c=J.correctSmallMetricDistance(t.yLength(),r)*J.maxAbsDiff(n,0,1),l=J.correctSmallMetricDistance(t.zLength(),r)*J.maxAbsDiff(s,0,1));const h=bi._workPoint=t.fractionToPoint(i,n,s,bi._workPoint),d=bi._workMatrix=xt.createScale(a,c,l,bi._workMatrix);return mt.createOriginAndMatrix(h,d,o)}}class Ai{constructor(t,e,i){this._toleranceSquared=i*i,this._source=t,this._dest=e}_source;_dest;_toleranceSquared;acceptPointByIndex(t){const e=this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(t));e&&this._dest.push(e)}static _vector01=tt.create();static _vectorQ=tt.create();indexOfMaxCrossProduct(t,e){let i,n,s=0;for(let r=t;r<=e;r++){const t=this._source.cyclicIndex(r),e=this._source.cyclicIndex(r+1),o=this._source.cyclicIndex(r+2);this._source.crossProductIndexIndexIndex(t,e,o,Ai._vectorQ),i=Ai._vectorQ.magnitudeSquared(),i>s&&(s=i,n=r)}return n}indexOfMaxDeviation(t,e){const i=this._source.cyclicIndex(t),n=this._source.cyclicIndex(e);let s,r,o,a,c,l=this._toleranceSquared;this._source.vectorIndexIndex(i,n,Ai._vector01);const h=Ai._vector01.magnitudeSquared();for(let d=t+1;d<e;d++)c=this._source.cyclicIndex(d),this._source.vectorIndexIndex(i,c,Ai._vectorQ),r=Ai._vector01.dotProduct(Ai._vectorQ),r<=0?o=Ai._vectorQ.magnitudeSquared():r>h?(this._source.vectorIndexIndex(n,c,Ai._vectorQ),o=Ai._vectorQ.magnitudeSquared()):(a=r/h,o=Ai._vectorQ.magnitudeSquared()-h*a*a),o>l&&(l=o,s=d);return s}recursiveCompressByChordErrorGo(t,e){if(e===t+1)return void this.acceptPointByIndex(e);const i=this.indexOfMaxDeviation(t,e);void 0===i?this.acceptPointByIndex(e):(this.recursiveCompressByChordErrorGo(t,i),this.recursiveCompressByChordErrorGo(i,e))}static compressPoint3dArrayByChordError(t,e){const i=new he(t),n=new he([]);return this.compressCollectionByChordError(i,n,e),n.data}static compressCollectionByChordError(t,e,i){e.clear();const n=t.length;if(1===n)return void e.push(t.getPoint3dAtCheckedPointIndex(0));const s=new Ai(t,e,i);let r=0,o=n-1;if(n>2&&t.distanceIndexIndex(0,n-1)<=i){const t=s.indexOfMaxCrossProduct(0,n-1);void 0!==t&&(r=t+1,o=r+n)}s.acceptPointByIndex(r),s.recursiveCompressByChordErrorGo(r,o)}static compressInPlaceByShortEdgeLength(t,e){const i=t.length;if(i<2)return;let n=0,s=i-1;for(;s>0&&t.distanceIndexIndex(s-1,i-1)<=e;)s--;if(0===s)return void(t.length=1);s<i-1&&t.moveIndexToIndex(i-1,s);let r=n+1;for(;r<=s;)t.distanceIndexIndex(n,r)>e&&(t.moveIndexToIndex(r,n+1),n++),r++;t.length=n+1}static compressInPlaceBySmallTriangleArea(t,e){const i=t.length;if(i<3)return;let n=0;const s=tt.create();for(let r=1;r+1<i;r++)t.crossProductIndexIndexIndex(n,r,r+1,s),.5*s.magnitude()>e&&t.moveIndexToIndex(r,++n);t.moveIndexToIndex(i-1,++n),t.length=n+1}static compressInPlaceByPerpendicularDistance(t,e,i=1.0001){const n=t.length;if(n<3)return;let s=0;const r=Ai._vector01,o=Ai._vectorQ;let a;const c=e*e;let l,h=1;for(;h+1<n;h++){t.vectorIndexIndex(s,h+1,r),t.vectorIndexIndex(s,h,o),l=r.magnitudeSquared();const e=J.conditionalDivideFraction(o.dotProduct(r),l);void 0!==e&&e>=0&&e<=i&&(a=Ai._vectorQ.magnitudeSquared()-l*e*e,a<=c)?(t.moveIndexToIndex(h+1,++s),h+=1):t.moveIndexToIndex(h,++s)}h<n&&t.moveIndexToIndex(h,++s),t.length=s+1}static compressColinearWrapInPlace(t,e,i){const n=t.length-1;if(n>=3&&t[0].distance(t[n])<e){const e=n-1,s=0,r=1,o=tt.createStartEnd(t[e],t[r]),a=tt.createStartEnd(t[e],t[s]),c=o.dotProduct(o),l=o.dotProduct(a),h=J.conditionalDivideFraction(l,c);if(void 0!==h&&h>0&&h<1){const n=a.magnitudeSquared()-h*h*c;Math.sqrt(Math.abs(n))<i&&(t[0]=t[e],t.pop())}}}}class Ci{static edgeLengthRange(t){const e=gt.createNull();for(let i=1;i<t.length;i++)e.extendX(t[i-1].distance(t[i]));return e}static compressByChordError(t,e){return Ai.compressPoint3dArrayByChordError(t,e)}static compressShortEdges(t,e){const i=rt.create(t);return Ai.compressInPlaceByShortEdgeLength(i,e),i.getPoint3dArray()}static compressSmallTriangles(t,e){const i=rt.create(t);return Ai.compressInPlaceBySmallTriangleArea(i,e),i.getPoint3dArray()}static compressByPerpendicularDistance(t,e,i=2){const n=rt.create(t);let s=n.length;for(let t=0;t<i;t++){Ai.compressInPlaceByPerpendicularDistance(n,e);const t=n.length;if(t===s)break;s=t}return n.getPoint3dArray()}static squaredDistanceToInterpolatedPoint(t,e,i,n){const s=1-i,r=t.x-(s*e.x+i*n.x),o=t.y-(s*e.y+i*n.y),a=t.z-(s*e.z+i*n.z);return r*r+o*o+a*a}static isDanglerConfiguration(t,e,i,n,s){if(e<0||e>=t.length)return!1;const r=t[e],o=r.distanceSquared(n);if(o<=s)return!0;if(i<0||i>=t.length)return!1;const a=t[i],c=r.dotVectorsToTargets(a,n);if(c<=0)return!1;const l=r.distanceSquared(a);let h;if(o>=l){const t=c/o;h=this.squaredDistanceToInterpolatedPoint(a,r,t,n)}else{const t=c/l;h=this.squaredDistanceToInterpolatedPoint(n,r,t,a)}return h<s}static compressDanglers(t,e=!1,i=J.smallMetricDistance){let n=t.length;const s=i*i;if(e)for(;n>1&&t[n-1].distanceSquared(t[0])<=s;)n--;const r=[];r.push(t[0].clone());for(let e=1;e<n;e++){const i=t[e];for(;this.isDanglerConfiguration(r,r.length-1,r.length-2,i,s);)r.pop();r.push(i.clone())}if(e){let t=0,e=r.length-1;for(;e>t+2;)if(this.isDanglerConfiguration(r,t,t+1,r[e],s))t++;else{if(!this.isDanglerConfiguration(r,e,e-1,r[t],s))break;e--}e+1<r.length&&(r.length=e+1),t>0&&r.splice(0,t)}return r}static addClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.addClosurePoint(e);return}const i=t[t.length-1];e instanceof $&&i instanceof $&&!e.isAlmostEqual(i)&&t.push(e.clone())}static removeClosurePoint(t){if(0===t.length)return;const e=t[0];if(Array.isArray(e)){for(const e of t)Array.isArray(e)&&this.removeClosurePoint(e);return}const i=t[t.length-1];e instanceof $&&i instanceof $&&e.isAlmostEqual(i)&&t.pop()}static createBisectorPlanesForDistinctPoints(t,e=!1){const i=Ci.compressShortEdges(t,2*J.smallMetricDistance);if(i.length<2)return;const n=[],s=i[0],r=i[1],o=tt.createNormalizedStartEnd(s,r),a=yt.create(s,o),c=yt.createXYPlane();n.push(a.clone());for(let t=1;t+1<i.length;t++)if(tt.createNormalizedStartEnd(i[t],i[t+1],o),void 0!==yt.create(i[t],o,c)){const e=a.getNormalRef().interpolate(.5,c.getNormalRef()),s=yt.create(i[t],e);void 0!==s&&n.push(s),a.setFrom(c)}n.push(yt.create(i[i.length-1],a.getNormalRef()));const l=n.length-1;if(l>0&&e){const t=n[0],e=n[l];if(J.isSamePoint3d(t.getOriginRef(),e.getOriginRef())){const i=t.getNormalRef().plus(e.getNormalRef()),s=yt.create(t.getOriginRef(),i);void 0!==s&&(n[0]=s,n[l]=yt.create(e.getOriginRef(),i))}}return n.length>1?n:void 0}static _workSegmentA;static _workSegmentB;static _workLocalDetailPair;static closestApproach(t,e,i,n,s=Number.MAX_VALUE,r){Array.isArray(t)&&(t=new he(t)),Array.isArray(i)&&(i=new he(i));let o=s,a=!1;const c=t.length-1,l=i.length-1,h=[S.None,S.None],d=[S.None,S.None],u=(t,e,i,n)=>{t[0]=t[1]=S.None,0===i?t[0]=ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,0):i===n-1&&(t[1]=ne.resolveVariantCurveExtendParameterToCurveExtendMode(e,1))},f=(t,e,i)=>void 0===i?Te.createCapture(t.getPoint3dAtUncheckedPointIndex(e),t.getPoint3dAtUncheckedPointIndex(e+1)):(t.getPoint3dAtUncheckedPointIndex(e,i.point0Ref),t.getPoint3dAtUncheckedPointIndex(e+1,i.point1Ref),i);for(let s=0;s<c;s++){this._workSegmentA=f(t,s,this._workSegmentA),u(h,e,s,c);for(let t=0;t<l;t++)if(this._workSegmentB=f(i,t,this._workSegmentB),u(d,n,t,l),void 0!==(this._workLocalDetailPair=Te.closestApproach(this._workSegmentA,h,this._workSegmentB,d,this._workLocalDetailPair))){const e=this._workLocalDetailPair.detailA.a;if(e<o){const i=r?.detailA.childDetail,n=r?.detailB.childDetail;r=this._workLocalDetailPair.clone(r),Fe.convertLocalToGlobalDetail(r.detailA,s,c,void 0,i),Fe.convertLocalToGlobalDetail(r.detailB,t,l,void 0,n),r.detailA.childDetail&&r.detailB.childDetail&&(r.detailA.childDetail.curve=r.detailB.childDetail.curve=void 0),o=e,a=!0}}}return a?r:void 0}}class Ti extends $e{curveCollectionType="parityRegion";isSameGeometryClass(t){return t instanceof Ti}_children;get children(){return this._children}constructor(){super(),this._children=[]}addLoops(t){if(void 0===t);else if(t instanceof oi)this.children.push(t);else if(Array.isArray(t))for(const e of t)e instanceof oi?this.children.push(e):Array.isArray(e)&&this.addLoops(e)}static createLoops(t){if(t instanceof oi)return t;const e=new Ti;return e.addLoops(t),e}static create(...t){const e=new Ti;for(const i of t)e.children.push(i);return e}dgnBoundaryType(){return 4}announceToCurveProcessor(t,e=-1){return t.announceParityRegion(this,e)}clone(){const t=new Ti;let e;for(e of this.children){const i=e.clone();i instanceof oi&&t.children.push(i)}return t}cloneStroked(t){const e=new Ti;let i;for(i of this.children){const n=i.cloneStroked(t);n&&e.children.push(n)}return e}cloneEmptyPeer(){return new Ti}tryAddChild(t){return!!(t&&t instanceof oi)&&(this._children.push(t),!0)}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleParityRegion(this)}}class wi{origin;needOrigin;sums;localToWorldMap;radiusOfGyration;absoluteQuantity;static _vectorA;static _vectorB;static _vectorC;_point0=$.create();_point1=$.create();constructor(){this.origin=$.createZero(),this.needOrigin=!1,this.sums=Bt.createZero(),this.localToWorldMap=mt.createIdentity(),this.radiusOfGyration=tt.create(),this.absoluteQuantity=.1,this.absoluteQuantity=void 0}get quantitySum(){return this.sums.weight()}signFactor(t){return t*this.quantitySum>0?1:-1}setOriginIfNeeded(t){this.needOrigin&&(this.origin.setFromPoint3d(t),this.needOrigin=!1)}setOriginFromGrowableXYZArrayIfNeeded(t){this.needOrigin&&t.length>0&&(t.getPoint3dAtCheckedPointIndex(0,this.origin),this.needOrigin=!1)}setOriginXYZIfNeeded(t,e,i){this.needOrigin&&(this.origin.set(t,e,i),this.needOrigin=!1)}static create(t,e=!1){const i=new wi;return i.needOrigin=e,t&&(i.origin.setFromPoint3d(t),i.needOrigin=!1),i}static momentTensorFromInertiaProducts(t){const e=t.sumDiagonal(),i=xt.createScale(e,e,e);return i.addScaledInPlace(t,-1),i}static sortColumnsForIncreasingMoments(t,e){const i=[t.indexedColumnWithWeight(0,e.x),t.indexedColumnWithWeight(1,e.y),t.indexedColumnWithWeight(2,e.z)].sort(((t,e)=>t.w<e.w?-1:t.w>e.w?1:0));t.setColumnsPoint4dXYZ(i[0],i[1],i[2]),t.determinant()<0&&t.scaleColumnsInPlace(-1,-1,-1),t.at(0,0)<0&&t.scaleColumnsInPlace(-1,-1,1),t.at(2,2)<0&&t.scaleColumnsInPlace(1,-1,-1),e.set(i[0].w,i[1].w,i[2].w)}static pointsToPrincipalAxes(t){const e=new wi;return 0===t.length?e:(e.clearSums(t[0]),e.accumulatePointMomentsFromOrigin(t),this.inertiaProductsToPrincipalAxes(e.origin,e.sums))}static inertiaProductsToPrincipalAxes(t,e){const i=new wi;if(i.sums.setFrom(e),i.origin.setFrom(t),!i.shiftOriginAndSumsToCentroidOfSums())return;const n=i.sums.matrixPart(),s=i.sums.weight();s<0&&n.scaleColumnsInPlace(-1,-1,-1);const r=wi.momentTensorFromInertiaProducts(n),o=tt.create(),a=xt.createZero();return r.fastSymmetricEigenvalues(a,o),o.x<0?void 0:(wi.sortColumnsForIncreasingMoments(a,o),s<0&&a.scaleColumnsInPlace(1,-1,-1),i.localToWorldMap=mt.createOriginAndMatrix(i.origin,a),i.radiusOfGyration.set(Math.sqrt(Math.abs(o.x)),Math.sqrt(Math.abs(o.y)),Math.sqrt(Math.abs(o.z))),i.radiusOfGyration.scaleInPlace(1/Math.sqrt(Math.abs(s))),i.absoluteQuantity=Math.abs(s),i)}static areEquivalentPrincipalAxes(t,e){if(t&&e&&J.isSameCoordinate(t.quantitySum,e.quantitySum)&&t.localToWorldMap.getOrigin().isAlmostEqual(e.localToWorldMap.getOrigin())&&t.radiusOfGyration.isAlmostEqual(e.radiusOfGyration)){if(J.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.y)){if(J.isSameCoordinate(t.radiusOfGyration.x,t.radiusOfGyration.z))return!0;const i=t.localToWorldMap.matrix.columnZ(),n=e.localToWorldMap.matrix.columnZ();return!!i.isParallelTo(n,!0)}const i=tt.create(),n=tt.create();for(let s=0;s<3;s++)if(t.localToWorldMap.matrix.getColumn(s,i),e.localToWorldMap.matrix.getColumn(s,n),!i.isParallelTo(n,!0))return!1;return!0}return!1}clearSums(t){this.sums.setZero(),t?this.origin.setFrom(t):this.origin.setZero()}accumulatePointMomentsFromOrigin(t){for(const e of t)this.sums.addMomentsInPlace(e.x-this.origin.x,e.y-this.origin.y,e.z-this.origin.z,1)}shiftOriginAndSumsToCentroidOfSums(){const t=this.sums.columnW().realPoint();return!!t&&(this.shiftOriginAndSumsByXYZ(t.x,t.y,t.z),!0)}shiftOriginAndSumsByXYZ(t,e,i){this.origin.addXYZInPlace(t,e,i),this.sums.multiplyTranslationSandwichInPlace(-t,-e,-i)}shiftOriginAndSumsToNewOrigin(t){this.shiftOriginAndSumsByXYZ(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z)}accumulateTriangleMomentsXY(t,e,i){this.setOriginXYZIfNeeded(e.x,e.y,0);const n=this.origin.x,s=this.origin.y,r=wi._vectorA=void 0!==t?Ot.create(t.x-n,t.y-s,0,1,wi._vectorA):Ot.create(0,0,0,1,wi._vectorA),o=wi._vectorB=Ot.create(e.x-n,e.y-s,0,1,wi._vectorB),a=wi._vectorC=Ot.create(i.x-n,i.y-s,0,1,wi._vectorC),c=J.crossProductXYXY(o.x-r.x,o.y-r.y,a.x-r.x,a.y-r.y);if(0!==c){const t=c/12,e=c/24;this.sums.addScaledOuterProductInPlace(r,r,t),this.sums.addScaledOuterProductInPlace(r,o,e),this.sums.addScaledOuterProductInPlace(r,a,e),this.sums.addScaledOuterProductInPlace(o,r,e),this.sums.addScaledOuterProductInPlace(o,o,t),this.sums.addScaledOuterProductInPlace(o,a,e),this.sums.addScaledOuterProductInPlace(a,r,e),this.sums.addScaledOuterProductInPlace(a,o,e),this.sums.addScaledOuterProductInPlace(a,a,t)}}accumulateScaledOuterProduct(t,e){this.setOriginXYZIfNeeded(t.x,t.y,0);const i=wi._vectorA=Ot.create(t.x-this.origin.x,t.y-this.origin.y,t.z-this.origin.z,1,wi._vectorA);this.sums.addScaledOuterProductInPlace(i,i,e)}accumulateLineMomentsXYZ(t,e){this.setOriginXYZIfNeeded(t.x,t.y,t.z);const i=this.origin.x,n=this.origin.y,s=this.origin.z,r=wi._vectorA=Ot.create(t.x-i,t.y-n,t.z-s,1,wi._vectorA),o=wi._vectorB=Ot.create(e.x-i,e.y-n,e.z-s,1,wi._vectorB),a=t.distance(e),c=a/3,l=a/6;this.sums.addScaledOuterProductInPlace(r,r,c),this.sums.addScaledOuterProductInPlace(r,o,l),this.sums.addScaledOuterProductInPlace(o,r,l),this.sums.addScaledOuterProductInPlace(o,o,c)}accumulateTriangleToLineStringMomentsXY(t,e){const i=e.length;if(i>1){e.getPoint3dAtUncheckedPointIndex(0,this._point0);for(let n=1;n<i;n++)e.getPoint3dAtUncheckedPointIndex(n,this._point1),this.accumulateTriangleMomentsXY(t,this._point0,this._point1),this._point0.setFromPoint3d(this._point1)}}accumulateXYProductsInCentroidalFrame(t,e,i,n,s,r,o){const a=Bt.createRowValues(t,e,0,0,e,i,0,0,0,0,0,0,0,0,0,n),c=J.crossProductXYXY(r.x,o.x,r.y,o.y),l=Bt.createRowValues(r.x,o.x,0,s.x-this.origin.x,r.y,o.y,0,s.y-this.origin.y,0,0,0,0,0,0,0,1),h=l.multiplyMatrixMatrix(a).multiplyMatrixMatrixTranspose(l);this.sums.addScaledInPlace(h,c)}accumulateProducts(t,e){this.setOriginIfNeeded(t.origin),this.sums.addTranslationSandwichInPlace(t.sums,this.origin.x-t.origin.x,this.origin.y-t.origin.y,this.origin.z-t.origin.z,e)}accumulateProductsFromOrigin(t,e,i){this.setOriginIfNeeded(t),this.sums.addTranslationSandwichInPlace(e,this.origin.x-t.x,this.origin.y-t.y,this.origin.z-t.z,i)}toJSON(){return{origin:this.origin,sums:this.sums.toJSON(),radiusOfGyration:this.radiusOfGyration.toJSON(),localToWorld:this.localToWorldMap.toJSON()}}}class Ei extends Ie{_geometry1;_fraction;constructor(t,e,i){super(),this._geometry1=i,this._fraction=e}handleLineSegment3d(t){if(this._geometry1 instanceof Te){const e=this._geometry1;return Te.create(t.startPoint().interpolate(this._fraction,e.startPoint()),t.endPoint().interpolate(this._fraction,e.endPoint()))}}handleLineString3d(t){if(this._geometry1 instanceof Fe){const e=this._geometry1;if(t.numPoints()===e.numPoints()){const i=t.numPoints(),n=Fe.create(),s=$.create(),r=$.create(),o=$.create(),a=this._fraction;for(let c=0;c<i;c++)t.pointAt(c,r),e.pointAt(c,o),r.interpolate(a,o,s),n.addPoint(s);if(t.fractions&&e.fractions)for(let s=0;s<i;s++)n.addFraction(J.interpolate(t.fractions.atUncheckedIndex(s),a,e.fractions.atUncheckedIndex(s)));if(t.strokeData&&e.strokeData&&(n.strokeData=t.strokeData.clone()),t.packedDerivatives&&e.packedDerivatives){const s=tt.create(),r=tt.create();for(let o=0;o<i;o++)t.packedDerivatives.getVector3dAtCheckedVectorIndex(o,s),e.packedDerivatives.getVector3dAtCheckedVectorIndex(o,r),n.addDerivative(s.interpolate(a,r))}return n}}}handleArc3d(t){if(this._geometry1 instanceof Si){const e=this._geometry1;return Si.create(t.center.interpolate(this._fraction,e.center),t.vector0.interpolate(this._fraction,e.vector0),t.vector90.interpolate(this._fraction,e.vector90),t.sweep.interpolate(this._fraction,e.sweep))}}static interpolateBetween(t,e,i){const n=new Ei(t,e,i);return t.dispatchToGeometryHandler(n)}}class ki extends zt{geometryCategory="solid";_capped;constructor(t){super(),this._capped=t}get capped(){return this._capped}set capped(t){this._capped=t}}class Fi extends ki{solidPrimitiveType="cone";_localToWorld;_radiusA;_radiusB;_maxRadius;constructor(t,e,i,n){super(n),this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._maxRadius=Math.max(this._radiusA,this._radiusB)}clone(){return new Fi(this._localToWorld.clone(),this._radiusA,this._radiusB,this.capped)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t)?e:void 0}static createAxisPoints(t,e,i,n,s){const r=t.vectorTo(e),o=r.magnitude();if(J.isSmallMetricDistance(o))return;if((i=J.correctSmallMetricDistance(i))*(n=J.correctSmallMetricDistance(n))<0)return;if(i+n===0)return;const a=xt.createRigidHeadsUp(r);a.scaleColumns(1,1,o,a);const c=mt.createOriginAndMatrix(t,a);return new Fi(c,i,n,s??!1)}static createBaseAndTarget(t,e,i,n,s,r,o){s=Math.abs(J.correctSmallMetricDistance(s)),r=Math.abs(J.correctSmallMetricDistance(r));const a=t.vectorTo(e),c=mt.createOriginAndMatrixColumns(t,i,n,a);return new Fi(c,s,r,o??!1)}static createDgnCone(t,e,i,n,s,r,o){const a=xt.createRigidFromColumns(i,n,f.XYZ);if(a){const n=i.magnitude();return this.createBaseAndTarget(t,e,a.columnX(),a.columnY(),s*n,r*n,o)}}getCenterA(){return this._localToWorld.multiplyXYZ(0,0,0)}getCenterB(){return this._localToWorld.multiplyXYZ(0,0,1)}getVectorX(){return this._localToWorld.matrix.columnX()}getVectorY(){return this._localToWorld.matrix.columnY()}getRadiusA(){return this._radiusA}getRadiusB(){return this._radiusB}getMaxRadius(){return this._maxRadius}vFractionToRadius(t){return J.interpolate(this._radiusA,t,this._radiusB)}isSameGeometryClass(t){return t instanceof Fi}isAlmostEqual(t){return t instanceof Fi&&this.capped===t.capped&&!!this._localToWorld.isAlmostEqualAllowZRotation(t._localToWorld)&&J.isSameCoordinate(this._radiusA,t._radiusA)&&J.isSameCoordinate(this._radiusB,t._radiusB)}dispatchToGeometryHandler(t){return t.handleCone(this)}strokeConstantVSection(t,e,i){let n=16;void 0!==e?n=e:void 0!==i&&(n=i.defaultCircleStrokes),n=J.clampToStartEnd(n,4,64);const s=this.vFractionToRadius(t),r=Fe.createForStrokes(e,i),o=2*Math.PI,a=o/n;let c=0;const l=r.fractions,h=r.packedDerivatives,d=r.packedUVParams,u=r.packedSurfaceNormals,f=$.create(),g=tt.create(),p=tt.create(),m=tt.create(),_=this._localToWorld;let x,y,v,P;for(let e=0;e<=n;e++)c=2*e<=n?e*a:(e-n)*a,v=Math.cos(c),P=Math.sin(c),x=s*v,y=s*P,_.multiplyXYZ(x,y,t,f),r.addPoint(f),l&&l.push(e/n),h&&(_.matrix.multiplyXYZ(-y*o,x*o,0,g),h.push(g)),u&&(_.matrix.multiplyXYZ(-P,v,0,g),_.matrix.multiplyXYZ(0,0,1,p),g.unitCrossProduct(p,m),u.push(m)),d&&d.pushXY(e/n,t);return r}constantVSection(t){const e=this.vFractionToRadius(t),i=this._localToWorld,n=i.multiplyXYZ(0,0,t),s=i.matrix.multiplyXYZ(e,0,0),r=i.matrix.multiplyXYZ(0,e,0);return oi.create(Si.create(n,s,r))}extendRange(t,e){const i=this.constantVSection(0),n=this.constantVSection(1);i.extendRange(t,e),n.extendRange(t,e)}uvFractionToPoint(t,e,i){const n=t*Math.PI*2,s=J.interpolate(this._radiusA,e,this._radiusB),r=Math.cos(n),o=Math.sin(n);return this._localToWorld.multiplyXYZ(s*r,s*o,e,i)}uvFractionToPointAndTangents(t,e,i){const n=t*Math.PI*2,s=J.interpolate(this._radiusA,e,this._radiusB),r=this._radiusB-this._radiusA,o=Math.cos(n),a=Math.sin(n),c=2*Math.PI;return Mt.createOriginAndVectors(this._localToWorld.multiplyXYZ(s*o,s*a,e),this._localToWorld.multiplyVectorXYZ(-s*a*c,s*o*c,0),this._localToWorld.multiplyVectorXYZ(r*o,r*a,1),i)}get isClosedVolume(){return this.capped}maxIsoParametricDistance(){const t=this._localToWorld.matrix.columnX(),e=this._localToWorld.matrix.columnY(),i=this._localToWorld.matrix.columnZ(),n=t.unitCrossProduct(e),s=n.dotProduct(i),r=i.plusScaled(n,s).magnitudeXY();return j.create(2*Math.PI*Math.max(this._radiusA,this._radiusB),J.hypotenuseXY(Math.abs(this._radiusB-this._radiusA)+r,s))}}class Ri{_data;_inUse;_blockSize;_growthFactor;constructor(t,e=8,i){this._data=new Float64Array(e*t),this._inUse=0,this._blockSize=t>0?t:1,this._growthFactor=void 0!==i&&i>=1?i:1.5}copyData(t,e,i){let n=void 0!==i?i*this.numPerBlock:0;if(n<0&&(n=0),n>=this._data.length)return{count:0,offset:0};let s=void 0!==e?e*this.numPerBlock:t.length;return s>0&&(s>t.length&&(s=t.length),n+s>this._data.length&&(s=this._data.length-n),s%this.numPerBlock!=0&&(s-=s%this.numPerBlock)),s<=0?{count:0,offset:0}:(s===t.length?this._data.set(t,n):t instanceof Float64Array?this._data.set(t.subarray(0,s),n):this._data.set(t.slice(0,s),n),{count:s/this.numPerBlock,offset:n/this.numPerBlock})}clone(){const t=new Ri(this.numPerBlock,this.numBlocks,this._growthFactor);return t.copyData(this._data,this.numBlocks),t._inUse=this.numBlocks,t}get length(){return this._inUse}get numBlocks(){return this._inUse}get numPerBlock(){return this._blockSize}getWithinBlock(t,e){return this._data[t*this._blockSize+e]}clear(){this._inUse=0}blockCapacity(){return this._data.length/this._blockSize}ensureBlockCapacity(t,e=!0){if(t>this.blockCapacity()){e&&(t*=this._growthFactor);const i=this._data;this._data=new Float64Array(t*this._blockSize),this.copyData(i,this._inUse)}}addBlock(t){const e=this.newBlockIndex();let i=t.length;i>this._blockSize&&(i=this._blockSize);for(let n=0;n<i;n++)this._data[e+n]=t[n]}newBlockIndex(){const t=this._blockSize*this._inUse;t+1>this._data.length&&this.ensureBlockCapacity(1+this._inUse),this._inUse++;for(let e=t;e<t+this._blockSize;e++)this._data[e]=0;return t}popBlock(){this._inUse>0&&this._inUse--}blockIndexToDoubleIndex(t){return this._blockSize*t}checkedComponent(t,e){if(!(t>=this._inUse||t<0||e<0||e>=this._blockSize))return this._data[this._blockSize*t+e]}component(t,e){return this._data[this._blockSize*t+e]}static compareLexicalBlock(t,e,i,n){let s=0,r=0;for(let o=0;o<e;o++){if(s=t[i+o],r=t[n+o],s>r)return 1;if(s<r)return-1}return i-n}sortIndicesLexical(t=(t,e,i,n)=>Ri.compareLexicalBlock(t,e,i,n)){const e=this._inUse,i=new Uint32Array(e),n=this._data,s=this._blockSize;for(let t=0;t<e;t++)i[t]=t;return i.sort(((e,i)=>t(n,s,e*s,i*s))),i}distanceBetweenBlocks(t,e){let i=0,n=this.blockIndexToDoubleIndex(t),s=this.blockIndexToDoubleIndex(e),r=0;const o=this._data;for(let t=0;t<this._blockSize;t++)r=o[n++]-o[s++],i+=r*r;return Math.sqrt(i)}distanceBetweenSubBlocks(t,e,i,n){let s=0;const r=this.blockIndexToDoubleIndex(t),o=this.blockIndexToDoubleIndex(e);let a=0;const c=this._data;for(let t=i;t<n;t++)a=c[r+t]-c[o+t],s+=a*a;return Math.sqrt(s)}}class Mi extends Ri{static _vectorFactor=.8732;static sortVectorComponent(t){let e=1;for(let i=1;i<t;i++)e*=Mi._vectorFactor;return e}_numCoordinatePerPoint;_numExtraDataPerPoint;constructor(t,e,i){super(1+t+e,i),this._numExtraDataPerPoint=e,this._numCoordinatePerPoint=t}addBlock(t){const e=this.newBlockIndex()+1,i=Math.min(this.numPerBlock-1,t.length);for(let n=0;n<i;n++)this._data[e+n]=t[n]}addDirect(t,e,i,n,s){const r=this.newBlockIndex();this._data[r+1]=t,void 0!==e&&(this._data[r+2]=e),void 0!==i&&(this._data[r+3]=i),void 0!==n&&(this._data[r+4]=n),void 0!==s&&(this._data[r+5]=s)}addPoint2d(t,e,i,n){const s=this.newBlockIndex();this._data[s+1]=t.x,this._data[s+2]=t.y,void 0!==e&&(this._data[s+3]=e),void 0!==i&&(this._data[s+4]=i),void 0!==n&&(this._data[s+5]=n)}addPoint3d(t,e,i,n){const s=this.newBlockIndex();this._data[s+1]=t.x,this._data[s+2]=t.y,this._data[s+3]=t.z,void 0!==e&&(this._data[s+4]=e),void 0!==i&&(this._data[s+5]=i),void 0!==n&&(this._data[s+6]=n)}getPoint2d(t,e){const i=this.blockIndexToDoubleIndex(t);return H.create(this._data[i+1],this._data[i+2],e)}getPoint3d(t,e){const i=this.blockIndexToDoubleIndex(t);return $.create(this._data[i+1],this._data[i+2],this._data[i+3],e)}getExtraData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+1+this._numCoordinatePerPoint+e]}getData(t,e){const i=this.blockIndexToDoubleIndex(t);return this._data[i+e]}setExtraData(t,e,i){const n=this.blockIndexToDoubleIndex(t);this._data[n+1+this._numCoordinatePerPoint+e]=i}static clusterTerminator=4294967295;static isClusterTerminator(t){return t===Mi.clusterTerminator}clusterIndicesLexical(t=J.smallMetricDistance){this.setupPrimaryClusterSort();const e=this.sortIndicesLexical(),i=new Uint32Array(2*e.length);let n=0;const s=this.numBlocks;let r=0,o=0,a=0,c=0,l=0;const h=1+this._numCoordinatePerPoint;for(c=0;c<s;c++)if(r=e[c],!Mi.isClusterTerminator(r)){for(i[n++]=r,a=this.component(r,0)+t,e[c]=Mi.clusterTerminator,l=c+1;l<s;l++)if(o=e[l],o!==Mi.clusterTerminator){if(this.component(o,0)>=a)break;this.distanceBetweenSubBlocks(r,o,1,h)<t&&(i[n++]=o,e[l]=Mi.clusterTerminator)}i[n++]=Mi.clusterTerminator}return i.slice(0,n)}setupPrimaryClusterSort(){const t=this.numBlocks,e=this._numCoordinatePerPoint,i=new Float64Array(e);i[0]=1;for(let t=1;t<e;t++)i[t]=i[t-1]*Mi._vectorFactor;let n=0,s=0;const r=this._data;for(let o=0;o<t;o++){n=this.blockIndexToDoubleIndex(o),s=0;for(let t=0;t<e;t++)s+=i[t]*r[n+1+t];r[n]=s}}toJSON(){const t=[];for(let e=0;e<this.numBlocks;e++){let i=this.blockIndexToDoubleIndex(e);const n=[e,this._data[i++]],s=[];for(let t=0;t<this._numCoordinatePerPoint;t++)s.push(this._data[i++]);n.push(s);for(let t=0;t<this._numExtraDataPerPoint;t++)n.push(this._data[i++]);t.push(n)}return t}createIndexBlockToClusterIndex(t){const e=this.numBlocks,i=new Uint32Array(e);i.fill(Mi.clusterTerminator);let n=0;for(const s of t)s>=e?n++:i[s]=n;return i}createIndexBlockToClusterStart(t){const e=t.length,i=this.numBlocks,n=new Uint32Array(i),s=Mi.clusterTerminator;n.fill(s);let r=0;for(let s=0;s<e;s++){const e=t[s];e>i?r=s+1:n[e]=r}return n}countClusters(t){let e=0;const i=Mi.clusterTerminator;for(const n of t)n===i&&e++;return e}createIndexClusterToClusterStart(t){let e=this.countClusters(t);const i=new Uint32Array(e),n=Mi.clusterTerminator;i.fill(n);const s=t.length;let r=0;for(let o=0;o<s;o++)t[o]===n?r=o+1:o===r&&(i[e++]=r);return i}sortSubsetsBySingleKey(t,e){const i=1+e;let n,s,r,o=0;const a=t.length;for(let e=0;e<a;e++)if(t[e]===Mi.clusterTerminator){for(let a=o;a+1<e;a++){s=this.getWithinBlock(t[a],i);for(let o=a+1;o<e;o++)r=this.getWithinBlock(t[o],i),r<s&&(n=t[a],t[a]=t[o],t[o]=n,s=r)}o=e+1}}static clusterPoint3dArray(t,e=J.smallMetricDistance){const i=new Mi(3,0,t.length);t.forEach((t=>{i.addDirect(t.x,t.y,t.z)}));const n=i.clusterIndicesLexical(e),s=new Oi(t.length);let r=0,o=0;return n.forEach((e=>{Mi.isClusterTerminator(e)?(r++,o=0):(0===o&&s.packedPoints.push(t[e].clone()),s.oldToNew[e]=r,o++)})),s}static clusterNumberArray(t,e=J.smallMetricDistance){const i=new Mi(1,0,t.length);t.forEach((t=>{i.addDirect(t)}));const n=i.clusterIndicesLexical(e),s=new Ni(t.length);let r=0,o=0;return n.forEach((e=>{Mi.isClusterTerminator(e)?(r++,o=0):(0===o&&s.packedNumbers.push(t[e]),s.oldToNew[e]=r,o++)})),s}static clusterGrowablePoint2dArray(t,e=J.smallMetricDistance){const i=new Mi(2,0,t.length),n=H.create(),s=t.length;for(let e=0;e<s;e++)t.getPoint2dAtUncheckedPointIndex(e,n),i.addDirect(n.x,n.y);const r=i.clusterIndicesLexical(e),o=i.countClusters(r),a=new Bi(t.length,o);let c=0,l=0;return r.forEach((e=>{Mi.isClusterTerminator(e)?(c++,l=0):(0===l&&a.growablePackedPoints.pushFromGrowableXYArray(t,e),a.oldToNew[e]=c,l++)})),a}static clusterGrowablePoint3dArray(t,e=J.smallMetricDistance){const i=new Mi(3,0,t.length),n=$.create(),s=t.length;for(let e=0;e<s;e++)t.getPoint3dAtUncheckedPointIndex(e,n),i.addDirect(n.x,n.y,n.z);const r=i.clusterIndicesLexical(e),o=new Oi(t.length),a=i.countClusters(r);o.growablePackedPoints=new rt(a);let c=0,l=0;return r.forEach((e=>{Mi.isClusterTerminator(e)?(c++,l=0):(0===l&&o.growablePackedPoints.pushFromGrowableXYZArray(t,e),o.oldToNew[e]=c,l++)})),o}}function Di(t,e){let i=0;return t.forEach(((t,n,s)=>{t<e.length?s[n]=e[t]:i++})),0===i}class Oi{packedPoints;growablePackedPoints;oldToNew;static invalidIndex=4294967295;constructor(t){this.packedPoints=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=Oi.invalidIndex}updateIndices(t){return Di(t,this.oldToNew)}}class Bi{growablePackedPoints;oldToNew;static invalidIndex=4294967295;constructor(t,e){this.growablePackedPoints=new Ee(e),this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=Bi.invalidIndex}updateIndices(t){return Di(t,this.oldToNew)}}class Ni{packedNumbers;oldToNew;static invalidIndex=4294967295;constructor(t){this.packedNumbers=[],this.oldToNew=new Uint32Array(t);for(let e=0;e<t;e++)this.oldToNew[e]=Oi.invalidIndex}updateIndices(t){return Di(t,this.oldToNew)}}!function(t){t[t.Scalar=0]="Scalar",t[t.Distance=1]="Distance",t[t.Vector=2]="Vector",t[t.Normal=3]="Normal"}(C||(C={}));class Xi{input;values;constructor(t,e){if(this.input=t,e instanceof Float64Array){this.values=[];for(const t of e)this.values.push(t)}else this.values=e}copyValues(t,e,i,n){for(let s=0;s<n;s++)this.values[e*n+s]=t.values[i*n+s]}clone(){return new Xi(this.input,this.values.slice())}isAlmostEqual(t,e){const i=e||1e-8;return Math.abs(this.input-t.input)<i&&ue.isAlmostEqual(this.values,t.values,i)}}class zi{data;dataType;name;inputName;constructor(t,e,i,n){this.data=t,this.dataType=e,this.name=i,this.inputName=n}clone(){const t=[];for(const e of this.data)t.push(e.clone());return new zi(t,this.dataType,this.name,this.inputName)}isAlmostEqual(t,e){if(this.dataType!==t.dataType||this.name!==t.name||this.inputName!==t.inputName||this.data.length!==t.data.length)return!1;for(let i=0;i<this.data.length;i++)if(!this.data[i].isAlmostEqual(t.data[i],e))return!1;return!0}static isScalar(t){return t===C.Distance||t===C.Scalar}get isScalar(){return zi.isScalar(this.dataType)}static entriesPerValue(t){return this.isScalar(t)?1:3}get entriesPerValue(){return zi.entriesPerValue(this.dataType)}get valueCount(){return 0===this.data.length?0:this.data[0].values.length/this.entriesPerValue}get scalarRange(){if(!this.isScalar)return;const t=gt.createNull();for(const e of this.data)t.extendArray(e.values);return t}computeDisplacementRange(t=1,e){if(e=ft.createNull(e),C.Vector===this.dataType)for(const i of this.data){const n=i.values;for(let i=0;i<n.length;i+=3)e.extendXYZ(n[i]*t,n[i+1]*t,n[i+2]*t)}return e}}class Li{channels;indices;constructor(t,e){this.channels=t,this.indices=e}clone(){const t=this.channels.map((t=>t.clone()));return new Li(t,this.indices.slice())}isAlmostEqual(t,e){if(!ue.isExactEqual(this.indices,t.indices)||this.channels.length!==t.channels.length)return!1;for(let i=0;i<this.channels.length;i++)if(!this.channels[i].isAlmostEqual(t.channels[i],e))return!1;return!0}static isAlmostEqual(t,e,i){return t===e||!(!t||!e)&&t.isAlmostEqual(e,i)}createForVisitor(){const t=[];for(const e of this.channels){const i=[];for(const t of e.data)i.push(new Xi(t.input,[]));t.push(new zi(i,e.dataType,e.name,e.inputName))}return new Li(t,[])}tryTransformInPlace(t){let e;const i=t.matrix,n=i.determinant(),s=Math.pow(Math.abs(n),1/3)*(n>=0?1:-1);for(const t of this.channels)for(const n of t.data)switch(t.dataType){case C.Scalar:continue;case C.Distance:for(let t=0;t<n.values.length;t++)n.values[t]*=s;break;case C.Normal:if(e=e??i.inverse(),!e)return!1;Yi(n.values,(t=>{e.multiplyTransposeVectorInPlace(t);const i=t.magnitudeSquared();if(i>1e-15&&Math.abs(i-1)>1e-15){const e=1/Math.sqrt(i);t.scaleInPlace(e)}}));break;case C.Vector:Yi(n.values,(t=>i.multiplyVectorInPlace(t)))}return!0}}function Yi(t,e){const i=new $;for(let n=0;n<t.length;n+=3)i.set(t[n],t[n+1],t[n+2]),e(i),t[n]=i.x,t[n+1]=i.y,t[n+2]=i.z}!function(t){let e,i,n;!function(t){t[t.SubdivisionSurface=-1e3]="SubdivisionSurface"}(e=t.TaggedNumericTagType||(t.TaggedNumericTagType={})),function(t){t[t.ChooseBasedOnFacets=0]="ChooseBasedOnFacets",t[t.CatmullClark=1]="CatmullClark",t[t.Loop=2]="Loop",t[t.DooSabin=3]="DooSabin"}(i=t.SubdivisionMethod||(t.SubdivisionMethod={})),function(t){t[t.FixedDepth=-100]="FixedDepth",t[t.AbsoluteTolerance=-101]="AbsoluteTolerance",t[t.FractionOfRangeBoxTolerance=-102]="FractionOfRangeBoxTolerance"}(n=t.SubdivisionControlCode||(t.SubdivisionControlCode={}))}(T||(T={}));class Vi{tagA;tagB;constructor(t=0,e=0,i,n){this.tagA=t,this.tagB=e,i&&(this.intData=i),n&&(this.doubleData=n)}intData;doubleData;pushIntPair(t,e){this.intData||(this.intData=[]),this.intData.push(t),this.intData.push(e)}pushIndexedDouble(t,e){this.intData||(this.intData=[]),this.doubleData||(this.doubleData=[]),this.intData.push(t),this.intData.push(this.doubleData.length),this.doubleData.push(e)}tagToInt(t,e,i,n){if(this.intData)for(let n=0;n+1<this.intData.length;n+=2)if(this.intData[n]===t)return Math.min(Math.max(this.intData[n+1],e),i);return n}tagToIndexedDouble(t,e,i,n){if(this.intData)for(let s=0;s+1<this.intData.length;s+=2)if(this.intData[s]===t)return J.clamp(this.getDoubleData(this.intData[s+1],n),e,i);return n}getDoubleData(t,e){return this.doubleData&&0<=t&&t<this.doubleData.length?this.doubleData[t]:e}isAlmostEqual(t){return void 0!==t&&this.tagA===t.tagA&&this.tagB===t.tagB&&J.exactEqualNumberArrays(this.intData,t.intData)&&J.almostEqualArrays(this.doubleData,t.doubleData,((t,e)=>J.isAlmostEqualNumber(t,e)))}static areAlmostEqual(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqual(e)}clone(t){return t||(t=new Vi(this.tagA,this.tagB)),this.intData&&(t.intData=this.intData.slice()),this.doubleData&&(t.doubleData=this.doubleData.slice()),t}}class Ui{static planarityLocalRelTol=1e-13;point;pointIndex;normal;normalIndex;param;paramIndex;color;colorIndex;face;auxData;taggedNumericData;edgeVisible;_twoSided;_expectedClosure;edgeMateIndex;edgeIndexToEdgeMateIndex(t){if(void 0!==t&&void 0!==this.edgeMateIndex&&t>=0&&t<this.edgeMateIndex.length)return this.edgeMateIndex[t]}isValidEdgeIndex(t){return void 0!==t&&t>=0&&t<this.pointIndex.length}constructor(t=!1,e=!1,i=!1,n=!0){this.point=new rt,this.pointIndex=[],t&&(this.normal=new rt,this.normalIndex=[]),e&&(this.param=new Ee,this.paramIndex=[]),i&&(this.color=[],this.colorIndex=[]),this.face=[],this.edgeVisible=[],this._twoSided=n,this._expectedClosure=0}clone(){const t=new Ui;return t.point=this.point.clone(),t.pointIndex=this.pointIndex.slice(),this.normal&&(t.normal=this.normal.clone()),this.normalIndex&&(t.normalIndex=this.normalIndex.slice()),this.param&&(t.param=this.param.clone()),this.paramIndex&&(t.paramIndex=this.paramIndex.slice()),this.color&&(t.color=this.color.slice()),this.colorIndex&&(t.colorIndex=this.colorIndex.slice()),t.face=this.face.slice(),this.auxData&&(t.auxData=this.auxData.clone()),this.taggedNumericData&&(t.taggedNumericData=this.taggedNumericData.clone()),t.edgeVisible=this.edgeVisible.slice(),t.twoSided=this.twoSided,t.expectedClosure=this.expectedClosure,this.edgeMateIndex&&(t.edgeMateIndex=this.edgeMateIndex.slice()),t}isAlmostEqual(t){return!!(rt.isAlmostEqual(this.point,t.point)&&ue.isExactEqual(this.pointIndex,t.pointIndex)&&rt.isAlmostEqual(this.normal,t.normal)&&ue.isExactEqual(this.normalIndex,t.normalIndex)&&Ee.isAlmostEqual(this.param,t.param)&&ue.isExactEqual(this.paramIndex,t.paramIndex)&&ue.isExactEqual(this.color,t.color)&&ue.isExactEqual(this.colorIndex,t.colorIndex)&&Li.isAlmostEqual(this.auxData,t.auxData)&&Vi.areAlmostEqual(this.taggedNumericData,t.taggedNumericData)&&ue.isExactEqual(this.edgeVisible,t.edgeVisible)&&this.twoSided===t.twoSided&&this.expectedClosure===t.expectedClosure&&ue.isExactEqual(this.edgeMateIndex,t.edgeMateIndex))}get requireNormals(){return void 0!==this.normal}get requireParams(){return void 0!==this.param}get requireColors(){return void 0!==this.color}get pointCount(){return this.point.length}get normalCount(){return this.normal?this.normal.length:0}get paramCount(){return this.param?this.param.length:0}get colorCount(){return this.color?this.color.length:0}get indexCount(){return this.pointIndex.length}get faceCount(){return this.face.length}getPoint(t,e){return this.point.getPoint3dAtCheckedPointIndex(t,e)}getNormal(t,e){return this.normal?this.normal.getVector3dAtCheckedVectorIndex(t,e):void 0}getParam(t,e){return this.param?this.param.getPoint2dAtCheckedPointIndex(t,e):void 0}getColor(t){return this.color?this.color[t]:0}getEdgeVisible(t){return this.edgeVisible[t]}get twoSided(){return this._twoSided}set twoSided(t){this._twoSided=t}get expectedClosure(){return this._expectedClosure}set expectedClosure(t){this._expectedClosure=t}setTaggedNumericData(t){this.taggedNumericData=t}copyPointTo(t,e){this.point.getPoint3dAtUncheckedPointIndex(t,e)}copyNormalTo(t,e){this.normal&&this.normal.getVector3dAtUncheckedVectorIndex(t,e)}copyParamTo(t,e){this.param&&this.param.getPoint2dAtUncheckedPointIndex(t,e)}isAlmostEqualParamIndexUV(t,e,i){return void 0!==this.param&&t>=0&&t<this.param.length&&J.isSameCoordinate(e,this.param.getXAtUncheckedPointIndex(t))&&J.isSameCoordinate(i,this.param.getYAtUncheckedPointIndex(t))}gatherIndexedData(t,e,i,n){const s=i-e;n>s&&(n=s);const r=s+n;this.resizeAllArrays(r);for(let i=0;i<s;i++)this.point.transferFromGrowableXYZArray(i,t.point,t.pointIndex[e+i]);for(let t=0;t<n;t++)this.point.transferFromGrowableXYZArray(s+t,this.point,t);for(let i=0;i<s;i++)this.pointIndex[i]=t.pointIndex[e+i];for(let t=0;t<n;t++)this.pointIndex[s+t]=this.pointIndex[t];if(this.normal&&this.normalIndex&&t.normal&&t.normalIndex){for(let i=0;i<s;i++)this.normal.transferFromGrowableXYZArray(i,t.normal,t.normalIndex[e+i]);for(let t=0;t<n;t++)this.normal.transferFromGrowableXYZArray(s+t,this.normal,t);for(let i=0;i<s;i++)this.normalIndex[i]=t.normalIndex[e+i];for(let t=0;t<n;t++)this.normalIndex[s+t]=this.normalIndex[t]}if(this.param&&this.paramIndex&&t.param&&t.paramIndex){for(let i=0;i<s;i++)this.param.transferFromGrowableXYArray(i,t.param,t.paramIndex[e+i]);for(let t=0;t<n;t++)this.param.transferFromGrowableXYArray(s+t,this.param,t);for(let i=0;i<s;i++)this.paramIndex[i]=t.paramIndex[e+i];for(let t=0;t<n;t++)this.paramIndex[s+t]=this.paramIndex[t]}if(this.color&&this.colorIndex&&t.color&&t.colorIndex){for(let i=0;i<s;i++)this.color[i]=t.color[t.colorIndex[e+i]];for(let t=0;t<n;t++)this.color[s+t]=this.color[t];for(let i=0;i<s;i++)this.colorIndex[i]=t.colorIndex[e+i];for(let t=0;t<n;t++)this.colorIndex[s+t]=this.colorIndex[t]}for(let i=0;i<s;i++)this.edgeVisible[i]=t.edgeVisible[e+i];for(let t=0;t<n;t++)this.edgeVisible[s+t]=this.edgeVisible[t];if(this.auxData&&t.auxData&&this.auxData.channels.length===t.auxData.channels.length){for(let i=0;i<this.auxData.channels.length;i++){const r=this.auxData.channels[i],o=t.auxData.channels[i],a=r.entriesPerValue;if(r.data.length===o.data.length)for(let i=0;i<r.data.length;i++){const c=r.data[i],l=o.data[i];for(let i=0;i<s;i++)c.copyValues(l,i,t.auxData.indices[e+i],a);for(let e=0;e<n;e++)c.copyValues(c,t.auxData.indices[s+e],e,a)}}for(let i=0;i<s;i++)this.auxData.indices[i]=t.auxData.indices[e+i];for(let t=0;t<n;t++)this.auxData.indices[s+t]=this.auxData.indices[t]}if(this.edgeMateIndex&&t.edgeMateIndex){for(let i=0;i<s;i++)this.edgeMateIndex[i]=t.edgeMateIndex[e+i];for(let t=0;t<n;t++)this.edgeMateIndex[s+t]=this.edgeMateIndex[t]}}static trimArray(t,e){t&&e<t.length&&(t.length=e)}trimAllIndexArrays(t){if(Ui.trimArray(this.pointIndex,t),Ui.trimArray(this.paramIndex,t),Ui.trimArray(this.normalIndex,t),Ui.trimArray(this.colorIndex,t),Ui.trimArray(this.edgeVisible,t),this.auxData){Ui.trimArray(this.auxData.indices,t);for(const e of this.auxData.channels)for(const i of e.data)Ui.trimArray(i.values,e.entriesPerValue*t)}Ui.trimArray(this.edgeMateIndex,t)}resizeAllArrays(t){if(t>this.point.length){for(;this.point.length<t;)this.point.push($.create());for(;this.pointIndex.length<t;)this.pointIndex.push(-1);if(this.normal)for(;this.normal.length<t;)this.normal.push(tt.create());if(this.normalIndex)for(;this.normalIndex.length<t;)this.normalIndex.push(-1);if(this.param)for(;this.param.length<t;)this.param.push(H.create());if(this.paramIndex)for(;this.paramIndex.length<t;)this.paramIndex.push(-1);if(this.color)for(;this.color.length<t;)this.color.push(0);if(this.colorIndex)for(;this.colorIndex.length<t;)this.colorIndex.push(-1);for(;this.edgeVisible.length<t;)this.edgeVisible.push(!1);if(this.auxData){for(const e of this.auxData.channels)for(const i of e.data)for(;i.values.length<t*e.entriesPerValue;)i.values.push(0);this.auxData.indices&&this.auxData.indices.push(-1)}if(this.edgeMateIndex)for(;this.edgeMateIndex.length<t;)this.edgeMateIndex.push(void 0)}else if(t<this.point.length){if(this.point.resize(t),this.pointIndex.length=t,this.normal&&this.normal.resize(t),this.normalIndex&&(this.normalIndex.length=t),this.param&&this.param.resize(t),this.paramIndex&&(this.paramIndex.length=t),this.color&&(this.color.length=t),this.colorIndex&&(this.colorIndex.length=t),this.edgeVisible.length=t,this.auxData){for(const e of this.auxData.channels)for(const i of e.data)i.values.length=t*e.entriesPerValue;this.auxData.indices&&(this.auxData.indices.length=t)}this.edgeMateIndex&&(this.edgeMateIndex.length=t)}}resizeAllDataArrays(t){if(t>this.point.length){for(;this.point.length<t;)this.point.push($.create());for(;this.pointIndex.length<t;)this.pointIndex.push(-1);for(;this.edgeVisible.length<t;)this.edgeVisible.push(!1);if(this.normal)for(;this.normal.length<t;)this.normal.push(tt.create());if(this.param)for(;this.param.length<t;)this.param.push(H.create());if(this.color)for(;this.color.length<t;)this.color.push(0);if(this.auxData)for(const e of this.auxData.channels)for(const i of e.data)for(;i.values.length<t*e.entriesPerValue;)i.values.push(0)}else if(t<this.point.length&&(this.point.resize(t),this.edgeVisible.length=t,this.pointIndex.length=t,this.normal&&this.normal.resize(t),this.param&&this.param.resize(t),this.color&&(this.color.length=t),this.auxData))for(const e of this.auxData.channels)for(const i of e.data)i.values.length=t*e.entriesPerValue}range(t,e){return(t=t||ft.createNull()).extendArray(this.point,e),t}tryTransformInPlace(t){if(this.point.multiplyTransformInPlace(t),this.normal&&!t.matrix.isIdentity&&this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(t.matrix),this.face.length>0){const e=Math.cbrt(Math.abs(t.matrix.determinant()));for(const t of this.face)t.scaleDistances(e)}return this.auxData&&this.auxData.tryTransformInPlace(t),!0}compress(t=J.smallMetricDistance){const e=Mi.clusterGrowablePoint3dArray(this.point,t);if(this.point=e.growablePackedPoints,e.updateIndices(this.pointIndex),this.normalIndex&&this.normal){const t=Mi.clusterGrowablePoint3dArray(this.normal);this.normal=t.growablePackedPoints,t.updateIndices(this.normalIndex)}if(this.paramIndex&&this.param){const t=Mi.clusterGrowablePoint2dArray(this.param);this.param=t.growablePackedPoints,t.updateIndices(this.paramIndex)}if(this.colorIndex&&this.color){const t=Mi.clusterNumberArray(this.color);this.color=t.packedNumbers,t.updateIndices(this.colorIndex)}if(this.auxData&&1===this.auxData.channels.length&&1===this.auxData.channels[0].data.length){const t=this.auxData.channels[0].entriesPerValue;if(1===t){const t=Mi.clusterNumberArray(this.auxData.channels[0].data[0].values);this.auxData.channels[0].data[0].values=t.packedNumbers,t.updateIndices(this.auxData.indices)}else if(3===t){const t=rt.create(this.auxData.channels[0].data[0].values),e=Mi.clusterGrowablePoint3dArray(t);this.auxData.channels[0].data[0].values=ue.create(e.growablePackedPoints.float64Data()),e.updateIndices(this.auxData.indices)}}}static isValidFacetStartIndexArray(t){if(0===t.length)return!1;for(let e=0;e+1<t.length;e++)if(t[e]>=t[e+1])return!1;return!0}static reverseIndices(t,e,i){if(!e||0===e.length)return!0;if(e.length>0&&t[t.length-1]===e.length){for(let n=0;n+1<t.length;n++){let s=t[n],r=t[n+1];if(i)for(;r>s+2;){r--,s++;const t=e[s];e[s]=e[r],e[r]=t}else for(;r>s+1;){r--;const t=e[s];e[s]=e[r],e[r]=t,s++}}return!0}return!1}static reverseIndicesSingleFacet(t,e,i,n){if(!i||0===i.length)return!0;if(i.length>0&&e[e.length-1]===i.length&&t>=0&&t+1<e.length){let s=e[t],r=e[t+1];if(n)for(;r>s+2;){r--,s++;const t=i[s];i[s]=i[r],i[r]=t}else for(;r>s+1;){r--;const t=i[s];i[s]=i[r],i[r]=t,s++}return!0}return!1}reverseIndices(t){t&&Ui.isValidFacetStartIndexArray(t)&&(Ui.reverseIndices(t,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Ui.reverseIndices(t,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Ui.reverseIndices(t,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Ui.reverseIndices(t,this.colorIndex,!0),Ui.reverseIndices(t,this.edgeVisible,!1))}reverseIndicesSingleFacet(t,e){Ui.reverseIndicesSingleFacet(t,e,this.pointIndex,!0),this.normalIndex!==this.pointIndex&&Ui.reverseIndicesSingleFacet(t,e,this.normalIndex,!0),this.paramIndex!==this.pointIndex&&Ui.reverseIndicesSingleFacet(t,e,this.paramIndex,!0),this.colorIndex!==this.pointIndex&&Ui.reverseIndicesSingleFacet(t,e,this.colorIndex,!0),Ui.reverseIndicesSingleFacet(t,e,this.edgeVisible,!1)}reverseNormals(){this.normal&&this.normal.scaleInPlace(-1)}}class qi extends Ui{_currentFacetIndex;_nextFacetIndex;_numWrap;_numEdges;_polyface;constructor(t,e){super(t.data.normalCount>0,t.data.paramCount>0,t.data.colorCount>0,t.twoSided),this._polyface=t,this._numWrap=e,t.data.auxData&&(this.auxData=t.data.auxData.createForVisitor()),t.data.edgeMateIndex&&(this.edgeMateIndex=[]),this._numEdges=0,this._nextFacetIndex=0,this._currentFacetIndex=-1,this.reset()}clientPolyface(){return this._polyface}getVisitableFacetCount(){return this._polyface.facetCount}setNumWrap(t){this._numWrap=t}get numEdgesThisFacet(){return this._numEdges}static create(t,e){return new qi(t,e)}moveToReadIndex(t){if(!this._polyface.isValidFacetIndex(t))return!1;const e=this._polyface.numEdgeInFacet(t);return this._currentFacetIndex===t&&e+this._numWrap===this.pointCount||(this._currentFacetIndex=t,this._numEdges=e,this.resizeAllArrays(this._numEdges+this._numWrap),this.gatherIndexedData(this._polyface.data,this._polyface.facetIndex0(this._currentFacetIndex),this._polyface.facetIndex1(this._currentFacetIndex),this._numWrap)),this._nextFacetIndex=t+1,!0}moveToNextFacet(){return this._nextFacetIndex!==this._currentFacetIndex?this.moveToReadIndex(this._nextFacetIndex):(this._nextFacetIndex++,!0)}reset(){this.moveToReadIndex(0),this._nextFacetIndex=0}tryGetDistanceParameter(t,e){if(t<0||t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}tryGetNormalizedParameter(t,e){if(t<0||t>=this.numEdgesThisFacet)return;if(void 0===this.param||0===this._polyface.data.face.length)return;const i=this._polyface.tryGetFaceData(this._currentFacetIndex);return i?i.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(t),this.param.getYAtUncheckedPointIndex(t),e):void 0}currentReadIndex(){return this._currentFacetIndex}clientPointIndex(t){return this.pointIndex[t]}clientParamIndex(t){return this.paramIndex?this.paramIndex[t]:-1}clientNormalIndex(t){return this.normalIndex?this.normalIndex[t]:-1}clientColorIndex(t){return this.colorIndex?this.colorIndex[t]:-1}clientAuxIndex(t){return this.auxData?this.auxData.indices[t]:-1}clearArrays(){this.point.length=0,this.edgeVisible.length=0,void 0!==this.param&&(this.param.length=0),void 0!==this.normal&&(this.normal.length=0),void 0!==this.color&&(this.color.length=0)}pushDataFrom(t,e){this.point.pushFromGrowableXYZArray(t.point,e),this.edgeVisible.push(t.edgeVisible[e]),this.param&&t.param&&e<t.param.length&&this.param.pushFromGrowableXYArray(t.param,e),this.normal&&t.normal&&e<t.normal.length&&this.normal.pushFromGrowableXYZArray(t.normal,e),this.color&&t.color&&e<t.color.length&&this.color.push(t.color[e])}pushInterpolatedDataFrom(t,e,i,n){e>n&&this.pushInterpolatedDataFrom(t,n,1-i,e),this.point.pushInterpolatedFromGrowableXYZArray(t.point,e,i,n);const s=(e+1)%t.edgeVisible.length===n&&t.edgeVisible[e];this.edgeVisible.push(s),this.param&&t.param&&e<t.param.length&&n<t.param.length&&this.param.pushInterpolatedFromGrowableXYArray(t.param,e,i,n),this.normal&&t.normal&&e<t.normal.length&&n<t.normal.length&&this.normal.pushInterpolatedFromGrowableXYZArray(t.normal,e,i,n),this.color&&t.color&&e<t.color.length&&n<t.color.length&&this.color.push(J.interpolateColor(t.color[e],i,t.color[n]))}createSubsetVisitor(t,e=0){return Zi.createSubsetVisitor(this._polyface,t,e)}}class Zi extends qi{_facetIndices;_currentSubsetIndex;_nextSubsetIndex;constructor(t,e,i){super(t,i),this._facetIndices=e.slice(),this._currentSubsetIndex=-1,this._nextSubsetIndex=0,this.reset()}isValidSubsetIndex(t){return t>=0&&t<this._facetIndices.length}static createSubsetVisitor(t,e,i=0){return new Zi(t,e,i)}moveToReadIndex(t){return!!this.isValidSubsetIndex(t)&&(this._currentSubsetIndex=t,this._nextSubsetIndex=t+1,super.moveToReadIndex(this._facetIndices[t]))}moveToNextFacet(){return this._nextSubsetIndex!==this._currentSubsetIndex?this.moveToReadIndex(this._nextSubsetIndex):(this._nextSubsetIndex++,!0)}reset(){this._facetIndices&&(this.moveToReadIndex(0),this._nextSubsetIndex=0)}parentFacetIndex(t){return void 0===t&&(t=this._currentSubsetIndex),this.isValidSubsetIndex(t)?this._facetIndices[t]:void 0}getVisitableFacetCount(){return this._facetIndices.length}static createNormalComparison(t,e=tt.unitZ(),i=G.createSmallAngle(),n=0){if(t instanceof Qi)return this.createNormalComparison(t.createVisitor(),e,i,n);const s=t,r=[],o=tt.createZero();for(s.reset();s.moveToNextFacet();)zr.unitNormal(s.point,o)&&(o.dotProduct(e)<0||o.angleFromPerpendicular(e).isMagnitudeLessThanOrEqual(i)||r.push(s.currentReadIndex()));return Zi.createSubsetVisitor(s.clientPolyface(),r,n)}}class Wi{_paramDistanceRange;_paramRange;get paramDistanceRange(){return this._paramDistanceRange}get paramRange(){return this._paramRange}constructor(t,e){this._paramDistanceRange=t,this._paramRange=e}static createNull(){return new Wi(pt.createNull(),pt.createNull())}clone(t){return t?(this._paramDistanceRange.clone(t._paramDistanceRange),this._paramRange.clone(t._paramRange),t):new Wi(this._paramDistanceRange.clone(),this._paramRange.clone())}setNull(){this._paramDistanceRange.setNull(),this._paramRange.setNull()}convertParamXYToDistance(t,e,i){i=i||H.create();const n=this._paramRange.high.minus(this._paramRange.low);return i.x=0===n.x?t:this._paramDistanceRange.low.x+(t-this._paramRange.low.x)*(this._paramDistanceRange.high.x-this._paramDistanceRange.low.x)/n.x,i.y=0===n.y?e:this.paramDistanceRange.low.y+(e-this._paramRange.low.y)*(this._paramDistanceRange.high.y-this._paramDistanceRange.low.y)/n.y,i}convertParamXYToNormalized(t,e,i){i=i||H.create();const n=this._paramRange.high.minus(this._paramRange.low);return i.x=0===n.x?t:(t-this._paramRange.low.x)/n.x,i.y=0===n.y?e:(e-this._paramRange.low.y)/n.y,i}convertParamToDistance(t,e){return this.convertParamXYToDistance(t.x,t.y,e)}convertParamToNormalized(t,e){return this.convertParamXYToNormalized(t.x,t.y,e)}scaleDistances(t){this._paramDistanceRange.low.x*=t,this._paramDistanceRange.low.y*=t,this._paramDistanceRange.high.x*=t,this._paramDistanceRange.high.y*=t}setParamDistanceRangeFromNewFaceData(t,e,i){const n=H.create(),s=H.create();this.setNull();let r=0;const o=qi.create(t,0);if(!o.moveToReadIndex(e)||i<=e)return!1;do{const t=o.numEdgesThisFacet,e=o.point,i=[],a=o.param,c=[];if(!a)return!1;a.extendRange(this._paramRange);const l=j.create(),h=j.create();for(let o=0;o<t;o++){if(i[2]=o,c[2]=o,o>1){a.vectorIndexIndex(c[1],c[0],l),a.vectorIndexIndex(c[1],c[2],h);const t=e.getPoint3dAtUncheckedPointIndex(i[0]).minus(e.getPoint3dAtUncheckedPointIndex(i[1])),o=e.getPoint3dAtUncheckedPointIndex(i[1]).minus(e.getPoint3dAtUncheckedPointIndex(i[2])),d=Math.abs(l.x*h.y-h.x*l.y);if(d){const e=$.createFrom(t);e.scaleInPlace(h.y),e.addScaledInPlace(o,-l.y);const i=$.createFrom(o);i.scaleInPlace(l.x),i.addScaledInPlace(t,-h.x);const a=H.create(e.magnitude()/d,i.magnitude()/d);n.x+=a.x,n.y+=a.y,s.x+=a.x*a.x,s.y+=a.y*a.y,r++}}c[0]=c[1],c[1]=c[2],i[0]=i[1],i[1]=i[2]}}while(o.moveToNextFacet()&&o.currentReadIndex()<i);if(0!==r){const t=H.create(n.x/r,n.y/r),e=H.create(Math.sqrt(Math.abs(s.x/r-t.x*t.x)),Math.sqrt(Math.abs(s.y/r-t.y*t.y)));this._paramDistanceRange.low.set(0,0),this._paramDistanceRange.high.set((t.x+e.x)*(this._paramRange.high.x-this._paramRange.low.x),(t.y+e.y)*(this._paramRange.high.y-this._paramRange.low.y))}return!0}}class Gi extends zt{geometryCategory="polyface";data;constructor(t){super(),this.data=t}get twoSided(){return this.data.twoSided}set twoSided(t){this.data.twoSided=t}get expectedClosure(){return this.data.expectedClosure}set expectedClosure(t){this.data.expectedClosure=t}static areIndicesValid(t,e,i,n,s){if(void 0===t&&void 0===n)return!0;if(void 0===t||void 0===n)return!1;if(e<0||e>=t.length)return!1;if(i<=e||i>t.length)return!1;for(let n=e;n<i;n++)if(t[n]<0||t[n]>=s)return!1;return!0}get facetCount(){}}class Qi extends Gi{_facetStart;_facetToFaceData;constructor(t,e,i){super(t),e?this._facetStart=e.slice():(this._facetStart=[],this._facetStart.push(0)),this._facetToFaceData=i?i.slice():[]}edgeIndexToFacetIndex(t){if(void 0!==t)return ue.searchStrictlyIncreasingNumbers(this._facetStart,t)}edgeIndexToFaceLoop(t){const e=this.edgeIndexToFacetIndex(t);if(void 0!==e)return gt.createXX(this.facetIndex0(e),this.facetIndex1(e))}isSameGeometryClass(t){return t instanceof Qi}isAlmostEqual(t){return t instanceof Qi&&this.data.isAlmostEqual(t.data)&&ue.isExactEqual(this._facetStart,t._facetStart)&&ue.isExactEqual(this._facetToFaceData,t._facetToFaceData)}get isEmpty(){return 0===this.data.pointCount||0===this.data.pointIndex.length}tryTransformInPlace(t){return this.data.tryTransformInPlace(t),t.matrix.determinant()<0&&this.reverseIndices(),!0}reverseSingleFacet(t){this.data.reverseIndicesSingleFacet(t,this._facetStart)}clone(){return new Qi(this.data.clone(),this._facetStart.slice(),this._facetToFaceData.slice())}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}reverseIndices(){this.data.reverseIndices(this._facetStart)}reverseNormals(){this.data.reverseNormals()}tryGetFaceData(t){if(t<0||t>=this._facetToFaceData.length)return;const e=this._facetToFaceData[t];return e<0||e>=this.data.face.length?void 0:this.data.face[e]}addIndexedPolyface(t,e,i){const n=t.facetCount,s=this.data.point.length,r=$.create();for(let e=0;e<t.data.point.length;e++)t.data.point.getPoint3dAtUncheckedPointIndex(e,r),i?(i.multiplyPoint3d(r,r),this.addPoint(r)):this.addPoint(r);for(let i=0;i<n;i++){const n=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >n;)this.addPointIndex(s+t.data.pointIndex[e],t.data.edgeVisible[e>n?e-1:r-1]);else for(let e=n;e<r;e++)this.addPointIndex(s+t.data.pointIndex[e],t.data.edgeVisible[e]);this.terminateFacet(!1)}if(void 0!==this.data.param&&void 0!==t.data.param&&void 0!==t.data.paramIndex){const i=this.data.param.length;this.data.param.pushFromGrowableXYArray(t.data.param);for(let s=0;s<n;s++){const n=t._facetStart[s],r=t._facetStart[s+1];if(e)for(let e=r;e-- >n;)this.addParamIndex(i+t.data.paramIndex[e]);else for(let e=n;e<r;e++)this.addParamIndex(i+t.data.paramIndex[e])}}if(void 0!==this.data.normal&&void 0!==t.data.normal&&void 0!==t.data.normalIndex){const s=this.data.normal.length;for(let n=0;n<t.data.normal.length;n++){const s=t.data.normal.getVector3dAtCheckedVectorIndex(n);i&&i.multiplyVector(s,s),e&&s.scaleInPlace(-1),this.addNormal(s)}for(let i=0;i<n;i++){const n=t._facetStart[i],r=t._facetStart[i+1];if(e)for(let e=r;e-- >n;)this.addNormalIndex(s+t.data.normalIndex[e]);else for(let e=n;e<r;e++)this.addNormalIndex(s+t.data.normalIndex[e])}}if(void 0!==this.data.color&&void 0!==t.data.color&&void 0!==t.data.colorIndex){const i=this.data.color.length;for(const e of t.data.color)this.addColor(e);for(let s=0;s<n;s++){const n=t._facetStart[s],r=t._facetStart[s+1];if(e)for(let e=r;e-- >n;)this.addColorIndex(i+t.data.colorIndex[e]);else for(let e=n;e<r;e++)this.addColorIndex(i+t.data.colorIndex[e])}}if(0!==t.data.face.length){const e=this.data.face.length;for(const e of t.data.face){const t=e.clone();this.data.face.push(t)}for(const i of t._facetToFaceData)this._facetToFaceData.push(e+i)}}get zeroTerminatedIndexCount(){return this.data.pointIndex.length+this._facetStart.length-1}static create(t=!1,e=!1,i=!1,n=!0){return new Qi(new Ui(t,e,i,n))}addPoint(t,e){if(void 0!==e){const i=this.data.point.distanceIndexToPoint(e,t);if(void 0!==i&&J.isSmallMetricDistance(i))return e}return this.data.point.pushXYZ(t.x,t.y,t.z),this.data.point.length-1}addPointXYZ(t,e,i){return this.data.point.pushXYZ(t,e,i),this.data.point.length-1}addParam(t){return this.data.param||(this.data.param=new Ee),this.data.param.push(t),this.data.param.length-1}addParamUV(t,e,i,n){return this.data.param||(this.data.param=new Ee),void 0!==i&&this.data.isAlmostEqualParamIndexUV(i,t,e)?i:void 0!==n&&this.data.isAlmostEqualParamIndexUV(n,t,e)?n:(this.data.param.pushXY(t,e),this.data.param.length-1)}addNormal(t,e,i){const n=e=>{const i=this.data.normal.distanceIndexToPoint(e,t);return void 0!==i&&J.isSmallMetricDistance(i)};if(void 0!==this.data.normal){if(void 0!==e&&n(e))return e;if(void 0!==i&&n(i))return i;if(void 0!==e||void 0!==i){const t=this.data.normal.length-1;if(n(t))return t}}return this.addNormalXYZ(t.x,t.y,t.z)}addNormalXYZ(t,e,i){return this.data.normal||(this.data.normal=new rt),this.data.normal.pushXYZ(t,e,i),this.data.normal.length-1}addColor(t){return this.data.color||(this.data.color=[]),this.data.color.push(t),this.data.color.length-1}addPointIndex(t,e=!0){this.data.pointIndex.push(t),this.data.edgeVisible.push(e)}addNormalIndex(t){this.data.normalIndex||(this.data.normalIndex=[]),this.data.normalIndex.push(t)}addParamIndex(t){this.data.paramIndex||(this.data.paramIndex=[]),this.data.paramIndex.push(t)}addColorIndex(t){this.data.colorIndex||(this.data.colorIndex=[]),this.data.colorIndex.push(t)}cleanupOpenFacet(){this.data.trimAllIndexArrays(this.data.pointIndex.length)}validateAllIndices(t=0,e){const i=this.data.pointIndex.length,n=e??[];return 0===i?(n.push("empty pointIndex array"),!1):t<0||t>=i?(n.push("invalid input offset"),!1):(this.data.normalIndex&&this.data.normalIndex.length!==i&&n.push("normalIndex count must match pointIndex count"),this.data.paramIndex&&this.data.paramIndex.length!==i&&n.push("paramIndex count must equal pointIndex count"),this.data.colorIndex&&this.data.colorIndex.length!==i&&n.push("colorIndex count must equal pointIndex count"),this.data.edgeVisible.length!==i&&n.push("visibleIndex count must equal pointIndex count"),Gi.areIndicesValid(this.data.pointIndex,t,i,this.data.point,this.data.point?this.data.point.length:0)||n.push("invalid point index encountered"),Gi.areIndicesValid(this.data.normalIndex,t,i,this.data.normal,this.data.normal?this.data.normal.length:0)||n.push("invalid normal index encountered"),Gi.areIndicesValid(this.data.paramIndex,t,i,this.data.param,this.data.param?this.data.param.length:0)||n.push("invalid param index encountered"),Gi.areIndicesValid(this.data.colorIndex,t,i,this.data.color,this.data.color?this.data.color.length:0)||n.push("invalid color index encountered"),this.data.edgeMateIndex&&(this.data.edgeMateIndex.length!==i?n.push("edgeMateIndex count must equal pointIndex count"):this.data.edgeMateIndex.every((t=>void 0===t||this.data.isValidEdgeIndex(t)))||n.push("invalid edgeMate encountered")),0===n.length)}terminateFacet(t=!0){const e=this._facetStart.length-1,i=this._facetStart[e],n=this.data.pointIndex.length;if(t){const t=[];if(n<i+2&&t.push("Less than 3 indices in the last facet"),this.validateAllIndices(i,t),t.length>0)return this.data.trimAllIndexArrays(i),t}this._facetStart.push(n)}get facetCount(){return this._facetStart.length-1}get faceCount(){return this.data.faceCount}get pointCount(){return this.data.pointCount}get colorCount(){return this.data.colorCount}get paramCount(){return this.data.paramCount}get normalCount(){return this.data.normalCount}isValidFacetIndex(t){return t>=0&&t<this.facetCount}numEdgeInFacet(t){return this.isValidFacetIndex(t)?this._facetStart[t+1]-this._facetStart[t]:0}facetIndex0(t){return this._facetStart[t]}facetIndex1(t){return this._facetStart[t+1]}get facetStart(){return this._facetStart}createVisitor(t=0){return qi.create(this,t)}range(t,e){return this.data.range(e,t)}extendRange(t,e){this.data.range(t,e)}getFaceDataByFacetIndex(t){return this.data.face[this._facetToFaceData[t]]}setNewFaceData(t=0){const e=this._facetToFaceData.length;if(e>=this._facetStart.length)return!1;0===t&&(t=this._facetStart.length);const i=Wi.createNull(),n=qi.create(this,0);if(!n.moveToReadIndex(e))return!1;const s=void 0!==this.data.param,r=i.paramRange.isNull&&s;do{r&&void 0!==n.param&&n.param.extendRange(i.paramRange)}while(n.moveToNextFacet()&&n.currentReadIndex()<t);s&&0!==this.data.param.length&&i.paramDistanceRange.isNull&&i.setParamDistanceRangeFromNewFaceData(this,e,t),this.data.face.push(i);const o=this.data.face.length-1;for(let e=this._facetToFaceData.length;e<t;e++)this._facetToFaceData.push(0===this._facetStart[e]?0:o);return!0}dispatchToGeometryHandler(t){return t.handleIndexedPolyface(this)}static hasEdgeMateIndex(t){let e;if(t instanceof Gi?t instanceof Qi&&(e=t):t.clientPolyface()&&t.clientPolyface()instanceof Qi&&(e=t.clientPolyface()),e){const t=e.data.edgeMateIndex;if(t&&t.length>0&&t.length===e.data.indexCount)return{parent:e,edgeMateIndex:t}}}}class Hi{_vectorU;_vectorV;_point0;_point1;_tolerance;get tolerance(){return this._tolerance}constructor(t=J.smallMetricDistance){this._tolerance=t}static create(t=J.smallMetricDistance){return new Hi(t)}static assignDetailInterpolatedFractionsAndPoints(t,e,i,n,s,r=!1){r?(t.fraction=i,t.fraction1=e):(t.fraction=e,t.fraction1=i),t.point=n.interpolate(t.fraction,s,t.point),t.point1=n.interpolate(t.fraction1,s,t.point1)}projectPointToSegmentXY(t,e,i){this._vectorU=tt.createStartEnd(e,i,this._vectorU),this._vectorV=tt.createStartEnd(e,t,this._vectorV);const n=this._vectorU.dotProductXY(this._vectorU),s=this._vectorU.dotProductXY(this._vectorV),r=J.safeDivideFraction(s,n,0);return Pt.createCurveFractionPoint(void 0,r,e.interpolate(r,i))}clampCoincidentOverlapToSegmentBounds(t,e,i,n,s,r=!1,o=!1,a=!1,c=!1){const l=De.create(t.detailA.fraction,t.detailA.hasFraction1?t.detailA.fraction1:t.detailA.fraction),h=De.create(t.detailB.fraction,t.detailB.hasFraction1?t.detailB.fraction1:t.detailB.fraction),d=l.signedDelta()<0,u=()=>{const r=l.x0,o=l.x1,a=h.x0,c=h.x1;return Hi.assignDetailInterpolatedFractionsAndPoints(t.detailA,r,o,e,i,r>o),Hi.assignDetailInterpolatedFractionsAndPoints(t.detailB,a,c,n,s,a>c),t},f=l.clampDirectedTo01(!r,!o,!1),g=h.clampDirectedTo01(!a,!c,!1);if(f&&g){if(J.isAlmostEqualNumber(l.absoluteDelta(),h.absoluteDelta(),J.smallFraction))return u();if(l.clampDirectedTo01(!0,!0,!1)&&h.clampDirectedTo01(!0,!0,!1))return u()}const p=(e,i,n,s)=>(e.clone(t.detailA.point),i.clone(t.detailB.point),t.detailA.fraction=n?0:1,t.detailB.fraction=s?0:1,t.detailA.collapseToStart(),t.detailB.collapseToStart(),t),m=l.clampDirectedTo01(!0,!0,!0),_=h.clampDirectedTo01(!0,!0,!0);if(m&&_){const r=t.detailA.point1??t.detailA.point;if(d){if(t.detailA.point.isAlmostEqual(e,this.tolerance))return p(e,n,!0,!0);if(r.isAlmostEqual(i,this.tolerance))return p(i,s,!1,!1)}else{if(r.isAlmostEqual(e,this.tolerance))return p(e,s,!0,!1);if(t.detailA.point.isAlmostEqual(i,this.tolerance))return p(i,n,!1,!0)}}}coincidentSegmentRangeXY(t,e,i,n,s=!0){const r=this.projectPointToSegmentXY(t,i,n);if(t.distanceXY(r.point)>this._tolerance)return;const o=this.projectPointToSegmentXY(e,i,n);if(e.distanceXY(o.point)>this._tolerance)return;const a=this.projectPointToSegmentXY(i,t,e);if(i.distanceXY(a.point)>this._tolerance)return;const c=this.projectPointToSegmentXY(n,t,e);if(n.distanceXY(c.point)>this._tolerance)return;r.fraction1=o.fraction,r.point1=o.point,a.fraction1=c.fraction,a.point1=c.point;const l=It.createCapture(a,r);return s?this.clampCoincidentOverlapToSegmentBounds(l,t,e,i,n):l}createDetailPair(t,e,i,n,s,r){const o=s-n,a=J.conditionalDivideFraction(i.x0-n,o),c=J.conditionalDivideFraction(i.x1-n,o);if(void 0!==a&&void 0!==c){const n=Pt.createCurveEvaluatedFractionFraction(t,i.x0,i.x1),s=Pt.createCurveEvaluatedFractionFraction(e,a,c);return r&&n.swapFractionsAndPoints(),It.createCapture(n,s)}}appendDetailPair(t,e){return void 0===e?t:void 0===t?[e]:(t.push(e),t)}coincidentArcIntersectionXY(t,e,i=!0){let n;if(t.center.isAlmostEqual(e.center,this.tolerance)){const i=t.matrixRef.multiplyMatrixInverseMatrix(e.matrixRef);if(i){const s=i.at(0,0),r=i.at(1,0),o=i.at(0,1),a=i.at(1,1),c=J.hypotenuseXY(s,r),l=J.hypotenuseXY(o,a),h=J.dotProductXYXY(s,r,o,a),d=J.crossProductXYXY(s,r,o,a);if(J.isAlmostEqualNumber(c,1)&&J.isAlmostEqualNumber(l,1)&&J.isAlmostEqualNumber(0,h)){const i=Math.atan2(r,s),o=d>0?1:-1,a=i+o*e.sweep.startRadians,c=i+o*e.sweep.endRadians,l=o*t.sweep.sweepRadians*e.sweep.sweepRadians<0,h=St.createStartEndRadians(a,c),u=t.sweep,f=u.fractionPeriod(),g=u.radiansToPositivePeriodicFraction(h.startRadians),p=g+h.sweepRadians/u.sweepRadians,m=(i,s)=>{const r=n?n.length:0,o=i.x0,a=i.x1;if(i.clampDirectedTo01()&&!J.isSmallRelative(i.absoluteDelta()))n=this.appendDetailPair(n,this.createDetailPair(t,e,i,o,a,l));else{const i=l?s:!s,r=this._point0=s?t.startPoint(this._point0):t.endPoint(this._point0),o=this._point1=i?e.startPoint(this._point1):e.endPoint(this._point1);if(r.isAlmostEqual(o,this.tolerance)){const a=Pt.createCurveFractionPoint(t,s?0:1,r),c=Pt.createCurveFractionPoint(e,i?0:1,o);n=this.appendDetailPair(n,It.createCapture(a,c))}}return void 0!==n&&n.length>r};m(De.create(g,p),!1),p>=f?m(De.create(g-f,p-f),!0):0===g&&m(De.create(g+f,p+f),!0)}}}return n}}class ji extends Se{_extendA0;_extendA1;_geometryB;_extendB0;_extendB1;_results;_worldToLocalPerspective;_worldToLocalAffine;_coincidentGeometryContext;static _workVector2dA=j.create();static _workPointA0H=Ot.create();static _workPointA1H=Ot.create();static _workPointB0H=Ot.create();static _workPointB1H=Ot.create();static _workPointAA0=$.create();static _workPointAA1=$.create();static _workPointBB0=$.create();static _workPointBB1=$.create();static _workPointA0=$.create();static _workPointA1=$.create();static _workPointB0=$.create();static _workPointB1=$.create();_xyzwA0;_xyzwA1;_xyzwPlane;_xyzwB;constructor(t,e,i,n,s=J.smallMetricDistance){super(),this._extendA0=e,this._extendA1=e,this._geometryB=i,this._extendB0=n,this._extendB1=n,this._worldToLocalPerspective=void 0,this._worldToLocalAffine=void 0,void 0===t||t.isIdentity()||(this._worldToLocalAffine=t.asTransform,this._worldToLocalAffine||(this._worldToLocalPerspective=t.clone())),this._coincidentGeometryContext=Hi.create(s),this._results=[]}resetGeometry(t){this._geometryB=t}acceptFraction(t,e,i,n=1e-12){return!(!t&&e<-n||!i&&e>1+n)}acceptFractionOnLine(t,e,i,n,s,r=J.smallMetricDistance){return!t&&e<0?J.isDistanceWithinTol(e*n.distanceXY(s),r):!(!i&&e>1)||J.isDistanceWithinTol((e-1)*n.distanceXY(s),r)}grabPairedResults(t=!1){const e=this._results;return t&&(this._results=[]),e}recordPointWithLocalFractions(t,e,i,n,s,r,o,a,c,l){let h,d,u,f;const g=void 0!==l&&l.detailA.hasFraction1&&l.detailB.hasFraction1;g?(h=J.interpolate(i,l.detailA.fraction,n),d=J.interpolate(o,l.detailB.fraction,a),u=J.interpolate(i,l.detailA.fraction1,n),f=J.interpolate(o,l.detailB.fraction1,a)):(h=u=J.interpolate(i,t,n),d=f=J.interpolate(o,s,a));const p=this._results.length;if(p>0&&!g){const t=this._results[p-1].detailA,i=this._results[p-1].detailB;if(c){if(i.isSameCurveAndFraction({curve:e,fraction:h})&&t.isSameCurveAndFraction({curve:r,fraction:d}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:h})&&i.isSameCurveAndFraction({curve:r,fraction:d}))return}const m=Pt.createCurveFractionPoint(e,h,e.fractionToPoint(h)),_=Pt.createCurveFractionPoint(r,d,r.fractionToPoint(d));g?(m.captureFraction1Point1(u,e.fractionToPoint(u)),_.captureFraction1Point1(f,r.fractionToPoint(f))):(m.setIntervalRole(v.isolated),_.setIntervalRole(v.isolated)),c?this._results.push(new It(_,m)):this._results.push(new It(m,_))}recordPairs(t,e,i,n){if(void 0!==i)for(const s of i)this.recordPointWithLocalFractions(s.detailA.fraction,t,0,1,s.detailB.fraction,e,0,1,n,s)}computeSegmentSegment3D(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g){const p=ji._workVector2dA,m=this._coincidentGeometryContext.coincidentSegmentRangeXY(i,s,l,d,!1);m?this._coincidentGeometryContext.clampCoincidentOverlapToSegmentBounds(m,i,s,l,d,e,o,c,f)&&this.recordPointWithLocalFractions(m.detailA.fraction,t,n,r,m.detailB.fraction,a,h,u,g,m):Ft.lineSegment3dXYTransverseIntersectionUnbounded(i,s,l,d,p)&&this.acceptFractionOnLine(e,p.x,o,i,s,this._coincidentGeometryContext.tolerance)&&this.acceptFractionOnLine(c,p.y,f,l,d,this._coincidentGeometryContext.tolerance)&&this.recordPointWithLocalFractions(p.x,t,n,r,p.y,a,h,u,g)}computeSegmentSegment3DH(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g){const p=ji._workPointA0H,m=ji._workPointA1H,_=ji._workPointB0H,x=ji._workPointB1H;this._worldToLocalPerspective.multiplyPoint3d(i,1,p),this._worldToLocalPerspective.multiplyPoint3d(s,1,m),this._worldToLocalPerspective.multiplyPoint3d(l,1,_),this._worldToLocalPerspective.multiplyPoint3d(d,1,x);const y=Ft.lineSegment3dHXYTransverseIntersectionUnbounded(p,m,_,x);if(void 0!==y){const i=y.x,s=y.y;this.acceptFraction(e,i,o)&&this.acceptFraction(c,s,f)&&this.recordPointWithLocalFractions(i,t,n,r,s,a,h,u,g)}}dispatchSegmentSegment(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g){this._worldToLocalAffine?(ji.setTransformedWorkPoints(this._worldToLocalAffine,i,s,l,d),this.computeSegmentSegment3D(t,e,ji._workPointA0,n,ji._workPointA1,r,o,a,c,ji._workPointB0,h,ji._workPointB1,u,f,g)):this._worldToLocalPerspective?this.computeSegmentSegment3DH(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g):this.computeSegmentSegment3D(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g)}dispatchSegmentArc(t,e,i,n,s,r,o,a,c,l,h){const d=this._coincidentGeometryContext.tolerance*this._coincidentGeometryContext.tolerance;let u;if(this._worldToLocalPerspective){const f=a.toTransformedPoint4d(this._worldToLocalPerspective),g=f.sweep.fractionToRadians(0),p=f.center.plus2Scaled(f.vector0,Math.cos(g),f.vector90,Math.sin(g)),m=f.sweep.fractionToRadians(1),_=f.center.plus2Scaled(f.vector0,Math.cos(m),f.vector90,Math.sin(m)),x=this._worldToLocalPerspective.multiplyPoint3d(i,1),y=this._worldToLocalPerspective.multiplyPoint3d(s,1),v=J.tripleProductPoint4dXYW(x,y,f.center),P=J.tripleProductPoint4dXYW(x,y,f.vector0),I=J.tripleProductPoint4dXYW(x,y,f.vector90),S=new bt(2),b=new bt(2),A=new bt(2),C=Ct.appendImplicitLineUnitCircleIntersections(v,P,I,S,b,A);if(C<=0)return;for(let i=0;i<C;i++){const s=f.center.plus2Scaled(f.vector0,S.atUncheckedIndex(i),f.vector90,b.atUncheckedIndex(i));let g=f.sweep.radiansToSignedFraction(A.atUncheckedIndex(i),c);const m=Ft.lineSegment3dHXYClosestPointUnbounded(x,y,s);if(void 0!==m)if(this.acceptFraction(e,m,o)&&this.acceptFraction(c,g,l))this.recordPointWithLocalFractions(m,t,n,r,g,a,0,1,h);else{const e=m<.5?x:y,i=(g=f.sweep.fractionToSignedPeriodicFraction(g))<.5?p:_;void 0!==(u=e.realDistanceSquaredXY(i))&&J.isDistanceWithinTol(u,d)&&this.recordPointWithLocalFractions(m<.5?0:1,t,n,r,g<.5?0:1,a,0,1,h)}}}else{const f=a.toTransformedVectors(this._worldToLocalAffine),g=f.sweep.fractionToRadians(0),p=f.center.plus2Scaled(f.vector0,Math.cos(g),f.vector90,Math.sin(g)),m=f.sweep.fractionToRadians(1),_=f.center.plus2Scaled(f.vector0,Math.cos(m),f.vector90,Math.sin(m));let x=i,y=s;this._worldToLocalAffine&&(x=this._worldToLocalAffine.multiplyPoint3d(i),y=this._worldToLocalAffine.multiplyPoint3d(s));const v=J.tripleProductXYW(x,1,y,1,f.center,1),P=J.tripleProductXYW(x,1,y,1,f.vector0,0),I=J.tripleProductXYW(x,1,y,1,f.vector90,0),S=new bt(2),b=new bt(2),A=new bt(2),C=Ct.appendImplicitLineUnitCircleIntersections(v,P,I,S,b,A);if(C<=0)return;for(let i=0;i<C;i++){const s=f.center.plus2Scaled(f.vector0,S.atUncheckedIndex(i),f.vector90,b.atUncheckedIndex(i));let g=f.sweep.radiansToSignedFraction(A.atUncheckedIndex(i),c);const m=Ft.lineSegment3dXYClosestPointUnbounded(x,y,s);if(void 0!==m)if(this.acceptFraction(e,m,o)&&this.acceptFraction(c,g,l))this.recordPointWithLocalFractions(m,t,n,r,g,a,0,1,h);else{const e=m<.5?x:y,i=(g=f.sweep.fractionToSignedPeriodicFraction(g))<.5?p:_;void 0!==(u=e.distanceSquaredXY(i))&&J.isDistanceWithinTol(u,d)&&this.recordPointWithLocalFractions(m<.5?0:1,t,n,r,g<.5?0:1,a,0,1,h)}}}}dispatchArcArcThisOrder(t,e,i,n,s,r,o,a,c){const l=e.inverse();if(l){const e=l.multiplyMatrixMatrix(r),h=[],d=[];wt.solveUnitCircleHomogeneousEllipseIntersection(e.coffs[2],e.coffs[5],e.coffs[8],e.coffs[0],e.coffs[3],e.coffs[6],e.coffs[1],e.coffs[4],e.coffs[7],h,d);for(let e=0;e<h.length;e++){const r=t.sweep.radiansToSignedFraction(d[e],i),l=s.sweep.radiansToSignedFraction(h[e],o);this.acceptFraction(i,r,n)&&this.acceptFraction(o,l,a)&&this.recordPointWithLocalFractions(r,t,0,1,l,s,0,1,c)}}}dispatchArcArc(t,e,i,n,s,r,o){let a,c;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective),i=n.toTransformedPoint4d(this._worldToLocalPerspective);a=xt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w),c=xt.createColumnsXYW(i.vector0,i.vector0.w,i.vector90,e.vector90.w,i.center,i.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine),i=n.toTransformedVectors(this._worldToLocalAffine);a=xt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1),c=xt.createColumnsXYW(i.vector0,0,i.vector90,0,i.center,1)}if(a.conditionNumber()>c.conditionNumber()?this.dispatchArcArcThisOrder(t,a,e,i,n,c,s,r,o):this.dispatchArcArcThisOrder(n,c,s,r,t,a,e,i,!o),this._coincidentGeometryContext)if(this._worldToLocalPerspective);else if(this._worldToLocalAffine);else{const e=this._coincidentGeometryContext.coincidentArcIntersectionXY(t,n,!0);void 0!==e&&this.recordPairs(t,n,e,o)}}dispatchArcBsplineCurve3d(t,e,i,n,s,r,o){let a;if(this._worldToLocalPerspective){const e=t.toTransformedPoint4d(this._worldToLocalPerspective);a=xt.createColumnsXYW(e.vector0,e.vector0.w,e.vector90,e.vector90.w,e.center,e.center.w)}else{const e=t.toTransformedVectors(this._worldToLocalAffine);a=xt.createColumnsXYW(e.vector0,0,e.vector90,0,e.center,1)}const c=a.inverse();if(c){const a=n.order,l=2*a-1,h=new Float64Array(a),d=new Ut(l),u=c.at(0,0),f=c.at(0,1),g=0,p=c.at(0,2),m=c.at(1,0),_=c.at(1,1),x=0,y=c.at(1,2),v=c.at(2,0),P=c.at(2,1),I=0,S=c.at(2,2);if(c){let a;for(let c=0;a=n.getSaturatedBezierSpan3dH(c,a),a;c++){this._worldToLocalPerspective?a.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective):this._worldToLocalAffine&&a.tryTransformInPlace(this._worldToLocalAffine),d.zero(),a.poleProductsXYZW(h,u,f,g,p),d.addSquaredSquaredBezier(h,1),a.poleProductsXYZW(h,m,_,x,y),d.addSquaredSquaredBezier(h,1),a.poleProductsXYZW(h,v,P,I,S),d.addSquaredSquaredBezier(h,-1);const c=d.roots(0,!0);if(c)for(const l of c){const c=a.fractionToParentFraction(l),h=a.fractionToPoint4d(l),d=h.dotProductXYZW(u,f,g,p),v=h.dotProductXYZW(m,_,x,y),P=t.sweep.radiansToSignedFraction(Math.atan2(v,d),e);this.acceptFraction(e,P,i)&&this.acceptFraction(s,c,r)&&this.recordPointWithLocalFractions(P,t,0,1,c,n,0,1,o)}}}}}transformBeziers(t){if(this._worldToLocalAffine)for(const e of t)e.tryTransformInPlace(this._worldToLocalAffine);else if(this._worldToLocalPerspective)for(const e of t)e.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective)}getRanges(t){const e=[];e.length=0;for(const i of t)e.push(i.range());return e}dispatchBezierBezierStrokeFirst(t,e,i,n,s,r,o,a){this._xyzwA0||(this._xyzwA0=Ot.create()),this._xyzwA1||(this._xyzwA1=Ot.create()),this._xyzwPlane||(this._xyzwPlane=Ot.create()),this._xyzwB||(this._xyzwB=Ot.create()),t.fractionToPoint4d(0,this._xyzwA0);let c,l=0;const h=1/i;for(let r=1;r<=i;r++,l=c,this._xyzwA0.setFrom(this._xyzwA1)){c=r*h,t.fractionToPoint4d(c,this._xyzwA1),Ot.createPlanePointPointZ(this._xyzwA0,this._xyzwA1,this._xyzwPlane),n.poleProductsXYZW(o.coffs,this._xyzwPlane.x,this._xyzwPlane.y,this._xyzwPlane.z,this._xyzwPlane.w);const i=o.roots(0,!0);if(i)for(const r of i){let i=r;n.fractionToPoint4d(i,this._xyzwB);const o=Ft.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0,this._xyzwA1,this._xyzwB);if(o&&J.isIn01WithTolerance(o,1e-5)){let r=J.interpolate(l,o,c);const h=new Kt(t,n),d=new Jt(h);d.setUV(r,i),d.runIterations()&&(r=d.getU(),i=d.getV());const u=t.fractionToParentFraction(r),f=n.fractionToParentFraction(i);this.acceptFraction(!1,u,!1)&&this.acceptFraction(!1,f,!1)&&this.recordPointWithLocalFractions(u,e,0,1,f,s,0,1,a)}}}}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){const n=t.collectBezierSpans(!0),s=e.collectBezierSpans(!0),r=n.length,o=s.length;this.transformBeziers(n),this.transformBeziers(s);const a=this.getRanges(n),c=this.getRanges(s),l=t.order,h=e.order,d=new Ut(l),u=new Ut(h);for(let l=0;l<r;l++)for(let r=0;r<o;r++)if(a[l].intersectsRangeXY(c[r])){const o=n[l].computeStrokeCountForOptions(),a=s[r].computeStrokeCountForOptions();o<a?this.dispatchBezierBezierStrokeFirst(n[l],t,o,s[r],e,a,u,i):this.dispatchBezierBezierStrokeFirst(s[r],e,a,n[l],t,o,d,!i)}}projectPoint(t,e=1){return this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyPoint3d(t,e):this._worldToLocalAffine?this._worldToLocalAffine.multiplyXYZW(t.x,t.y,t.z,e):Ot.createFromPointAndWeight(t,e)}mapNPCPlaneToWorld(t,e){this._worldToLocalAffine?this._worldToLocalAffine.multiplyTransposeXYZW(t.x,t.y,t.z,t.w,e):this._worldToLocalPerspective?this._worldToLocalPerspective.multiplyTransposePoint4d(t,e):t.clone(e)}dispatchSegmentBsplineCurve(t,e,i,n,s,r,o,a,c,l,h){const d=this.projectPoint(i),u=this.projectPoint(s),f=Ot.createPlanePointPointZ(d,u);this.mapNPCPlaneToWorld(f,f);const g=[];a.appendPlaneIntersectionPoints(f,g);for(const i of g){const s=i.fraction,f=i.point,g=this.projectPoint(f),p=Ft.lineSegment3dHXYClosestPointUnbounded(d,u,g);void 0!==p&&this.acceptFraction(e,p,o)&&this.acceptFraction(c,s,l)&&this.recordPointWithLocalFractions(p,t,n,r,s,a,0,1,h)}}dispatchLineStringBSplineCurve(t,e,i,n,s,r,o){const a=t.numPoints();if(a>1){const c=1/(a-1);let l,h;l=0;const d=ji._workPointA0,u=ji._workPointA1;t.pointAt(0,d);for(let f=1;f<a;f++,d.setFrom(u),l=h)t.pointAt(f,u),h=f*c,this.dispatchSegmentBsplineCurve(t,1===f&&e,d,l,u,h,f+1===a&&i,n,s,r,o)}}computeSegmentLineString(t,e,i,n,s,r,o){const a=t.point0Ref,c=t.point1Ref,l=ji._workPointBB0,h=ji._workPointBB1,d=n.numPoints();if(d>1){const u=1/(d-1);let f,g;f=0,n.pointAt(0,l);for(let p=1;p<d;p++,l.setFrom(h),f=g)n.pointAt(p,h),g=p*u,this.dispatchSegmentSegment(t,e,a,0,c,1,i,n,1===p&&s,l,f,h,g,p+1===d&&r,o)}}computeArcLineString(t,e,i,n,s,r,o){const a=ji._workPointBB0,c=ji._workPointBB1,l=n.numPoints();if(l>1){const h=1/(l-1);let d,u;d=0,n.pointAt(0,a);for(let f=1;f<l;f++,a.setFrom(c),d=u)n.pointAt(f,c),u=f*h,this.dispatchSegmentArc(n,1===f&&s,a,d,c,u,f+1===l&&r,t,e,i,!o)}}computeLineStringLineString(t,e,i){const n=ji._workPointAA0,s=ji._workPointAA1,r=ji._workPointBB0,o=ji._workPointBB1,a=t.numPoints(),c=e.numPoints();if(a>1&&c>1){t.pointAt(0,n);const l=1/(a-1),h=1/(c-1);let d,u,f,g=0;t.pointAt(0,n);for(let p=1;p<a;p++,n.setFrom(s),g=u){u=p*l,d=0,t.pointAt(p,s),e.pointAt(0,r);for(let l=1;l<c;l++,r.setFrom(o),d=f)e.pointAt(l,o),f=l*h,this.dispatchSegmentSegment(t,1===p&&this._extendA0,n,g,s,u,p+1===a&&this._extendA1,e,1===l&&this._extendB0,r,d,o,f,l+1===c&&this._extendB1,i)}}}static setTransformedWorkPoints(t,e,i,n,s){t.multiplyPoint3d(e,this._workPointA0),t.multiplyPoint3d(i,this._workPointA1),t.multiplyPoint3d(n,this._workPointB0),t.multiplyPoint3d(s,this._workPointB1)}dispatchCurveCollection(t,e){const i=this._geometryB;if(!(i&&i.children&&i instanceof $e))return;const n=i.children,s=this._extendB0,r=this._extendB1;for(let o=0;o<n.length;o++)this.resetGeometry(n[o]),i instanceof ii&&n.length>1?0===o?this._extendB1=!1:o===n.length-1?this._extendB0=!1:this._extendB0=this._extendB1=!1:i instanceof oi&&(this._extendB0=this._extendB1=!1),e(t),this._extendB0=s,this._extendB1=r;this.resetGeometry(i)}dispatchCurveChainWithDistanceIndex(t,e){if(!(this._geometryB&&this._geometryB instanceof ri))return;const i=this._results.length,n=this._geometryB;this.resetGeometry(n.path),this.dispatchCurveCollection(t,e),this.resetGeometry(n),this._results=ri.convertChildDetailToChainDetail(this._results,i,void 0,n,!0)}handleChildren(t){const e=t.children,i=this._extendA0,n=this._extendA1;if(e)for(let s=0;s<e.length;s++)t instanceof ii&&e.length>1?0===s?this._extendA1=!1:s===e.length-1?this._extendA0=!1:this._extendA0=this._extendA1=!1:t instanceof oi&&(this._extendA0=this._extendA1=!1),e[s].dispatchToGeometryHandler(this),this._extendA0=i,this._extendA1=n}handleLineSegment3d(t){if(this._geometryB instanceof Te){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,e,this._extendB0,e.point0Ref,0,e.point1Ref,1,this._extendB1,!1)}else this._geometryB instanceof Fe?this.computeSegmentLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Si?this.dispatchSegmentArc(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ye?this.dispatchSegmentBsplineCurve(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleLineSegment3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineSegment3d.bind(this))}handleLineString3d(t){if(this._geometryB instanceof Fe){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof Te?this.computeSegmentLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Si?this.computeArcLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ye?this.dispatchLineStringBSplineCurve(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleLineString3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineString3d.bind(this))}handleArc3d(t){this._geometryB instanceof Te?this.dispatchSegmentArc(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Fe?this.computeArcLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Si?this.dispatchArcArc(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ye?this.dispatchArcBsplineCurve3d(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleArc3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleArc3d.bind(this))}handleBSplineCurve3d(t){this._geometryB instanceof Te?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Fe?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Si?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Le?this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(t){super.handleCurveChainWithDistanceIndex(t),this._results=ri.convertChildDetailToChainDetail(this._results,0,t,void 0,!0)}handleBSplineCurve3dH(t){}}class Ji extends Se{_extendA0;_extendA1;_geometryB;_extendB0;_extendB1;_results;static _workVector2dA=j.create();static _workPointAA0=$.create();static _workPointAA1=$.create();static _workPointBB0=$.create();static _workPointBB1=$.create();constructor(t,e,i){super(),this._extendA0=t,this._extendA1=t,this._geometryB=e,this._extendB0=i,this._extendB1=i,this._results=[]}resetGeometry(t){this._geometryB=t}grabPairedResults(t=!1){const e=this._results;return t&&(this._results=[]),e}acceptFraction(t,e,i,n=1e-12){return!(!t&&e<-n||!i&&e>1+n)}recordPointWithLocalFractions(t,e,i,n,s,r,o,a,c){const l=J.interpolate(i,t,n),h=J.interpolate(o,s,a),d=this._results.length;if(d>0){const t=this._results[d-1].detailA,i=this._results[d-1].detailB;if(c){if(i.isSameCurveAndFraction({curve:e,fraction:l})&&t.isSameCurveAndFraction({curve:r,fraction:h}))return}else if(t.isSameCurveAndFraction({curve:e,fraction:l})&&i.isSameCurveAndFraction({curve:r,fraction:h}))return}const u=e.fractionToPoint(l),f=r.fractionToPoint(h);if(!u.isAlmostEqualMetric(f))return;const g=Pt.createCurveFractionPoint(e,l,u);g.setIntervalRole(v.isolated);const p=Pt.createCurveFractionPoint(r,h,f);if(p.setIntervalRole(v.isolated),c){const t=new It(p,g);this._results.push(t)}else{const t=new It(g,p);this._results.push(t)}}computeSegmentSegment3D(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g){const p=Ji._workVector2dA;Ft.lineSegment3dClosestApproachUnbounded(i,s,l,d,p)&&this.acceptFraction(e,p.x,o)&&this.acceptFraction(c,p.y,f)&&this.recordPointWithLocalFractions(p.x,t,n,r,p.y,a,h,u,g)}dispatchSegmentSegment(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g){this.computeSegmentSegment3D(t,e,i,n,s,r,o,a,c,l,h,d,u,f,g)}createPlaneWithPreferredPerpendicular(t,e,i,n,s){i=J.restrictToInterval(Math.abs(i),0,1-J.smallFraction);const r=e.magnitudeSquared(),o=n.magnitudeSquared(),a=Math.abs(e.dotProduct(n)),c=e.unitCrossProduct(a*a<=i*i*r*o?n:s);if(c)return yt.create(t,c)}dispatchSegmentArc(t,e,i,n,s,r,o,a,c,l,h){const d=tt.createStartEnd(i,s),u=this.createPlaneWithPreferredPerpendicular(i,d,.94,a.perpendicularVector,a.vector0);if(void 0!==u){const d=[];let f,g;a.appendPlaneIntersectionPoints(u,d);for(const u of d){const d=a.sweep.fractionToSignedPeriodicFraction(u.fraction,c);this.acceptFraction(c,d,l)&&(f=Ft.lineSegment3dClosestPointUnbounded(i,s,u.point),void 0!==f&&(g=i.interpolate(f,s,g),g.isAlmostEqualMetric(u.point)&&this.acceptFraction(e,f,o)&&this.recordPointWithLocalFractions(f,t,n,r,d,a,0,1,h)))}}}dispatchArcArcInPlane(t,e,i,n,s,r,o){const a=t.otherArcAsLocalVectors(n);if(void 0!==a){const c=[],l=[];wt.solveUnitCircleHomogeneousEllipseIntersection(a.center.x,a.center.y,1,a.vector0.x,a.vector0.y,0,a.vector90.x,a.vector90.y,0,c,l);for(let a=0;a<c.length;a++){const h=t.sweep.radiansToSignedFraction(l[a],e),d=n.sweep.radiansToSignedFraction(c[a],s);this.acceptFraction(e,h,i)&&this.acceptFraction(s,d,r)&&this.recordPointWithLocalFractions(h,t,0,1,d,n,0,1,o)}}}dispatchArcArc(t,e,i,n,s,r,o){const a=yt.create(t.center,t.perpendicularVector),c=yt.create(n.center,n.perpendicularVector);if(void 0!==a&&void 0!==c)if(a.getNormalRef().isParallelTo(c.getNormalRef()))a.isPointInPlane(c.getOriginRef())&&c.isPointInPlane(a.getOriginRef())&&this.dispatchArcArcInPlane(t,e,i,n,s,r,o);else{const l=[];n.appendPlaneIntersectionPoints(a,l);const h=[];t.appendPlaneIntersectionPoints(c,h);for(const a of l)for(const c of h)if(c.point.isAlmostEqual(a.point)){const l=t.sweep.fractionToSignedPeriodicFraction(c.fraction,e),h=n.sweep.fractionToSignedPeriodicFraction(a.fraction,s);this.acceptFraction(e,l,i)&&this.acceptFraction(s,h,r)&&this.recordPointWithLocalFractions(l,t,0,1,h,n,0,1,o)}}}dispatchArcBsplineCurve3d(t,e,i,n,s,r,o){}dispatchBSplineCurve3dBSplineCurve3d(t,e,i){}dispatchSegmentBsplineCurve(t,e,i,n,s,r,o,a,c,l,h){}dispatchLineStringBSplineCurve(t,e,i,n,s,r,o){}computeSegmentLineString(t,e,i,n,s,r,o){const a=t.point0Ref,c=t.point1Ref,l=Ji._workPointBB0,h=Ji._workPointBB1,d=n.numPoints();if(d>1){const u=1/(d-1);let f,g;f=0,n.pointAt(0,l);for(let p=1;p<d;p++,l.setFrom(h),f=g)n.pointAt(p,h),g=p*u,this.dispatchSegmentSegment(t,e,a,0,c,1,i,n,1===p&&s,l,f,h,g,p+1===d&&r,o)}}computeArcLineString(t,e,i,n,s,r,o){const a=Ji._workPointBB0,c=Ji._workPointBB1,l=n.numPoints();if(l>1){const h=1/(l-1);let d,u;d=0,n.pointAt(0,a);for(let f=1;f<l;f++,a.setFrom(c),d=u)n.pointAt(f,c),u=f*h,this.dispatchSegmentArc(n,1===f&&s,a,d,c,u,f+1===l&&r,t,e,i,!o)}}computeLineStringLineString(t,e,i){const n=Ji._workPointAA0,s=Ji._workPointAA1,r=Ji._workPointBB0,o=Ji._workPointBB1,a=t.numPoints(),c=e.numPoints();if(a>1&&c>1){t.pointAt(0,n);const l=1/(a-1),h=1/(c-1);let d,u,f,g=0;t.pointAt(0,n);for(let p=1;p<a;p++,n.setFrom(s),g=u){u=p*l,d=0,t.pointAt(p,s),e.pointAt(0,r);for(let l=1;l<c;l++,r.setFrom(o),d=f)e.pointAt(l,o),f=l*h,this.dispatchSegmentSegment(t,1===p&&this._extendA0,n,g,s,u,p+1===a&&this._extendA1,e,1===l&&this._extendB0,r,d,o,f,l+1===c&&this._extendB1,i)}}}dispatchCurveCollection(t,e){const i=this._geometryB;if(!(i&&i.children&&i instanceof $e))return;const n=i.children,s=this._extendB0,r=this._extendB1;for(let o=0;o<n.length;o++)this.resetGeometry(n[o]),i instanceof ii&&n.length>1?0===o?this._extendB1=!1:o===n.length-1?this._extendB0=!1:this._extendB0=this._extendB1=!1:i instanceof oi&&(this._extendB0=this._extendB1=!1),e(t),this._extendB0=s,this._extendB1=r;this.resetGeometry(i)}dispatchCurveChainWithDistanceIndex(t,e){if(!(this._geometryB&&this._geometryB instanceof ri))return;const i=this._results.length,n=this._geometryB;this.resetGeometry(n.path),this.dispatchCurveCollection(t,e),this.resetGeometry(n),this._results=ri.convertChildDetailToChainDetail(this._results,i,void 0,n,!0)}handleChildren(t){const e=t.children,i=this._extendA0,n=this._extendA1;if(e)for(let s=0;s<e.length;s++)t instanceof ii&&e.length>1?0===s?this._extendA1=!1:s===e.length-1?this._extendA0=!1:this._extendA0=this._extendA1=!1:t instanceof oi&&(this._extendA0=this._extendA1=!1),e[s].dispatchToGeometryHandler(this),this._extendA0=i,this._extendA1=n}handleLineSegment3d(t){if(this._geometryB instanceof Te){const e=this._geometryB;this.dispatchSegmentSegment(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,e,this._extendB0,e.point0Ref,0,e.point1Ref,1,this._extendB1,!1)}else this._geometryB instanceof Fe?this.computeSegmentLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Si?this.dispatchSegmentArc(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ye?this.dispatchSegmentBsplineCurve(t,this._extendA0,t.point0Ref,0,t.point1Ref,1,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleLineSegment3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineSegment3d.bind(this))}handleLineString3d(t){if(this._geometryB instanceof Fe){const e=this._geometryB;this.computeLineStringLineString(t,e,!1)}else this._geometryB instanceof Te?this.computeSegmentLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Si?this.computeArcLineString(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Ye?this.dispatchLineStringBSplineCurve(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleLineString3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleLineString3d.bind(this))}handleArc3d(t){this._geometryB instanceof Te?this.dispatchSegmentArc(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Fe?this.computeArcLineString(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Si?this.dispatchArcArc(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof Ye?this.dispatchArcBsplineCurve3d(t,this._extendA0,this._extendA1,this._geometryB,this._extendB0,this._extendB1,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleArc3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleArc3d.bind(this))}handleBSplineCurve3d(t){this._geometryB instanceof Te?this.dispatchSegmentBsplineCurve(this._geometryB,this._extendB0,this._geometryB.point0Ref,0,this._geometryB.point1Ref,1,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Fe?this.dispatchLineStringBSplineCurve(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Si?this.dispatchArcBsplineCurve3d(this._geometryB,this._extendB0,this._extendB1,t,this._extendA0,this._extendA1,!0):this._geometryB instanceof Le?this.dispatchBSplineCurve3dBSplineCurve3d(t,this._geometryB,!1):this._geometryB instanceof $e?this.dispatchCurveCollection(t,this.handleBSplineCurve3d.bind(this)):this._geometryB instanceof ri&&this.dispatchCurveChainWithDistanceIndex(t,this.handleBSplineCurve3d.bind(this))}handleCurveChainWithDistanceIndex(t){super.handleCurveChainWithDistanceIndex(t),this._results=ri.convertChildDetailToChainDetail(this._results,0,t,void 0,!0)}handleBSplineCurve3dH(t){}}class Ki{static intersectionXYPairs(t,e,i,n,s=J.smallMetricDistance){return Ki.intersectionProjectedXYPairs(void 0,t,e,i,n,s)}static intersectionProjectedXYPairs(t,e,i,n,s,r=J.smallMetricDistance){const o=new ji(t,i,n,s,r);return e.dispatchToGeometryHandler(o),o.grabPairedResults()}static intersectionXYZPairs(t,e,i,n){const s=new Ji(e,i,n);return t.dispatchToGeometryHandler(s),s.grabPairedResults()}static allIntersectionsAmongPrimitivesXY(t,e=J.smallMetricDistance){const i=new ji(void 0,!1,void 0,!1,e);for(let e=0;e<t.length;e++){const n=t[e];for(let s=e+1;s<t.length;s++)i.resetGeometry(t[s]),n.dispatchToGeometryHandler(i)}return i.grabPairedResults()}static closeApproachProjectedXYPairs(t,e,i){const n=new ci(e);return n.maxDistanceToAccept=i,t.dispatchToGeometryHandler(n),n.grabPairedResults()}static closestApproachProjectedXYPair(t,e){const i=t.range();i.extendRange(e.range());const n=i.low.distanceXY(i.high),s=this.closeApproachProjectedXYPairs(t,e,n);if(!s.length)return;let r=0,o=2*n;for(let t=0;t<s.length;++t){const e=s[t].detailA.point.distanceXY(s[t].detailB.point);e<o&&(r=t,o=e)}return s[r]}}class $i{_chains;_gapTolerance;_snapTolerance;_planeTolerance;static _staticPointA;static _staticPointB;_xyzWork0;_xyzWork1;constructor(t=J.smallMetricDistance,e){this._chains=[],this._gapTolerance=t,this._snapTolerance=J.smallMetricDistance,this._planeTolerance=e}findAnyChainToConnect(t,e,i=-1){for(let n=0;n<this._chains.length;n++){if(i===n)continue;const s=this._chains[n];if(this._xyzWork1=s[s.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:n,atEnd:!0};if(this._xyzWork1=s[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t,e))return{chainIndex:n,atEnd:!1}}}captureCurvePrimitive(t){this._snapTolerance<this._gapTolerance&&this.attachPrimitiveToAnyChain(t,this._snapTolerance)||this.attachPrimitiveToAnyChain(t,this._gapTolerance)||this._chains.push([t])}captureCurve(t){if(t instanceof le)this.captureCurvePrimitive(t);else if(t instanceof $e)for(const e of t.children)this.captureCurve(e)}static simpleEndPointMove(t,e,i){if(t instanceof Te)return e?t.point1Ref.setFrom(i):t.point0Ref.setFrom(i),!0;if(t instanceof Fe&&t.numPoints()>0){const n=e?t.numPoints()-1:0;return t.packedPoints.setAtCheckedPointIndex(n,i),!0}return!1}static moveHeadOrTail(t,e,i){const n=t.endPoint(),s=e.startPoint(),r=.001*J.smallMetricDistance,o=n.distanceXY(s);if(o<r)return!1;if(o<i&&(this.simpleEndPointMove(e,!1,n)||this.simpleEndPointMove(t,!0,s)))return!0;const a=Ki.intersectionXYPairs(t,!0,e,!0);for(const r of a){const o=r.detailA,a=r.detailB,c=o.point.distanceXY(n),l=a.point.distanceXY(s);if(c<5*i&&l<5*i&&t instanceof Si&&e instanceof Si){const i=t.sweep.fractionToRadians(o.fraction);t.sweep.setStartEndRadians(t.sweep.startRadians,i);const n=e.sweep.fractionToRadians(a.fraction);return e.sweep.setStartEndRadians(n,e.sweep.endRadians),!0}}return!1}attachPrimitiveToAnyChain(t,e){if(t){this._xyzWork0=t.startPoint(this._xyzWork0);let i=this.findAnyChainToConnect(this._xyzWork0,e);if(i){if(i.atEnd){const n=this._chains[i.chainIndex],s=n.length-1;return this._chains[i.chainIndex].push(t),$i.moveHeadOrTail(n[s],n[s+1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{t.reverseInPlace();const n=this._chains[i.chainIndex];return n.splice(0,0,t),$i.moveHeadOrTail(n[0],n[1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}if(this._xyzWork0=t.endPoint(this._xyzWork0),i=this.findAnyChainToConnect(this._xyzWork0,e),i){if(i.atEnd){t.reverseInPlace();const n=this._chains[i.chainIndex],s=n.length-1;return this._chains[i.chainIndex].push(t),$i.moveHeadOrTail(n[s],n[s+1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}{const n=this._chains[i.chainIndex];return n.splice(0,0,t),$i.moveHeadOrTail(n[0],n[1],this._gapTolerance),this.searchAndMergeChainIndex(i.chainIndex,e),!0}}}return!1}mergeChainsForwardForward(t,e){const i=this._chains[t],n=this._chains[e];for(const t of n)i.push(t);n.length=0;const s=this._chains.length-1;e!==s&&(this._chains[e]=this._chains[s]),this._chains.pop()}reverseChain(t){const e=this._chains[t];e.reverse();for(const t of e)t.reverseInPlace()}searchAndMergeChainIndex(t,e){const i=this._chains[t],n=i.length-1;this._xyzWork0=i[0].startPoint(this._xyzWork0);let s=this.findAnyChainToConnect(this._xyzWork0,e,t);return s?(s.atEnd||this.reverseChain(s.chainIndex),void this.mergeChainsForwardForward(s.chainIndex,t)):(this._xyzWork0=i[n].endPoint(this._xyzWork0),s=this.findAnyChainToConnect(this._xyzWork0,e,t),s?(s.atEnd&&this.reverseChain(s.chainIndex),void this.mergeChainsForwardForward(t,s.chainIndex)):void 0)}promoteArrayToCurves(t,e){if(0!==t.length){if(e){const e=t[0],i=t[t.length-1];if($i._staticPointA=e.startPoint($i._staticPointA),$i._staticPointB=i.endPoint($i._staticPointB),$i.moveHeadOrTail(i,e,this._gapTolerance)&&($i._staticPointA=e.startPoint($i._staticPointA),$i._staticPointB=i.endPoint($i._staticPointB)),$i._staticPointA.isAlmostEqual($i._staticPointB,this._gapTolerance)){const e=bi.createRightHandedLocalToWorld(t);if(e){const i=e.inverse();if(i){const e=wr.curveArrayRange(t,i);if(void 0!==this._planeTolerance&&e.zLength()<=this._planeTolerance)return oi.createArray(t)}}return ii.createArray(t)}}return 1===t.length?t[0]:ii.createArray(t)}}chainToLineString3d(t,e){if(0===t.length)return;const i=Fe.create();for(const n of t)n.emitStrokes(i,e);return i.removeDuplicatePoints(this._gapTolerance),i}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=ei.create();for(const n of e){const e=this.promoteArrayToCurves(n,t);i.tryAddChild(e)}return i}announceChainsAsLineString3d(t,e){const i=this._chains;if(1===i.length){const n=this.chainToLineString3d(i[0],e);n&&t(n)}else if(i.length>1)for(const n of i){const i=this.chainToLineString3d(n,e);i&&t(i)}}}!function(t){t[t.Unknown=0]="Unknown",t[t.Cap=1]="Cap",t[t.Extend=2]="Extend",t[t.Trim=-1]="Trim",t[t.JustGeometry=3]="JustGeometry",t[t.Gap=4]="Gap"}(w||(w={}));class tn{flexure;curve0;fraction0;curve1;fraction1;jointCurve;swingPoint;nextJoint;previousJoint;constructor(t,e,i){this.curve0=t,this.curve1=e,this.swingPoint=i,this.flexure=w.Unknown}static constructArc(t,e,i){if(void 0!==e&&J.isSameCoordinate(t.origin.distance(e),i.origin.distance(e))){const n=t.direction.angleToXY(i.direction),s=tt.createStartEnd(e,t.origin),r=s.rotate90CCWXY();return Si.create(e,s,r,St.createStartEndRadians(0,n.radians))}}shallowExtract(){return{curve0:this.curve0,curve1:this.curve1,fraction0:this.fraction0,fraction1:this.fraction1}}static link(t,e){t.nextJoint=e,e&&(e.previousJoint=t),t.curve1&&e&&!e.curve0?e.curve0=t.curve1:!t.curve1&&e&&e.curve0&&(t.curve1=e.curve0)}nextJointFraction0(t){return this.nextJoint&&void 0!==this.nextJoint.fraction0?this.nextJoint.fraction0:t}static addStrokes(t,e){e&&e.emitStrokes(t)}static addPoint(t,e){t.packedPoints.length>0&&(t.endPoint().isAlmostEqual(e)||t.packedPoints.push(e))}static collectStrokesFromChain(t,e,i=100){let n=-2*i;tn.visitJointsOnChain(t,(t=>{if(this.addStrokes(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,n=t.nextJointFraction0(1);let s;0===i&&1===n?s=t.curve1.clone():i<n&&(s=t.curve1.clonePartialCurve(i,n)),s&&(t.jointCurve||this.addPoint(e,s.startPoint())),this.addStrokes(e,s)}return n++<i}),i)}static collectPrimitive(t,e){if(e){if(t.length>0){const i=t[t.length-1].endPoint(),n=e.startPoint();i.isAlmostEqual(n)||t.push(Te.create(i,n))}t.push(e)}}static adjustJointToPrimitives(t){const e=t.jointCurve;if(e instanceof Fe){if(t.curve0){const i=t.curve0.endPoint(),n=e.startPoint();i.isAlmostEqual(n)||e.packedPoints.setAtCheckedPointIndex(0,i)}if(t.curve1){const i=t.curve1.startPoint(),n=e.endPoint();i.isAlmostEqual(n)||e.packedPoints.setAtCheckedPointIndex(e.packedPoints.length-1,i)}}}static collectCurvesFromChain(t,e,i=100){if(void 0===t)return;let n=-2*i;tn.visitJointsOnChain(t,(t=>{if(this.adjustJointToPrimitives(t),this.collectPrimitive(e,t.jointCurve),t.curve1&&void 0!==t.fraction1){const i=t.fraction1,n=t.nextJointFraction0(1);let s;0===i&&1===n?s=t.curve1.clone():i<n&&(s=t.curve1.clonePartialCurve(i,n)),this.collectPrimitive(e,s)}return n++<i}),i)}static annotateChain(t,e,i=100){t&&tn.visitJointsOnChain(t,(t=>(t.annotateJointMode(e),!0)),i)}static visitJointsOnChain(t,e,i=100){let n=t;if(n){let s=0;for(;void 0!==n;){if(s++>=i+5)return!0;if(!e(n))return!1;if(n=n.nextJoint,n===t)break}}return!0}annotateExtension(t){if(this.curve0&&this.curve1){const e=this.curve0.fractionToPointAndDerivative(1),i=this.curve1.fractionToPointAndDerivative(0);e.direction.z=i.direction.z=0;const n=Rt.closestApproachRay3dRay3d(e,i);if(n.approachType===I.Intersection&&n.detailA.fraction>=0&&n.detailB.fraction<=0){this.fraction0=1,this.fraction1=0,this.flexure=w.Extend;const s=e.getDirectionRef().angleToXY(i.getDirectionRef());if(t.needArc(s)){const t=tn.constructArc(e,this.curve0.baseCurveEnd,i);if(t)return void(this.jointCurve=t)}const r=t.numChamferPoints(s);if(r<=1)return void(this.jointCurve=Fe.create(e.origin,n.detailA.point,i.origin));if(r>1){const t=2*r,n=s.radians/t,o=tn.constructArc(e,this.curve0.baseCurveEnd,i);if(void 0!==o){const s=1/Math.cos(n),a=Fe.create();this.jointCurve=a,a.addPoint(e.origin);for(let e=0;e<r;e++){const i=(1+2*e)/t;a.addPoint(o.fractionAndRadialFractionToPoint(i,s))}return void a.addPoint(i.origin)}}}this.flexure=w.Gap,this.jointCurve=Te.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0}}selectIntersectionIndexByFraction(t,e,i){let n=-1,s=Number.MAX_VALUE;for(let r=0;r<i.length;r++){const o=Math.abs(i[r].detailA.fraction-t)+Math.abs(i[r].detailB.fraction-e);o<s&&(s=o,n=r)}return n}annotateJointMode(t){if(!this.curve0&&this.curve1)this.flexure=w.Cap,this.fraction1=0;else if(this.curve0&&!this.curve1)this.flexure=w.Cap,this.fraction0=1;else if(this.curve0&&this.curve1)if(this.curve0.endPoint().isAlmostEqualXY(this.curve1.startPoint()))this.fraction0=1,this.fraction1=0,this.flexure=w.Trim;else if(this.curve0 instanceof Te&&this.curve1 instanceof Te){const e=this.curve0.fractionToPointAndDerivative(0),i=this.curve1.fractionToPointAndDerivative(0);e.direction.z=i.direction.z=0;const n=Rt.closestApproachRay3dRay3d(e,i);n.approachType!==I.Intersection&&n.approachType!==I.PerpendicularChord||(this.fraction0=n.detailA.fraction,this.fraction1=n.detailB.fraction,this.fraction0>=1&&this.fraction1<=0?this.annotateExtension(t):this.fraction0<1&&this.fraction1>0?this.flexure=w.Trim:this.fraction0>1&&this.fraction1>1&&(this.flexure=w.Gap,this.jointCurve=Te.create(this.curve0.fractionToPoint(1),this.curve1.fractionToPoint(0)),this.fraction0=1,this.fraction1=0))}else{const e=Ki.intersectionXYPairs(this.curve0,!1,this.curve1,!1),i=this.selectIntersectionIndexByFraction(1,0,e);i>=0?(this.flexure=w.Trim,this.fraction0=e[i].detailA.fraction,this.fraction1=e[i].detailB.fraction):this.annotateExtension(t)}}static removeDegeneratePrimitives(t,e,i){let n=t,s=0,r=0;if(n)for(;void 0!==n&&r++<i;){const i=n.nextJoint;if(n&&i&&n.previousJoint&&i.nextJoint&&void 0!==n.fraction1&&void 0!==i.fraction0){const r=n.fraction1,o=i.fraction0,a=i.fraction1,c=i.nextJoint.fraction0,l=r>=o||r>1;if(l&&(void 0!==a&&a>1||void 0!==a&&void 0!==c&&a>=c)){const t=i.nextJoint,s=new tn(n.curve0,t.curve1,void 0);tn.link(n.previousJoint,s),tn.link(s,t.nextJoint),s.annotateJointMode(e),s.previousJoint.annotateJointMode(e),s.nextJoint&&s.nextJoint.annotateJointMode(e)}else if(l){const r=new tn(n.curve0,i.curve1,void 0);if(tn.link(n.previousJoint,r),tn.link(r,i.nextJoint),r.annotateJointMode(e),r.previousJoint.annotateJointMode(e),r.nextJoint.annotateJointMode(e),s++,n===t&&(t=r),n=r,s>=1)return{newStart:t,numJointRemoved:s}}}if(n=n.nextJoint,n===t)break}return{newStart:t,numJointRemoved:s}}}class en{constructor(){}static _unitAlong=tt.create();static _unitPerp=tt.create();static _offsetA=$.create();static _offsetB=$.create();static createOffsetSegment(t,e,i){if(tt.createStartEnd(t,e,this._unitAlong),this._unitAlong.z=0,this._unitAlong.normalizeInPlace()){this._unitAlong.rotate90CCWXY(this._unitPerp);const n=Te.create(t.plusScaled(this._unitPerp,i,this._offsetA),e.plusScaled(this._unitPerp,i,this._offsetB));return nn.applyBasePoints(n,t.clone(),e.clone()),n}}constructPolygonWireXYOffset(t,e,i){e&&!t[0].isAlmostEqual(t[t.length-1])&&(e=!1);const n=Ae.create(i),s=t.length;let r,o,a;for(let e=0;e+1<s;++e)if(a){const i=en.createOffsetSegment(t[e],t[e+1],n.leftOffsetDistance);if(i){const n=new tn(r,i,t[e]);tn.link(a,n),a=n,r=i}}else(r=en.createOffsetSegment(t[e],t[e+1],n.leftOffsetDistance))&&(a=o=new tn(void 0,r,t[e]));if(!r||!a||!o)return;const c=e?o:new tn(r,void 0,t[s-1]);tn.link(a,c),tn.annotateChain(o,n,s);for(let t=0;t++<5;){const t=tn.removeDegeneratePrimitives(o,n,s);if(o=t.newStart,0===t.numJointRemoved)break}const l=Fe.create();return tn.collectStrokesFromChain(o,l,s),l.packedPoints.length>1?l.packedPoints.front().isAlmostEqual(l.packedPoints.back())?oi.create(l):ii.create(l):void 0}}class nn{constructor(){}static applyBasePoints(t,e,i){return void 0!==t&&(void 0!==e&&(t.baseCurveStart=e),void 0!==i&&(t.baseCurveEnd=i)),t}static createSingleOffsetPrimitiveXY(t,e){const i=t.constructOffsetXY(e);if(void 0!==i){if(Array.isArray(i)){const e=t.collectCurvePrimitives(void 0,!0,!0);if(e.length!==i.length)return;for(let t=0;t<e.length;++t)this.applyBasePoints(i[t],e[t].startPoint(),e[t].endPoint());return i}return this.applyBasePoints(i,t.startPoint(),t.endPoint())}}static constructCurveXYOffset(t,e){const i=t instanceof oi,n=Ce.create(e),s=[];for(const e of t.children){const t=nn.createSingleOffsetPrimitiveXY(e,n);if(void 0===t);else if(t instanceof le)s.push(t);else if(Array.isArray(t))for(const e of t)e instanceof le&&s.push(e)}let r,o,a,c;for(const t of s)t&&(o=new tn(r,t,t.fractionToPoint(0)),void 0!==o&&void 0===c&&(c=o),a&&tn.link(a,o),a=o,r=t);c&&a&&t instanceof oi&&tn.link(a,c);const l=s.length;tn.annotateChain(c,n.jointOptions,l);const h=[];return tn.collectCurvesFromChain(c,h,l),wr.createLoopPathOrBagOfCurves(h,i,!0)}}class sn{static sumLengths(t){let e=0;if(t instanceof le)e+=t.curveLength();else if(t instanceof $e)e+=t.sumLengths();else if(Array.isArray(t))for(const i of t)e+=this.sumLengths(i);return e}static extendRange(t,e){if(Array.isArray(e))for(const i of e)this.extendRange(t,i);else e.extendRange(t);return t}static appendXYOffsets(t,e,i){let n=0;if(t instanceof le){const s=nn.constructCurveXYOffset(ii.create(t),e);s&&(n+=this.sumLengths(s),i.push(s))}else if(t instanceof oi||t instanceof ii){const s=nn.constructCurveXYOffset(t,e);s&&(n+=this.sumLengths(s),i.push(s))}else if(t instanceof ei)for(const s of t.children)n+=this.appendXYOffsets(s,e,i);else if(Array.isArray(t))for(const s of t)n+=this.appendXYOffsets(s,e,i);return n}static collectInsideAndOutsideXYOffsets(t,e,i){const n=new $i(i,i);for(const e of t)n.captureCurve(e);const s=n.grabResult(!0),r=[],o=[];return sn.appendXYOffsets(s,e,r)>sn.appendXYOffsets(s,-e,o)?{outsideOffsets:r,insideOffsets:o,chains:s}:{insideOffsets:r,outsideOffsets:o,chains:s}}static constructCurveXYOffset(t,e){return nn.constructCurveXYOffset(t,e)}static createSingleOffsetPrimitiveXY(t,e){return nn.createSingleOffsetPrimitiveXY(t,e)}static collectChains(t,e=J.smallMetricDistance,i){const n=new $i(e,i);for(const e of t)n.captureCurve(e);return n.grabResult(!0)}static collectChainsAsLineString3d(t,e,i,n=J.smallMetricDistance,s){const r=new $i(n);for(const e of t)r.captureCurve(e);r.announceChainsAsLineString3d(e,i)}}class rn{world;local;a;closestEdgeIndex;closestEdgeParam;constructor(){this.world=new $,this.local=new $,this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.world.setZero(),this.local.setZero(),this.a=0,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new rn:t.invalidate(),t}copyContentsFrom(t){this.world.setFrom(t.world),this.local.setFrom(t.local),this.a=t.a,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return!this.local.isZero}get isInsideOrOn(){return this.isValid&&this.local.x>=0&&this.local.y>=0&&this.local.z>=0}get classify(){if(!this.isValid)return _.Unknown;if(this.isInsideOrOn){let t=0;return 0===Math.abs(this.local.x)&&++t,0===Math.abs(this.local.y)&&++t,0===Math.abs(this.local.z)&&++t,2===t?_.OnPolygonVertex:1===t?_.OnPolygonEdgeInterior:_.InsidePolygonProjectsToEdgeInterior}return 0===this.closestEdgeParam?_.OutsidePolygonProjectsToVertex:_.OutsidePolygonProjectsToEdgeInterior}}class on{points;edgeLength2;static _workPoint;static _workVector0;static _workVector1;static _workRay;static _workMatrix;constructor(t,e,i){this.points=[],this.points.push(t),this.points.push(e),this.points.push(i),this.edgeLength2=[],this.edgeLength2.push(e.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(i)),this.edgeLength2.push(t.distanceSquared(e))}set(t,e,i){this.points[0].setFromPoint3d(t),this.points[1].setFromPoint3d(e),this.points[2].setFromPoint3d(i),this.edgeLength2[0]=this.points[1].distanceSquared(this.points[2]),this.edgeLength2[1]=this.points[0].distanceSquared(this.points[2]),this.edgeLength2[2]=this.points[0].distanceSquared(this.points[1])}setFrom(t){for(let e=0;e<3;++e)this.points[e].setFromPoint3d(t.points[e]),this.edgeLength2[e]=t.edgeLength2[e]}static createXYZXYZXYZ(t,e,i,n,s,r,o,a,c,l){return l?(l.points[0].set(t,e,i),l.points[1].set(n,s,r),l.points[2].set(o,a,c),l):new this($.create(t,e,i),$.create(n,s,r),$.create(o,a,c))}static create(t,e,i,n){return n?(n.set(t,e,i),n):new this(t.clone(),e.clone(),i.clone())}clone(t){return on.create(this.points[0],this.points[1],this.points[2],t)}cloneTransformed(t,e){return on.create(t.multiplyPoint3d(this.points[0],e?.points[0]),t.multiplyPoint3d(this.points[1],e?.points[1]),t.multiplyPoint3d(this.points[2],e?.points[2]),e)}get area(){return.5*this.points[0].crossProductToPointsMagnitude(this.points[1],this.points[2])}edgeLengthSquared(t){return this.edgeLength2[J.cyclic3dAxis(t)]}edgeLength(t){return Math.sqrt(this.edgeLengthSquared(t))}get aspectRatio(){return J.safeDivideFraction(this.area,this.edgeLengthSquared(0)+this.edgeLengthSquared(1)+this.edgeLengthSquared(2),0)}get perimeter(){return this.edgeLength(0)+this.edgeLength(1)+this.edgeLength(2)}normal(t){const e=this.points[0].crossProductToPoints(this.points[1],this.points[2],t);if(e.tryNormalizeInPlace())return e}fractionToPoint(t,e,i,n){return $.createAdd3Scaled(this.points[0],t,this.points[1],e,this.points[2],i,n)}pointToFraction(t,e){const i=on._workVector0=this.normal(on._workVector0);if(void 0===i)return rn.create(e);const n=on._workRay=Rt.create(t,i,on._workRay);return this.intersectRay3d(n,e)}static edgeOppositeVertexIndexToStartVertexIndex(t){return J.cyclic3dAxis(t+1)}static edgeStartVertexIndexToOppositeVertexIndex(t){return J.cyclic3dAxis(t-1)}static isInsideTriangle(t,e,i){return t>0&&e>0&&i>0}static isInsideOrOnTriangle(t,e,i){return t>=0&&e>=0&&i>=0}static isInRegionBeyondEdge(t,e,i){return t<0&&e>=0&&i>=0?0:t>=0&&e<0&&i>=0?1:t>=0&&e>=0&&i<0?2:-1}static isInRegionBeyondVertex(t,e,i){return e<0&&i<0?0:t<0&&i<0?1:t<0&&e<0?2:-1}static isOnVertex(t,e,i){return 1===t&&0===e&&0===i?0:0===t&&1===e&&0===i?1:0===t&&0===e&&1===i?2:-1}static isOnBoundedEdge(t,e,i){return 0===t&&e>0&&i>0?0:t>0&&0===e&&i>0?1:t>0&&e>0&&0===i?2:-1}static indexOfMinimum(t){let e=0,i=t(0);const n=t(1);return i>n&&(e=1,i=n),i>t(2)&&(e=2),e}distanceSquared(t,e,i,n,s,r){return-this.edgeLengthSquared(0)*(s-e)*(r-i)-this.edgeLengthSquared(1)*(r-i)*(n-t)-this.edgeLengthSquared(2)*(n-t)*(s-e)}closestVertexIndex(t,e,i){return on.indexOfMinimum((n=>{const s=on._workPoint=$.createZero(on._workPoint);return s.setAt(n,1),this.distanceSquared(s.x,s.y,s.z,t,e,i)}))}dotProductOfEdgeVectorsAtVertex(t){const e=J.cyclic3dAxis(t),i=J.cyclic3dAxis(e+1),n=J.cyclic3dAxis(i+1);return J.dotProductXYZXYZ(this.points[i].x-this.points[e].x,this.points[i].y-this.points[e].y,this.points[i].z-this.points[e].z,this.points[n].x-this.points[e].x,this.points[n].y-this.points[e].y,this.points[n].z-this.points[e].z)}computeProjectionToEdge(t,e){t=J.cyclic3dAxis(t);const i=J.cyclic3dAxis(t+1);return e[J.cyclic3dAxis(i+1)]+e[t]*this.dotProductOfEdgeVectorsAtVertex(i)/this.edgeLengthSquared(t)}closestPoint(t,e,i){const n=[t,e,i];let s=-1,r=0;return on.isInsideTriangle(t,e,i)?(s=on.indexOfMinimum((t=>n[t]*n[t]/this.edgeLengthSquared(t))),r=this.computeProjectionToEdge(s,n)):(s=on.isInRegionBeyondVertex(t,e,i))>=0?(s=J.cyclic3dAxis(s+1),r=this.computeProjectionToEdge(s,n),(r<0||r>1)&&(s=J.cyclic3dAxis(s+1),r=this.computeProjectionToEdge(s,n),(r<0||r>1)&&(r=0,s=on.edgeStartVertexIndexToOppositeVertexIndex(this.closestVertexIndex(t,e,i))))):(s=on.isInRegionBeyondEdge(t,e,i))>=0?(r=this.computeProjectionToEdge(s,n),r<0?r=0:r>1&&(r=0,s=J.cyclic3dAxis(s+1))):(s=on.isOnBoundedEdge(t,e,i))>=0?r=1-n[on.edgeOppositeVertexIndexToStartVertexIndex(s)]:(s=on.isOnVertex(t,e,i))>=0&&(r=0,s=on.edgeStartVertexIndexToOppositeVertexIndex(s)),{closestEdgeIndex:s<0?-1:on.edgeOppositeVertexIndexToStartVertexIndex(s),closestEdgeParam:r}}intersectRay3d(t,e){e=rn.create(e);const i=t.origin,n=t.direction,s=on._workVector0=tt.createStartEnd(this.points[0],this.points[1],on._workVector0),r=on._workVector1=tt.createStartEnd(this.points[0],this.points[2],on._workVector1),o=n.tripleProduct(s,r);if(o*o<=s.dotProduct(s)*r.dotProduct(r)*n.dotProduct(n)*J.smallAngleRadiansSquared)return e;const a=on._workMatrix=xt.createColumns(s,r,n,on._workMatrix),c=tt.createStartEnd(this.points[0],i,on._workVector0),l=on._workVector1;if(void 0===a.multiplyInverse(c,l))return e;e.a=-l.z,t.fractionToPoint(e.a,e.world),e.local.set(1-l.x-l.y,l.x,l.y);const h=this.closestPoint(e.local.x,e.local.y,e.local.z);return e.closestEdgeIndex=h.closestEdgeIndex,e.closestEdgeParam=h.closestEdgeParam,e}intersectSegment(t,e,i){return on._workRay=Rt.createStartEnd(t,e,on._workRay),this.intersectRay3d(on._workRay,i)}snapLocationToEdge(t,e=J.smallMetricDistance,i=J.smallFloatingPoint){if(!t.isValid)return!1;if(i>0){let e=0,n=0;for(let s=0;s<3;s++){const r=Math.abs(t.local.at(s));r>0&&r<i&&(t.local.setAt(s,0),e++),n+=t.local.at(s)}if(e>0&&n>0)return t.local.scaleInPlace(1/n),1===e?(t.closestEdgeIndex=on.edgeOppositeVertexIndexToStartVertexIndex(on.isOnBoundedEdge(t.local.x,t.local.y,t.local.z)),t.closestEdgeParam=1-t.local.at(t.closestEdgeIndex)):(t.closestEdgeIndex=on.isOnVertex(t.local.x,t.local.y,t.local.z),t.closestEdgeParam=0),this.fractionToPoint(t.local.x,t.local.y,t.local.z,t.world),!0}if(e>0){const i=t.closestEdgeIndex,n=(i+1)%3,s=(n+1)%3,r=on._workPoint=this.points[i].interpolate(t.closestEdgeParam,this.points[n],on._workPoint),o=t.world.distance(r);if(o>0&&o<e)return t.local.setAt(i,1-t.closestEdgeParam),t.local.setAt(n,t.closestEdgeParam),t.local.setAt(s,0),t.world.setFrom(r),!0}return!1}dotProductOfCrossProductsFromOrigin(t){return on._workVector0=this.points[0].crossProductToPoints(this.points[1],this.points[2],on._workVector0),on._workVector1=t.points[0].crossProductToPoints(t.points[1],t.points[2],on._workVector1),on._workVector0.dotProduct(on._workVector1)}centroid(t){return $.create((this.points[0].x+this.points[1].x+this.points[2].x)/3,(this.points[0].y+this.points[1].y+this.points[2].y)/3,(this.points[0].z+this.points[1].z+this.points[2].z)/3,t)}incenter(t){const e=this.edgeLength(0),i=this.edgeLength(1),n=this.edgeLength(2),s=J.safeDivideFraction(1,e+i+n,0);return this.fractionToPoint(s*e,s*i,s*n,t)}circumcenter(t){const e=this.edgeLengthSquared(0),i=this.edgeLengthSquared(1),n=this.edgeLengthSquared(2),s=e*(i+n-e),r=i*(n+e-i),o=n*(e+i-n),a=J.safeDivideFraction(1,s+r+o,0);return this.fractionToPoint(a*s,a*r,a*o,t)}isAlmostEqual(t,e){return this.points[0].isAlmostEqual(t.points[0],e)&&this.points[1].isAlmostEqual(t.points[1],e)&&this.points[2].isAlmostEqual(t.points[2],e)}}class an{_parentArray;constructor(t=0){this._parentArray=[];for(let e=0;e<t;e++)this._parentArray.push(e)}get length(){return this._parentArray.length}isValidIndex(t){return 0<=t&&t<this._parentArray.length}addLeaf(){const t=this._parentArray.length;return this._parentArray.push(t),t}findRoot(t){if(!this.isValidIndex(t))return t;let e=t,i=this._parentArray[t];for(;i!==e;)e=i,i=this._parentArray[e];const n=e;for(e=t;e!==n;)i=this._parentArray[e],this._parentArray[e]=n,e=i;return n}mergeSubsets(t,e){if(!this.isValidIndex(t)||!this.isValidIndex(e))return t;const i=this.findRoot(t),n=this.findRoot(e);return i!==n&&(this._parentArray[i]=n),this.findRoot(t)}askParent(t){return this.isValidIndex(t)?this._parentArray[t]:t}countRoots(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t++;return t}countNonTrivialPaths(){let t=0;const e=this._parentArray.length;for(let i=0;i<e;i++){const e=this._parentArray[i];e!==i&&this._parentArray[e]!==e&&t++}return t}collectRootIndices(){const t=[],e=this._parentArray.length;for(let i=0;i<e;i++)this._parentArray[i]===i&&t.push(i);return t}}class cn{_freeMasks;_originalFreeMasks;_firstFreeMask;constructor(t,e){this._freeMasks=t,this._originalFreeMasks=t,this._firstFreeMask=e}static create(t){let e=0,i=1;for(let n=0;n<32;n++){if(i&t){e=i;break}i<<=1}if(0!==e)return new cn(t,e)}grabMask(){if(0===this._freeMasks)return 0;let t=this._firstFreeMask;for(;!(t&this._freeMasks);)t<<=1;return this._freeMasks&=~t,t}dropMask(t){t&=this._originalFreeMasks,this._freeMasks|=t}}!function(t){t[t.EXTERIOR=1]="EXTERIOR",t[t.BOUNDARY_EDGE=2]="BOUNDARY_EDGE",t[t.PRIMARY_EDGE=4]="PRIMARY_EDGE",t[t.VISITED=16]="VISITED",t[t.TRIANGULATED_FACE=256]="TRIANGULATED_FACE",t[t.NULL_FACE=512]="NULL_FACE",t[t.NULL_MASK=0]="NULL_MASK",t[t.ALL_GRAB_DROP_MASKS=4293918720]="ALL_GRAB_DROP_MASKS",t[t.ALL_MASK=4294967295]="ALL_MASK"}(E||(E={}));class ln{i;maskBits;x;y;z;sortAngle;sortData;edgeTag;faceTag;_id;get id(){return this._id}_facePredecessor;_faceSuccessor;_edgeMate;get facePredecessor(){return this._facePredecessor}get faceSuccessor(){return this._faceSuccessor}get edgeMate(){return this._edgeMate}static _totalNodesCreated=0;constructor(t=0,e=0,i=0,n=0){this._id=ln._totalNodesCreated++,this.i=n,this.maskBits=0,this.x=t,this.y=e,this.z=i,this.sortAngle=void 0,this.sortData=void 0,this.edgeTag=void 0,this.faceTag=void 0,this._facePredecessor=this,this._faceSuccessor=this,this._edgeMate=this}faceStepY(t){let e=this;if(t>0)for(let i=0;i<t;i++)e=e.faceSuccessor;else if(t<0)for(let i=0;i>t;i--)e=e.facePredecessor;return e.y}static createHalfEdgePair(t){const e=new ln,i=new ln;return t&&(t.push(e),t.push(i)),ln.setFaceLinks(e,i),ln.setFaceLinks(i,e),ln.setEdgeMates(e,i),e}static createHalfEdgePairWithCoordinates(t=0,e=0,i=0,n=0,s=0,r=0,o=0,a=0,c){const l=ln.createHalfEdgePair(c),h=l._edgeMate;return l.x=t,l.y=e,l.z=i,l.i=n,h.x=s,h.y=r,h.z=o,h.i=a,l}static setFaceLinks(t,e){t._faceSuccessor=e,e._facePredecessor=t}static setEdgeMates(t,e){t._edgeMate=e,e._edgeMate=t}static splitEdge(t,e=0,i=0,n=0,s=0,r){const o=new ln(e,i,n,s),a=new ln(e,i,n,s);if(r&&(r.push(o),r.push(a)),void 0===t)o._faceSuccessor=o._facePredecessor=o,a._faceSuccessor=a._facePredecessor=a,ln.setEdgeMates(o,a);else{const e=t._faceSuccessor,i=t._edgeMate,n=i._faceSuccessor;ln.setFaceLinks(o,e),ln.setFaceLinks(t,o),ln.setFaceLinks(i,a),ln.setFaceLinks(a,n),ln.setEdgeMates(o,i),ln.setEdgeMates(a,t),this.transferEdgeProperties(t,o),this.transferEdgeProperties(i,a)}return o}static splitEdgeCreateSliverFace(t,e){const i=t.edgeMate,n=new ln,s=new ln;return e&&(e.push(n),e.push(s)),n._faceSuccessor=n._facePredecessor=s,s._faceSuccessor=s._facePredecessor=n,ln.setEdgeMates(n,i),ln.setEdgeMates(s,t),n.copyDataFrom(t,!0,!0,!1,!1),s.copyDataFrom(i,!0,!0,!1,!1),n}static _edgePropertyMasks=[E.BOUNDARY_EDGE,E.EXTERIOR,E.PRIMARY_EDGE,E.NULL_FACE];static transferEdgeProperties(t,e){e.edgeTag=t.edgeTag;for(const i of this._edgePropertyMasks)t.getMask(i)?e.setMask(i):e.clearMask(i)}get vertexSuccessor(){return this.facePredecessor.edgeMate}get vertexPredecessor(){return this.edgeMate.faceSuccessor}setMask(t){this.maskBits|=t}getMask(t){return this.maskBits&t}clearMask(t){this.maskBits&=~t}setMaskAroundVertex(t){let e=this;do{e.setMask(t),e=e.vertexSuccessor}while(e!==this)}setXYZAroundVertex(t,e,i){let n=this;do{n.x=t,n.y=e,n.z=i,n=n.vertexSuccessor}while(n!==this)}setMaskAroundFace(t){let e=this;do{e.setMask(t),e=e.faceSuccessor}while(e!==this)}setMaskAroundEdge(t){this.setMask(t),this.edgeMate.setMask(t)}clearMaskAroundEdge(t){this.clearMask(t),this.edgeMate.clearMask(t)}countEdgesAroundFace(){let t=0,e=this;do{t++,e=e.faceSuccessor}while(e!==this);return t}findAroundVertex(t){let e=this;do{if(e===t)return!0;e=e.vertexSuccessor}while(e!==this);return!1}findAroundFace(t){let e=this;do{if(e===t)return!0;e=e.faceSuccessor}while(e!==this);return!1}isMaskedAroundFace(t,e=!0){let i=this;if(e)do{if(!i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);else do{if(i.isMaskSet(t))return!1;i=i.faceSuccessor}while(i!==this);return!0}setMaskAndEdgeTagAroundFace(t,e,i=!1){let n=this;do{if(n.setMask(t),n.edgeTag=e,i){const i=n.edgeMate;i.setMask(t),i.edgeTag=e}n=n.faceSuccessor}while(n!==this)}countEdgesAroundVertex(){let t=0,e=this;do{t++,e=e.vertexSuccessor}while(e!==this);return t}countMaskAroundFace(t,e=!0){let i=0,n=this;if(e)do{n.isMaskSet(t)&&i++,n=n.faceSuccessor}while(n!==this);else do{n.isMaskSet(t)||i++,n=n.faceSuccessor}while(n!==this);return i}countMaskAroundVertex(t,e=!0){let i=0,n=this;if(e)do{n.isMaskSet(t)&&i++,n=n.vertexSuccessor}while(n!==this);else do{n.isMaskSet(t)||i++,n=n.vertexSuccessor}while(n!==this);return i}findMaskAroundVertex(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.vertexSuccessor}while(i!==this)}findMaskAroundFace(t,e=!0){let i=this;do{if(i.isMaskSet(t)===e)return i;i=i.faceSuccessor}while(i!==this)}findMaskAroundEdge(t,e=!0){if(this.isMaskSet(t)===e)return this;const i=this.edgeMate;return i.isMaskSet(t)===e?i:void 0}testAndSetMask(t){const e=this.maskBits&t;return this.maskBits|=t,e}setXYZFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}setXYZ(t){this.x=t.x,this.y=t.y,this.z=t.z}isMaskSet(t){return!!(this.maskBits&t)}static filterIsMaskOn(t,e){return t.isMaskSet(e)}static filterIsMaskOff(t,e){return!t.isMaskSet(e)}static createEdgeXYXY(t,e,i,n,s,r){const o=new ln(e,i),a=new ln(s,r);return o._faceSuccessor=o._facePredecessor=o._edgeMate=a,a._faceSuccessor=a._facePredecessor=a._edgeMate=o,o._id=t,a._id=n,o}static pinch(t,e){if(t!==e){const i=t._facePredecessor,n=e._facePredecessor;e._facePredecessor=i,t._facePredecessor=n,n._faceSuccessor=t,i._faceSuccessor=e}}yankFromVertexLoop(){const t=this.edgeMate.faceSuccessor;if(t!==this)return ln.pinch(this,t),t}decommission(){this._facePredecessor=void 0,this._faceSuccessor=void 0,this._edgeMate=void 0}static nodeToSelf(t){return t}static nodeToId(t){return t.id}static nodeToIdString(t){return t.id.toString()}static nodeToIdMaskXY(t){return{id:t.id,mask:ln.nodeToMaskString(t),xy:[t.x,t.y]}}static nodeToIdXYString(t){return`${t.id.toString()}+${ln.nodeToMaskString(t)}[${t.x},${t.y}]`}static nodeToIdXYZString(t){return`[${t.id.toString()}: ${t.x},${t.y},${t.z}]`}static nodeToMaskString(t){let e="";return t.isMaskSet(E.BOUNDARY_EDGE)&&(e+="B"),t.isMaskSet(E.PRIMARY_EDGE)&&(e+="P"),t.isMaskSet(E.EXTERIOR)&&(e+="X"),t.isMaskSet(E.NULL_FACE)&&(e+="N"),e}static nodeToXY(t){return[t.x,t.y]}vectorToFaceSuccessorXY(t){return j.create(this.faceSuccessor.x-this.x,this.faceSuccessor.y-this.y,t)}vectorToFaceSuccessor(t){const e=this.faceSuccessor;return tt.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}vectorToFacePredecessor(t){const e=this.facePredecessor;return tt.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}static isNodeVisibleInSector(t,e){if(e.vertexSuccessor===e)return!0;const i=e.faceSuccessor,n=e.facePredecessor,s=this.crossProductXYToTargets(e,i,t),r=this.crossProductXYToTargets(n,e,t);if(s>0&&r>0)return!0;const o=this.crossProductXYToTargets(n,e,i);return r<=0&&s<=0?0===r&&0===s&&0===o&&(n===i&&e.vertexSuccessor!==e?t===i:ln.dotProductNodeToNodeVectorsXY(n,e,e,t)>0):0===o&&0!==r&&0!==s?n!==i:o<0}static crossProductXYToTargets(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static dotProductNodeToNodeVectorsXY(t,e,i,n){return J.dotProductXYXY(e.x-t.x,e.y-t.y,n.x-i.x,n.y-i.y)}static crossProductXYAlongChain(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-e.x,i.y-e.y)}static isSectorConvex(t,e,i,n=0){const s=.5*ln.crossProductXYAlongChain(t,e,i);return n=n??0,Math.abs(s)<=Math.abs(n)?ln.dotProductNodeToNodeVectorsXY(t,e,e,i)>0:s>-n}isSectorConvex(t){return void 0===t&&(t=J.smallMetricDistanceSquared*this.signedFaceArea()),ln.isSectorConvex(this.facePredecessor,this,this.faceSuccessor,t)}isFaceConvex(t=J.smallMetricDistanceSquared){let e=this;const i=t>0?t*e.signedFaceArea():0;do{if(!e.isSectorConvex(i))return!1;e=e.faceSuccessor}while(e!==this);return!0}isolateEdge(){const t=this.edgeMate;this.yankFromVertexLoop(),t.yankFromVertexLoop()}get isIsolatedEdge(){return this===this.vertexSuccessor&&this.edgeMate===this.edgeMate.vertexSuccessor}belowYX(t){return this.y<t.y||!(this.y>t.y)&&this.x<t.x}static testNodeMaskNotExterior(t){return!t.isMaskSet(E.EXTERIOR)}static testMateMaskExterior(t){return t.edgeMate.isMaskSet(E.EXTERIOR)}static sectorSweepRadiansXYZ(t,e){const i=t.faceSuccessor,n=t.facePredecessor;return G.orientedRadiansBetweenVectorsXYZ(i.x-t.x,i.y-t.y,i.z-t.z,n.x-t.x,n.y-t.y,n.z-t.z,e.x,e.y,e.z,!0)}static testFacePositiveAreaXY(t){return t.countEdgesAroundFace()>2&&t.signedFaceArea()>0}isEqualXY(t){return this.x===t.x&&this.y===t.y}distanceXY(t){return J.distanceXYXY(this.x,this.y,t.x,t.y)}distanceXYZ(t){return J.distanceXYZXYZ(this.x,this.y,this.z,t.x,t.y,t.z)}collectAroundFace(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.faceSuccessor}while(i!==this);return e}collectMaskedEdgesAroundVertex(t,e=!0,i){void 0===i?i=[]:i.length=0;let n=this;do{n.isMaskSet(t)===e&&i.push(n),n=n.vertexSuccessor}while(n!==this);return i}collectAroundVertex(t){const e=[];let i=this;do{e.push(t?t(i):i),i=i.vertexSuccessor}while(i!==this);return e}sumAroundFace(t){let e=this,i=0;do{i+=t(e),e=e.faceSuccessor}while(e!==this);return i}sumAroundVertex(t){let e=this,i=0;do{i+=t(e),e=e.vertexSuccessor}while(e!==this);return i}clearMaskAroundFace(t){let e=this;do{e.clearMask(t),e=e.faceSuccessor}while(e!==this)}clearMaskAroundVertex(t){let e=this;do{e.clearMask(t),e=e.vertexSuccessor}while(e!==this)}signedFaceArea(){let t=0,e=this.x,i=0;const n=this.y;let s,r=0,o=0,a=this;do{s=a.faceSuccessor,i=s.x,o=s.y-n,t+=(e-i)*(r+o),e=i,r=o,a=s}while(a!==this);return.5*t}fractionToPoint2d(t,e){const i=this.faceSuccessor;return H.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,e)}fractionToPoint3d(t,e){const i=this.faceSuccessor;return $.create(this.x+(i.x-this.x)*t,this.y+(i.y-this.y)*t,this.z+(i.z-this.z)*t,e)}fractionAlongAndPerpendicularToPoint2d(t,e,i){const n=this.faceSuccessor,s=n.x-this.x,r=n.y-this.y;return H.create(this.x+s*t-r*e,this.y+r*t+s*e,i)}getPoint3d(t){return $.create(this.x,this.y,this.z,t)}getPoint2d(t){return H.create(this.x,this.y,t)}getVector3dAlongEdge(t){const e=this.faceSuccessor;return tt.create(e.x-this.x,e.y-this.y,e.z-this.z,t)}getVector2dAlongEdge(t){const e=this.faceSuccessor;return j.create(e.x-this.x,e.y-this.y,t)}fractionToX(t){const e=this.faceSuccessor;return this.x+(e.x-this.x)*t}fractionToY(t){const e=this.faceSuccessor;return this.y+(e.y-this.y)*t}fractionToZ(t){const e=this.faceSuccessor;return this.z+(e.z-this.z)*t}static transverseIntersectionFractions(t,e,i){const n=t.faceSuccessor,s=e.faceSuccessor;if(i||(i=j.create()),Ft.linearSystem2d(n.x-t.x,e.x-s.x,n.y-t.y,e.y-s.y,e.x-t.x,e.y-t.y,i))return i}static horizontalScanFraction(t,e){const i=t.faceSuccessor,n=i.y-t.y;return J.isSameCoordinate(e,t.y)&&J.isSameCoordinate(e,i.y)?t:J.isSameCoordinate(n,0)?void 0:J.conditionalDivideFraction(e-t.y,n)}static horizontalScanFraction01(t,e){const i=t.faceSuccessor,n=i.y-t.y;if(J.isSameCoordinate(e,t.y)&&J.isSameCoordinate(e,i.y))return;if(J.isSameCoordinate(n,0))return;const s=J.conditionalDivideFraction(e-t.y,n);return void 0!==s&&s>=0&&s<=1?s:void 0}copyDataFrom(t,e,i,n,s){e&&(this.x=t.x,this.y=t.y,this.z=t.z),i&&(this.i=t.i),n&&(ln.transferEdgeProperties(t,this),this.edgeTag=t.edgeTag),s&&(this.faceTag=t.faceTag)}}class hn{allHalfEdges;_maskManager;_numNodesCreated=0;constructor(){this.allHalfEdges=[],this._maskManager=cn.create(E.ALL_GRAB_DROP_MASKS)}grabMask(t=!0){const e=this._maskManager.grabMask();return t&&this.clearMask(e),e}dropMask(t){this._maskManager.dropMask(t)}createEdgeXYZXYZ(t=0,e=0,i=0,n=0,s=0,r=0,o=0,a=0){return ln.createHalfEdgePairWithCoordinates(t,e,i,n,s,r,o,a,this.allHalfEdges)}createEdgeIdId(t=0,e=0){return ln.createHalfEdgePairWithCoordinates(0,0,0,t,0,0,0,e,this.allHalfEdges)}createEdgeXYZHalfEdge(t=0,e=0,i=0,n=0,s,r=0){const o=ln.createHalfEdgePairWithCoordinates(t,e,i,n,s.x,s.y,s.z,r,this.allHalfEdges),a=o.faceSuccessor;return ln.pinch(s,a),o}createEdgeHalfEdgeHalfEdge(t,e,i,n=0){const s=ln.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,n,this.allHalfEdges),r=s.faceSuccessor;return ln.pinch(t,s),ln.pinch(i,r),s}createEdgeXYAndZ(t,e,i,n){return ln.createHalfEdgePairWithCoordinates(t.x,t.y,t.z,e,i.x,i.y,i.z,n,this.allHalfEdges)}splitEdge(t,e=0,i=0,n=0,s=0){return ln.splitEdge(t,e,i,n,s,this.allHalfEdges)}splitEdgeCreateSliverFace(t){return ln.splitEdgeCreateSliverFace(t,this.allHalfEdges)}splitEdgeAtFraction(t,e){return ln.splitEdge(t,t.fractionToX(e),t.fractionToY(e),t.fractionToZ(e),0,this.allHalfEdges)}decommission(){for(const t of this.allHalfEdges)t.decommission();this.allHalfEdges.length=0,this.allHalfEdges=void 0}addEdgeXY(t,e,i,n){const s=ln.createEdgeXYXY(this._numNodesCreated,t,e,this._numNodesCreated+1,i,n);return this._numNodesCreated+=2,this.allHalfEdges.push(s),this.allHalfEdges.push(s.faceSuccessor),s}clearMask(t){for(const e of this.allHalfEdges)e.maskBits&=~t}setMask(t){for(const e of this.allHalfEdges)e.maskBits|=t}reverseMask(t){for(const e of this.allHalfEdges)e.maskBits^=t}countMask(t){let e=0;for(const i of this.allHalfEdges)i.isMaskSet(t)&&e++;return e}collectSegments(){const t=[];for(const e of this.allHalfEdges)e.id<e.edgeMate.id&&t.push(Te.create($.create(e.x,e.y),$.create(e.faceSuccessor.x,e.faceSuccessor.y)));return t}countVertexLoops(){let t=0;return this.announceVertexLoops(((e,i)=>(t++,!0))),t}countFaceLoops(){let t=0;return this.announceFaceLoops(((e,i)=>(t++,!0))),t}countFaceLoopsWithMaskFilter(t,e){let i=0;return this.announceFaceLoops(((n,s)=>(t(s,e)&&i++,!0))),i}collectVertexLoops(){const t=[];return this.announceVertexLoops(((e,i)=>(t.push(i),!0))),t}collectFaceLoops(){const t=[];return this.announceFaceLoops(((e,i)=>(t.push(i),!0))),t}announceVertexLoops(t){this.clearMask(E.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(E.VISITED)&&(e.setMaskAroundVertex(E.VISITED),!t(this,e)))break}announceFaceLoops(t){this.clearMask(E.VISITED);for(const e of this.allHalfEdges)if(!e.getMask(E.VISITED)&&(e.setMaskAroundFace(E.VISITED),!t(this,e)))break}announceEdges(t){this.clearMask(E.VISITED);for(const e of this.allHalfEdges){if(e.getMask(E.VISITED))continue;const i=e.edgeMate;if(e.setMask(E.VISITED),i.setMask(E.VISITED),!t(this,e))break}}announceNodes(t){for(const e of this.allHalfEdges)if(!t(this,e))break}countNodes(){return this.allHalfEdges.length}transformInPlace(t){for(const e of this.allHalfEdges)t.multiplyXYAndZInPlace(e)}yankAndDeleteEdges(t){const e=this.allHalfEdges.length;let i=0;for(let n=0;n<e;n++){const e=this.allHalfEdges[n];t(e)?e.yankFromVertexLoop():this.allHalfEdges[i++]=e}const n=e-i;return this.allHalfEdges.length=i,n}deleteIsolatedEdges(){const t=this.allHalfEdges.length;let e=0;for(let i=0;i<t;i++){const t=this.allHalfEdges[i];t.isIsolatedEdge||(this.allHalfEdges[e++]=t)}const i=t-e;return this.allHalfEdges.length=e,i}}class dn{_array=[];_compare;_clone;constructor(t,e=V){this._compare=t,this._clone=e}get length(){return this._array.length}get isEmpty(){return 0===this.length}[Symbol.iterator](){return this._array[Symbol.iterator]()}_swap(t,e){const i=this._array[t];this._array[t]=this._array[e],this._array[e]=i}_heapify(t){let e=-1;for(;;){const i=2*(t+1),n=i-1;if(e=n<this.length&&this._compare(this._array[n],this._array[t])<0?n:t,i<this.length&&this._compare(this._array[i],this._array[e])<0&&(e=i),e===t)break;this._swap(e,t),t=e}}sort(){for(let t=Math.ceil(this.length/2);t>=0;t--)this._heapify(t)}push(t){const e=this._clone(t);let i=this.length;for(this._array.push(e);0!==i;){const t=Math.floor((i-1)/2);if(!(this._compare(this._array[i],this._array[t])<0))break;this._swap(i,t),i=t}return e}append(t){const e=this._clone(t);return this._array.push(e),e}get front(){return this._peek(0)}pop(){return this._pop(0)}clear(){this._array.length=0}_pop(t){if(t<0||t>=this.length)return;const e=this._array[t];return this._swap(t,this.length-1),this._array.length--,this._heapify(t),e}_peek(t){return t<0||t>=this.length?void 0:this._array[t]}}class un{priorityQueue;activeEdges;constructor(t=(t,e)=>qn.compareNodesYXUp(t,e)){this.priorityQueue=new dn(t),this.activeEdges=[]}popQueueToArray(){if(this.priorityQueue.isEmpty)return;const t=this.priorityQueue.pop();return this.activeEdges.push(t),t}popArrayToArrayIndex(t){if(t<this.activeEdges.length){const e=this.activeEdges.pop();this.activeEdges[t]=e}}removeArrayMembersWithY1Below(t){let e=0;const i=this.activeEdges.length;for(let n=0;n<i;n++){const i=this.activeEdges[n];i.faceSuccessor.y>=t&&(e<n&&(this.activeEdges[e]=i),e++)}this.activeEdges.length=e}}class fn{static announceEdge;constructor(t){this.graph=t,this.upEdges=[],this.downEdges=[],this.bottomPeaks=[],this.topPeaks=[],this.localMin=[],this.localMax=[]}graph;upEdges;downEdges;topPeaks;bottomPeaks;localMin;localMax;collectVerticalEventsAroundFace(t){let e,i,n,s,r=t;this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0;do{e=r.faceSuccessor,i=e.faceSuccessor,n=qn.compareNodesYXUp(r,e)<0,s=qn.compareNodesYXUp(e,i)<0,n?(this.upEdges.push(r),s||(qn.crossProductToTargets(e,r,i)<0?this.localMax.push(e):this.topPeaks.push(e))):(this.downEdges.push(r),s&&(qn.crossProductToTargets(e,r,i)>0?this.bottomPeaks.push(e):this.localMin.push(e))),r=e}while(r!==t)}collectVerticalEventFromEdgesInAndArray(t){let e,i,n,s,r;for(e of(this.upEdges.length=0,this.downEdges.length=0,this.topPeaks.length=0,this.bottomPeaks.length=0,this.localMin.length=0,this.localMax.length=0,t))i=e.faceSuccessor,n=i.faceSuccessor,s=qn.compareNodesYXUp(e,i)<0,r=qn.compareNodesYXUp(i,n)<0,s?(this.upEdges.push(e),r||(qn.crossProductToTargets(i,e,n)<0?this.localMax.push(i):this.topPeaks.push(i))):(this.downEdges.push(e),r&&(qn.crossProductToTargets(i,e,n)>0?this.bottomPeaks.push(i):this.localMin.push(i)))}swapArrays(){let t=this.downEdges;this.downEdges=this.upEdges,this.upEdges=t,t=this.localMax,this.localMax=this.localMin,this.localMin=t,t=this.topPeaks,this.topPeaks=this.bottomPeaks,this.bottomPeaks=t}findTopVisibleEdge(t,e,i){const n=t.y,s=t.x;let r,o,a=Number.MAX_SAFE_INTEGER;for(const c of e){const e=c.faceSuccessor;if(c===t||e===t)continue;if(qn.compareNodesYXUp(t,c)*qn.compareNodesYXUp(t,e)>=0)continue;const l=ln.horizontalScanFraction01(c,n);void 0!==l&&(r=i*(c.fractionToX(l)-s),r>0&&r<a&&(o=c,a=r))}return o}highestUpPeakConnection(t,e,i){let n;for(const s of this.topPeaks){const r=s.y,o=s.x;if(!(void 0!==n&&qn.compareNodesYXUp(s,n)<0)&&qn.compareNodesYXUp(s,t)<0){if(e){const t=ln.horizontalScanFraction01(e,r);if(void 0===t)continue;if(o<=e.fractionToX(t))continue}if(i){const t=ln.horizontalScanFraction01(i,r);if(void 0===t)continue;if(i.fractionToX(t)<=o)continue}n=s}}return n}updateMaxNode(t,e,i){return t?e&&i(t,e)<0?e:t:e}negateXY(){for(const t of this.graph.allHalfEdges)t.x*=-1,t.y*=-1}downwardConnectionFromBottomPeak(t){let e;const i=(t,e)=>qn.compareNodesYXUp(t,e),n=this.findTopVisibleEdge(t,this.upEdges,1),s=this.findTopVisibleEdge(t,this.downEdges,-1);e=this.updateMaxNode(e,n,i),s&&(e=this.updateMaxNode(e,s.faceSuccessor,i));const r=this.highestUpPeakConnection(t,s,n);return void 0!==r&&(e=this.updateMaxNode(e,r,i)),e}findVisibleSector(t,e){let i=t;do{if(ln.isNodeVisibleInSector(e,i))return i;i=i.vertexSuccessor}while(i!==t)}joinNodes(t,e,i){const n=this.graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0),s=this.findVisibleSector(t,e),r=this.findVisibleSector(e,t);if(void 0!==s&&void 0!==r)return ln.pinch(s,n),ln.pinch(r,n.edgeMate),fn.announceEdge&&fn.announceEdge(this.graph,t,e,i),n}runRegularization(t=!0,e=!0){if(t){this.bottomPeaks.sort(((t,e)=>qn.compareNodesYXUp(t,e)));for(const t of this.bottomPeaks){if(!qn.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,1)}}if(e){this.negateXY(),this.swapArrays(),this.bottomPeaks.sort(((t,e)=>qn.compareNodesYXUp(t,e)));for(const t of this.bottomPeaks){if(!qn.isDownPeak(t))continue;const e=this.downwardConnectionFromBottomPeak(t);void 0!==e&&this.joinNodes(t,e,-1)}this.negateXY(),this.swapArrays()}}regularizeFace(t,e=!0,i=!0){this.collectVerticalEventsAroundFace(t),this.runRegularization(e,i)}regularizeGraph(t=!0,e=!0){this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges),this.runRegularization(t,e)}static isMonotoneFace(t){let e,i=0,n=0,s=t;do{const t=s.faceSuccessor,r=t.faceSuccessor,o=qn.compareNodesYXUp(s,t),a=qn.compareNodesYXUp(t,r);o*a<=0&&(o>0&&(i++,e=t),a>0&&n++)}while((s=s.faceSuccessor)!==t);return 1===i&&1===n?e:void 0}static collectMappedFaceRepresentatives(t,e,i,n,s){n&&(n.length=0),s&&(s.length=0);const r=E.VISITED;t.clearMask(r);for(const o of t.allHalfEdges)if(!o.getMask(r)&&(o.setMaskAroundFace(r),!e||o.signedFaceArea()>0)){const t=i(o);t?n&&n.push(t):s&&s.push(o)}}}class gn extends $e{curveCollectionType="unionRegion";isSameGeometryClass(t){return t instanceof gn}_children;get children(){return this._children}constructor(){super(),this._children=[]}static create(...t){const e=new gn;for(const i of t)e.tryAddChild(i);return e}dgnBoundaryType(){return 5}announceToCurveProcessor(t,e=-1){return t.announceUnionRegion(this,e)}cloneStroked(t){const e=new gn;let i;for(i of this._children){const n=i.cloneStroked(t);n&&e.children.push(n)}return e}cloneEmptyPeer(){return new gn}tryAddChild(t){return!(!t||!(t instanceof Ti||t instanceof oi)||(this._children.push(t),0))}getChild(t){if(t<this._children.length)return this._children[t]}dispatchToGeometryHandler(t){return t.handleUnionRegion(this)}}class pn{_cachedObjects;numDrop;numCreate;numReuse;constructor(){this._cachedObjects=[],this.numDrop=0,this.numCreate=0,this.numReuse=0}dropToCache(t){t&&(this.numDrop++,this.clearForCache(t),this._cachedObjects.push(t))}grabFromCache(){let t=this._cachedObjects.pop();return void 0===t?(t=this.createForCache(),this.numCreate++):this.numReuse++,t}dropAllToCache(t){for(;t.length>0;)this.dropToCache(t.pop())}}class mn extends pn{clearForCache(t){t.length=0}createForCache(){return new rt(10)}constructor(){super()}grabAndFill(t){const e=this.grabFromCache();return e.pushFrom(t),e}}class _n{_convexSets;get convexSets(){return this._convexSets}constructor(){this._convexSets=[]}toJSON(){const t=[];for(const e of this._convexSets)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new _n)._convexSets.length=0,!Array.isArray(t))return e;for(const i of t)e._convexSets.push(As.fromJSON(i));return e}static createEmpty(t){return t?(t._convexSets.length=0,t):new _n}isAlmostEqual(t){if(this._convexSets.length!==t._convexSets.length)return!1;for(let e=0;e<this._convexSets.length;e++)if(!this._convexSets[e].isAlmostEqual(t._convexSets[e]))return!1;return!0}static createConvexSets(t,e){e=e||new _n;for(const i of t)e._convexSets.push(i);return e}clone(t){(t=t||new _n)._convexSets.length=0;for(const e of this._convexSets)t._convexSets.push(e.clone());return t}addConvexSet(t){t&&this._convexSets.push(t)}hasIntersectionWithRay(t,e){if(void 0===e){for(const e of this._convexSets)if(e.hasIntersectionWithRay(t))return!0;return!1}e.setNull();const i=gt.createNull();for(const n of this._convexSets)n.hasIntersectionWithRay(t,i)&&e.extendRange(i);return!e.isNull}isPointInside(t){for(const e of this._convexSets)if(e.isPointInside(t))return!0;return!1}isPointOnOrInside(t,e=J.smallMetricDistance){for(const i of this._convexSets)if(i.isPointOnOrInside(t,e))return!0;return!1}isSphereInside(t,e){for(const i of this._convexSets)if(i.isSphereInside(t,e))return!0;return!1}isAnyPointInOrOnFromSegment(t){for(const e of this._convexSets)if(e.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref))return!0;return!1}appendIntervalsFromSegment(t,e){for(const i of this._convexSets)i.announceClippedSegmentIntervals(0,1,t.point0Ref,t.point1Ref,((t,i)=>e.push(De.create(t,i))))}transformInPlace(t){for(const e of this._convexSets)e.transformInPlace(t)}classifyPointContainment(t,e){for(const i of this._convexSets){const n=i.classifyPointContainment(t,e);if(n!==R.StronglyOutside)return n}return R.StronglyOutside}polygonClip(t,e){e.length=0,Array.isArray(t)&&(t=rt.create(t));const i=new rt;for(const n of this._convexSets){const s=new rt;n.polygonClip(t,s,i),0!==s.length&&e.push(s)}}announceClippedSegmentIntervals(t,e,i,n,s){let r=0;for(const o of this._convexSets)o.announceClippedSegmentIntervals(t,e,i,n,s)&&r++;return r>0}static _clipArcFractionArray=new bt;announceClippedArcIntervals(t,e){const i=_n._clipArcFractionArray;i.clear();for(const e of this._convexSets)for(const n of e.planes)n.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),kn.selectIntervals01(t,i,this,e)}computePlanePlanePlaneIntersectionsInAllConvexSets(t,e,i,n=!0){let s=0;for(const r of this._convexSets)s+=r.computePlanePlanePlaneIntersections(t,e,i,n);return s}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._convexSets)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}setInvisible(t){for(const e of this._convexSets)e.setInvisible(t)}addOutsideZClipSets(t,e,i){if(e){const i=As.createEmpty();i.addZClipPlanes(t,e),this._convexSets.push(i)}if(i){const e=As.createEmpty();e.addZClipPlanes(t,void 0,i),this._convexSets.push(e)}}takeConvexSets(t){let e;for(;void 0!==(e=t._convexSets.pop());)this._convexSets.push(e)}appendPolygonClip(t,e,i,n){const s=i.length,r=e.length;let o,a,c=[n.grabAndFill(t)],l=[];for(const t of this._convexSets){for(;void 0!==(a=c.pop());)t.appendPolygonClip(a,e,l,n),n.dropToCache(a);o=l,l=c,c=o}for(;void 0!==(a=c.pop());)i.push(a);i.length===s?kn.restoreSingletonInPlaceOfMultipleShards(e,r,t,n):e.length===r&&kn.restoreSingletonInPlaceOfMultipleShards(i,s,t,n)}}class xn{static advanceIntervalDifference(t,e,i,n){const s=e.length;let r=t.low,o=t.high;for(;i<s;){const t=e[i];if(t.high<r)i++;else{if(!(t.high<=o)){t.low<o&&(o=t.low);break}t.low>r&&n.push(gt.createXX(r,t.low)),r=t.high,i++}}return r<o&&n.push(gt.createXX(r,o)),n}static differenceSorted(t,e){const i=t.length,n=[];for(let s=0;s<i;s++)xn.advanceIntervalDifference(t[s],e,0,n);return n}static advanceIntervalIntersection(t,e,i){return e.low>t.high||(e.high>=t.high?(i.push(gt.createXX(e.low,t.high)),!0):(i.push(gt.createXX(e.low,e.high)),!1))}static intersectSorted(t,e){let i=0,n=0;const s=t.length,r=e.length,o=[];for(;i<s&&n<r;){const s=t[i],r=e[n];s.low<=r.low?xn.advanceIntervalIntersection(s,r,o)?i++:n++:xn.advanceIntervalIntersection(r,s,o)?n++:i++}return o}static advanceIntervalUnion(t,e,i){if(i>=e.length)return!1;const n=e[i];return!(n.low>t.high||(n.high>t.high&&(t.high=n.high),0))}static unionSorted(t,e){const i=t.length,n=e.length;let s=0,r=0;const o=[];for(;s<i&&r<n;){const i=t[s],n=e[r];let a;i.low<=n.low?(a=i.clone(),s++):(a=n.clone(),r++);let c=!0;do{const i=xn.advanceIntervalUnion(a,t,s),n=xn.advanceIntervalUnion(a,e,r);i&&s++,n&&r++,i||n||(c=!1)}while(c);o.push(a)}for(;s<i;)o.push(t[s++]);for(;r<n;)o.push(e[r++]);return o}static paritySorted(t,e){const i=[];for(const e of t)i.push(e.clone());for(const t of e)i.push(t.clone());return i.sort(yn),xn.simplifySortParity(i,!0),i}static sort(t){t.sort(yn)}static simplifySortUnion(t,e=!1){if(t.length<2)return;t.sort(yn);let i=0;for(let e=1;e<t.length;e++)t[e].low<=t[i].high?t[e].high>t[i].high&&(t[i].high=t[e].high):(i++,t[i].setFrom(t[e]));if(t.length=i+1,e){i=-1;for(let e=0;e<t.length;e++)t[e].low<t[e].high&&i<e&&t[++i].setFrom(t[e])}}static simplifySortParity(t,e=!1){const i=[];for(const e of t)e.low!==e.high&&(i.push(e.low),i.push(e.high));const n=i.length;i.sort(((t,e)=>t<e?-1:t>e?1:0));let s,r,o=0;for(let a=0;a<n;a+=2)if(s=i[a],r=i[a+1],e){for(;a+2<n&&i[a+2]===r;)a+=2,r=i[a+1];r>s&&gt.createXX(s,r,t[o++])}else gt.createXX(s,r,t[o++]);t.length=o}static testUnion(t,e){return this.countContainingRanges(t,e)>0}static testParity(t,e){let i=!1;for(const n of t)n.containsX(e)&&(i=!i);return i}static countContainingRanges(t,e){let i=0;for(const n of t)n.containsX(e)&&i++;return i}static getBreaks(t,e,i=!1,n=!1,s=!0){e||(e=new bt(2*t.length)),s&&e.clear();for(const i of t)e.push(i.low),e.push(i.high);return i&&e.sort(),n&&e.compressAdjacentDuplicates(),e}static appendFractionalPoints(t,e,i,n,s,r,o,a){const c=t.length;if(c>0){void 0!==e&&a.push(t[0].fractionToPoint(e));for(let e=0;e<c;e++)void 0===i||!n&&t[e].low===t[e].high||a.push(t[e].fractionToPoint(i)),e>1&&void 0!==s&&(r||t[e].low!==t[e].high)&&a.push(J.interpolate(t[e-1].high,s,t[e].low));void 0!==o&&a.push(t[c-1].fractionToPoint(o))}return a}static firstLowToLastHigh(t){return 0===t.length?gt.createNull():gt.createXX(t[0].low,t[t.length-1].high)}static sumLengths(t){let e=0;for(const i of t)e+=i.length();return e}static isSorted(t,e=!0){const i=t.length;if(e){for(let e=0;e+1<i;e++)if(t[e].high>=t[e+1].low)return!1}else for(let e=0;e+1<i;e++)if(t[e].high>t[e+1].low)return!1;return!0}}function yn(t,e){return t.low<e.low?-1:t.low>e.low?1:t.high<e.high?-1:t.high>e.high?1:0}class vn{points=[];planes=As.createEmpty();children=[];startIdx=-1;numPoints=-1;constructor(){}static createWithIndices(t,e,i){return(i=i||new vn).startIdx=t,i.numPoints=e,i.children.length=0,i}static createTreeForPolygon(t,e){return(e=e||new vn).empty(),Pn.createPointsRef(t).buildHullTree(e),e}static createHullAndInletsForPolygon(t,e){return(e=e||new vn).empty(),Pn.createPointsRef(t).buildHullAndInletsForPolygon(e),e}extractLoopsGo(t){t.push(fe.clonePoint3dArray(this.points));for(const e of this.children)e.extractLoopsGo(t)}extractLoops(){const t=[];return this.extractLoopsGo(t),t}empty(){this.points.length=0,this.planes.planes.length=0,this.children.length=0,this.startIdx=-1,this.numPoints=-1}clone(t){t=t||new vn;for(const e of this.points)t.points.push(e.clone());t.planes=As.createEmpty();for(const e of this.planes.planes)t.planes.planes.push(e.clone());for(const e of this.children)t.children.push(e.clone());return t.startIdx=this.startIdx,t.numPoints=this.numPoints,t}addEmptyChild(t,e){const i=vn.createWithIndices(t,e);this.children.push(i)}addPlane(t){this.planes.addPlaneToConvexSet(t)}isPointOnOrInside(t){if(!this.planes.isPointOnOrInside(t,0))return!1;for(const e of this.children)if(e.isPointOnOrInside(t))return!1;return!0}captureConvexClipPlaneSetAsVoid(t){this.children.push(t)}appendCurvePrimitiveClipIntervals(t,e,i){(new In).appendSingleClipPrimitive(this,t,e,i)}appendCurveCollectionClipIntervals(t,e,i){(new In).appendCurveCollectionClip(this,t,e,i)}appendPolygonClip(t,e,i,n){const s=i.length,r=this.planes.clipInsidePushOutside(t,i,n);if(void 0===r)kn.restoreSingletonInPlaceOfMultipleShards(i,s,t,n);else{let t,s,o=[r],a=[];for(const e of this.children){for(a.length=0;void 0!==(s=o.pop());)e.appendPolygonClip(s,i,a,n),n.dropToCache(s);t=a,a=o,o=t}for(;void 0!==(s=o.pop());)e.push(s)}}depth(){let t=0;for(const e of this.children)t=Math.max(t,e.depth());return 1+t}}class Pn{_points=[];_stack=[];constructor(){}static createPointsRef(t,e){return(e=e||new Pn)._points=t,zr.areaXY(t)<0&&e._points.reverse(),e._points[e._points.length-1].isAlmostEqualMetric(e._points[0])&&e._points.pop(),e}get period(){return this._points.length}indexAfter(t){return(t+1)%this._points.length}indexBefore(t){return(t+this._points.length-1)%this._points.length}pushIndex(t){this._stack.push(t)}static cross(t,e,i){return t.crossProductToPointsXY(e,i)}cyclicStackPoint(t){let e;const i=this._stack;return e=t>0?t:t+10*i.length,e%=i.length,this._points[i[e]]}signFromStackTip(t,e){const i=this.cyclicStackPoint(-2),n=this.cyclicStackPoint(-1),s=this._points[t];return e*Pn.cross(i,n,s)>=0?1:-1}get indexOfMaxX(){let t=0;const e=this._points,i=this._points.length;for(let n=1;n<i;n++)e[n].x>e[t].x&&(t=n);return t}extendHullChain(t,e,i){for(;this._stack.length>1&&this.signFromStackTip(t,e)<0;)this._stack.pop();i&&this.pushIndex(t)}collectHullChain(t,e,i){if(this._stack.length=0,e>2){let n=t;for(let t=0;t<e;t++)this.extendHullChain(n,i,!0),n=this.indexAfter(n)}}collectHullPointsInArray(t,e,i,n){if(t.length=0,i>2){let n=e;for(let e=0;e<i;e++)t.push(this._points[n]),n=this.indexAfter(n)}}buildHullTreeGo(t,e,i=!0){this.collectHullChain(t.startIdx,t.numPoints,e?1:-1),t.points.length=0;const n=this._stack,s=this._points,r=n.length;for(let i=0;i<r;i++){const o=n[i];if(t.points.push(s[o]),i+1<r){let r=n[i+1];if(r===this.indexAfter(o)){const i=Vr.createEdgeAndUpVector(s[o],s[r],tt.create(0,0,1),G.createRadians(0));void 0!==i&&(e&&i.negateInPlace(),t.addPlane(i))}else r<o&&(r+=this.period),t.addEmptyChild(o,r-o+1)}}if(i)for(const i of t.children)this.buildHullTreeGo(i,!e);else for(const i of t.children)this.collectHullPointsInArray(i.points,i.startIdx,i.numPoints,e?-1:1);return!0}buildHullAndInletsForPolygon(t){return vn.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0,!1)}buildHullTree(t){return vn.createWithIndices(this.indexOfMaxX,this.period+1,t),this.buildHullTreeGo(t,!0)}}class In{_curve;_intervalStack;_stackDepth;constructor(){this._stackDepth=0,this._intervalStack=[]}setCurveRef(t){this._curve=t}popSegmentFrame(){this._stackDepth>0&&(this._topOfStack.length=0,this._stackDepth-=1)}clearSegmentStack(){for(;this._stackDepth>0;)this.popSegmentFrame()}pushEmptySegmentFrame(){for(this._stackDepth+=1;this._intervalStack.length<this._stackDepth;)this._intervalStack.push([]);this._topOfStack.length=0}get _topOfStack(){return this._intervalStack[this._stackDepth-1]}set _topOfStack(t){const e=this._stackDepth;e>0&&(this._intervalStack[e-1]=t)}stackEntry(t){return t<=this._stackDepth?this._intervalStack[this._stackDepth-1-t]:[]}isTopOfStackEmpty(){return 0===this._topOfStack.length}static _fractionIntervals=[];appendSingleClipToStack(t,e){const i=In._fractionIntervals;if(this._curve instanceof Te){let i,n;return this._curve.announceClipIntervals(t,((t,e,s)=>{i=t,n=e}))&&e.push(gt.createXX(i,n)),!0}if(this._curve instanceof Si){const n=this._curve;i.length=0,n.announceClipIntervals(t,((t,e,n)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(gt.createXX(i[t],i[t+1]));return!0}if(this._curve instanceof Fe&&this._curve.points.length>1){const i=this._curve;let n,s;const r=i.points.length,o=1/(r-1);for(let a=0;a<r-1;a++)Te.create(i.points[a],i.points[a+1]).announceClipIntervals(t,((t,e,i)=>{n=t,s=e}))&&e.push(gt.createXX((a+n)*o,(a+s)*o));return!0}if(this._curve instanceof Ye){const n=this._curve;i.length=0,n.announceClipIntervals(t,((t,e,n)=>{i.push(t),i.push(e)}));for(let t=0;t<i.length;t+=2)e.push(gt.createXX(i[t],i[t+1]));return!0}return!1}recurse(t){if(this.pushEmptySegmentFrame(),this.appendSingleClipToStack(t.planes,this._topOfStack),xn.sort(this._topOfStack),!this.isTopOfStackEmpty())for(const e of t.children){if(this.recurse(e),this.isTopOfStackEmpty())this.popSegmentFrame();else{const t=xn.differenceSorted(this.stackEntry(1),this.stackEntry(0));this.popSegmentFrame(),this._topOfStack=t}if(this.isTopOfStackEmpty())break}}appendSingleClipPrimitive(t,e,i,n){if(this.setCurveRef(e),this.clearSegmentStack(),this.recurse(t),1!==this._stackDepth)return;const s=this._topOfStack;for(const t of s){const n=t.low,s=t.high,r=e.fractionToPoint(n),o=e.fractionToPoint(s);i.push(It.createCapture(Pt.createCurveFractionPoint(e,n,r),Pt.createCurveFractionPoint(e,s,o)))}this.popSegmentFrame()}appendCurveCollectionClip(t,e,i,n){for(const s of e.children)s instanceof le?this.appendSingleClipPrimitive(t,s,i,n):s instanceof $e&&this.appendCurveCollectionClip(t,s,i,n)}}!function(t){t[t.None=0]="None",t[t.XLow=1]="XLow",t[t.XHigh=2]="XHigh",t[t.YLow=4]="YLow",t[t.YHigh=8]="YHigh",t[t.ZLow=16]="ZLow",t[t.ZHigh=32]="ZHigh",t[t.XAndY=15]="XAndY",t[t.All=63]="All"}(k||(k={}));class Sn{_clipPlanes;_invisible;fetchClipPlanesRef(){return this.ensurePlaneSets(),this._clipPlanes}get invisible(){return this._invisible}constructor(t,e=!1){this._clipPlanes=t,this._invisible=e}static createCapture(t,e=!1){let i;return t instanceof _n&&(i=t),t instanceof As&&(i=_n.createConvexSets([t])),new Sn(i,e)}toJSON(){const t={};return this._clipPlanes&&(t.clips=this._clipPlanes.toJSON()),this._invisible&&(t.invisible=!0),{planes:t}}arePlanesDefined(){return void 0!==this._clipPlanes}clone(){const t=this._clipPlanes?this._clipPlanes.clone():void 0;return new Sn(t,this._invisible)}ensurePlaneSets(){}pointInside(t,e=J.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}isPointOnOrInside(t,e=J.smallMetricDistanceSquared){this.ensurePlaneSets();let i=!0;return this._clipPlanes&&(i=this._clipPlanes.isPointOnOrInside(t,e)),i}announceClippedSegmentIntervals(t,e,i,n,s){this.ensurePlaneSets();let r=!1;return this._clipPlanes&&(r=this._clipPlanes.announceClippedSegmentIntervals(t,e,i,n,s)),r}announceClippedArcIntervals(t,e){this.ensurePlaneSets();let i=!1;return this._clipPlanes&&(i=this._clipPlanes.announceClippedArcIntervals(t,e)),i}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}return this._clipPlanes&&this._clipPlanes.multiplyPlanesByMatrix4d(t),!0}transformInPlace(t){return this._clipPlanes&&this._clipPlanes.transformInPlace(t),!0}setInvisible(t){this._invisible=t}containsZClip(){if(void 0!==this.fetchClipPlanesRef())for(const t of this._clipPlanes.convexSets)for(const e of t.planes)if(Math.abs(e.inwardNormalRef.z)>1e-6&&Math.abs(e.distance)!==Number.MAX_VALUE)return!0;return!1}classifyPointContainment(t,e){this.ensurePlaneSets();const i=this._clipPlanes;let n=R.StronglyInside;if(i&&(n=i.classifyPointContainment(t,!1)),this._invisible&&!e)switch(n){case R.StronglyInside:return R.StronglyOutside;case R.StronglyOutside:return R.StronglyInside;case R.Ambiguous:return R.Ambiguous}return n}static fromJSON(t){if(!t)return;return An.fromClipShapeJSON(t)||Sn.fromJSONClipPrimitive(t)}static fromJSONClipPrimitive(t){const e=t?.planes;if(!e)return;const i=e.clips?_n.fromJSON(e.clips):void 0,n=void 0!==e.invisible&&e.invisible;return new Sn(i,n)}}class bn{pointA;pointB;normal;constructor(t,e,i,n){this.pointA=$.create(t.x,t.y,n),this.pointB=$.create(e.x,e.y,n),this.normal=i}static makeUnitPerpendicularToBisector(t,e,i){let n=e.normal.minus(t.normal);if(void 0!==n.normalize(n)||(n=tt.createStartEnd(t.pointA,e.pointB),void 0!==n.normalize(n)))return i&&n.scale(-1,n),n}}class An extends Sn{_polygon;_zLow;_zHigh;_isMask;_transformFromClip;_transformToClip;constructor(t=[],e,i,n,s=!1,r=!1){super(void 0,r),this._isMask=!1,this._polygon=t,this.initSecondaryProps(s,e,i,n)}get invisible(){return this._invisible}get transformFromClip(){return this._transformFromClip}get transformToClip(){return this._transformToClip}get transformValid(){return void 0!==this.transformFromClip}get zLowValid(){return void 0!==this._zLow}get zHighValid(){return void 0!==this._zHigh}get transformIsValid(){return void 0!==this._transformFromClip}get zLow(){return this._zLow}get zHigh(){return this._zHigh}get polygon(){return this._polygon}get isMask(){return this._isMask}setPolygon(t){t[0].isAlmostEqual(t[t.length-1])||t.push(t[0].clone()),this._polygon=t}ensurePlaneSets(){void 0===this._clipPlanes&&(this._clipPlanes=_n.createEmpty(),this.parseClipPlanes(this._clipPlanes),this._transformFromClip&&this._clipPlanes.transformInPlace(this._transformFromClip))}initSecondaryProps(t,e,i,n){this._isMask=t,this._zLow=e,this._zHigh=i,void 0!==n?(this._transformFromClip=n,this._transformToClip=n.inverse()):(this._transformFromClip=mt.createIdentity(),this._transformToClip=mt.createIdentity())}toJSON(){const t={points:this._polygon.map((t=>t.toJSON()))};return this.invisible&&(t.invisible=!0),this._transformFromClip&&!this._transformFromClip.isIdentity&&(t.trans=this._transformFromClip.toJSON()),this.isMask&&(t.mask=!0),void 0!==this.zLow&&this.zLow!==-Number.MAX_VALUE&&(t.zlow=this.zLow),void 0!==this.zHigh&&this.zHigh!==Number.MAX_VALUE&&(t.zhigh=this.zHigh),{shape:t}}static fromClipShapeJSON(t,e){const i=t?.shape;if(!i)return;const n=i.points?i.points.map((t=>$.fromJSON(t))):[],s=i.trans?mt.fromJSON(i.trans):void 0,r="number"==typeof i.zlow?i.zlow:void 0,o="number"==typeof i.zhigh?i.zhigh:void 0,a="boolean"==typeof i.mask&&i.mask,c="boolean"==typeof i.invisible&&i.invisible;return An.createShape(n,r,o,s,a,c,e)}static createFrom(t,e){const i=An.createEmpty(!1,!1,void 0,e);i._invisible=t._invisible;for(const e of t._polygon)i._polygon.push(e.clone());return i._isMask=t._isMask,i._zLow=t._zLow,i._zHigh=t._zHigh,i._transformToClip=t._transformToClip?t._transformToClip.clone():void 0,i._transformFromClip=t._transformFromClip?t._transformFromClip.clone():void 0,i}static createShape(t=[],e,i,n,s=!1,r=!1,o){if(t.length<3)return;const a=t.slice(0);return a[0].isAlmostEqual(a[a.length-1])?a[0].clone(a[a.length-1]):a.push(a[0].clone()),o?(o._clipPlanes=void 0,o._invisible=r,o._polygon=a,o.initSecondaryProps(s,e,i,n),o):new An(a,e,i,n,s,r)}static createBlock(t,e,i=!1,n=!1,s,r){const o=t.low,a=t.high,c=[];for(let t=0;t<5;t++)c.push($.create());return c[0].x=c[3].x=c[4].x=o.x,c[1].x=c[2].x=a.x,c[0].y=c[1].y=c[4].y=o.y,c[2].y=c[3].y=a.y,An.createShape(c,k.None!==(e&k.ZLow)?o.z:void 0,k.None!==(e&k.ZHigh)?a.z:void 0,s,i,n,r)}static createEmpty(t=!1,e=!1,i,n){return n?(n._clipPlanes=void 0,n._invisible=e,n._polygon.length=0,n.initSecondaryProps(t,void 0,void 0,i),n):new An([],void 0,void 0,i,t,e)}get isValidPolygon(){return!(this._polygon.length<3||!this._polygon[0].isExactEqual(this._polygon[this._polygon.length-1]))}clone(t){return An.createFrom(this,t)}parseClipPlanes(t){const e=this._polygon;if(3===e.length&&!this._isMask&&e[0].isExactEqual(e[e.length-1]))return this.parseLinearPlanes(t,this._polygon[0],this._polygon[1]),!0;if(!this.isMask){const e=zr.testXYPolygonTurningDirections(this.polygon);if(0!==e)return this.parseConvexPolygonPlanes(t,this._polygon,e,!1),!0}return this.parsePolygonPlanes(t,this._polygon,this.isMask),!0}parseLinearPlanes(t,e,i,n){const s=e.vectorTo(i);if(0===s.magnitude())return!1;s.normalize(s);const r=As.createEmpty();if(void 0===n){const t=j.create(-s.y,s.x);r.planes.push(Vr.createNormalAndPoint(tt.create(s.x,s.y),$.createFrom(e),this._invisible)),r.planes.push(Vr.createNormalAndPoint(tt.create(-s.x,-s.y),$.createFrom(i),this._invisible)),r.planes.push(Vr.createNormalAndPoint(tt.create(t.x,t.y),$.createFrom(e),this._invisible)),r.planes.push(Vr.createNormalAndPoint(tt.create(-t.x,-t.y),$.createFrom(e),this._invisible))}else{const t=$.create(e.x,e.y,-n),s=$.create(i.x,i.y,-n),o=tt.createFrom(s),a=o.crossProduct(tt.createFrom(t)).normalize();let c=tt.createFrom(t).crossProduct(a).normalize();r.planes.push(Vr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(Vr.createNormalAndDistance(c,0,this._invisible)),a.negate(),c=o.crossProduct(a).normalize(),r.planes.push(Vr.createNormalAndDistance(a,0,this._invisible)),r.planes.push(Vr.createNormalAndDistance(c,0,this._invisible))}return r.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(r),!0}parseConvexPolygonPlanes(t,e,i,n,s){const r=[],o=i<0;for(let t=0;t<e.length-1;t++){const i=void 0===s?0:-s,n=tt.createStartEnd(e[t],e[t+1]),a=n.magnitude();if(n.normalize(n),a>1e-8){const s=tt.create(o?n.y:-n.y,o?-n.x:n.x);r.push(new bn(e[t],e[t+1],s,i))}}if(r.length<3)return!1;if(n){const e=r.length-1;for(let i=0;i<=e;i++){const n=r[i],s=r[i?i-1:e],a=r[i===e?0:i+1],c=As.createEmpty(),l=bn.makeUnitPerpendicularToBisector(s,n,!o),h=bn.makeUnitPerpendicularToBisector(n,a,o);l&&c.planes.push(Vr.createNormalAndPoint(l,n.pointA,this._invisible,!0)),c.planes.push(Vr.createNormalAndPoint(n.normal,n.pointB,this._invisible,!1)),h&&c.planes.push(Vr.createNormalAndPoint(h,a.pointA,this._invisible,!0)),t.addConvexSet(c),t.addOutsideZClipSets(this._invisible,this._zLow,this._zHigh)}}else{const e=As.createEmpty();if(void 0===s)for(const t of r)e.planes.push(Vr.createNormalAndPoint(tt.create(t.normal.x,t.normal.y),t.pointA));else if(o)for(const t of r)e.planes.push(Vr.createNormalAndDistance(tt.createFrom(t.pointA).crossProduct(tt.createFrom(t.pointB)).normalize(),0));else for(const t of r)e.planes.push(Vr.createNormalAndDistance(tt.createFrom(t.pointB).crossProduct(tt.createFrom(t.pointA)).normalize(),0));e.addZClipPlanes(this._invisible,this._zLow,this._zHigh),t.addConvexSet(e)}return!0}parsePolygonPlanes(t,e,i,n){const s=Ci.compressDanglers(e,!0),r=(e,i)=>{if(!i.isMaskSet(E.EXTERIOR)){const e=i.collectAroundFace((t=>{if(!t.isMaskSet(E.EXTERIOR))return $.create(t.x,t.y,0)}));e.push(e[0].clone());const s=zr.testXYPolygonTurningDirections(e);this.parseConvexPolygonPlanes(t,e,s,!1,n)}return!0};if(i){const e=fe.clonePoint3dArray(s),i=vn.createHullAndInletsForPolygon(e).extractLoops();if(0===i.length)return!1;const o=i[0],a=zr.testXYPolygonTurningDirections(o);this.parseConvexPolygonPlanes(t,o,-a,!0,n);for(let t=1;t<i.length;t++){const e=Ln.createTriangulatedGraphFromSingleLoop(i[t]);e&&(Ln.flipTriangles(e),e.announceFaceLoops(r))}return!0}{const t=Ln.createTriangulatedGraphFromSingleLoop(s);if(void 0===t)return!1;Ln.flipTriangles(t),t.announceFaceLoops(r)}return!0}multiplyPlanesByMatrix4d(t,e=!0,i=!0){return this.ensurePlaneSets(),super.multiplyPlanesByMatrix4d(t,e,i)}transformInPlace(t){return t.isIdentity||(super.transformInPlace(t),this._transformFromClip?t.multiplyTransformTransform(this._transformFromClip,this._transformFromClip):this._transformFromClip=t.clone(),this._transformToClip=this._transformFromClip.inverse()),!0}get isXYPolygon(){return 0!==this._polygon.length&&(void 0===this._transformFromClip||this._transformFromClip.matrix.columnZ().magnitudeXY()<1e-8)}performTransformToClip(t){void 0!==this._transformToClip&&this._transformToClip.multiplyPoint3d(t,t)}performTransformFromClip(t){void 0!==this._transformFromClip&&this._transformFromClip.multiplyPoint3d(t,t)}}class Cn{_clippers;_intervalsA;_intervalsB;_keepInside;constructor(t){this._keepInside=t,this._clippers=[],this._intervalsA=[],this._intervalsB=[]}toJSON(){const t=[];for(const e of this._clippers){const i=e;i.toJSON&&t.push(i.toJSON())}const e={};return e[this.operationName]=t,e}captureChild(t){if(Array.isArray(t))for(const e of t)this.captureChild(e);else this._clippers.push(t)}toggleResult(){return this.selectResult(!this._keepInside)}selectResult(t){const e=this._keepInside;return this._keepInside=t,e}testedAnnounceNN(t,e,i){return t<e?(i&&i(t,e),1):0}testedAnnounceNNC(t,e,i,n){return t<e?(n&&n(t,e,i),1):0}swapAB(){const t=this._intervalsA;this._intervalsA=this._intervalsB,this._intervalsB=t}announcePartsNN(t,e,i,n,s){let r=0;if(t)for(const t of e)r+=this.testedAnnounceNN(t.low,t.high,s);else{let t=i;for(const i of e)r+=this.testedAnnounceNN(t,i.low,s),t=i.high;r+=this.testedAnnounceNN(t,n,s)}return r>0}announcePartsNNC(t,e,i,n,s,r){let o=0;if(t)for(const t of e)o+=this.testedAnnounceNNC(t.low,t.high,s,r);else{let t=i;for(const i of e)o+=this.testedAnnounceNNC(t,i.low,s,r),t=i.high;o+=this.testedAnnounceNNC(t,n,s,r)}return o>0}isPointOnOrInside(t){const e=this.isPointOnOrInsideChildren(t);return this._keepInside?e:!e}announceClippedSegmentIntervals(t,e,i,n,s){this._intervalsA.length=0;const r=(t,e)=>{this._intervalsB.push(gt.createXX(t,e))};let o=0;for(const s of this._clippers)this._intervalsB.length=0,s.announceClippedSegmentIntervals(t,e,i,n,r),xn.simplifySortUnion(this._intervalsB),0===o?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),o++;return this.announcePartsNN(this._keepInside,this._intervalsA,t,e,s)}announceClippedArcIntervals(t,e){this._intervalsA.length=0;const i=(t,e)=>{this._intervalsB.push(gt.createXX(t,e))};let n=0;for(const e of this._clippers)this._intervalsB.length=0,e.announceClippedArcIntervals(t,i),xn.simplifySortUnion(this._intervalsB),0===n?this.swapAB():this._intervalsA=this.combineIntervals(this._intervalsA,this._intervalsB),n++;return this.announcePartsNNC(this._keepInside,this._intervalsA,0,1,t,e)}}class Tn extends Cn{get operationName(){return this._keepInside?"AND":"NAND"}constructor(t){super(t)}isPointOnOrInsideChildren(t){for(const e of this._clippers)if(!e.isPointOnOrInside(t))return!1;return!0}combineIntervals(t,e){return xn.intersectSorted(t,e)}appendPolygonClip(t,e,i,n){kn.doPolygonClipSequence(t,this._clippers,this._keepInside?e:i,this._keepInside?i:e,void 0,M.passToNextStep,M.acceptOut,M.acceptIn,n)}}class wn{_clips;boundingRange=ft.createNull();get clips(){return this._clips}constructor(t){this._clips=t||[]}get isValid(){return this._clips.length>0}static createEmpty(t){return t?(t._clips.length=0,t):new wn}static createCapture(t,e){return e?(e._clips=t,e):new wn(t)}static create(t,e){const i=[];for(const e of t)i.push(e.clone());return wn.createCapture(i,e)}clone(t){const e=t||new wn;e._clips.length=0;for(const t of this._clips)e._clips.push(t.clone());return e.boundingRange.setFrom(this.boundingRange),e}toJSON(){return this.isValid?this.clips.map((t=>t.toJSON())):[]}static fromJSON(t,e){if((e=e||new wn).clear(),!Array.isArray(t))return e;try{for(const i of t){const t=Sn.fromJSON(i);t&&e._clips.push(t)}}catch{e.clear()}return e}clear(){this._clips.length=0}appendClone(t){this._clips.push(t.clone())}appendReference(t){this._clips.push(t)}appendShape(t,e,i,n,s=!1,r=!1){const o=An.createShape(t,e,i,n,s,r);return!!o&&(this._clips.push(o),!0)}pointInside(t,e=J.smallMetricDistanceSquared){return this.isPointOnOrInside(t,e)}isPointOnOrInside(t,e=J.smallMetricDistanceSquared){if(!this.boundingRange.isNull&&!this.boundingRange.containsPoint(t))return!1;for(const i of this._clips)if(!i.pointInside(t,e))return!1;return!0}_clipNodeProxy;ensureProxyClipNode(){if(this._clipNodeProxy)return!0;this._clipNodeProxy=new Tn(!0);let t=0;for(const e of this._clips){const i=e.fetchClipPlanesRef();i&&(t++,this._clipNodeProxy.captureChild(i))}return t>0}announceClippedSegmentIntervals(t,e,i,n,s){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedSegmentIntervals(t,e,i,n,s)}announceClippedArcIntervals(t,e){return this.ensureProxyClipNode(),!!this._clipNodeProxy&&this._clipNodeProxy.announceClippedArcIntervals(t,e)}appendPolygonClip(t,e,i,n){this.ensureProxyClipNode(),this._clipNodeProxy&&this._clipNodeProxy.appendPolygonClip(t,e,i,n)}transformInPlace(t){for(const e of this._clips)if(!1===e.transformInPlace(t))return!1;return this.boundingRange.isNull||t.multiplyRange(this.boundingRange,this.boundingRange),!0}extractBoundaryLoops(t,e){let i=k.None,n=-Number.MAX_VALUE,s=Number.MAX_VALUE;const r=[];let o,a=0;if(0===this._clips.length)return r;const c=mt.createIdentity();for(const e of this._clips)if(e instanceof An){if(void 0!==o&&e!==o){let t=mt.createIdentity(),i=mt.createIdentity();o.transformValid&&e.transformValid&&(t=e.transformFromClip.clone(),i=o.transformToClip.clone()),c.setFrom(i.multiplyTransformTransform(t))}if(o||(o=e),t[a]=[],void 0!==e.polygon){i=k.XAndY,e.zHighValid&&(i|=k.ZHigh,s=e.zHigh),e.zLowValid&&(i|=k.ZLow,n=e.zLow);for(const i of e.polygon)t[a].push(i.clone());c.multiplyPoint3dArray(t[a],t[a]),a++}}return r.push(i),r.push(n),r.push(s),e&&o&&e.setFrom(o.transformFromClip),r}setInvisible(t){for(const e of this._clips)e.setInvisible(t)}parseClipPlanes(){for(const t of this._clips)t.fetchClipPlanesRef()}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._clips)e.multiplyPlanesByMatrix4d(t,!1,i);return!0}classifyPointContainment(t,e=!1){let i=R.Ambiguous;for(const n of this._clips){const s=n.classifyPointContainment(t,e);if(R.Ambiguous===s)return R.Ambiguous;if(R.Ambiguous===i)i=s;else if(i!==s)return R.Ambiguous}return i}classifyRangeContainment(t,e){const i=t.corners();return this.classifyPointContainment(i,e)}isAnyLineStringPointInside(t){for(const e of this._clips){const i=e.fetchClipPlanesRef();if(void 0!==i)for(let e=0;e+1<t.length;e++){const n=Te.create(t[e],t[e+1]);if(i.isAnyPointInOrOnFromSegment(n))return!0}}return!1}sumSizes(t,e,i){let n=0;for(let s=e;s<i;s++)n+=t[s].x1-t[s].x0;return n}static _TARGET_FRACTION_SUM=.99999999;isLineStringCompletelyContained(t){const e=[];for(let i=0;i+1<t.length;i++){const n=Te.create(t[i],t[i+1]);let s=0,r=0;for(const t of this._clips){const i=t.fetchClipPlanesRef();if(void 0!==i){i.appendIntervalsFromSegment(n,e);const t=e.length;if(s+=this.sumSizes(e,r,t),r=t,s>=wn._TARGET_FRACTION_SUM)break}}if(s<wn._TARGET_FRACTION_SUM)return!1}return!0}toCompactString(){function t(t){return`${t.toString()}_`}function e(e){let i=e.invisible?1:0;return i|=e.interior?2:0,`${function(t){const e=t.toString();return e.length,e}(i)}${n=e.inwardNormalRef,`${t(n.x)}${t(n.y)}${t(n.z)}`}${t(e.distance)}`;var n}function i(t){let i="";for(const n of t.planes)i=`${i}${e(n)}`;return`${i}_`}function n(t){let e=(t.invisible?1:0).toString();e.length;const n=t.fetchClipPlanesRef();if(n)for(const t of n.convexSets)e=`${e}${i(t)}`;return`${e}_`}let s="";for(const t of this.clips)s=`${s}${n(t)}`;return`${s}_`}}!function(t){t.fromClipVector=function(t){if(!t||!t.isValid)return;const e=t;void 0===e.clipString&&(e.clipString=t.toCompactString());const i=e;return i.clipString,i}}(F||(F={}));class En{_positiveOffsetLeft;_positiveOffsetRight;_turnDegrees;constructor(t,e){this._positiveOffsetLeft=t,this._positiveOffsetRight=e,this._turnDegrees=60}static createUnit(t,e,i,n=!0){let s=e,r=e+1;const o=t.length-1;i?e<0?(s=o-1,r=o):e>=o&&(s=0,r=1):0===e?(s=0,r=1):r>o&&(s=o-1,r=o);const a=t.vectorIndexIndex(s,r);if(a)return n&&(a.z=0),a.normalize(a)}static createDirectedPlane(t,e,i,n,s=!1){return Vr.createNormalAndPointXYZXYZ(e.x*n,e.y*n,e.z*n,t.x+i*e.x,t.y+i*e.y,t.z+i*e.z,s,s)}createChamferCut(t,e,i,n){const s=i.angleToXY(n).degrees;if(Math.abs(s)>this._turnDegrees){const r=i.interpolate(.5,n);r.rotate90CCWXY(r),r.normalizeInPlace(),s>0?t.addPlaneToConvexSet(En.createDirectedPlane(e,r,-this._positiveOffsetRight,1,!1)):t.addPlaneToConvexSet(En.createDirectedPlane(e,r,this._positiveOffsetLeft,-1,!1))}}createOffsetFromSegment(t,e,i,n,s){if(void 0===n)return;void 0===i&&(i=n),void 0===s&&(s=n);const r=i.interpolate(.5,n);r.normalizeInPlace();const o=n.rotate90CCWXY(),a=n.interpolate(.5,s);a.normalizeInPlace();const c=As.createEmpty();return c.addPlaneToConvexSet(En.createDirectedPlane(t,o,this._positiveOffsetLeft,-1,!1)),c.addPlaneToConvexSet(En.createDirectedPlane(t,o,-this._positiveOffsetRight,1,!1)),c.addPlaneToConvexSet(En.createDirectedPlane(t,r,0,1,!0)),c.addPlaneToConvexSet(En.createDirectedPlane(e,a,0,-1,!0)),this.createChamferCut(c,t,i,n),this.createChamferCut(c,e,n,s),c}static createClipBetweenOffsets(t,e,i,n,s){const r=new En(e,i),o=_n.createEmpty();if(t.length>1){const e=J.isSmallMetricDistance(t.distanceIndexIndex(0,t.length-1));for(let i=0;i+1<t.length;i++){const a=this.createUnit(t,i-1,e),c=this.createUnit(t,i,e),l=this.createUnit(t,i+1,e),h=r.createOffsetFromSegment(t.getPoint3dAtUncheckedPointIndex(i),t.getPoint3dAtUncheckedPointIndex(i+1),a,c,l);h?.addZClipPlanes(!1,n,s),h&&o.addConvexSet(h)}}else{const t=As.createEmpty();t?.addZClipPlanes(!1,n,s),t.planes.length>0&&o.addConvexSet(t)}return o}}!function(t){t[t.StronglyInside=1]="StronglyInside",t[t.Ambiguous=2]="Ambiguous",t[t.StronglyOutside=3]="StronglyOutside"}(R||(R={})),function(t){t[t.acceptIn=1]="acceptIn",t[t.acceptOut=-1]="acceptOut",t[t.passToNextStep=0]="passToNextStep"}(M||(M={})),function(t){t[t.ClipRequired=0]="ClipRequired",t[t.TrivialReject=1]="TrivialReject",t[t.TrivialAccept=2]="TrivialAccept"}(D||(D={}));class kn{static _workTransform;static _workRange;static _workClipper;static _selectIntervals01TestPoint=$.create();static selectIntervals01(t,e,i,n){e.push(0),e.push(1),e.sort();let s,r,o=e.atUncheckedIndex(0);const a=kn._selectIntervals01TestPoint,c=e.length;for(let l=1;l<c;l++)if(s=e.atUncheckedIndex(l),s>o+J.smallFraction){if(r=.5*(o+s),r>=0&&r<=1&&(t.fractionToPoint(r,a),i.isPointOnOrInside(a))){if(!n)return!0;n(o,s,t)}o=s}return!1}static announceNNC(t,e,i){if(i)for(const n of t)i(n.low,n.high,e);return t.length>0}static collectClippedCurves(t,e){const i=[];return t.announceClipIntervals(e,((t,e,n)=>{if(e!==t){const s=n.clonePartialCurve(t,e);s&&i.push(s)}})),i}static clipAnyRegion(t,e){let i;const n=kn._workTransform=bi.createRightHandedFrame(void 0,t,kn._workTransform);if(!n)return i;const s=n?.inverse();if(!s)return i;const r=t.cloneTransformed(s);if(!r)return i;const o=kn._workRange=r.range(),a=o.xLength(),c=o.yLength(),l=Fe.createRectangleXY(o.low,a,c,!0);l.tryTransformInPlace(n);const h=[],d=new mn;if(e.appendPolygonClip?.(l.packedPoints,h,[],d),0===h.length)return i;for(const t of h){const e=oi.createPolygon(t);e.tryTransformInPlace(s);const o=wr.regionBooleanXY(r,e,Y.Intersection);o&&(o.tryTransformInPlace(n),i||(i=o instanceof gn?o:gn.create(o)),o instanceof gn?i.children.push(...o.children):i.tryAddChild(o))}return i?wr.simplifyRegionType(i):void 0}static clipAnyCurve(t,e){if(t instanceof le)return kn.collectClippedCurves(t,e);if(t.isAnyRegion()){const i=kn.clipAnyRegion(t,e);return i?[i]:[]}const i=[];if(t instanceof ii||t instanceof ei)for(const n of t.children){const t=kn.clipAnyCurve(n,e);i.push(...t)}return i}static clipPolygonToClipShape(t,e){const i=this.clipPolygonToClipShapeReturnGrowableXYZArrays(t,e),n=[];for(const t of i)n.push(t.getPoint3dArray());return n}static clipPolygonToClipShapeReturnGrowableXYZArrays(t,e){const i=[],n=e.fetchClipPlanesRef();return n&&n.polygonClip(t,i),i}static pointSetSingleClipStatus(t,e,i){if(0===e.convexSets.length)return D.TrivialAccept;for(const n of e.convexSets){let e=!1,s=!1;for(const r of n.planes){let n=0,o=0;const a=r.distance-i,c=$.create(),l=tt.create();for(let e=0;e<t.length;e++)t.getPoint3dAtUncheckedPointIndex(e,c),l.setFrom(c),l.dotProduct(r.inwardNormalRef)>a?n++:o++;if(s=0!==o||s,0===n){e=!0;break}}if(!s)return D.TrivialAccept;if(!e)return D.ClipRequired}return D.TrivialReject}static announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,i,n=!0,s=!0,r=!1){const o=new rt;if(n)if(t instanceof As)for(const n of t.planes){if(r&&n.invisible)continue;const s=n.intersectRange(e,!0),a=new rt;s&&(t.polygonClip(s,a,o,n),a.length>0&&i(a))}else if(r&&t.invisible);else{const n=t.intersectRange(e,!0);n&&i(n)}if(s){const n=e.corners();for(let e=0;e<6;e++){const s=ft.faceCornerIndices(e),r=new rt,a=Fe.createIndexedPoints(n,s);t instanceof As?(t.polygonClip(a.packedPoints,r,o),r.length>0&&i(r)):(t.clipConvexPolygonInPlace(a.packedPoints,o),a.packedPoints.length>0&&i(a.packedPoints))}}}static loopsOfConvexClipPlaneIntersectionWithRange(t,e,i=!0,n=!0,s=!1){const r=[];if(t instanceof _n)for(const o of t.convexSets)this.announceLoopsOfConvexClipPlaneSetIntersectRange(o,e,(t=>{t.length>0&&r.push(oi.createPolygon(t))}),i,n,s);else(t instanceof As||t instanceof Vr)&&this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&r.push(oi.createPolygon(t))}),i,n,s);return r}static rangeOfConvexClipPlaneSetIntersectionWithRange(t,e){const i=ft.createNull();return this.announceLoopsOfConvexClipPlaneSetIntersectRange(t,e,(t=>{t.length>0&&i.extendArray(t)}),!0,!0,!1),i}static rangeOfClipperIntersectionWithRange(t,e,i=!0){if(void 0===t)return e.clone();if(t instanceof As)return this.rangeOfConvexClipPlaneSetIntersectionWithRange(t,e);if(t instanceof _n){const i=ft.createNull();for(const n of t.convexSets){const t=this.rangeOfConvexClipPlaneSetIntersectionWithRange(n,e);i.extendRange(t)}return i}if(t instanceof Sn)return i&&t.invisible?e.clone():this.rangeOfClipperIntersectionWithRange(t.fetchClipPlanesRef(),e);if(t instanceof wn){const n=e.clone();for(const s of t.clips)if(i&&s.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(s,e,i);n.intersect(t,n)}return n}return e.clone()}static doesClipperIntersectRange(t,e,i=!0){if(void 0===t)return!0;if(t instanceof As)return this.doesConvexClipPlaneSetIntersectRange(t,e);if(t instanceof _n){for(const i of t.convexSets)if(this.doesConvexClipPlaneSetIntersectRange(i,e))return!0;return!1}if(t instanceof Sn)return!(!i||!t.invisible)||this.doesClipperIntersectRange(t.fetchClipPlanesRef(),e);if(t instanceof wn){const n=e.clone();for(const s of t.clips)if(i&&s.invisible);else{const t=this.rangeOfClipperIntersectionWithRange(s,e,i);n.intersect(t,n)}return!n.isNull}return!1}static doesConvexClipPlaneSetIntersectRange(t,e,i=!0,n=!0,s=!1){const r=new rt;if(i)for(const i of t.planes){if(s&&i.invisible)continue;const n=i.intersectRange(e,!0);if(n){const e=new rt;if(t.polygonClip(n,e,r,i),e.length>0)return!0}}if(n){const i=e.corners();for(let e=0;e<6;e++){const n=ft.faceCornerIndices(e),s=new rt,o=Fe.createIndexedPoints(i,n);if(t.polygonClip(o.packedPoints,s,r),s.length>0)return!0}}return!1}static createClipperFromTransformedRange3d(t,e,i){e||(e=mt.createIdentity());const n=ir.create();n.addTransformedRangeMesh(e,t);const s=n.claimPolyface(),r=this._workClipper=As.createConvexPolyface(s,this._workClipper).clipper;if(r.planes.length>0)return r;if(i){s.data.point.length;for(let t=0;t<2;++t){const e=s.data.point.getPoint3dAtCheckedPointIndex(t);e&&i.push(e)}}}static rangeIntersectPointOrSegment(t,e,i,n){const s=n?(t,e,s)=>{n.extendPoint(s.fractionToPoint(t),i),n.extendPoint(s.fractionToPoint(e),i)}:void 0;let r=!1;if(e.length>1){const i=Te.createCapture(e[0],e[1]),n=As.createRange3dPlanes(t);r=i.announceClipIntervals(n,s)}else e.length>0&&(r=t.containsPoint(e[0]),r&&n&&n.extendPoint(e[0],i));return r}static doLocalRangesIntersect(t,e,i,n,s){const r=this._workTransform=n.inverse(this._workTransform);if(!r)return!1;let o=i;s&&(o=this._workRange=i.clone(this._workRange),o.expandInPlace(s));const a=[],c=r.multiplyTransformTransform(e,r),l=this.createClipperFromTransformedRange3d(t,c,a);return l?this.doesClipperIntersectRange(l,o):this.rangeIntersectPointOrSegment(o,a,n)}static rangeOfIntersectionOfLocalRanges(t,e,i,n,s){const r=ft.createNull(s),o=this._workTransform=n.inverse(this._workTransform);if(!o)return r;const a=[],c=o.multiplyTransformTransform(e,o),l=this.createClipperFromTransformedRange3d(t,c,a);return l?this.announceLoopsOfConvexClipPlaneSetIntersectRange(l,i,(t=>{t.extendRange(r,n)})):this.rangeIntersectPointOrSegment(i,a,n,r),r}static isClipper(t){return!!(t&&t.isPointOnOrInside&&t.announceClippedSegmentIntervals&&t.announceClippedArcIntervals)}static restoreSingletonInPlaceOfMultipleShards(t,e,i,n){if(t&&t.length>e+1){for(;t.length>e;){const e=t.pop();n.dropToCache(e)}t.push(n.grabAndFill(i))}}static createXYOffsetClipFromLineString(t,e,i,n,s){return Array.isArray(t)?En.createClipBetweenOffsets(new he(t),e,i,n,s):En.createClipBetweenOffsets(t,e,i,n,s)}static captureOrDrop(t,e,i,n){t.length>=e?i.push(t):n.dropToCache(t)}static clipSegmentToLLeftOfLineXY(t,e,i,n,s,r=1e-14){const o=e.x-t.x,a=e.y-t.y,c=-(o*(i.y-t.y)-a*(i.x-t.x)),l=-(o*(n.y-t.y)-a*(n.x-t.x));if(!(c<r&&l<r))if(c*l>0)c>0&&s.setNull();else{if(c*l<0){const t=-c/(l-c);return c<0?s.intersectRangeXXInPlace(0,t):s.intersectRangeXXInPlace(t,1)}c>0?s.intersectRangeXXInPlace(1,1):l>0&&s.intersectRangeXXInPlace(0,0)}}static clipSegmentToCCWTriangleXY(t,e,i,n,s,r,o=1e-14){r.isNull||(this.clipSegmentToLLeftOfLineXY(t,e,n,s,r,o),r.isNull||(this.clipSegmentToLLeftOfLineXY(e,i,n,s,r,o),r.isNull||this.clipSegmentToLLeftOfLineXY(i,t,n,s,r,o)))}static clipSegmentBelowPlaneXY(t,e,i,n,s=1e-14){const r=t.altitudeXY(e.x,e.y),o=t.altitudeXY(i.x,i.y);if(!(r<s&&o<s))if(r*o>0)r>0&&n.setNull();else{if(r*o<0){const t=-r/(o-r);return r<0?n.intersectRangeXXInPlace(0,t):n.intersectRangeXXInPlace(t,1)}r>0?n.intersectRangeXXInPlace(1,1):o>0&&n.intersectRangeXXInPlace(0,0)}}static clipSegmentBelowPlanesXY(t,e,i,n,s=1e-14){const r=t.length;for(let o=0;!n.isNull&&o<r;o++)this.clipSegmentBelowPlaneXY(t[o],e,i,n,s)}static announcePolylineClip(t,e,i){for(let n=0;n+1<e.length;n++)t.announceClippedSegmentIntervals(0,1,e[n],e[n+1],((t,s)=>{i(e[n].interpolate(t,e[n+1]),e[n].interpolate(s,e[n+1]))}))}static sumPolylineClipLength(t,e){let i=0;for(let n=0;n+1<e.length;n++){const s=e[n].distance(e[n+1]);t.announceClippedSegmentIntervals(0,1,e[n],e[n+1],((t,e)=>{i+=Math.abs(e-t)*s}))}return i}static doPolygonClipSequence(t,e,i,n,s,r,o,a,c){void 0===c&&(c=new mn);let l=[c.grabAndFill(t)],h=[];const d=[],u=[],f=i?i.length:0,g=n?n.length:0;let p;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(p=l.pop());)t.appendPolygonClip(p,d,u,c),Rn(r,d,i,n,h,c),Rn(o,u,i,n,h,c),c.dropToCache(p);const e=l;l=h,h=e}Rn(a,l,i,n,s,c),n?.length===g&&kn.restoreSingletonInPlaceOfMultipleShards(i,f,t,c),i?.length===f&&kn.restoreSingletonInPlaceOfMultipleShards(n,g,t,c)}static doPolygonClipParitySequence(t,e,i,n,s){void 0===s&&(s=new mn);let r=[s.grabAndFill(t)],o=[],a=[],c=[];const l=[],h=[];let d;for(const t of e)if(t.appendPolygonClip){for(;void 0!==(d=o.pop());)t.appendPolygonClip(d,l,h,s),Rn(M.acceptOut,l,a,c,void 0,s),Rn(M.acceptIn,h,a,c,void 0,s),s.dropToCache(d);for(;void 0!==(d=r.pop());)t.appendPolygonClip(d,l,h,s),Rn(M.acceptIn,l,a,c,void 0,s),Rn(M.acceptOut,h,a,c,void 0,s),s.dropToCache(d);const e=o;o=a,a=e;const i=r;r=c,c=i}0===r.length?i?.push(s.grabAndFill(t)):0===r.length?n?.push(s.grabAndFill(t)):(Fn(o,i,s),Fn(r,n,s))}static createComplementaryClips(t){const e=t.planes,i=gt.createNull(),n=e.length,s=[];for(const t of e){const e=As.createEmpty();e.addPlaneToConvexSet(t.cloneNegated()),s.push(e)}for(let r=0;r<n;r++)for(let o=r+1;o<n;o++){const n=Xs.planePlaneIntersectionRay(e[r],e[o]);if(n&&t.hasIntersectionWithRay(n,i)){const t=e[o].inwardNormalRef.minus(e[r].inwardNormalRef),i=Vr.createNormalAndPoint(t,n.origin);if(i){const t=i.cloneNegated();s[r].addPlaneToConvexSet(i),s[o].addPlaneToConvexSet(t)}}}return _n.createConvexSets(s)}}function Fn(t,e,i){if(void 0===e)i.dropAllToCache(t);else for(const i of t)e.push(i);t.length=0}function Rn(t,e,i,n,s,r){let o;if(t===M.acceptIn?o=i:t===M.acceptOut?o=n:t===M.passToNextStep&&(o=s),void 0===o)r.dropAllToCache(e);else for(const t of e)o.push(t);e.length=0}class Mn{_graph;_candidates;_mask;constructor(t,e){this._graph=t,this._candidates=[],this._mask=e,this._graph.clearMask(e)}clear(){for(;void 0!==this.chooseAndRemoveAny(););}getLength(){let t=0;for(const e of this._candidates)e.isMaskSet(this._mask)&&t++;return t}getNumCandidates(){return this._candidates.length}get graph(){return this._graph}teardown(){this._graph.dropMask(this._mask),this._candidates.length=0}get mask(){return this._mask}popAndReturn(){const t=this._candidates.length;if(0===t)return;const e=this._candidates[t-1];return this._candidates.pop(),e}getAtIndex(t){if(t>=0&&t<this._candidates.length){const e=this._candidates[t];if(e.isMaskSet(this._mask))return e}}addToSet(t){return!t.isMaskSet(this._mask)&&(this._candidates.push(t),this.setMaskInScope(t),!0)}isCandidateInSet(t){return t.isMaskSet(this._mask)}removeFromSet(t){return!!t.isMaskSet(this._mask)&&(this.clearMaskInScope(t),!0)}chooseAndRemoveAny(){for(;;){const t=this.popAndReturn();if(!t)return;if(this.removeFromSet(t))return t}}[Symbol.iterator](){return new On(this)}addAroundFace(t){let e=t;do{this.addToSet(e),e=e.faceSuccessor}while(e!==t)}addAroundVertex(t){let e=t;do{this.addToSet(e),e=e.vertexSuccessor}while(e!==t)}}class Dn extends Mn{constructor(t,e){super(t,e)}static create(t){const e=t.grabMask();if(e!==E.NULL_MASK)return new Dn(t,e)}setMaskInScope(t){t.setMaskAroundEdge(this._mask)}clearMaskInScope(t){t.clearMaskAroundEdge(this._mask)}countHalfEdgesAroundCandidate(t){return t?2:0}}class On{_markSet;_nextReadIndex;constructor(t){this._markSet=t,this._nextReadIndex=0}next(){const t=this._markSet.getNumCandidates();for(;this._nextReadIndex<t;){const t=this._markSet.getAtIndex(this._nextReadIndex++);if(void 0!==t)return{done:!1,value:t}}return{done:!0,value:void 0}}[Symbol.iterator](){return this}}class Bn{_node;_x;_y;_z;_u;_v;constructor(t,e,i,n,s,r){this._x=e,this._y=i,this._z=n,this._u=s,this._v=r,this._node=t}set(t,e,i,n,s,r){return this._x=e,this._y=i,this._z=n,this._u=s,this._v=r,this._node=t,this}setFrom(t){this._x=t.x,this._y=t.y,this._z=t.z,this._u=t.u,this._v=t.v,this._node=t.node}static createNodeAndRayOrigin(t,e,i){const n=t.x,s=t.y,r=t.z,o=n-e.origin.x,a=s-e.origin.y,c=J.dotProductXYXY(o,a,e.direction.x,e.direction.y),l=J.crossProductXYXY(e.direction.x,e.direction.y,o,a);return i?i.set(t,n,s,r,c,l):new Bn(t,n,s,r,c,l)}static create(t,e=0,i=0,n=0,s=0,r=0){return new Bn(t,e,i,n,s,r)}get node(){return this._node}get x(){return this._x}get y(){return this._y}get z(){return this._z}get u(){return this._u}get v(){return this._v}getXYZAsPoint3d(t){return $.create(this._x,this._y,this._z,t)}getUVAsPoint2d(t){return H.create(this._u,this._v,t)}classifyU(t,e){const i=this.u-t;return Math.abs(i)<=e?0:i>=0?1:-1}classifyV(t,e){const i=t-this._v;return Math.abs(i)<=e?0:i>=0?1:-1}}!function(t){t[t.None=0]="None",t[t.Vertex=1]="Vertex",t[t.Edge=2]="Edge",t[t.Face=3]="Face",t[t.ExteriorFace=4]="ExteriorFace"}(O||(O={}));class Nn{_node;x;y;z;_edgeFraction;_topo;_iTag;_dTag;_isExteriorTarget;constructor(t,e,i,n,s,r,o,a,c){this._node=t,this.x=e,this.y=i,this.z=n,this._topo=s,this._edgeFraction=r,this._iTag=o,this._dTag=a,this._isExteriorTarget=c}setFrom(t){this._node=t._node,this.x=t.x,this.y=t.y,this.z=t.z,this._topo=t._topo,this._edgeFraction=t._edgeFraction,this._iTag=t._iTag,this._dTag=t._dTag}resetAsUnknown(){this._node=void 0,this._topo=O.None}static create(){return new Nn(void 0,0,0,0,O.None)}getITag(){return this._iTag}setITag(t){this._iTag=t}getDTag(){return this._dTag}setDTag(t){this._dTag=t}getTopo(){return this._topo}static createEdgeAtFraction(t,e){const i=t.faceSuccessor,n=J.interpolate(t.x,e,i.x),s=J.interpolate(t.y,e,i.y),r=J.interpolate(t.z,e,i.z);return new Nn(t,n,s,r,O.Edge,e)}resetAsFace(t,e){return this._topo=O.Face,t&&(this._node=t),e&&(this.x=e.x,this.y=e.y,this.z=e.z),this._isExteriorTarget=void 0,this}resetAsUndefinedWithTag(t){return this._topo=O.None,this._dTag=0,this._iTag=0,this._dTag=t,this._node=void 0,this._isExteriorTarget=void 0,this}resetAtEdgeAndFraction(t,e){this._topo=O.Edge,this._node=t;const i=t.faceSuccessor;return this._edgeFraction=e,this.x=J.interpolate(t.x,e,i.x),this.y=J.interpolate(t.y,e,i.y),this.z=J.interpolate(t.z,e,i.z),this._isExteriorTarget=void 0,this}static createVertex(t){return new Nn(t,t.x,t.y,t.z,O.Vertex)}resetAsVertex(t){return this._topo=O.Vertex,this._node=t,this._edgeFraction=0,this.setXYZFromNode(t),this._isExteriorTarget=void 0,this}setIsExteriorTarget(t){this._isExteriorTarget=t}setXYZFromNode(t){this.x=t.x,this.y=t.y,this.z=t.z}get edgeFraction(){return this._edgeFraction}get isExteriorTarget(){return void 0!==this._isExteriorTarget&&this._isExteriorTarget}get isFace(){return this._topo===O.Face}get isEdge(){return this._topo===O.Edge}get isVertex(){return this._topo===O.Vertex}get isUnclassified(){return this._topo===O.None}get node(){return this._node}clonePoint(t){return $.create(this.x,this.y,this.z,t)}isAtXY(t,e){return this._topo!==O.None&&J.isSameCoordinate(this.x,t)&&J.isSameCoordinate(this.y,e)}}!function(t){t[t.NoHits=0]="NoHits",t[t.TargetOnVertex=1]="TargetOnVertex",t[t.TargetOnEdge=2]="TargetOnEdge",t[t.Bracket=3]="Bracket",t[t.TargetBefore=4]="TargetBefore",t[t.TargetAfter=5]="TargetAfter"}(B||(B={}));class Xn{_tol;constructor(t){this._tol=t}static create(t=J.smallMetricDistance){return new Xn(t)}panic(){return Nn.create()}reAimFromEdge(t,e,i){const n=t.node,s=Bn.createNodeAndRayOrigin(n,e),r=Bn.createNodeAndRayOrigin(n.edgeMate,e),o=-s.classifyV(0,this._tol),a=-r.classifyV(0,this._tol);let c;if(o*a<0)c=o>0?t.resetAsFace(s.node):t.resetAsFace(r.node);else if(0===o||0===a){const e=s.classifyU(i,this._tol),n=r.classifyU(i,this._tol);if(0===o&&0===e)c=t.resetAsVertex(s.node),c.setITag(1);else if(0===a&&0===n)c=t.resetAsVertex(r.node),c.setITag(1);else if(0===o&&0===a)if(e*n<0){const e=(i-s.u)/(r.u-s.u);c=t.resetAtEdgeAndFraction(s.node,e),c.setITag(1)}else e<0&&n<0?c=s.u>r.u?t.resetAsVertex(s.node):t.resetAsVertex(r.node):(t.resetAsUnknown(),c=this.panic());else c=0===o?0===s.classifyU(0,this._tol)?t.resetAsVertex(s.node):t.resetAsFace(a>0?r.node:s.node):0===r.classifyU(0,this._tol)?t.resetAsVertex(r.node):t.resetAsFace(o>0?s.node:r.node)}else t.resetAsUnknown(),c=this.panic();return c}reAimFromVertex(t,e,i){e.origin.isExactEqual(t);const n=t.node;let s=n;const r=e=>{if(Math.abs(e-i)<=this._tol)t.resetAsVertex(s.faceSuccessor).setITag(1);else if(e>i)t.resetAtEdgeAndFraction(s,i/e);else{if(!(e>this._tol))return!1;t.resetAsVertex(s.faceSuccessor)}return!0};do{const i=Bn.createNodeAndRayOrigin(s.faceSuccessor,e),n=Bn.createNodeAndRayOrigin(s.facePredecessor,e),o=i.u,a=n.u,c=i.v,l=n.v;if(Math.abs(c)<=this._tol){if(r(o))return t;if(Math.abs(o)<=this._tol&&c<=0&&l>this._tol&&(o>=0||o<0&&a>this._tol))return t.resetAsFace(s,s)}else if(c<-this._tol){if(l>this._tol)return t.resetAsFace(s,s);if(l>=-this._tol)if(Math.abs(a)<=this._tol){if(l>0&&(a>=0||o>this._tol&&a<0))return t.resetAsFace(s,s)}else if(o>this._tol&&a<0)return t.resetAsVertex(s.faceSuccessor)}s=s.vertexSuccessor}while(s!==n);return this.panic()}reAimAroundFace(t,e,i,n,s){t.isMaskSet(E.EXTERIOR),n.resetAsUndefinedWithTag(-Number.MAX_VALUE),s.resetAsUndefinedWithTag(Number.MAX_VALUE);const r=Bn.createNodeAndRayOrigin(t,e);let o,a=t;do{const t=a.faceSuccessor;o=Bn.createNodeAndRayOrigin(t,e,o);const c=r.u,l=o.u,h=r.v,d=o.v;if(Math.abs(d)<this._tol){const e=Nn.createVertex(t);if(e.setDTag(l),Math.abs(l-i)<this._tol)return s.setFrom(e),n.setFrom(e),B.TargetOnVertex;l>i&&l<s.getDTag()&&s.setFrom(e),l<i&&l>n.getDTag()&&n.setFrom(e)}else if(h*d<0){const t=-h/(d-h),e=J.interpolate(c,t,l),o=Nn.createEdgeAtFraction(r.node,t);if(o.setDTag(e),Math.abs(e-i)<=this._tol)return s.setFrom(o),n.setFrom(o),B.TargetOnEdge;e>i&&e<s.getDTag()&&s.setFrom(o),e<i&&e>n.getDTag()&&n.setFrom(o)}r.setFrom(o),a=a.faceSuccessor}while(a!==t);return s.setITag(0),n.setITag(0),n.isUnclassified?s.isUnclassified?B.NoHits:B.TargetBefore:s.isUnclassified?B.TargetAfter:B.Bracket}setSearchRay(t,e,i){i.origin.setFromPoint3d(t),tt.createStartEnd(i.origin,e,i.direction),i.direction.z=0;const n=i.direction.magnitudeXY();return!(n<this._tol||(i.a=n,i.direction.scaleInPlace(1/n),0))}}!function(t){t[t.Ignore=0]="Ignore",t[t.Replace=1]="Replace",t[t.ReplaceIfLarger=2]="ReplaceIfLarger",t[t.ReplaceIfSmaller=3]="ReplaceIfSmaller"}(N||(N={}));class zn{_graph;_edgeSet;_searcher;_tolerance;constructor(t,e){this._graph=t,this._edgeSet=Dn.create(t),this._searcher=Nn.create(),this._tolerance=e}static create(t,e=J.smallMetricDistance){return new zn(t,e)}get graph(){return this._graph}retriangulateFromBaseVertex(t){const e=t.countEdgesAroundFace();if(e<4||t.isMaskSet(E.EXTERIOR))return;this._edgeSet.addAroundFace(t);const i=e-3;let n=t.faceSuccessor,s=t;for(let t=0;t<i;t++)n=n.faceSuccessor,s=this._graph.createEdgeHalfEdgeHalfEdge(s,0,n,0),n=s.faceSuccessor,this._edgeSet.addToSet(s)}reset(){this._searcher=Nn.create()}get currentPosition(){return this._searcher}searchForNearestEdgeOrVertex(t){const e=Nn.create();e.setDTag(Number.MAX_VALUE);const i=$.create();let n,s;for(const r of this._graph.allHalfEdges){const o=r.faceSuccessor;n=Ft.lineSegment3dXYClosestPointUnbounded(r,o,t),void 0!==n&&(n>1?(s=t.distanceXY(o),s<e.getDTag()&&(e.resetAsVertex(o),e.setDTag(s))):n<0?(s=t.distanceXY(r),s<e.getDTag()&&(e.resetAsVertex(r),e.setDTag(s))):(r.fractionToPoint3d(n,i),s=t.distanceXY(i),s<e.getDTag()&&e.resetAtEdgeAndFraction(r,n)))}return e}searchForNearestVertex(t){const e=Nn.create();let i;e.setDTag(Number.MAX_VALUE);for(const n of this._graph.allHalfEdges)i=t.distanceXY(n),i<e.getDTag()&&(e.resetAsVertex(n),e.setDTag(i));return e}resetSearch(t,e){this._searcher=e?this.searchForNearestEdgeOrVertex(t):this.searchForNearestVertex(t)}reclassifyFaceHit(t){if(void 0===this._searcher.node||!this._searcher.isFace||this._searcher.node.isMaskSet(E.EXTERIOR))return!1;const e=$.create(t.x,t.y),i=this._searcher.node.collectAroundFace((t=>{const e=$.create(t.x,t.y);return e.node=t,e})),n=zr.closestPointOnBoundary(i,e,this._tolerance);if(n.code,_.OnPolygonEdgeInterior,n.a>this._tolerance)return!1;const s=i[n.closestEdgeIndex].node,r=n.closestEdgeParam<.5?s:s.faceSuccessor;return n.point.distanceSquaredXY(r)<=this._tolerance*this._tolerance?this._searcher.resetAsVertex(r):this._searcher.resetAtEdgeAndFraction(s,n.closestEdgeParam),!0}reclassifyEdgeHit(t){if(void 0===this._searcher.node||!this._searcher.isEdge||this._searcher.node.isMaskSet(E.BOUNDARY_EDGE))return!1;const e=$.create(t.x,t.y),i=[];for(let t=this._searcher.node.faceSuccessor;t!==this._searcher.node;t=t.faceSuccessor){const e=$.create(t.x,t.y);e.node=t,i.push(e)}for(let t=this._searcher.node.vertexPredecessor;t!==this._searcher.node.edgeMate;t=t.faceSuccessor){const e=$.create(t.x,t.y);e.node=t,i.push(e)}const n=zr.closestPointOnBoundary(i,e,this._tolerance);if(n.a>this._tolerance)return!1;const s=i[n.closestEdgeIndex].node,r=n.closestEdgeParam<.5?s:s.faceSuccessor;return n.code===_.OnPolygonVertex||n.point.distanceSquaredXY(r)<=this._tolerance*this._tolerance?this._searcher.resetAsVertex(r):this._searcher.resetAtEdgeAndFraction(s,n.closestEdgeParam),!0}updateZAroundVertex(t,e,i){N.Ignore!==i&&(N.ReplaceIfLarger===i&&e.z<=t.z||N.ReplaceIfSmaller===i&&e.z>=t.z||t.setXYZAroundVertex(t.x,t.y,e.z))}insertAndRetriangulate(t,e){if(this.moveToPoint(this._searcher,t),void 0===this._searcher.node)return!1;if(this.reclassifyFaceHit(t)||this.reclassifyEdgeHit(t),this._searcher.isFace){if(!this._searcher.node.isMaskSet(E.EXTERIOR)){const e=this._graph.createEdgeXYZHalfEdge(t.x,t.y,t.z,0,this._searcher.node,0);this.retriangulateFromBaseVertex(e),Ln.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(e)}}else if(this._searcher.isEdge){const e=this._graph.splitEdgeAtFraction(this._searcher.node,this._searcher.edgeFraction),i=e.vertexPredecessor;this.updateZAroundVertex(e,t,N.Replace),this.retriangulateFromBaseVertex(e),this.retriangulateFromBaseVertex(i),Ln.flipTrianglesInEdgeSet(this._graph,this._edgeSet),this._searcher.resetAsVertex(e)}else this._searcher.isVertex&&this.updateZAroundVertex(this._searcher.node,t,e);return!0}moveToPoint(t,e,i){const n=Xn.create(this._tolerance);if(t.setITag(0),t.isUnclassified&&(function(t,e,i,n){for(const i of t.allHalfEdges)if(!i.isMaskSet(n))return e.resetAtEdgeAndFraction(i,.5),!0}(this.graph,t,0,E.NULL_MASK),t.isUnclassified))return!1;let s=0;const r=Rt.createXAxis();for(;0===t.getITag()&&s<2&&(void 0===i||i(t));){if(!n.setSearchRay(t,e,r))return!1;if(t.isFace){const i=Nn.create(),o=Nn.create();switch(n.reAimAroundFace(t.node,r,r.a,i,o)){case B.NoHits:t.resetAsUnknown();break;case B.TargetOnVertex:case B.TargetOnEdge:t.setFrom(i),t.setITag(1);break;case B.Bracket:t.resetAsFace(i.node,e),t.setITag(1);break;case B.TargetBefore:t.resetAsFace(t.node,e),t.setITag(1);break;case B.TargetAfter:t.node===i.node&&t.isFace&&(i.isEdge||i.isVertex)?s++:s=0,t.setFrom(i)}}else if(t.isEdge){if(n.reAimFromEdge(t,r,r.a),t.isUnclassified)break}else if(t.isVertex&&(n.reAimFromVertex(t,r,r.a),t.isUnclassified))break}return!!t.isAtXY(e.x,e.y)||s>1&&(void 0!==t.node&&t.setIsExteriorTarget(!0),!1)}}class Ln{static flipEdgeBetweenTriangles(t,e,i,n,s,r){ln.pinch(t,s),ln.pinch(i,n),ln.pinch(r,i),ln.pinch(s,e),s.x=e.x,s.y=e.y,s.z=e.z,s.i=e.i,i.i=r.i,i.x=r.x,i.y=r.y,i.z=r.z}static computeCircumcircleDeterminantIsStrongPositive(t){const e=t.faceSuccessor,i=e.faceSuccessor;if(i.faceSuccessor!==t)return!1;const n=t.edgeMate,s=n.faceSuccessor.faceSuccessor;if(s.faceSuccessor!==n)return!1;const r=e.x-t.x,o=e.y-t.y,a=i.x-t.x,c=i.y-t.y;if(J.crossProductXYXY(r,o,a,c)<0)return!1;const l=s.x-t.x,h=s.y-t.y,d=l*l+h*h,u=a*a+c*c,f=r*r+o*o,g=J.tripleProduct(l,h,d,a,c,u,r,o,f);return!(g<0)&&g>1e-12*(Math.abs(l*c*f)+Math.abs(h*u*r)+Math.abs(d*a*o)+Math.abs(l*u*o)+Math.abs(h*a*f)+Math.abs(d*c*r))}static flipTriangles(t){const e=Dn.create(t);for(const i of t.allHalfEdges)e.addToSet(i);const i=this.flipTrianglesInEdgeSet(t,e);return e.teardown(),i}static flipTrianglesInEdgeSet(t,e){const i=E.EXTERIOR|E.PRIMARY_EDGE|E.BOUNDARY_EDGE,n=10*t.allHalfEdges.length;let s,r=0,o=0;for(;void 0!==(s=e.chooseAndRemoveAny())&&(s.isMaskSet(i)||(Ln.computeCircumcircleDeterminantIsStrongPositive(s)?(Ln.flipEdgeBetweenTriangles(s.edgeMate.faceSuccessor,s.edgeMate.facePredecessor,s.edgeMate,s.faceSuccessor,s,s.facePredecessor),e.addAroundFace(s),e.addAroundFace(s.edgeMate),r++):o++,!(r+o>n))););return r}static createTriangulatedGraphFromPoints(t,e=N.ReplaceIfLarger,i=J.smallMetricDistance){if(t.length<3)return;const n=[],s=[];fe.computeConvexHullXY(t,n,s,!0);const r=new hn,o=zn.create(r,i),a=Ln.createFaceLoopFromCoordinates(r,n,!0,!0);if(void 0!==a){for(const t of s)o.insertAndRetriangulate(t,e);return a.countEdgesAroundFace()>3?Ln.createTriangulatedGraphFromSingleLoop(n):r}}static createTriangulatedGraphFromLoops(t){if(t.length<1)return;const e=E.BOUNDARY_EDGE|E.PRIMARY_EDGE,i=new hn,n=[];let s=-1e4,r=-1;for(let o=0;o<t.length;o++){let a=Ln.directCreateFaceLoopFromCoordinates(i,t[o]);if(a){a=a.faceSuccessor;const t=a.vertexSuccessor;a.setMaskAroundFace(e),t.setMaskAroundFace(e);const i=a.signedFaceArea(),c=Math.abs(i);n.push(i>=0?a:t),(0===o||c>s)&&(s=c,r=o)}}if(0===n.length)return;const o=n[r];n[r]=n[n.length-1],n.pop(),o.vertexSuccessor.setMaskAroundFace(E.EXTERIOR);for(let t=0;t<n.length;t++){const e=n[t];e.setMaskAroundFace(E.EXTERIOR),n[t]=this.getLeftmost(e.vertexSuccessor)}const a=Ln.spliceLeftMostNodesOfHoles(i,o,n);return a&&Ln.triangulateSingleFace(i,a)?i:void 0}static triangulateAllPositiveAreaFaces(t){const e=t.collectFaceLoops();let i=0;for(const n of e)n.countEdgesAroundFace()>3&&n.signedFaceArea()>0&&(Ln.triangulateSingleFace(t,n)||i++);return 0===i}static _workTransform;static triangulateAllInteriorFaces(t,e){const i=t.collectFaceLoops(),n=e?t.grabMask():E.NULL_MASK;let s,r,o=0,a=0;for(const n of i)if(n.countEdgesAroundFace()>3){if(n.getMask(E.EXTERIOR))continue;if(e&&(o=t.countNodes(),r=n.collectAroundFace(),s=this._workTransform=bi.createRightHandedLocalToWorld(r,this._workTransform),s?.multiplyInversePoint3dArrayInPlace(r)),Ln.triangulateSingleFace(t,n,e)||a++,s&&r){for(let e=o;e<t.countNodes();++e)r.push(t.allHalfEdges[e]);s.multiplyPoint3dArrayInPlace(r)}}return t.dropMask(n),0===a}static createTriangulatedGraphFromSingleLoop(t){const e=new hn,i=Ln.createFaceLoopFromCoordinates(e,t,!0,!0);if(i&&!(e.countNodes()<6)&&Ln.triangulateSingleFace(e,i))return Ln.flipTriangles(e),e}static interiorEdgeSplit(t,e,i){let n=0,s=0,r=0;if(Array.isArray(i))n=i[0],s=i[1],r=i.length>2?i[3]:0;else{const t=i;t.hasOwnProperty("x")&&(n=t.x),t.hasOwnProperty("y")&&(s=t.y),t.hasOwnProperty("z")&&(r=t.z)}return e&&Ln.isAlmostEqualXAndYXY(e,n,s)?e:t.splitEdge(e,n,s,r)}static getUnwrappedLength(t){let e,i,n,s,r=t.length;for(;r>1&&(t instanceof nt?(e=t.getXAtUncheckedPointIndex(0),i=t.getYAtUncheckedPointIndex(0),n=t.getXAtUncheckedPointIndex(r-1),s=t.getYAtUncheckedPointIndex(r-1)):J.isArrayOfNumberArray(t,r,2)?(e=t[0][0],i=t[0][1],n=t[r-1][0],s=t[r-1][1]):(e=t[0].x,i=t[0].y,n=t[r-1].x,s=t[r-1].y),J.isAlmostEqualNumber(e,n)&&J.isAlmostEqualNumber(i,s));)--r;return r}static directCreateFaceLoopFromCoordinates(t,e){const i=this.getUnwrappedLength(e);let n;if(e instanceof nt){const s=$.create();for(let r=0;r<i;r++)e.getPoint3dAtCheckedPointIndex(r,s),n=Ln.interiorEdgeSplit(t,n,s)}else for(let s=0;s<i;s++)n=Ln.interiorEdgeSplit(t,n,e[s]);return n}static directCreateChainsFromCoordinates(t,e,i=0){const n=new Yn(t,i);return dt.streamXYZ(e,n),n.claimSeeds()}static maskAndOrientNewFaceLoop(t,e,i,n,s){if(e){const t=(e=e.faceSuccessor).signedFaceArea(),r=e.edgeMate;n!==E.NULL_MASK&&(e.setMaskAroundFace(n),r.setMaskAroundFace(n));let o=e;i&&t<0&&(o=r);const a=o.vertexSuccessor;return s!==E.NULL_MASK&&a.setMaskAroundFace(s),o}}static createFaceLoopFromCoordinates(t,e,i,n){const s=Ln.directCreateFaceLoopFromCoordinates(t,e);return Ln.maskAndOrientNewFaceLoop(t,s,i,E.BOUNDARY_EDGE|E.PRIMARY_EDGE,n?E.EXTERIOR:E.NULL_MASK)}static createFaceLoopFromCoordinatesAndMasks(t,e,i,n,s){const r=Ln.directCreateFaceLoopFromCoordinates(t,e);return Ln.maskAndOrientNewFaceLoop(t,r,i,n,s)}static joinNeighborsOfEar(t,e){const i=t.createEdgeXYZXYZ(e.facePredecessor.x,e.facePredecessor.y,e.facePredecessor.z,e.facePredecessor.i,e.faceSuccessor.x,e.faceSuccessor.y,e.faceSuccessor.z,e.faceSuccessor.i),n=i.edgeMate;ln.pinch(e.faceSuccessor,n),ln.pinch(e.facePredecessor,i),e.setMaskAroundFace(E.TRIANGULATED_FACE)}static isInteriorTriangle(t){if(!t.isMaskSet(E.TRIANGULATED_FACE)||t.isMaskSet(E.EXTERIOR))return!1;const e=t.faceSuccessor;if(!e.isMaskSet(E.TRIANGULATED_FACE)||e.isMaskSet(E.EXTERIOR))return!1;const i=e.faceSuccessor;return!(!i.isMaskSet(E.TRIANGULATED_FACE)||i.isMaskSet(E.EXTERIOR))&&i.faceSuccessor===t}static doPostCutFlips(t){let e=t,i=e.facePredecessor,n=i.edgeMate;for(;Ln.isInteriorTriangle(i)&&Ln.isInteriorTriangle(n)&&Ln.computeCircumcircleDeterminantIsStrongPositive(i);){const t=n.faceSuccessor;Ln.flipEdgeBetweenTriangles(t,t.faceSuccessor,t.facePredecessor,e,e.facePredecessor,e.faceSuccessor),e=i,i=e.facePredecessor,n=i.edgeMate}return e}static triangulateSingleFace(t,e,i=!1){if(!e)return Ln.setDebugGraph(t),!1;let n,s,r,o=e.countEdgesAroundFace(),a=0;for(e.clearMaskAroundFace(E.TRIANGULATED_FACE);!e.isMaskSet(E.TRIANGULATED_FACE);){if(r=e?.facePredecessor,n=e.faceSuccessor,s=n.faceSuccessor,n===e||s===e)return!0;if(s.faceSuccessor===e)return e.setMaskAroundFace(E.TRIANGULATED_FACE),!0;if(!J.isAlmostEqualXAndY(s,r)||s.findAroundVertex(r)){if(++a>o)return Ln.setDebugGraph(t),!1;Ln.isEar(e)?(o--,a=0,e.faceSuccessor.faceSuccessor!==e.facePredecessor?(Ln.joinNeighborsOfEar(t,e),i||(e=Ln.doPostCutFlips(e)),e=e.faceSuccessor.edgeMate.faceSuccessor):(e.setMaskAroundFace(E.TRIANGULATED_FACE),e=n.faceSuccessor)):e=n}else{const t=s.faceSuccessor;if(this.nodeInTriangle(r,e,n,t)){const t=s.vertexPredecessor;ln.pinch(r.vertexSuccessor,t)}else ln.pinch(r,s),e.setMaskAroundFace(E.TRIANGULATED_FACE);e=s}}return!0}static sDebugGraph;static sEnableDebugGraphCapture=!1;static claimDebugGraph(){const t=Ln.sDebugGraph;return Ln.sDebugGraph=void 0,Ln.sEnableDebugGraphCapture=!1,t}static setDebugGraph(t){Ln.sEnableDebugGraphCapture&&(Ln.sDebugGraph=t)}static clearAndEnableDebugGraphCapture(t){Ln.sEnableDebugGraphCapture=t,Ln.sDebugGraph=void 0}static findAroundOrAtVertex(t,e){return!!t.findAroundVertex(e)||J.isAlmostEqualXAndY(t,e)}static _edgeInterval=gt.createNull();static _earRange=pt.createNull();static _edgeRange=pt.createNull();static _planes=[yt.createXYPlane(),yt.createXYPlane(),yt.createXYPlane()];static isEar(t){const e=t.facePredecessor,i=t,n=t.faceSuccessor,s=Ln.signedTolerancedCCWTriangleArea(e,i,n);if(s<=0)return!1;const r=this._planes;if(!yt.createOriginAndTargetXY(e,i,r[0])||!yt.createOriginAndTargetXY(i,n,r[1])||!yt.createOriginAndTargetXY(n,e,r[2]))return!1;const o=this._earRange,a=this._edgeRange,c=this._edgeInterval;pt.createXYXYXY(e.x,e.y,i.x,i.y,n.x,n.y,o),o.expandInPlace(J.smallMetricDistance);let l=n;const h=1e-10*s;for(;l!==e;){const t=l.faceSuccessor;if(pt.createXYXY(l.x,l.y,t.x,t.y,a),o.intersectsRange(a)&&(gt.createXX(-1e-8,1.00000001,c),kn.clipSegmentBelowPlanesXY(r,l,t,c,h),!c.isNull))if(c.low>.99999999){if(!this.findAroundOrAtVertex(e,t)&&!this.findAroundOrAtVertex(i,t)&&!this.findAroundOrAtVertex(n,t))return!1}else if(c.high<1e-8){if(!this.findAroundOrAtVertex(e,l)&&!this.findAroundOrAtVertex(i,l)&&!this.findAroundOrAtVertex(n,l))return!1}else if(this.findAroundOrAtVertex(i,t)&&this.findAroundOrAtVertex(n,l));else if(!this.findAroundOrAtVertex(e,t)||!this.findAroundOrAtVertex(i,l))return!1;l=l.faceSuccessor}return!0}static spliceLeftMostNodesOfHoles(t,e,i){i.sort(((t,e)=>Ln.compareX(t,e)));let n=0;for(const s of i)Ln.eliminateHole(t,s,e)||n++;return 0===n?e:void 0}static compareX(t,e){return t.x-e.x}static eliminateHole(t,e,i){const n=Ln.findHoleBridge(e,i);return!!n&&void 0!==Ln.splitFace(t,n,e)}static findHoleBridge(t,e){let i=e;if(!i)return;const n=t.x,s=t.y;let r,o=-1/0;do{if(s<=i.y&&s>=i.faceSuccessor.y&&i.faceSuccessor.y!==i.y){const t=i.x+(s-i.y)*(i.faceSuccessor.x-i.x)/(i.faceSuccessor.y-i.y);if(t<=n&&t>o){if(o=t,t===n){if(s===i.y)return i;if(s===i.faceSuccessor.y)return i.faceSuccessor}r=i.x<i.faceSuccessor.x?i:i.faceSuccessor}}i=i.faceSuccessor}while(i!==e);if(!r)return;if(n===o)return r.facePredecessor;const a=r,c=r.x,l=r.y;let h,d=1/0;for(i=r.faceSuccessor;i!==a;)n>=i.x&&i.x>=c&&n!==i.x&&Ln.pointInTriangle(s<l?n:o,s,c,l,s<l?o:n,s,i.x,i.y)&&(h=Math.abs(s-i.y)/(n-i.x),(h<d||h===d&&i.x>r.x)&&Ln.locallyInside(i,t)&&(r=i,d=h)),i=i.faceSuccessor;return r}static getLeftmost(t){let e=t,i=t;do{e.x<i.x&&(i=e),e=e.faceSuccessor}while(e!==t);return i}static pointInTriangle(t,e,i,n,s,r,o,a){return(s-o)*(e-a)-(t-o)*(r-a)>=0&&(t-o)*(n-a)-(i-o)*(e-a)>=0&&(i-o)*(r-a)-(s-o)*(n-a)>=0}static nodeInTriangle(t,e,i,n){return Ln.signedTolerancedCCWTriangleArea(t,e,n)>0&&Ln.signedTolerancedCCWTriangleArea(e,i,n)>0&&Ln.signedTolerancedCCWTriangleArea(i,t,n)>0}static signedCWTriangleArea(t,e,i){return.5*((e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y))}static signedTolerancedCCWTriangleArea(t,e,i,n=1e-12){const s=e.x-t.x,r=e.y-t.y,o=i.x-t.x,a=i.y-t.y,c=.5*(s*a-r*o);return c<0?c:c<n*(s*s+r*r+(o*o+a*a))?0:c}static isAlmostEqualXAndYXY(t,e,i){return J.isAlmostEqualNumber(t.x,e)&&J.isAlmostEqualNumber(t.y,i)}static locallyInside(t,e){return Ln.signedCWTriangleArea(t.facePredecessor,t,t.faceSuccessor)<0?Ln.signedCWTriangleArea(t,e,t.faceSuccessor)>=0&&Ln.signedCWTriangleArea(t,t.facePredecessor,e)>=0:Ln.signedCWTriangleArea(t,e,t.facePredecessor)<0||Ln.signedCWTriangleArea(t,t.faceSuccessor,e)<0}static splitFace(t,e,i){if(ln.isNodeVisibleInSector(e,i)&&ln.isNodeVisibleInSector(i,e)){const n=t.createEdgeXYZXYZ(e.x,e.y,e.z,e.i,i.x,i.y,i.z,i.i),s=n.faceSuccessor;return ln.pinch(e,n),ln.pinch(i,s),n}}static triangulateSingleMonotoneFace(t,e){let i,n=e.facePredecessor,s=e.faceSuccessor;for(;n!==s&&s!==e&&s.faceSuccessor!==n;){if(ln.crossProductXYAlongChain(n,e,s)<=0)return!1;if(!e.belowYX(n))return!1;if(!e.belowYX(s))return!1;if(n.belowYX(s)){let r=n,o=e,a=s;for(;r!==a&&r.belowYX(s);){for(;a!==s&&a!==r&&a!==o&&ln.crossProductXYAlongChain(r,o,a)>0;){if(i=Ln.splitFace(t,r,a),void 0===i)return!1;r=i,o=r.faceSuccessor,a=o.faceSuccessor}a=o,o=r,r=r.facePredecessor}for(n=o,a=s,o=a.facePredecessor,r=o.facePredecessor;a.faceSuccessor!==r&&r!==n;){if(i=Ln.splitFace(t,r,a),void 0===i)return!1;o=i,r=o.facePredecessor}if(a.faceSuccessor!==r){if(i=Ln.splitFace(t,r,a),void 0===i)return!1;r=i}s=(e=r).faceSuccessor,n=e.facePredecessor}else{let r=n,o=e,a=s;for(;r!==a&&a.belowYX(n);){for(;r!==n&&a!==r&&a!==o&&ln.crossProductXYAlongChain(r,o,a)>0;){if(i=Ln.splitFace(t,r,a),void 0===i)return!1;r=i.facePredecessor,o=i}r=o,o=a,a=a.faceSuccessor}for(s=o,r=n,o=r.faceSuccessor,a=o.faceSuccessor;a.faceSuccessor!==r&&a!==s;){if(i=Ln.splitFace(t,r,a),void 0===i)return!1;r=i,a=a.faceSuccessor}if(a.faceSuccessor!==r&&void 0===Ln.splitFace(t,r,a))return!1;s=(e=s).faceSuccessor,n=e.facePredecessor}}return!0}}class Yn extends at{_seeds;_baseNode;_nodeB;_nodeC;_graph;_id;constructor(t,e){super(),this._graph=t,this._id=e}startChain(t,e){super.startChain(t,e),this._baseNode=void 0,this._nodeB=void 0}handleXYZXYZ(t,e,i,n,s,r){this._nodeC=this._graph.createEdgeXYZXYZ(t,e,i,this._id,n,s,r,this._id),void 0===this._baseNode?(this._baseNode=this._nodeC,this._nodeB=this._baseNode.faceSuccessor):(ln.pinch(this._nodeB,this._nodeC),this._nodeB=this._nodeC.faceSuccessor)}endChain(t,e){super.endChain(t,e),void 0!==this._baseNode&&(void 0===this._seeds&&(this._seeds=[]),this._seeds.push(this._baseNode)),this._baseNode=void 0,this._nodeB=void 0,this._nodeC=void 0}claimSeeds(){return void 0===this._seeds?[]:this._seeds}}class Vn{numUpEdge=0;numIntersectionTest=0;numSplit=0;numPopOut=0;numA0B0=0;numA0B1=0;constructor(){}}class Un{index;radiusOfCurvature;node;radians;constructor(t,e,i,n){this.index=t,this.radiusOfCurvature=e,this.node=i,this.radians=n}}class qn{static compareNodesYXUp(t,e){return t.y<e.y?-1:t.y>e.y?1:t.x<e.x?-1:t.x>e.x?1:0}static isDownPeak(t){const e=t.facePredecessor,i=t.faceSuccessor;return this.compareNodesYXUp(t,e)<0&&this.compareNodesYXUp(t,i)<0&&this.crossProductToTargets(t,e,i)>0}static crossProductToTargets(t,e,i){return J.crossProductXYXY(e.x-t.x,e.y-t.y,i.x-t.x,i.y-t.y)}static graphRange(t){const e=ft.create();for(const i of t.allHalfEdges)e.extendXYZ(i.x,i.y,i.z);return e}static segmentArrayToGraphEdges(t,e,i){const n=[];let s=0;for(const r of t){const t=e.createEdgeXYZXYZ(r.point0Ref.x,r.point0Ref.y,r.point0Ref.z,s,r.point1Ref.x,r.point1Ref.y,r.point1Ref.z,s+1),o=t.edgeMate;s+=2,t.setMaskAroundFace(i),n.push(t),n.push(o)}return n}static isolateAllEdges(t){for(const e of t.allHalfEdges){const t=e.vertexPredecessor;ln.pinch(e,t)}}static isSectorConvexAfterEdgeRemoval(t,e,i,n=0){let s=t;do{if(s.isMaskSet(i)||s.edgeMate.isMaskSet(i))break;s=s.vertexSuccessor}while(s!==t&&s.isMaskSet(e));if(s===t)return!1;let r=t;do{if(r.isMaskSet(i)||r.edgeMate.isMaskSet(i))break;r=r.vertexPredecessor}while(r!==t&&r.isMaskSet(e));return r!==t&&ln.isSectorConvex(s.edgeMate,t,r.faceSuccessor,n)}static markRemovableEdgesToExpandConvexFaces(t,e,i=E.BOUNDARY_EDGE){if(E.NULL_MASK===e)return 0;const n=t.grabMask(!0);let s=0;for(const r of t.allHalfEdges){if(!r.isMaskSet(n)&&!r.isMaskSet(i)&&!r.edgeMate.isMaskSet(i)){const t=J.smallMetricDistanceSquared*(r.signedFaceArea()+r.edgeMate.signedFaceArea());this.isSectorConvexAfterEdgeRemoval(r,e,i,t)&&this.isSectorConvexAfterEdgeRemoval(r.edgeMate,e,i,t)&&(r.setMaskAroundEdge(e),++s)}r.setMaskAroundEdge(n)}return t.dropMask(n),s}static collectRemovableEdgesToExpandConvexFaces(t,e=E.BOUNDARY_EDGE){const i=[],n=t.grabMask(!0);if(0<this.markRemovableEdgesToExpandConvexFaces(t,n,e)){const e=t.grabMask(!0);for(const s of t.allHalfEdges)s.isMaskSet(n)&&!s.isMaskSet(e)&&(s.setMaskAroundEdge(e),i.push(s));t.dropMask(e)}return t.dropMask(n),i}static expandConvexFaces(t,e=E.BOUNDARY_EDGE){const i=t.grabMask(!0),n=this.markRemovableEdgesToExpandConvexFaces(t,i,e);return n>0&&t.yankAndDeleteEdges((t=>t.getMask(i))),t.dropMask(i),n}static isEveryFaceConvex(t,e=E.EXTERIOR){const i=t.collectFaceLoops();for(const t of i)if(!t.isMaskedAroundFace(e)&&!t.isFaceConvex())return!1;return!0}}class Zn{static getCommonThetaEndIndex(t,e,i,n){let s=i+1;const r=t.getExtraData(e[i],0);for(;s<n;){const i=t.getExtraData(e[s],0);if(!G.isAlmostEqualRadiansAllowPeriodShift(r,i))return s;s++}return s}static _announceVertexNeighborhoodFunction;static set announceVertexNeighborhoodFunction(t){this._announceVertexNeighborhoodFunction=t}static doAnnounceVertexNeighborhood(t,e,i,n,s){if(this._announceVertexNeighborhoodFunction){const r=[];for(let o=n;o<s;o++){const n=t.getExtraData(e[o],1),s=t.getExtraData(e[o],0),a=i[n],c=this.curvatureSortKey(a);r.push(new Un(e[o],c,a,s))}this._announceVertexNeighborhoodFunction(r)}}static secondarySortAroundVertex(t,e,i,n,s){const r=[];for(let o=n;o<s;){const n=this.getCommonThetaEndIndex(t,e,o,s);if(o+1<n){r.length=0;for(let s=o;s<n;s++){const n=i[t.getExtraData(e[s],1)],o=this.curvatureSortKey(n);r.push(new Un(e[s],o,n))}r.sort(((t,e)=>t.radiusOfCurvature-e.radiusOfCurvature));for(let t=0;t<r.length;t++)e[o+t]=r[t].index}o=n}}static curvatureSortKey(t){const e=t.edgeTag;if(void 0!==e){const i=e.fraction,n=e.curve;if(n){let e=n.fractionToSignedXYRadiusOfCurvature(i);return void 0!==t.sortData&&t.sortData<0&&(e=-e),e}}return 0}static isNullFace(t){return t.isMaskSet(E.NULL_FACE)&&t.faceSuccessor.isMaskSet(E.NULL_FACE)&&t===t.faceSuccessor.faceSuccessor}static clusterAndMergeXYTheta(t,e){const i=t.allHalfEdges,n=i.length;t.clearMask(E.NULL_FACE);const s=new Mi(2,2,n);for(let t=0;t<n;t++){const e=i[t],n=e.x,r=e.y;ln.pinch(e,e.vertexSuccessor),s.addDirect(n,r,0,t)}const r=J.smallMetricDistance,o=s.clusterIndicesLexical(r);let a=0;const c=o.length;for(let t=0;t<c;t++)if(o[t]===Mi.clusterTerminator){if(t>a){const e=i[s.getExtraData(o[a],1)];for(let n=a+1;n<t;n++){const t=i[s.getExtraData(o[n],1)];t.x=e.x,t.y=e.y}}a=t+1}for(const t of o)if(t!==Mi.clusterTerminator){const n=i[t],r=n.faceSuccessor;let o=e;if(o){const t=n.edgeTag;(void 0===t||void 0===t.curve||t.curve instanceof Te)&&(o=void 0)}let a=o?o(n):Math.atan2(r.y-n.y,r.x-n.x);G.isAlmostEqualRadiansAllowPeriodShift(a,-Math.PI)&&(a=Math.PI),s.setExtraData(t,0,a)}s.sortSubsetsBySingleKey(o,2);const l=[];let h,d;a=0;for(let t=0;t<c;t++)if(o[t]===Mi.clusterTerminator){if(t>a){t>a+1&&this.secondarySortAroundVertex(s,o,i,a,t),this.doAnnounceVertexNeighborhood(s,o,i,a,t);const e=s.getExtraData(o[a],1);h=s.getExtraData(o[a],0);let n=i[e];for(let e=a+1;e<t;e++){const t=s.getExtraData(o[e],1);d=s.getExtraData(o[e],0);const a=i[t];if(n.isMaskSet(E.NULL_FACE)){const t=l.findIndex((t=>n===t));t>=0&&(l[t]=l[l.length-1],l.pop()),n=a,h=d}else if(a.isMaskSet(E.NULL_FACE)){const t=l.findIndex((t=>a===t));t>=0&&(l[t]=l[l.length-1],l.pop())}else{if(ln.pinch(n,a),G.isAlmostEqualRadiansAllowPeriodShift(h,d)){const t=n.faceSuccessor,e=a.edgeMate;if(t.isEqualXY(e)){const i=this.curvatureSortKey(n),s=this.curvatureSortKey(a);J.isSameCoordinate(i,s,r)&&(ln.pinch(t,e),n.setMask(E.NULL_FACE),e.setMask(E.NULL_FACE),l.push(e))}}n=a,h=d}}}a=t+1}}static buildVerticalSweepPriorityQueue(t){const e=new un;for(const i of t.allHalfEdges)qn.compareNodesYXUp(i,i.faceSuccessor)<0&&e.priorityQueue.push(i);return e}static snapFractionToNode(t,e,i,n){return J.isSameCoordinate(t.x,i.x)&&J.isSameCoordinate(t.y,i.y)?n:e}static computeIntersectionFractionsOnEdges(t,e,i,n,s){const r=t.faceSuccessor,o=t.x,a=t.y,c=r.x-o,l=r.y-a,h=e.faceSuccessor,d=e.x,u=e.y,f=h.x-d,g=h.y-u;return!!Ft.lineSegmentXYUVTransverseIntersectionUnbounded(o,a,c,l,d,u,f,g,i)&&(n.x=o+i.x*c,n.y=a+i.x*l,s.x=d+i.y*f,s.y=u+i.y*g,i.x=this.snapFractionToNode(n,i.x,t,0),i.x=this.snapFractionToNode(n,i.x,r,1),i.y=this.snapFractionToNode(s,i.y,e,0),i.y=this.snapFractionToNode(s,i.y,h,1),J.isIn01(i.x)&&J.isIn01(i.y))}static splitIntersectingEdges(t){const e=new Vn,i=this.buildVerticalSweepPriorityQueue(t);let n,s;const r=.99999999;let o;const a=j.create(),c=H.create(),l=H.create();let h;const d=J.smallMetricDistance;for(;void 0!==(n=i.priorityQueue.pop());){e.numUpEdge++;const u=i.activeEdges.length;for(i.removeArrayMembersWithY1Below(n.y-d),e.numPopOut+=u-i.activeEdges.length,o=0;o<i.activeEdges.length;o++)if(h=i.activeEdges[o],s=h.faceSuccessor,J.isSameCoordinateXY(n.x,n.y,h.x,h.y))e.numA0B0++;else if(J.isSameCoordinateXY(s.x,s.y,n.x,n.y))e.numA0B1++;else if(e.numIntersectionTest++,this.computeIntersectionFractionsOnEdges(n,h,a,c,l)){if(a.x>1e-8&&a.x<r){const s=t.splitEdgeAtFraction(n,a.x);i.priorityQueue.push(s),e.numSplit++}if(a.y>1e-8&&a.y<r){const n=t.splitEdgeAtFraction(h,a.y);i.priorityQueue.push(n),e.numSplit++}}i.activeEdges.push(n)}return e}static formGraphFromSegments(t){const e=new hn;return qn.segmentArrayToGraphEdges(t,e,E.BOUNDARY_EDGE),this.splitIntersectingEdges(e),this.clusterAndMergeXYTheta(e),e}static formGraphFromChains(t,e=!0,i=E.PRIMARY_EDGE){if(t.length<1)return;const n=new hn,s=Ln.directCreateChainsFromCoordinates(n,t);for(const t of s)t.setMaskAroundFace(i);return this.splitIntersectingEdges(n),this.clusterAndMergeXYTheta(n),e&&new fn(n).regularizeGraph(!0,!0),n}}class Wn{tolerance;static _defaultPrimarySortDirection=tt.create(.294234298,.72391399,.45234328798);primarySortDirection;static createPrimarySortVector(t){return void 0===t&&(t=this._defaultPrimarySortDirection.clone()),t.normalizeWithDefault(Wn._defaultPrimarySortDirection.x,Wn._defaultPrimarySortDirection.y,Wn._defaultPrimarySortDirection.z)}constructor(t,e){this.tolerance=t,this.primarySortDirection=e}static createFromUnValidated(t){const e=new Wn(J.smallMetricDistance,Wn.createPrimarySortVector());return void 0!==t&&(void 0!==t.tolerance&&(e.tolerance=t.tolerance),void 0!==t.primarySortDirection&&(e.primarySortDirection=Wn.createPrimarySortVector())),e}clone(){return new Wn(this.tolerance,this.primarySortDirection)}}class Gn{_graph;_options;_plane;_convexClipper;constructor(t){this._graph=new hn,this._options=t}set plane(t){this._plane=t}get plane(){return this._plane}set convexClipper(t){this._convexClipper=t}get convexClipper(){return this._convexClipper}static create(t){const e=Wn.createFromUnValidated(t);return new Gn(e)}addSegment(t,e){this._graph.createEdgeXYZXYZ(t.x,t.y,t.z,0,e.x,e.y,e.z,0)}addLineSegment3dArray(t){for(const e of t)this.addSegment(e.point0Ref,e.point1Ref)}addSegmentsOnPlane(t,e=!1){if(!this._plane)return;const i=this._plane;let n,s=e?t.length-1:0,r=t.evaluateUncheckedIndexPlaneAltitude(s,i),o=e?0:1;for(;o<t.length;s=o++,r=n)n=t.evaluateUncheckedIndexPlaneAltitude(o,i),J.isSmallMetricDistance(r)&&J.isSmallMetricDistance(n)&&this._graph.createEdgeXYZXYZ(t.getXAtUncheckedPointIndex(s),t.getYAtUncheckedPointIndex(s),t.getZAtUncheckedPointIndex(s),0,t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getZAtUncheckedPointIndex(o),0)}primarySortKey(t){return this._options.primarySortDirection.dotProductXYZ(t.x,t.y,t.z)}static nodeCompareSortData(t,e){return t.sortData-e.sortData}static isIsolatedEnd(t){return t.vertexSuccessor===t}static isChainInteriorVertex(t){const e=t.vertexSuccessor;return e!==t&&e.vertexSuccessor===t}clusterAndMergeVerticesXYZ(){qn.isolateAllEdges(this._graph);for(const t of this._graph.allHalfEdges)t.sortData=this.primarySortKey(t);const t=this._graph.allHalfEdges.slice();t.sort(((t,e)=>Gn.nodeCompareSortData(t,e)));const e=this._options.tolerance,i=t.length;for(let n=0;n<i;n++){const s=t[n],r=s.sortData+e;if(Gn.isIsolatedEnd(s))for(let o=n+1;o<i;o++){const i=t[o];if(Gn.isIsolatedEnd(i)){if(i.sortData>r)break;s.distanceXYZ(i)<=e&&(ln.pinch(s,i),i.setXYZFrom(s))}}}}collectMaximalLineString3dFromStartNode(t,e,i){if(!e.isMaskSet(i)){const n=Fe.create();for(n.addPointXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,n.addPointXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&Gn.isChainInteriorVertex(e););t.push(n)}}collectMaximalGrowableXYXArrayFromStartNode(t,e,i){if(!e.isMaskSet(i)){const n=new rt;for(n.pushXYZ(e.x,e.y,e.z);e.setMask(i),e.edgeMate.setMask(i),e=e.faceSuccessor,n.pushXYZ(e.x,e.y,e.z),!e.isMaskSet(i)&&Gn.isChainInteriorVertex(e););n.length>0&&t.push(n)}}exciseAndMarkSlingEdges(t){let e=0;for(const i of this._graph.allHalfEdges)if(i.distanceXYZ(i.edgeMate)<this._options.tolerance&&!i.isMaskSet(t)){const n=i.edgeMate;ln.pinch(i,i.vertexPredecessor),ln.pinch(n,n.vertexPredecessor),i.setMask(t),n.setMask(t),e++}return e}collectMaximalChains(){const t=[],e=E.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)Gn.isChainInteriorVertex(i)||this.collectMaximalLineString3dFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalLineString3dFromStartNode(t,i,e);return t}collectMaximalGrowableXYZArrays(){const t=[],e=E.VISITED;this.exciseAndMarkSlingEdges(e),this._graph.clearMask(e);for(const i of this._graph.allHalfEdges)Gn.isChainInteriorVertex(i)||this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);for(const i of this._graph.allHalfEdges)this.collectMaximalGrowableXYXArrayFromStartNode(t,i,e);return t}}class Qn{constructor(){this._unmatchedEdges=new Map,this._graph=new hn,this._halfEdgesAroundCurrentLoop=[]}_unmatchedEdges;_graph;get graph(){return this._graph}_halfEdgesAroundCurrentLoop;indexPairToString(t,e){return`${t.toString()},${e.toString()}`}insertLoop(t,e){if(t.length>2){let i=t[t.length-1];this._halfEdgesAroundCurrentLoop.length=0;for(const n of t){const t=this.indexPairToString(i,n),s=this._unmatchedEdges.get(t);if(void 0===s){const t=this.indexPairToString(n,i),s=this._graph.createEdgeIdId(i,n);void 0!==e&&e(s),this._unmatchedEdges.set(t,s.edgeMate),this._halfEdgesAroundCurrentLoop.push(s),s.edgeMate.setMask(E.EXTERIOR)}else this._halfEdgesAroundCurrentLoop.push(s),s.clearMask(E.EXTERIOR);i=n}let n=this._halfEdgesAroundCurrentLoop[this._halfEdgesAroundCurrentLoop.length-1];for(const t of this._halfEdgesAroundCurrentLoop){const e=n.faceSuccessor;ln.pinch(t,e),n=t}return this._halfEdgesAroundCurrentLoop[0]}}}class Hn{positiveSum;numPositive;negativeSum;numNegative;numZero;largestPositiveItem;largestNegativeItem;largestPositiveValue;largestNegativeValue;negativeItemArray;zeroItemArray;positiveItemArray;constructor(t){this.positiveSum=this.negativeSum=0,this.numPositive=this.numNegative=this.numZero=0,this.largestPositiveValue=this.largestNegativeValue=0,t&&(this.negativeItemArray=[],this.positiveItemArray=[],this.zeroItemArray=[])}announceItem(t,e){e<0?(this.numNegative++,this.negativeSum+=e,this.negativeItemArray&&this.negativeItemArray.push(t),e<this.largestNegativeValue&&(this.largestNegativeValue=e,this.largestNegativeItem=t)):e>0?(this.numPositive++,this.positiveSum+=e,this.positiveItemArray&&this.positiveItemArray.push(t),e>this.largestPositiveValue&&(this.largestPositiveValue=e,this.largestPositiveItem=t)):(this.numZero++,this.zeroItemArray&&this.zeroItemArray.push(t))}}class jn{_targetMask;_targetValue;constructor(t,e=!0){this._targetMask=t,this._targetValue=e}testEdge(t){return t.isMaskSet(this._targetMask)===this._targetValue}}class Jn{static signedFaceArea(t){return t.signedFaceArea()}static collectFaceAreaSummary(t,e=!1,i=t=>Jn.signedFaceArea(t)){const n=new Hn(e);let s;s=t instanceof hn?t.collectFaceLoops():t;for(const t of s){const e=i(t);n.announceItem(t,e)}return n}static findMinimumAreaFace(t,e){return Jn.collectFaceAreaSummary(t,!1,e).largestNegativeItem}static isTriangulatedCCW(t,e=!0,i=0){let n;n=t instanceof hn?t.collectFaceLoops():t;let s=0,r=0;for(const t of n){const n=t.countEdgesAroundFace();if(n>=3)if(t.signedFaceArea()>0){if(n>3&&(r++,r>i))return!1}else if(s++,s>1&&!e)return!1}return!0}static pushAndMaskAllNodesInFace(t,e,i,n){n.push(t),t.collectAroundFace((t=>{t.setMask(e),i.push(t)}))}static parityFloodFromSeed(t,e,i,n){const s=[];if(t.isMaskSet(e))return s;const r=n|e,o=[];for(Jn.pushAndMaskAllNodesInFace(t,r,o,s);o.length>0;){const t=o.pop(),a=t.edgeMate;if(a&&!a.isMaskSet(e)){let c=t.isMaskSet(n);i&&!i.testEdge(t)||(c=!c),Jn.pushAndMaskAllNodesInFace(a,c?r:e,o,s)}}return s}static correctParityInSingleComponent(t,e){const i=Jn.findMinimumAreaFace(e);if(i)if(i.isMaskSet(t));else for(const i of e)i.isMaskSet(t)?i.clearMaskAroundFace(t):i.setMaskAroundFace(t)}static correctParityInComponentArrays(t,e){if(t!==E.NULL_MASK)for(const i of e)Jn.correctParityInSingleComponent(t,i)}static collectConnectedComponentsWithExteriorParityMasks(t,e,i=E.NULL_MASK){const n=[],s=E.VISITED,r=i|s;t.clearMask(r);for(const r of t.allHalfEdges)if(!r.isMaskSet(s)){const t=Jn.parityFloodFromSeed(r,s,e,i);n.push(t)}return Jn.correctParityInComponentArrays(i,n),n}static exploreComponent(t,e,i,n=E.EXTERIOR,s=1/0){s<=0&&(s=1/0);const r=i|n;let o=0;const a=[];for(a.push(e);0!==a.length&&o<s;){const e=a.shift();if(e.isMaskSet(r))continue;t.push(e),++o;const n=t=>{t.setMask(i);const e=t.vertexSuccessor;e.isMaskSet(r)||a.push(e)};e.collectAroundFace(n)}if(0!==a.length){const t=a[0];for(;0!==a.length;){const t=a.shift();if(t.vertexSuccessor.isMaskSet(n))return t;if(t.edgeMate.isMaskSet(n))return t}return t}}static collectConnectedComponents(t,e=1/0,i=E.EXTERIOR){const n=[];0===t.countMask(i)&&(i=E.NULL_MASK);const s=E.VISITED,r=s|i,o=e=>{for(let i=e;i<t.countNodes();++i)if(!t.allHalfEdges[i].isMaskSet(r)&&t.allHalfEdges[i].edgeMate.isMaskSet(r)){e=i;break}return e};for(let a=0;a<t.countNodes();++a){if(t.allHalfEdges[a].isMaskSet(r))continue;const c=o(a);let l=t.allHalfEdges[c];do{const t=[];l=Jn.exploreComponent(t,l,s,i,e),0!==t.length&&n.push(t)}while(void 0!==l);t.allHalfEdges[a].isMaskSet(s)||--a}return n}static pointInOrOnFaceXY(t,e,i){const n=new Nt(e,i);let s=t,r=t.faceSuccessor;for(;!n.tryStartEdge(s.x,s.y,r.x,r.y);s=r){if(r===t)return gt.createXX(r.x,r.faceSuccessor.x).containsX(e)?0:-1;r=s.faceSuccessor}let o=r.faceSuccessor;for(;;){if(!n.advance(o.x,o.y))return n.classifyCounts();if(o===r)break;o=o.faceSuccessor}return n.classifyCounts()}static collectExtendedBoundaryLoopFromSeed(t,e,i,n){let s=0;for(;!t.getMask(e)&&i(t);){n(t,s++),t.setMask(e);const r=t.faceSuccessor;let o=r;for(;;){if(o.getMask(e))return;if(i(o)){t=o;break}if(o=o.vertexPredecessor,o===r)break}}}static collectExtendedBoundaryLoopsInGraph(t,e){const i=[],n=t.grabMask(!0),s=t=>0===t.getMask(e)&&0!==t.edgeMate.getMask(e),r=(t,e)=>{0===e&&i.push([]),i[i.length-1].push(t)};for(const e of t.allHalfEdges)this.collectExtendedBoundaryLoopFromSeed(e,n,s,r);return t.dropMask(n),i}}class Kn{static spaceTriangleAspectRatio(t,e,i){const n=.5*t.crossProductToPoints(e,i).magnitude(),s=t.distanceSquared(e)+e.distanceSquared(i)+i.distanceSquared(t);return J.safeDivideFraction(n,s,0)}static spaceQuadDiagonalAspectRatio(t,e,i,n){const s=this.spaceTriangleAspectRatio(t,e,i),r=this.spaceTriangleAspectRatio(t,i,n);return Math.max(s,r)}static triangulateGreedyEarCut(t,e){const i=zr.areaNormal(t),n=[],s=t.slice();for(Ci.removeClosurePoint(s);s.length>2;){let t,e=-1,r=0,o=s.length-2,a=s.length-1;for(t=0;t<s.length;o=a,a=t,t++){const n=this.spaceTriangleAspectRatio(s[o],s[a],s[t]);s[o].crossProductToPoints(s[a],s[t]).dotProduct(i)>0&&n>e&&(e=n,r=o)}if(e<=0)return!1;o=r,a=(o+1)%s.length,t=(a+1)%s.length;const c=[];c.push(s[o],s[a],s[t]),s.splice(a,1),n.push(c)}return e(t,n),!0}static triangulateSimplestSpaceLoopGo(t,e,i){const n=fe.countNonDuplicates(t);if(void 0!==i&&fe.sumEdgeLengths(t,!0,n)>i)return!1;if(n<3)return!1;if(3===n)return 0!==this.spaceTriangleAspectRatio(t[0],t[1],t[2])&&(e(t,[t.slice()]),!0);if(4===n){const i=this.spaceQuadDiagonalAspectRatio(t[0],t[1],t[2],t[3]),n=this.spaceQuadDiagonalAspectRatio(t[1],t[2],t[3],t[0]);return!(0===i&&0===n||(i>n?(e(t,[[t[0],t[1],t[2]],[t[2],t[3],t[0]]]),0):(e(t,[[t[0],t[1],t[3]],[t[3],t[1],t[2]]]),0)))}return this.triangulateGreedyEarCut(t,e)}static triangulateSimplestSpaceLoop(t,e,i){return t instanceof Fe?this.triangulateSimplestSpaceLoopGo(t.points,e,i):this.triangulateSimplestSpaceLoopGo(t,e,i)}}class $n{_facetIndex;_detail;_normal;_param;_color;constructor(t=-1,e){this._facetIndex=t,this._detail=e||rn.create()}invalidate(t=!0){this._facetIndex=-1,t&&this._detail.invalidate(),this._normal=void 0,this._param=void 0,this._color=void 0}static create(t=-1,e,i){return i?i.invalidate(!1):i=new $n,i._facetIndex=t,void 0!==e&&i._detail!==e&&i._detail.copyContentsFrom(e),i}static createCapture(t,e){return new $n(t,e)}get facetIndex(){return this._facetIndex}get edgeCount(){return 3}get point(){return this._detail.world}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!0}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.classify}clone(){const t=new $n;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._detail.copyContentsFrom(t._detail),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color}getNormal(t){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){this._normal=tt.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._normal)}return this._normal}getParam(t){if(this._detail.isValid&&void 0===this._param&&void 0!==t){this._param=H.create();const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];t.linearCombination(e,this._param)}return this._param}getColor(t){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const e=[this._detail.local.x,this._detail.local.y,this._detail.local.z];this._color=ue.linearCombinationOfColors(t,e)}return this._color}getBarycentricCoordinates(){return[this._detail.local.x,this._detail.local.y,this._detail.local.z]}}class ts{_facetIndex;_edgeCount;_detail;constructor(t=-1,e=0,i){this._facetIndex=t,this._edgeCount=e,this._detail=i||Or.create()}invalidate(t=!0){this._facetIndex=-1,this._edgeCount=0,t&&this._detail.invalidate()}static create(t=-1,e=0,i,n){return n?n.invalidate(!1):n=new ts,n._facetIndex=t,n._edgeCount=e,void 0!==i&&n._detail!==i&&n._detail.copyContentsFrom(i),n}static createCapture(t,e,i){return new ts(t,e,i)}get facetIndex(){return this._facetIndex}get edgeCount(){return this._edgeCount}get point(){return this._detail.point}get a(){return this._detail.a}get closestEdge(){return{startVertexIndex:this._detail.closestEdgeIndex,edgeParam:this._detail.closestEdgeParam}}get _isValid(){return this._facetIndex>=0&&this._edgeCount>=3}get isValid(){return this._isValid&&this._detail.isValid}get isConvex(){return!1}get isInsideOrOn(){return this._isValid&&this._detail.isInsideOrOn}get classify(){return this._detail.code}clone(){const t=new ts;return t.copyContentsFrom(this),t}copyContentsFrom(t){this._facetIndex=t._facetIndex,this._edgeCount=t._edgeCount,this._detail.copyContentsFrom(t._detail)}getNormal(){}getParam(){}getColor(){}getBarycentricCoordinates(){}}class es extends ts{_normal;_param;_color;_barycentricCoordinates;constructor(t=-1,e=0,i){super(t,e,i)}invalidate(t=!0){super.invalidate(t),this._normal=void 0,this._param=void 0,this._color=void 0,this._barycentricCoordinates=void 0}static create(t=-1,e=0,i,n){return n?n.invalidate(!1):n=new es,super.create(t,e,i,n)}static createCapture(t,e,i){return new es(t,e,i)}get isConvex(){return!0}clone(){const t=new es;return t.copyContentsFrom(this),t}copyContentsFrom(t){super.copyContentsFrom(t),this._normal=t._normal?.clone(),this._param=t._param?.clone(),this._color=t._color,this._barycentricCoordinates=t._barycentricCoordinates?.slice()}getNormal(t,e,i=J.smallMetricDistance){if(this._detail.isValid&&void 0===this._normal&&void 0!==t){const n=this.getBarycentricCoordinates(e,i);void 0!==n&&(this._normal=tt.create(),t.linearCombination(n,this._normal))}return this._normal}getParam(t,e,i=J.smallMetricDistance){if(this._detail.isValid&&void 0===this._param&&void 0!==t){const n=this.getBarycentricCoordinates(e,i);void 0!==n&&(this._param=H.create(),t.linearCombination(n,this._param))}return this._param}getColor(t,e,i=J.smallMetricDistance){if(this._detail.isValid&&void 0===this._color&&void 0!==t){const n=this.getBarycentricCoordinates(e,i);void 0!==n&&(this._color=ue.linearCombinationOfColors(t,n))}return this._color}getBarycentricCoordinates(t,e=J.smallMetricDistance){return this._detail.isValid&&void 0===this._barycentricCoordinates&&void 0!==t&&(this._barycentricCoordinates=zr.convexBarycentricCoordinates(t,this._detail.point,e)),this._barycentricCoordinates}}class is{_v;_a;constructor(t,e,i){this._v=[t,e],this._a=i}clone(){return new is(this._v[0],this._v[1],this._a)}get startVertex(){return this._v[0]}get endVertex(){return this._v[1]}get facetIndex(){return this._a}get isLowHigh(){return this._v[0]<this._v[1]}get lowVertex(){return this.isLowHigh?this._v[0]:this._v[1]}get highVertex(){return this.isLowHigh?this._v[1]:this._v[0]}static areSameEdge(t,e){return t._v[0]===e._v[0]&&t._v[1]===e._v[1]}static areDirectedPartners(t,e){return t._v[0]===e._v[1]&&t._v[1]===e._v[0]}static areUndirectedPartners(t,e){return this.areSameEdge(t,e)||this.areDirectedPartners(t,e)}static relativeOrientation(t,e){return this.areSameEdge(t,e)?1:this.areDirectedPartners(t,e)?-1:0}get isNullEdge(){return this._v[0]===this._v[1]}static lessThan(t,e){const i=t.lowVertex,n=e.lowVertex;if(i<n)return-1;if(n<i)return 1;const s=t.highVertex,r=e.highVertex;return s<r?-1:r<s?1:t.startVertex-e.startVertex}toJSON(){return[this._v[0],this._v[1],this._a]}static clusterToJSON(t){if(t instanceof is)return t.toJSON();const e=[];for(const i of t)e.push(i.toJSON())}static clusterArrayToJSON(t){const e=[];for(const i of t)e.push(is.clusterToJSON(i));return e}}class ns{edges;constructor(){this.edges=[]}addEdge(t,e,i){const n=new is(t,e,i);return this.edges.push(n),n}addPath(t,e,i){if(0===t.length)return;const n=t.length-1;for(let i=0;i<n;i++)this.addEdge(t[i],t[i+1],e);i&&this.addEdge(t[n],t[0],e)}sort(){this.edges.sort(((t,e)=>is.lessThan(t,e)))}collectSortableEdgeCluster(t,e,i){if(void 0!==i&&e>t)if(e===t+1)i.push(this.edges[t]);else{const n=[];for(let i=t;i<e;i++)n.push(this.edges[i]);i.push(n)}}sortAndCollectClusters(t,e,i,n){this.sort(),t&&(t.length=0),e&&(e.length=0),i&&(i.length=0),n&&(n.length=0);const s=this.edges.length;let r;for(let o=0;o<s;o+=r){const a=this.edges[o];r=1;for(let t=o+1;t<s&&is.areUndirectedPartners(a,this.edges[t]);t++)r++;this.edges[o].isNullEdge?this.collectSortableEdgeCluster(o,o+r,i):2===r&&is.areDirectedPartners(a,this.edges[o+1])?this.collectSortableEdgeCluster(o,o+r,t):1===r?this.collectSortableEdgeCluster(o,o+1,e):this.collectSortableEdgeCluster(o,o+r,n)}}}class ss{numPositive;numNegative;firstEdgeIndex;constructor(t){this.numPositive=this.numNegative=0,this.firstEdgeIndex=t}recordOrientation(t){t>0?this.numPositive++:t<0&&this.numNegative++}}class rs{_edges;_edgeToPartnerEdge;_edgeToEdgeInComponent;_facetToFirstEdgeInComponent;_facetOrientation;_components;_visitor;_mesh;constructor(t){this._visitor=t.createVisitor(1),this._edges=bs.createIndexedEdges(this._visitor),this._edgeToPartnerEdge=[],this._edgeToEdgeInComponent=[],this._facetToFirstEdgeInComponent=[],this._facetOrientation=[],this._components=[],this._mesh=t}edgeIdToFacetOrientation(t){const e=this._edges.edges[t].facetIndex;return this._facetOrientation[e]}setupUnoriented(){this._edges.sort();const t=this._edges.edges;let e=-1;const i=this._edges.edges.length;for(let t=0;t<i;t++){const i=this._edges.edges[t].facetIndex;i>e&&(e=i),this._edgeToEdgeInComponent.push(t),this._edgeToPartnerEdge.push(t)}for(let t=0;t<=e;t++)this._facetToFirstEdgeInComponent.push(-1),this._facetOrientation.push(0);for(let t=0;t<i;t++){const e=this._edges.edges[t].facetIndex,i=this._facetToFirstEdgeInComponent[e];-1===i?this._facetToFirstEdgeInComponent[e]=t:rs.swapEntries(this._edgeToEdgeInComponent,t,i)}for(let e=0;e<i;e++){let n=e+1;for(;n<i&&is.areUndirectedPartners(t[e],t[n]);)rs.swapEntries(this._edgeToPartnerEdge,e,n),n++;if(n>e+2)return!1}return!0}recordFacetInComponent(t,e){const i=this._components[this._components.length-1];this._facetOrientation[t]=e,i.recordOrientation(e)}initializeComponent(t){const e=this._edges.edges[t].facetIndex;this._components.push(new ss(t)),this.recordFacetInComponent(e,1)}_workArray=[];pushFacetEdgesOnStack(t,e){rs.extractCyclicIndices(this._edgeToEdgeInComponent,t,this._workArray);for(const t of this._workArray)e.push(t)}doFlood(){const t=[],e=this._edges.edges,i=e.length,n=[];for(let s=0;s<i;s++)if(0===this.edgeIdToFacetOrientation(s)){let i;for(t.length=0,this.initializeComponent(s),this.pushFacetEdgesOnStack(s,t);void 0!==(i=t.pop());){const s=e[i].facetIndex,r=this._facetOrientation[s];rs.extractCyclicIndices(this._edgeToPartnerEdge,i,n);for(const s of n)if(s!==i){const n=e[s].facetIndex,o=this._facetOrientation[n];if(0===o){const o=is.areDirectedPartners(e[i],e[s])?r:-r;this.recordFacetInComponent(n,o),this.pushFacetEdgesOnStack(s,t),rs.swapEntries(this._edgeToEdgeInComponent,i,s)}else if(is.relativeOrientation(e[i],e[s])*r*o>0)return!1}}}return!0}doFacetReversals(){let t=0;for(this._visitor.reset();this._visitor.moveToNextFacet();){const e=this._visitor.currentReadIndex();this._facetOrientation[e]<0&&(t++,this._mesh.reverseSingleFacet(e))}return t}static doFixup(t){const e=new rs(t);if(!e.setupUnoriented())return!1;const i=e.doFlood();return i&&e.doFacetReversals(),i}static swapEntries(t,e,i){const n=t[e];t[e]=t[i],t[i]=n}static extractCyclicIndices(t,e,i){i.length=0;let n=e;do{i.push(n),n=t[n]}while(n!==e)}}class os{constructor(t,e,i){this.index=t,this.area=e,this.normal=i}index;area;normal;addWeightedNormal(t,e){this.area+=t,this.normal.addScaledInPlace(e,t)}divideNormalByArea(){this.normal.scaleInPlace(1/this.area)}}class as{constructor(t,e,i){this.facetData=t,this.sectorClusterData=void 0,this.sectorIndex=e,this.vertexIndex=i}facetData;sectorIndex;vertexIndex;sectorClusterData;static cbSectorSort(t,e){return t.sectorIndex-e.sectorIndex}static cbVertexSort(t,e){return t.vertexIndex-e.vertexIndex}static pushToArray(t,e,i,n){t.push(new as(e,i,n))}}class cs{static buildFastAverageNormals(t,e){const i=t.createVisitor(0),n=tt.create(0,0,1),s=J.smallMetricDistanceSquared,r=[];let o=0,a=0;for(;i.moveToNextFacet();){let t=zr.areaNormalGo(i.point),e=0;t?(e=t.magnitude(),e<s?(t.setFromVector3d(n),e=0):t.scaleInPlace(1/e)):(t=n.clone(),e=0);const c=new os(o++,e,t);for(let t=0;t<i.pointCount;t++)as.pushToArray(r,c,a++,i.clientPointIndex(t))}r.sort(((t,e)=>as.cbVertexSort(t,e)));const c=[];let l=e.radians;l<1e-4&&(l=1e-4);let h=0;for(let t=0;t<r.length;t++){const e=r[t],i=e.vertexIndex,n=e.facetData;if(void 0===e.sectorClusterData){const s=new os(h++,0,tt.createZero());c.push(s),s.addWeightedNormal(1,e.facetData.normal);for(let e=t;e<r.length;e++){const t=r[e];if(t.vertexIndex!==i)break;t.facetData.normal.angleTo(n.normal).radians>l||void 0===t.sectorClusterData&&(s.addWeightedNormal(1,t.facetData.normal),t.sectorClusterData=s)}}}r.sort(((t,e)=>as.cbSectorSort(t,e))),t.data.normalIndex=[],t.data.normal=new rt(r.length);for(const e of c)e.divideNormalByArea(),e.index=t.data.normal.length,t.data.normal.push(e.normal);for(const e of r)t.data.normalIndex.push(e.sectorClusterData.index)}static buildPerFaceNormals(t){const e=t.createVisitor(0),i=tt.create(0,0,1),n=tt.create(0,0,1),s=new rt(t.faceCount),r=[];for(;e.moveToNextFacet();){const t=s.length;zr.unitNormal(e.point,i)?s.push(i):s.push(n);for(let i=0;i<e.pointCount;i++)r.push(t)}t.data.normalIndex=r,t.data.normal=s}}function ls(t){return void 0!==t&&t}class hs{constructor(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal=tt.create(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}clear(){this.numActiveSectors=0,this.numInactiveSectors=0,this.averageNormal.setZero(),this.radiansSum=0,this.maxDeviationRadiansFromAverage=0}numActiveSectors;numInactiveSectors;averageNormal;maxDeviationRadiansFromAverage;radiansSum;accumulateNormal(t,e,i){if(t.isMaskSet(i))this.numInactiveSectors++;else{const i=ln.sectorSweepRadiansXYZ(t,e);this.averageNormal.addScaledInPlace(e,i),this.radiansSum+=i,this.numActiveSectors++}}finishNormalAveraging(){return!!(this.numActiveSectors>0&&this.averageNormal.normalizeInPlace())}recordDeviation(t,e){if(e){const e=this.averageNormal.radiansTo(t);this.maxDeviationRadiansFromAverage=Math.max(Math.abs(this.maxDeviationRadiansFromAverage),e)}}get maxDeviationRadians(){return this.maxDeviationRadiansFromAverage}}function ds(t){void 0!==gs.stringDebugFunction&&(gs.stringDebugFunction(`    Sector xyz    ${t.xyz.x},${t.xyz.y},${t.xyz.z} `),gs.stringDebugFunction(`           normal ${t.normal.x},${t.normal.y},${t.normal.z} `))}class us{constructor(t,e){this.facetIndex=t,this.facetNormal=e}facetIndex;facetNormal}class fs{constructor(t,e){this.xyz=e,this.normal=t,this.count=0}normal;xyz;count;static edgeHasLargeExteriorAngleBetweenNormals(t,e,i,n,s=.5*Math.PI){const r=t.edgeTag,o=t.edgeMate.edgeTag;if(void 0!==r&&void 0!==o){t.vectorToFaceSuccessor(e);const a=r.normal.signedRadiansTo(o.normal,e);if(J.split3WaySign(n,-1,1,1)*a>=s&&(tt.createAdd2Scaled(r.normal,1,o.normal,1,i),i.normalizeInPlace()))return!0}return!1}static almostEqualNormals(t,e,i=J.smallAngleRadians){return t.normal.radiansTo(e.normal)<=i}static radiansBetweenNormals(t,e){return t.normal.radiansTo(e.normal)}setOffsetPointAtDistanceAtHalfEdge(t,e){t.getPoint3d(this.xyz),this.xyz.addScaledInPlace(this.normal,e)}static setXYZAtHalfEdge(t,e){const i=t.edgeTag;void 0!==i&&void 0!==e&&i.xyz.set(e.x,e.y,e.z)}setXYAndZ(t){this.xyz.set(t.x,t.y,t.z)}static setNormalAtHalfEdge(t,e,i){const n=t.edgeTag;void 0!==n&&(n.normal.set(e.x,e.y,e.z),void 0!==i&&n.setOffsetPointAtDistanceAtHalfEdge(t,i))}static sweepRadiansAroundNormal(t,e){const i=t.edgeTag,n=t.vertexSuccessor.edgeTag;if(void 0!==i&&void 0!==n)return i.normal.planarRadiansTo(n.normal,e)}static getSectorPointAtHalfEdge(t,e,i){const n=t.edgeTag;return void 0!==n&&(void 0!==e&&e.setFromPoint3d(n.xyz),void 0!==i&&i.push(n.xyz),!0)}static pushXYZ(t,e){const i=e.edgeTag;return void 0!==i&&t.push(i.xyz),i}static accumulateScaledNormalAtHalfEdge(t,e,i){const n=t.edgeTag;void 0!==n&&i.addScaledInPlace(n.normal,e)}}class gs{constructor(t,e,i){this._basePolyface=t,this._baseGraph=e,this._breakMaskA=e.grabMask(),this._breakMaskB=e.grabMask(),this._insideOfChamferFace=e.grabMask(),this._outsideOfChamferFace=e.grabMask(),this._insideChamferSling=e.grabMask(),this._outsideEndOfChamferFace=e.grabMask(),this._exteriorMask=E.EXTERIOR,this._offsetCoordinatesReassigned=e.grabMask(),this._smoothRadiansBetweenNormals=i.smoothSingleAngleBetweenNormals.radians,this._chamferTurnRadians=i.chamferAngleBetweenNormals.radians,this._smoothAccumulatedRadiansBetweenNormals=i.smoothAccumulatedAngleBetweenNormals.radians}_basePolyface;_baseGraph;get exteriorMask(){return this._exteriorMask}_exteriorMask;_offsetCoordinatesReassigned;get breakMaskA(){return this._breakMaskA}_breakMaskA;get breakMaskB(){return this._breakMaskB}_breakMaskB;get insideOfChamferFace(){return this._insideOfChamferFace}_insideOfChamferFace;get outsideOfChamferFace(){return this._outsideOfChamferFace}_outsideOfChamferFace;get insideChamferSling(){return this._insideChamferSling}_insideChamferSling;get outsideEndOfChamferFace(){return this._outsideEndOfChamferFace}_outsideEndOfChamferFace;_smoothRadiansBetweenNormals;_smoothAccumulatedRadiansBetweenNormals;_chamferTurnRadians;static graphDebugFunction;static stringDebugFunction;applyFaceNormalOffsetsToSectorData(t){this._baseGraph.announceNodes(((e,i)=>{const n=i.edgeTag;return void 0!==n&&n.setOffsetPointAtDistanceAtHalfEdge(i,t),!0}))}static buildOffsetMeshWithEdgeChamfers(t,e,i,n){const s=this.buildBaseGraph(t);if(void 0!==s){const r=new gs(t,s,n);r.applyFaceNormalOffsetsToSectorData(i),void 0!==gs.graphDebugFunction&&gs.graphDebugFunction("BaseGraph",s,r._breakMaskA,r._breakMaskB);const o=n.outputSelector?n.outputSelector:{outputOffsetsFromFaces:!0,outputOffsetsFromEdges:!0,outputOffsetsFromVertices:!0};ls(o.outputOffsetsFromFacesBeforeChamfers)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),r.addChamferTopologyToAllEdges(n,i),r.computeOffsetFacetIntersections(i),void 0!==gs.graphDebugFunction&&gs.graphDebugFunction("after computeEdgeChamfers",s,r._breakMaskA,r._breakMaskB),ls(o.outputOffsetsFromFaces)&&r.announceFacetsWithSectorCoordinatesAroundFaces(e),ls(o.outputOffsetsFromEdges)&&r.announceFacetsWithSectorCoordinatesAroundEdges(e),ls(o.outputOffsetsFromVertices)&&r.announceFacetsWithSectorCoordinatesAroundVertices(e)}}announceSimpleOffsetFromFaces(t,e){const i=new rt,n=$.create(),s=tt.create(),r=t=>(t.getPoint3d(n),n.addInPlace(s),i.push(n),0);this._baseGraph.announceFaceLoops(((n,o)=>{if(!o.isMaskSet(E.EXTERIOR)){const n=o.faceTag;s.setFromVector3d(n.facetNormal.direction),s.scaleInPlace(e),i.length=0,o.sumAroundFace(r),t.addPolygonGrowableXYZArray(i)}return!0}))}announceFacetsWithSectorCoordinatesAroundFaces(t){const e=new rt,i=t=>{const i=t.edgeTag;return void 0!==i&&e.push(i.xyz),0};this._baseGraph.announceFaceLoops(((n,s)=>(s.isMaskSet(E.EXTERIOR)||(e.length=0,s.sumAroundFace(i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}countBits(t){let e=0,i=t;for(;0!==i;)1&i&&e++,i>>=1;return e}announceFacetsWithSectorCoordinatesAroundEdges(t){const e=new rt,i=J.smallMetricDistance,n=this._exteriorMask|this._outsideEndOfChamferFace|this._outsideOfChamferFace|this._insideOfChamferFace|this._insideChamferSling;this._baseGraph.announceEdges(((s,r)=>{if(void 0!==r.findMaskAroundEdge(this._exteriorMask))return!0;if(r.isMaskSet(n))return!0;{const s=r.faceSuccessor,o=r.edgeMate;if(!o.isMaskSet(n)){const n=o.faceSuccessor;e.clear(),fs.getSectorPointAtHalfEdge(r,void 0,e),fs.getSectorPointAtHalfEdge(s,void 0,e),fs.getSectorPointAtHalfEdge(o,void 0,e),fs.getSectorPointAtHalfEdge(n,void 0,e),Ai.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)}}return!0}))}getCoordinateString(t,e=!0,i=!1){return e?i?`${ln.nodeToIdXYZString(t)} ==> ${ln.nodeToIdXYZString(t.faceSuccessor)}`:`${ln.nodeToIdXYZString(t)}`:i?`==> ${ln.nodeToIdXYZString(t.faceSuccessor)}`:""}inspectMasks(t,e=!0,i=!1){return"[".concat(t.id.toString(),t.isMaskSet(this._exteriorMask)?"X":"",t.isMaskSet(this.breakMaskA)?"A":"",t.isMaskSet(this.breakMaskB)?"B":"",t.isMaskSet(this.insideChamferSling)?"(sling)":"",t.isMaskSet(this.insideOfChamferFace)?"(in chamfer)":"",t.isMaskSet(this.outsideEndOfChamferFace)?"(@sling)":"",t.isMaskSet(this.outsideOfChamferFace)?"(@chamfer)":"",this.getCoordinateString(t,e,i),"]")}announceFacetsWithSectorCoordinatesAroundVertices(t){const e=new rt,i=J.smallMetricDistance;this._baseGraph.announceVertexLoops(((n,s)=>(s.findMaskAroundVertex(this._exteriorMask)||(e.length=0,s.sumAroundVertex((t=>(t.isMaskSet(this._insideChamferSling)||fs.getSectorPointAtHalfEdge(t,void 0,e),0))),Ai.compressInPlaceByShortEdgeLength(e,i),e.length>2&&t.addPolygonGrowableXYZArray(e)),!0)))}static buildBaseGraph(t){const e=new Qn,i=t.createVisitor(),n=$.create(),s=$.create();for(i.reset();i.moveToNextFacet();){const r=zr.centroidAreaNormal(i.point);if(void 0!==r){const o=e.insertLoop(i.pointIndex,(e=>{const i=e.edgeMate;t.data.getPoint(e.i,n),e.setXYZ(n),t.data.getPoint(i.i,s),i.setXYZ(s)})),a=new us(i.currentReadIndex(),r);void 0!==o&&o.sumAroundFace((t=>(t.faceTag=a,t.edgeTag=new fs(r.direction.clone(),t.getPoint3d()),0)))}}return e.graph}setOffsetAtDistanceAroundVertex(t,e,i=!1){t.sumAroundVertex((n=>{const s=n.edgeTag;return void 0!==s&&(i&&this.isInsideChamferOrSling(t)||s.setOffsetPointAtDistanceAtHalfEdge(n,e)),0}))}setOffsetXYAndZAroundVertex(t,e){t.sumAroundVertex((t=>{const i=t.edgeTag;return void 0!==i&&(i.setXYAndZ(e),t.setMask(this._offsetCoordinatesReassigned)),0}))}announceNodeAndSectorPropertiesInSmoothSector(t,e){let i=0;for(let n=t;;n=n.vertexSuccessor){const s=n.edgeTag;if(void 0!==s&&(e(n,s),i++),n.isMaskSet(this._breakMaskB))return i;if(n.isMaskSet(this._exteriorMask))return i;if(n===t&&0===i)return i}}computeAverageNormalAndMaxDeviationAroundVertex(t,e){e.clear();const i=this._exteriorMask|this._insideChamferSling;if(t.sumAroundVertex((t=>{const n=t.edgeTag;return n&&e.accumulateNormal(t,n.normal,i),0})),e.finishNormalAveraging())return t.sumAroundVertex((t=>{const n=t.edgeTag;return n&&e.recordDeviation(n.normal,!t.isMaskSet(i)),0})),e.maxDeviationRadians}assignOffsetByAverageNormalAroundVertex(t,e,i,n){const s=this.computeAverageNormalAndMaxDeviationAroundVertex(t,i);return gs.stringDebugFunction&&(gs.stringDebugFunction(`XYZ ${ln.nodeToIdXYZString(t)} Average Normal ${JSON.stringify(i.averageNormal.toJSON())}`),gs.stringDebugFunction(`           angle ratio ${i.radiansSum/(2*Math.PI)}   maxDeviation ${i.maxDeviationRadiansFromAverage}`)),void 0!==s&&s<=e&&(t.sumAroundVertex((t=>(fs.setNormalAtHalfEdge(t,i.averageNormal,n),0))),!0)}markBreakEdgesAndSaveAverageNormalsAroundVertex(t){t.clearMaskAroundVertex(this._breakMaskA),t.clearMaskAroundVertex(this._breakMaskB);const e=this._smoothRadiansBetweenNormals,i=this._smoothAccumulatedRadiansBetweenNormals;let n=0,s=t,r=0;do{const t=s.edgeMate,i=t.faceSuccessor;s.isMaskSet(this._exteriorMask)?t.isMaskSet(this._exteriorMask)||(i.setMask(this._breakMaskB),n++):s.isMaskSet(this._outsideOfChamferFace)?s.setMask(this._breakMaskA):s.isMaskSet(this._outsideEndOfChamferFace)?(s.setMask(this._breakMaskA),s.setMask(this._breakMaskB)):s.isMaskSet(this._insideChamferSling)||(s.isMaskSet(this._insideOfChamferFace)?(s.setMask(this._breakMaskA),s.setMask(this._breakMaskB),i.setMask(this._breakMaskB)):t.isMaskSet(this._exteriorMask)?(n++,s.setMask(this._breakMaskA)):fs.almostEqualNormals(s.edgeTag,i.edgeTag,e)?r++:(s.setMask(this._breakMaskA),n++,i.setMask(this._breakMaskB))),s=s.vertexSuccessor}while(s!==t);void 0!==gs.stringDebugFunction&&gs.stringDebugFunction(`   numSkip   ${r} `),0===n&&(t.setMask(this._breakMaskA),t.vertexPredecessor.setMask(this._breakMaskB),n=1);const o=s.findMaskAroundVertex(this._breakMaskA);if(void 0!==o){s=o;do{if(s.isMaskSet(this._breakMaskA)&&!s.isMaskSet(this._breakMaskB)){let t=0;do{const e=s.vertexSuccessor;t+=fs.radiansBetweenNormals(s.edgeTag,e.edgeTag),t>i&&(s.setMask(this._breakMaskB),e.setMask(this._breakMaskA),n++,t=0),s=e}while(!s.isMaskSet(this._breakMaskB))}else s=s.vertexSuccessor}while(s!==o)}if(n>0&&void 0!==o){s=o;const t=tt.create(),e=tt.create(),i=tt.create();t.setZero();do{if(s.isMaskSet(this._breakMaskA)&&!s.isMaskSet(this._breakMaskB)){let n=s;for(t.setZero();;){n.vectorToFaceSuccessor(e),n.vectorToFacePredecessor(i);let s=e.signedRadiansTo(i,n.faceTag.facetNormal.direction);if(s<0&&(s+=2*Math.PI),fs.accumulateScaledNormalAtHalfEdge(n,s,t),n.isMaskSet(this._breakMaskB))break;n=n.vertexSuccessor}if(t.normalizeInPlace())for(n=s;fs.setNormalAtHalfEdge(n,t),!n.isMaskSet(this._breakMaskB);)n=n.vertexSuccessor}s=s.vertexSuccessor}while(s!==o)}}compute3SectorIntersection(t,e,i,n){const s=t.edgeTag,r=e.edgeTag,o=i.edgeTag;return Ft.intersect3Planes(s.xyz,s.normal,r.xyz,r.normal,o.xyz,o.normal,n)}compute3SectorIntersectionDebug(t,e,i,n){const s=t.edgeTag,r=e.edgeTag,o=i.edgeTag;if(void 0!==gs.stringDebugFunction){gs.stringDebugFunction(`compute3${this.inspectMasks(t)}${this.inspectMasks(e)}${this.inspectMasks(i)} `);for(const t of[s,r,o])ds(t)}const a=Ft.intersect3Planes(s.xyz,s.normal,r.xyz,r.normal,o.xyz,o.normal,n);return void 0!==gs.stringDebugFunction&&(void 0===a?gs.stringDebugFunction(" NO INTERSECTION"):gs.stringDebugFunction(` ComputedVector ${a.x},${a.y},${a.z} `)),a}compute2SectorIntersection(t,e,i){const n=t.edgeTag,s=e.edgeTag,r=n.normal.crossProduct(s.normal);return Ft.intersect3Planes(n.xyz,n.normal,s.xyz,s.normal,s.xyz,r,i)}addChamferTopologyToAllEdges(t,e){const i=[],n=t.chamferAngleBetweenNormals.radians,s=$.create(),r=tt.create(),o=tt.create(),a=tt.create();this._baseGraph.announceEdges(((t,s)=>!fs.edgeHasLargeExteriorAngleBetweenNormals(s,r,a,e,n)||(i.push(s),!0)));for(const t of i)if(fs.edgeHasLargeExteriorAngleBetweenNormals(t,r,a,n)){const i=this._baseGraph.splitEdgeCreateSliverFace(t),n=i.facePredecessor,c=i.getPoint3d();c.addScaledInPlace(a,e);const l=Rt.createCapture(c,a.clone()),h=new us(-1,l);let d=-1;for(const t of[i,n]){r.scale(d,o),t.getPoint3d(s),t.setMask(this._insideOfChamferFace),t.edgeMate.setMask(this._outsideOfChamferFace),t.faceTag=h;const e=this._baseGraph.splitEdge(void 0,s.x,s.y,s.z,t.i),i=e.edgeMate;e.setMask(this._outsideEndOfChamferFace),e.faceTag=h,i.setMask(this._insideChamferSling),ln.pinch(t,e);const n=Rt.create(s,o),l=new us(-1,n);i.faceTag=l,t.edgeTag=new fs(a.clone(),c.clone()),e.edgeTag=new fs(a.clone(),c.clone()),i.edgeTag=new fs(o.clone(),s.clone());const u=this.compute3SectorIntersection(t,t.edgeMate,i),f=this.compute3SectorIntersection(e,e.vertexSuccessor,i);fs.setXYZAtHalfEdge(t,u),fs.setXYZAtHalfEdge(e,f),d*=-1}}}computeOffsetFacetIntersections(t){void 0!==gs.stringDebugFunction&&gs.stringDebugFunction("*****                                 recompute intersections");const e=[],i=$.create(),n=$.create(),s=2*t,r=new hs,o=G.degreesToRadians(25);this._baseGraph.announceVertexLoops(((a,c)=>{let l=c.findMaskAroundVertex(this._outsideEndOfChamferFace);if(void 0===l&&(l=c.findMaskAroundVertex(this._breakMaskA)),void 0===l&&(l=c),void 0!==gs.stringDebugFunction&&(gs.stringDebugFunction(""),gs.stringDebugFunction(` VERTEX LOOP   ${JSON.stringify(l.getPoint3d().toJSON())} `),l.sumAroundVertex((t=>(gs.stringDebugFunction(this.inspectMasks(t,!1,!0)),0)))),this.assignOffsetByAverageNormalAroundVertex(l,o,r,t))return!0;if(this.markBreakEdgesAndSaveAverageNormalsAroundVertex(l),this.setOffsetAtDistanceAroundVertex(l,t,!0),l.collectMaskedEdgesAroundVertex(this._breakMaskA,!0,e),void 0!==gs.stringDebugFunction){gs.stringDebugFunction(` BREAK EDGES from ${this.inspectMasks(l,!0,!1)}`);for(const t of e)gs.stringDebugFunction(this.inspectMasks(t,!1,!0))}if(e.length<=1);else if(2===e.length){const t=this.compute2SectorIntersection(e[0],e[1]);void 0!==t&&this.setOffsetXYAndZAroundVertex(l,t)}else if(3===e.length){void 0!==gs.stringDebugFunction&&gs.stringDebugFunction(` Vertex Update just ${e.length} `);const t=this.compute3SectorIntersection(e[0],e[1],e[2]);void 0!==t&&this.setOffsetXYAndZAroundVertex(l,t)}else{void 0!==gs.stringDebugFunction&&gs.stringDebugFunction(` Vertex Update breakEdges ${e.length} `),l.getPoint3d(i);for(let t=0;t<e.length;t++){const i=t,n=(i+1)%e.length,s=(n+1)%e.length;if(e[i].isMaskSet(this._outsideEndOfChamferFace)&&e[n].isMaskSet(this._outsideOfChamferFace)&&e[s].isMaskSet(this._insideOfChamferFace)){void 0!==gs.stringDebugFunction&&gs.stringDebugFunction(`    ChamferChamfer Fixup ${this.inspectMasks(e[i])} ${this.inspectMasks(e[n])} ${this.inspectMasks(e[s])} `);const r=this.compute3SectorIntersection(e[i],e[n],e[s]);if(void 0!==r){for(const t of[i,n,s])this.announceNodeAndSectorPropertiesInSmoothSector(e[t],((t,e)=>{e.setXYAndZ(r),t.setMask(this._offsetCoordinatesReassigned)}));t+=2}}}for(let t=0;t<e.length;t++){const i=t,s=(i+1)%e.length;this.isInsideSling(e[i],e[s])||(!this.isOffsetAssigned(e[i])&&e[s].isMaskSet(this.insideOfChamferFace)?this.transferXYZFromNodeToSmoothSector(e[s],e[i],"push left from chamfer",n):!this.isOffsetAssigned(e[s])&&e[i].isMaskSet(this.outsideEndOfChamferFace)&&this.transferXYZFromNodeToSmoothSector(e[i],e[s],"push right from chamfer",n))}for(let t=0;t<e.length;t++){const n=t,r=(n+1)%e.length,o=(r+1)%e.length;if(this.isInsideSling(e[n],e[r],e[o]))continue;if(this.isOffsetAssigned(e[r]))continue;void 0!==gs.stringDebugFunction&&gs.stringDebugFunction(`    Intersection Fixup ${this.inspectMasks(e[n])} ${this.inspectMasks(e[r])} ${this.inspectMasks(e[o])} `);const a=this.compute3SectorIntersection(e[n],e[r],e[o]);void 0!==a&&i.distance(a)<s&&this.announceNodeAndSectorPropertiesInSmoothSector(e[r],((t,e)=>{e.setXYAndZ(a),t.setMask(this._offsetCoordinatesReassigned)}))}}if(void 0!==gs.stringDebugFunction){const t=l.countMaskAroundVertex(this._offsetCoordinatesReassigned,!1),e=`   **** Vertex offset mask counts(TRUE ${l.countMaskAroundVertex(this._offsetCoordinatesReassigned,!0)})(FALSE ${t})`;gs.stringDebugFunction(e)}return!0}))}isInsideSling(t,e,i){return t.isMaskSet(this._insideChamferSling)||void 0!==e&&e.isMaskSet(this._insideChamferSling)||void 0!==i&&i.isMaskSet(this._insideChamferSling)}isInsideChamferOrSling(t){return t.isMaskSet(this._insideChamferSling)||t.isMaskSet(this._insideOfChamferFace)||t.isMaskSet(this._outsideEndOfChamferFace)}isOffsetAssigned(t,e,i){return t.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==e&&e.isMaskSet(this._offsetCoordinatesReassigned)||void 0!==i&&i.isMaskSet(this._offsetCoordinatesReassigned)}transferXYZFromNodeToSmoothSector(t,e,i,n){void 0!==gs.stringDebugFunction&&gs.stringDebugFunction(`    ${i} ${this.inspectMasks(t)} to ${this.inspectMasks(e)}} `),fs.getSectorPointAtHalfEdge(t,n,void 0),this.announceNodeAndSectorPropertiesInSmoothSector(e,((t,e)=>{e.setXYAndZ(n),t.setMask(this._offsetCoordinatesReassigned)}))}}class ps{_spacePoints;_spacePointsRange;_numSpacePoints;constructor(t){this._spacePoints=t,this._spacePointsRange=t.getRange(),this._numSpacePoints=this._spacePoints.length}static create(t){if(t.length>1)return new ps(t)}_segmentPoint0=$.create();_segmentPoint1=$.create();_localSegmentPoint0=$.create();_localSegmentPoint1=$.create();_clipFractions=De.create(0,1);_localFrame=mt.createIdentity();_polygonRange=ft.create();projectToPolygon(t,e,i,n){t.setRange(this._polygonRange);let s=0;if(!this._polygonRange.intersectsRangeXY(this._spacePointsRange))return s;for(let r=1;r+1<t.length;r++){s++;const o=t.fillLocalXYTriangleFrame(0,r,r+1,this._localFrame);if(o)for(let t=1;t<this._numSpacePoints;t++)if(s++,this._spacePoints.getPoint3dAtCheckedPointIndex(t-1,this._segmentPoint0),this._spacePoints.getPoint3dAtCheckedPointIndex(t,this._segmentPoint1),o.multiplyInversePoint3d(this._segmentPoint0,this._localSegmentPoint0),o.multiplyInversePoint3d(this._segmentPoint1,this._localSegmentPoint1),this._clipFractions.set(0,1),this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.x,this._localSegmentPoint1.x)&&this._clipFractions.clipBy01FunctionValuesPositive(this._localSegmentPoint0.y,this._localSegmentPoint1.y)&&this._clipFractions.clipBy01FunctionValuesPositive(1-this._localSegmentPoint0.x-this._localSegmentPoint0.y,1-this._localSegmentPoint1.x-this._localSegmentPoint1.y)){s++;const r=this._localSegmentPoint0.interpolate(this._clipFractions.x0,this._localSegmentPoint1),o=this._localSegmentPoint0.interpolate(this._clipFractions.x1,this._localSegmentPoint1),a=this._localFrame.multiplyPoint3d(r),c=this._localFrame.multiplyPoint3d(o),l=this._localFrame.multiplyXYZ(r.x,r.y,0),h=this._localFrame.multiplyXYZ(o.x,o.y,0),d=J.inverseInterpolate01(this._localSegmentPoint0.z,this._localSegmentPoint1.z);if(void 0!==d&&d>this._clipFractions.x0&&d<this._clipFractions.x1){s++;const r=this._segmentPoint0.interpolate(d,this._segmentPoint1),o=r.clone();e(this._spacePoints,t-1,i,n,[a,r,l],2,1),e(this._spacePoints,t-1,i,n,[c,o,h],1,2)}else this._localSegmentPoint0.z>0?e(this._spacePoints,t-1,i,n,[a,c,h,l],3,2):e(this._spacePoints,t-1,i,n,[c,a,l,h],2,3)}}return s}}class ms{edgePlane;clip;_crossingPoints;constructor(t,e){this.edgePlane=t,this.clip=e,this._crossingPoints=[]}static createPointPointSweep(t,e,i){const n=tt.createStartEnd(t,e),s=n.fractionOfProjectionToVector(i),r=n.plusScaled(i,-s),o=Vr.createNormalAndPoint(r,t),a=Vr.createNormalAndPoint(r,e),c=Vr.createOriginAndVectors(t,n,i);if(void 0!==o&&void 0!==a&&void 0!==c){a.negateInPlace();const t=As.createPlanes([o,a]);return new ms(c,t)}}processPolygon(t,e){this._crossingPoints.length=0,Array.isArray(t)?Yr.polygonPlaneCrossings(this.edgePlane,t,this._crossingPoints):Lr.polygonPlaneCrossings(this.edgePlane,t,this._crossingPoints),2===this._crossingPoints.length&&this.clip.announceClippedSegmentIntervals(0,1,this._crossingPoints[0],this._crossingPoints[1],((t,i)=>{e(this._crossingPoints[0].interpolate(t,this._crossingPoints[1]),this._crossingPoints[0].interpolate(i,this._crossingPoints[1]))}))}}class _s{_edgeClippers;_localToWorld;_worldToLocal;_localRange;constructor(t,e){this._edgeClippers=t,void 0!==e&&(this._localToWorld=e.localToWorld,this._worldToLocal=e.worldToLocal,this._localRange=e.localRange)}static create(t,e){if(void 0===e&&(e=tt.create(0,0,1)),t.length>1){const i=$.createZero(),n=$.createZero(),s=[];t.getPoint3dAtUncheckedPointIndex(0,i);let r=xt.createRigidHeadsUp(e);void 0===r&&(r=xt.createIdentity());const o=mt.createOriginAndMatrix(i,r),a=o.inverse(),c=t.getRange(a);for(let r=1;r<t.length;r++){t.getPoint3dAtUncheckedPointIndex(r,n);const o=ms.createPointPointSweep(i,n,e);void 0!==o&&(i.setFrom(n),s.push(o))}return new _s(s,{localToWorld:o,worldToLocal:a,localRange:c})}}processPolygon(t,e){if(void 0===this._worldToLocal||void 0===this._localRange||ft.createTransformedArray(this._worldToLocal,t).intersectsRangeXY(this._localRange))for(const i of this._edgeClippers)i.processPolygon(t,e)}}class xs{_range;_numXEdge;_numYEdge;_data;constructor(t,e,i){this._range=t,this._numXEdge=Math.max(e,1),this._numYEdge=Math.max(i,1),this._data=[];for(let t=0;t<i;t++){const t=[];for(let i=0;i<e;i++)t.push(void 0);this._data.push(t)}}get numXEdge(){return this._numXEdge}get numYEdge(){return this._numYEdge}xIndex(t){const e=(t-this._range.low.x)/(this._range.high.x-this._range.low.x),i=Math.floor(e*this._numXEdge);return i<0?0:i>this._numXEdge-1?this._numXEdge-1:i}yIndex(t){const e=(t-this._range.low.y)/(this._range.high.y-this._range.low.y),i=Math.floor(e*this._numYEdge);return i<0?0:i>this._numYEdge-1?this._numYEdge-1:i}static createWithEstimatedCounts(t,e,i){if(t.low.x>=t.high.x||t.low.y>=t.high.y)return;const n=pt.createXYXY(t.low.x,t.low.y,t.high.x,t.high.y),s=n.xLength(),r=n.yLength();let o,a;return r>s?(a=Math.ceil(Math.sqrt(r*e/(i*s))),o=Math.ceil(e/a)):(o=Math.ceil(Math.sqrt(s*e/(i*r))),a=Math.ceil(e/(o*i))),new xs(n,o,a)}addDataAtXY(t,e,i){const n=this.xIndex(t),s=this.yIndex(e);let r=this._data[s][n];r||(r=[],this._data[s][n]=r),r.push(i)}getDataAtXY(t,e){const i=this.xIndex(t),n=this.yIndex(e);return this._data[n][i]}getDataAtIndex(t,e){if(!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge))return this._data[e][t]}isValidIndex(t,e){return!(t<0||t>=this._numXEdge||e<0||e>=this._numYEdge)}}class ys{_points;_buckets;get indexGrid(){return this._buckets}constructor(t,e){this._points=t,this._buckets=e}static create(t,e){const i=t.length;if(t.length<1)return;const n=t.getRange();n.expandInPlace(1e3*J.smallMetricDistance);const s=xs.createWithEstimatedCounts(n,t.length,e);if(void 0===s)return;const r=new ys(t,s),o=$.create();for(let e=0;e<i;e++)t.getPoint3dAtUncheckedPointIndex(e,o),s.addDataAtXY(o.x,o.y,e);return r}announcePointsInRange(t,e){const i=this._buckets.xIndex(t.low.x),n=this._buckets.xIndex(t.high.x),s=this._buckets.yIndex(t.low.y),r=this._buckets.yIndex(t.high.y),o=this._points.length;for(let a=i;a<=n;a++)for(let i=s;i<=r;i++){const n=this._buckets.getDataAtIndex(a,i);if(void 0!==n)for(const i of n)if(i<o){const n=this._points.getXAtUncheckedPointIndex(i),s=this._points.getYAtUncheckedPointIndex(i),r=this._points.getZAtUncheckedPointIndex(i);if(t.containsXY(n,s)&&!e(i,n,s,r))return}}}}class vs{_count;_sumX;_sumXX;_minMax;_origin;constructor(t=0){this._minMax=gt.createNull(),this._count=this._sumX=this._sumXX=0,this._origin=t}get count(){return this._count}get mean(){return this._count>0?this._sumX/this._count:0}get meanSquare(){return this._count>0?this._sumXX/this._count:0}get minMax(){return this._minMax.clone()}get standardDeviation(){if(this._count<1)return 0;const t=this.mean,e=this._sumXX,i=this._sumX;return Math.sqrt((e-2*t*i+this._count*t*t)/this._count)}clearSums(){this._count=this._sumX=this._sumXX=0,this._minMax.setNull()}get origin(){return this._origin}setOrigin(t){this._origin=t}shiftOriginAndSums(t){const e=t-this._origin;this._origin=t,this._sumXX=this._sumXX-2*e*this._sumX+this._count*e*e,this._sumX=this._sumX-this._count*e,this._minMax.cloneTranslated(-e,this._minMax)}accumulate(t){t-=this._origin,this._count+=1,this._sumX+=t,this._sumXX+=t*t,this._minMax.extendX(t)}accumulateArray(t){for(const e of t)this.accumulate(e)}clone(t){return t||(t=new vs),this._minMax.clone(t._minMax),t._count=this._count,t._origin=this._origin,t._sumX=this._sumX,t._sumXX=this._sumXX,t}isAlmostEqual(t){return J.isAlmostEqualNumber(this._sumX,t._sumX)&&J.isAlmostEqualNumber(this._sumXX,t._sumXX)&&J.isAlmostEqualNumber(this._origin,t._origin)&&this._count===t._count&&this._minMax.isAlmostEqual(t._minMax)}}class Ps{range;xSums;ySums;zSums;constructor(){this.range=ft.createNull(),this.xSums=new vs,this.ySums=new vs,this.zSums=new vs,this._workRange=ft.createNull()}_workRange;accumulateGrowableXYZArrayRange(t){t.setRange(this._workRange),this.range.extendRange(this._workRange),this.xSums.accumulate(this._workRange.xLength()),this.ySums.accumulate(this._workRange.yLength()),this.zSums.accumulate(this._workRange.zLength())}}class Is{vectorToEye;collectOnForwardFacets;collectOnSideFacets;collectOnRearFacets;sideAngle;assembleChains;searcher;constructor(t,e,i,n,s,r,o){this.vectorToEye=t,this.sideAngle=e,this.assembleChains=i,this.collectOnForwardFacets=n,this.collectOnSideFacets=s,this.collectOnRearFacets=r,this.searcher=o}static create(t,e,i,n,s,r,o){return new Is(!t||o?tt.unitZ():t.clone(),e?.clone()??G.createRadians(J.smallAngleRadians),i??!0,n??!0,s??!0,r??!0,o)}get collectAll(){return this.collectOnForwardFacets&&this.collectOnSideFacets&&this.collectOnRearFacets}collectFromThisFacetNormal(t){return void 0!==t&&(t.angleFromPerpendicular(this.vectorToEye).isMagnitudeLessThanOrEqual(this.sideAngle)?this.collectOnSideFacets:t.dotProduct(this.vectorToEye)>0?this.collectOnForwardFacets:this.collectOnRearFacets)}}class Ss{smoothSingleAngleBetweenNormals;smoothAccumulatedAngleBetweenNormals;chamferAngleBetweenNormals;outputSelector;constructor(t=G.createDegrees(25),e=G.createDegrees(60),i=G.createDegrees(90)){this.smoothSingleAngleBetweenNormals=t.clone(),this.smoothAccumulatedAngleBetweenNormals=e.clone(),this.chamferAngleBetweenNormals=i.clone()}static create(t=G.createDegrees(25),e=G.createDegrees(60),i=G.createDegrees(120)){const n=t.clone(),s=e.clone(),r=i.clone();return n.degrees<1&&s.setDegrees(1),s.degrees<1&&s.setDegrees(1),s.degrees<15&&s.setDegrees(15),new Ss(n,s,r)}}!function(t){t[t.SelectNone=0]="SelectNone",t[t.SelectAny=1]="SelectAny",t[t.SelectAll=2]="SelectAll",t[t.SelectOneByParity=3]="SelectOneByParity"}(X||(X={}));class bs{static visitorToLoop(t){const e=Fe.createPoints(t.point.getPoint3dArray());return oi.create(e)}static indexedPolyfaceToLoops(t){const e=ei.create(),i=t.createVisitor(1);for(;i.moveToNextFacet();){const t=bs.visitorToLoop(i);e.tryAddChild(t)}return e}static sumFacetAreas(t,e){let i,n=0;for(t instanceof Gi?t=t.createVisitor(1):t.setNumWrap(1),void 0!==e&&(i=e.normalize()),t.reset();t.moveToNextFacet();){const e=zr.areaNormal(t.point.getPoint3dArray());n+=i?e.dotProduct(i):e.magnitude()}return n}static sumTetrahedralVolumes(t,e){let i=0;if(t instanceof Gi)return bs.sumTetrahedralVolumes(t.createVisitor(0),e);let n=e;const s=$.create(),r=$.create(),o=$.create();for(t.reset();t.moveToNextFacet();){void 0===n&&(n=t.point.getPoint3dAtUncheckedPointIndex(0)),t.point.getPoint3dAtUncheckedPointIndex(0,s);for(let e=1;e+1<t.point.length;e++)t.point.getPoint3dAtUncheckedPointIndex(e,r),t.point.getPoint3dAtUncheckedPointIndex(e+1,o),i+=n.tripleProductToPoints(s,r,o)}return i/6}static sumVolumeBetweenFacetsAndPlane(t,e,i){const n=t instanceof Gi?t.createVisitor(0):t;n.setNumWrap(0);const s=$.create(),r=$.create(),o=tt.create(),a=Bt.createZero();let c=0;const l=i?void 0:wi.create(void 0,!0),h=i?void 0:wi.create(void 0,!0),d={skipMoments:i,p0:s,p1:r,v0:o,m0:a};for(n.reset();n.moveToNextFacet();){const t=zr.volumeBetweenPolygonAndPlane(n.point,e,d);c+=t.volume6,i||(void 0!==l&&void 0!==h&&void 0!==t.origin&&t.products,t.area2>0?l.accumulateProductsFromOrigin(t.origin,t.products,1):h.accumulateProductsFromOrigin(t.origin,t.products,1))}return{volume:c/6,positiveProjectedFacetAreaMoments:l?wi.inertiaProductsToPrincipalAxes(l.origin,l.sums):void 0,negativeProjectedFacetAreaMoments:h?wi.inertiaProductsToPrincipalAxes(h.origin,h.sums):void 0}}static sumFacetSecondAreaMomentProducts(t,e){if(t instanceof Gi)return bs.sumFacetSecondAreaMomentProducts(t.createVisitor(0),e);const i=Bt.createZero();for(t.reset();t.moveToNextFacet();)zr.addSecondMomentAreaProducts(t.point,e,i);return i}static sumFacetSecondVolumeMomentProducts(t,e){if(t instanceof Gi)return bs.sumFacetSecondVolumeMomentProducts(t.createVisitor(0),e);const i=Bt.createZero();for(t.reset();t.moveToNextFacet();)zr.addSecondMomentVolumeProducts(t.point,e,i);return i}static computePrincipalAreaMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=bs.sumFacetSecondAreaMomentProducts(t,e);return wi.inertiaProductsToPrincipalAxes(e,i)}static computePrincipalVolumeMoments(t){const e=t.data.getPoint(0);if(!e)return;const i=bs.sumFacetSecondVolumeMomentProducts(t,e);return wi.inertiaProductsToPrincipalAxes(e,i)}static areFacetsConvex(t){if(t instanceof Gi)return this.areFacetsConvex(t.createVisitor(0));for(t.setNumWrap(0),t.reset();t.moveToNextFacet();)if(t.pointCount>3&&!zr.isConvex(t.point))return!1;return!0}static dihedralAngleSummary(t,e=!1){const i=new ns,n=t instanceof Gi?t.data.point:void 0,s=t instanceof Gi?t.createVisitor(1):t;s.setNumWrap(1);const r=[];let o=0;for(s.reset();s.moveToNextFacet();){const t=s.pointCount-1,e=zr.centroidAreaNormal(s.point);if(void 0===e)return-2;r.push(e);for(let e=0;e<t;e++){const t=i.addEdge(s.clientPointIndex(e),s.clientPointIndex(e+1),o);n||(t.edgeVector=tt.createStartEnd(s.point.getPoint3dAtUncheckedPointIndex(e),s.point.getPoint3dAtUncheckedPointIndex(e+1)))}o++}const a=[],c=[];if(i.sortAndCollectClusters(c,e?void 0:a,void 0,a),a.length>0)return-2;let l=0,h=0,d=0;const u=tt.create();for(const t of c)if(Array.isArray(t)&&2===t.length){const e=t[0],i=t[1];n?n.vectorIndexIndex(e.startVertex,e.endVertex,u):u.setFrom(e.edgeVector);const s=r[e.facetIndex].direction,o=r[i.facetIndex].direction,a=s.signedAngleTo(o,u);a.isAlmostZero?h++:a.radians>0?l++:d++}return l>0&&0===d?1:d>0&&0===l?-1:h>0&&0===l&&0===d?0:-2}static isConvexByDihedralAngleCount(t,e=!1){return this.dihedralAngleSummary(t,e)>0}static isSubsetVisitor(t){if(t instanceof Gi)return!1;const e=t.clientPolyface()?.facetCount,i=t.getVisitableFacetCount?.();return void 0!==e&&void 0!==i&&e>i}static isPolyfaceManifoldFast(t,e){if(e)return;if(this.isSubsetVisitor(t))return!1;const i=Qi.hasEdgeMateIndex(t);if(i){for(const t of i.edgeMateIndex)if(void 0===t)return!1;return!0}}static isPolyfaceManifold(t,e=!1){const i=this.isPolyfaceManifoldFast(t,e);if(void 0!==i)return i;const n=[];return this.createIndexedEdges(t).sortAndCollectClusters(void 0,e?void 0:n,void 0,n),0===n.length}static isPolyfaceClosedByEdgePairing(t){return this.isPolyfaceManifold(t,!1)}static announceBoundaryEdgesFast(t,e,i,n,s){if(i!==n)return!1;if(!i&&!s)return!0;if(this.isSubsetVisitor(t))return!1;const r=Qi.hasEdgeMateIndex(t);if(!r)return!1;const o=$.create(),a=$.create();for(let t=0;t<r.edgeMateIndex.length;t++){const n=r.edgeMateIndex[t];if(i&&void 0===n||s&&n===t){const i=r.parent.edgeIndexToFacetIndex(t);if(void 0!==i){const n=r.parent.data.pointIndex[t];let s=t+1;s>=r.parent.facetIndex1(i)&&(s=r.parent.facetIndex0(i));const c=r.parent.data.pointIndex[s];r.parent.data.getPoint(n,o),r.parent.data.getPoint(c,a),e(o,a,n,c,i)}}}return!0}static announceBoundaryEdges(t,e,i=!0,n=!0,s=!0){if(this.announceBoundaryEdgesFast(t,e,i,n,s))return;if(!i&&!n&&!s)return;const r=t instanceof Gi?t.data.point:void 0,o=t instanceof Gi?t.createVisitor(1):t;o.setNumWrap(1);const a=new ns;for(o.reset();o.moveToNextFacet();){const t=o.pointCount-1;for(let e=0;e<t;e++){const t=a.addEdge(o.clientPointIndex(e),o.clientPointIndex(e+1),o.currentReadIndex());r||(t.pointA=o.point.getPoint3dAtUncheckedPointIndex(e),t.pointB=o.point.getPoint3dAtUncheckedPointIndex(e+1))}}const c=[],l=i?c:void 0,h=s?c:void 0,d=n?c:void 0;if(a.sortAndCollectClusters(void 0,l,h,d),0===c.length)return;const u=$.create(),f=$.create();for(const t of c){const i=t instanceof is?t:t[0],n=i.startVertex,s=i.endVertex;r?(r.getPoint3dAtUncheckedPointIndex(n,u),r.getPoint3dAtUncheckedPointIndex(s,f)):(u.setFrom(i.pointA),f.setFrom(i.pointB)),e(u,f,n,s,i.facetIndex)}}static boundaryEdges(t,e=!0,i=!0,n=!0){const s=new ei;if(bs.announceBoundaryEdges(t,((t,e,i,n,r)=>{s.tryAddChild(Te.create(t,e))}),e,i,n),0!==s.children.length)return s}static collectBoundaryEdges(t,e=!0,i=!0,n=!0){const s=new $i(J.smallMetricDistance,J.smallMetricDistance);return bs.announceBoundaryEdges(t,((t,e)=>s.captureCurve(Te.create(t,e))),e,i,n),s.grabResult(!0)}static createIndexedEdges(t){const e=new ns,i=t instanceof Gi?t.createVisitor(1):t;for(i.setNumWrap(1),i.reset();i.moveToNextFacet();)e.addPath(i.pointIndex,i.currentReadIndex(),!1);return e}static announceSilhouetteEdges(t,e,i,n=G.createSmallAngle()){if(t instanceof Gi)return this.announceSilhouetteEdges(t.createVisitor(1),e,i,n);const s=t.clientPolyface();if(void 0===s)return;t.setNumWrap(1);const r=[];this.createIndexedEdges(t).sortAndCollectClusters(r);const o=n.radians<0?-n.radians:n.radians,a=$.create(),c=$.create(),l=tt.create(),h=e=>{if(!bs.computeFacetUnitNormal(t,e,l))return{isSideFace:!1,perpAngle:0};const n=l.radiansFromPerpendicular(i);return{isSideFace:Math.abs(n)<=o,perpAngle:n}};for(const t of r){if(!Array.isArray(t)||2!==t.length)continue;const i=t[0].startVertex,n=t[0].endVertex;if(!s.data.getPoint(i,a)||!s.data.getPoint(n,c))continue;const r=h(t[0].facetIndex);if(r.isSideFace){e(a,c,i,n,t[0].facetIndex);continue}const o=h(t[1].facetIndex);o.isSideFace?e(c,a,n,i,t[1].facetIndex):r.perpAngle*o.perpAngle<0&&e(a,c,i,n,t[0].facetIndex)}}static collectSilhouetteEdges(t,e,i=G.createSmallAngle()){const n=new $i(J.smallMetricDistance,J.smallMetricDistance);return bs.announceSilhouetteEdges(t,((t,e)=>n.captureCurve(Te.create(t,e))),e,i),n.grabResult(!0)}static announceSweepLinestringToConvexPolyfaceXY(t,e,i){const n=ps.create(t);if(n){const t=e.createVisitor(0);for(t.reset();t.moveToNextFacet();)n.projectToPolygon(t.point,i,e,t.currentReadIndex())}}static _asyncWorkLimit=1e6;static setAsyncWorkLimit(t){const e=this._asyncWorkLimit;return this._asyncWorkLimit=t,e}static get asyncWorkLimit(){return this._asyncWorkLimit}static awaitBlockCount=0;static async continueAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){let n=0;for(;n<this.asyncWorkLimit&&e.moveToNextFacet();)n+=t.projectToPolygon(e.point,i,e.clientPolyface(),e.currentReadIndex());return n}static async asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,i){const n=ps.create(t);this.awaitBlockCount=0;let s=0;if(n){const t=e.createVisitor(0);let r;for(;0<(r=await Promise.resolve(bs.continueAnnounceSweepLinestringToConvexPolyfaceXY(n,t,i)));)s+=r,this.awaitBlockCount++}return s}static partitionFacetIndicesByVertexConnectedComponent(t){if(t instanceof Gi)return this.partitionFacetIndicesByVertexConnectedComponent(t.createVisitor(0));const e=new an(this.visitorClientPointCount(t));for(t.reset();t.moveToNextFacet();){const i=t.pointIndex[0];for(const n of t.pointIndex)e.mergeSubsets(i,n)}const i=e.collectRootIndices(),n=[],s=i.length;for(let t=0;t<s;t++)n.push([]);for(t.reset();t.moveToNextFacet();){const r=t.pointIndex[0],o=e.findRoot(r);for(let e=0;e<s;e++)if(i[e]===o){n[e].push(t.currentReadIndex());break}}return n}static partitionFacetIndicesByVisibilityVector(t,e,i){if(t instanceof Gi)return this.partitionFacetIndicesByVisibilityVector(t.createVisitor(0),e,i);const n=[];for(let t=0;t<3;t++)n.push([]);const s=n[0],r=n[1],o=n[2],a=Math.max(i.radians,1e-8);for(t.reset();t.moveToNextFacet();){const i=zr.areaNormalGo(t.point),n=t.currentReadIndex();if(i){const t=i.angleFromPerpendicular(e);Math.abs(t.radians)<a?o.push(n):i.dotProduct(e)<0?r.push(n):s.push(n)}}return n}static boundaryOfVisibleSubset(t,e,i,n=G.createDegrees(.001)){const s=t instanceof Gi?t.createVisitor(0):t;if(!s.createSubsetVisitor)return;const r=this.partitionFacetIndicesByVisibilityVector(t,i,n);if(0===r[e].length)return;const o=s.createSubsetVisitor(r[e],1);return this.boundaryEdges(o,!0,!1,!1)}static announceBoundaryChainsAsLineString3d(t,e){const i=new $i(J.smallMetricDistance);bs.announceBoundaryEdges(t,((t,e)=>i.captureCurve(Te.create(t,e))),!0,!1,!1),i.announceChainsAsLineString3d(e)}static cloneWithMaximalPlanarFacets(t,e){if(t instanceof Gi)return this.cloneWithMaximalPlanarFacets(t.createVisitor(0),e);const i=bs.visitorClientFacetCount(t),n=bs.collectEdgesByDihedralAngle(t,e),s=bs.partitionFacetIndicesBySortableEdgeClusters(n,i),r=ir.create(),o=t,a=[],c=[],l=tt.createZero();for(const t of s)if(1===t.length)o.moveToReadIndex(t[0])&&r.addFacetFromVisitor(o);else if(t.length>1){const e=tt.createZero(),i=$.createZero();o.moveToReadIndex(t[0])&&o.point.getPoint3dAtCheckedPointIndex(0,i);for(const i of t)o.moveToReadIndex(i)&&zr.areaNormalGo(o.point,l)&&e.addInPlace(l);c.push(Rt.createCapture(i,e)),a.push(t)}const h=bs.clonePartitions(t,a);a.length,c.length,a.length,h.length;const d=mt.createIdentity(),u=mt.createIdentity();for(let t=0;t<h.length;++t){const e=h[t],i=[],n=[];bs.announceBoundaryEdges(e,((t,e,s,r)=>{i.push(Te.create(t,e)),n.push([t.clone(),e.clone()])}),!0,!1,!1);const s=sn.collectChains(i,1e-4,1e-4);if(s&&(c[t].toRigidZFrame(d),d.inverse(u))){u.multiplyPoint3dArrayArrayInPlace(n);const t=!(s instanceof oi),e=Zn.formGraphFromChains(n,t,E.BOUNDARY_EDGE);if(e){Jn.collectConnectedComponentsWithExteriorParityMasks(e,new jn(E.BOUNDARY_EDGE),E.EXTERIOR);const t=ir.graphToPolyface(e);r.addIndexedPolyface(t,!1,d)}}}return r.claimPolyface(!0)}static fillSimpleHoles(t,e,i){if(t instanceof Gi)return this.fillSimpleHoles(t.createVisitor(0),e,i);const n=ir.create(),s=[];bs.announceBoundaryChainsAsLineString3d(t,(t=>{t.reverseInPlace(),s.push(t)}));for(const t of s){const s=t.points;let r=!1;t.isPhysicallyClosed?(void 0!==e.maxEdgesAroundHole&&s.length>e.maxEdgesAroundHole||void 0!==e.maxPerimeter&&fe.sumEdgeLengths(s,!1)>e.maxPerimeter||void 0!==e.upVector&&zr.sumTriangleAreasPerpendicularToUpVector(s,e.upVector)<=0)&&(r=!0):r=!0,!r&&Kn.triangulateSimplestSpaceLoop(s,((t,e)=>{for(const t of e)n.addPolygon(t)}))||(r=!0),r&&void 0!==i&&i.push(t)}if(void 0!==e.includeOriginalMesh&&e.includeOriginalMesh)for(t.reset();t.moveToNextFacet();)n.addFacetFromVisitor(t);return n.claimPolyface(!0)}static clonePartitions(t,e){if(t instanceof Gi)return this.clonePartitions(t.createVisitor(0),e);t.setNumWrap(0);const i=[],n=be.createForFacets();n.needNormals=void 0!==t.normal,n.needParams=void 0!==t.param,n.needColors=void 0!==t.color,n.needTwoSided=t.twoSided;for(const s of e){const e=ir.create(n);t.reset();for(const i of s)t.moveToReadIndex(i),e.addFacetFromVisitor(t);i.push(e.claimPolyface(!0))}return i}static cloneFiltered(t,e){if(t instanceof Gi)return this.cloneFiltered(t.createVisitor(0),e);t.setNumWrap(0);const i=be.createForFacets();i.needNormals=void 0!==t.normal,i.needParams=void 0!==t.param,i.needColors=void 0!==t.color,i.needTwoSided=t.twoSided;const n=ir.create(i);for(t.reset();t.moveToNextFacet();)e(t)&&n.addFacetFromVisitor(t);return n.claimPolyface(!0)}static cloneWithDanglingEdgesRemoved(t){if(t instanceof Gi)return this.cloneWithDanglingEdgesRemoved(t.createVisitor(0));const e=be.createForFacets();e.needNormals=void 0!==t.normal,e.needParams=void 0!==t.param,e.needColors=void 0!==t.color,e.needTwoSided=t.twoSided;const i=ir.create(e),n=(t,e)=>{const i=t.length;for(let n=0;n<i;++n){let s=1,r=n,o=n;for(;s+2<=i;){const n=0===r?i-1:r-1,a=o===i-1?0:o+1;if(e[t[n]]!==e[t[a]])break;r=n,o=a,s+=2}if(s>1)return r<o?t.splice(r,s-1):r>o&&(t.splice(r),t.splice(0,o)),!0}return!1};for(t.setNumWrap(0),t.reset();t.moveToNextFacet();){const e=[...Array(t.pointIndex.length).keys()];for(;n(e,t.pointIndex););i.addFacetFromIndexedVisitor(t,e)}return i.claimPolyface(!0)}static visitorClientPointCount(t){if(t instanceof Gi)return t.data.point.length;const e=t.clientPolyface();if(void 0!==e)return e.data.point.length;const i=t.currentReadIndex();t.reset();let n=-1;for(;t.moveToNextFacet();)for(const e of t.pointIndex)e>n&&(n=e);return t.moveToReadIndex(i),n+1}static visitorClientFacetCount(t){if(t instanceof Gi){if(void 0!==t.facetCount)return t.facetCount;t=t.createVisitor(0)}if(t.getVisitableFacetCount)return t.getVisitableFacetCount();const e=t.clientPolyface();if(void 0!==e&&void 0!==e.facetCount)return e.facetCount;const i=t.currentReadIndex();let n=0;for(t.reset();t.moveToNextFacet();)++n;return t.moveToReadIndex(i),n}static partitionFacetIndicesBySortableEdgeClusters(t,e){const i=new an(e);for(const e of t)if(e instanceof is);else{const t=e[0];for(let n=1;n<e.length;n++)i.mergeSubsets(t.facetIndex,e[n].facetIndex)}const n=i.collectRootIndices(),s=[],r=n.length;for(let t=0;t<r;t++)s.push([]);for(let t=0;t<e;t++){const e=i.findRoot(t);for(let i=0;i<r;i++)if(n[i]===e){s[i].push(t);break}}return s}static partitionFacetIndicesByEdgeConnectedComponent(t,e=!1){if(t instanceof Gi)return this.partitionFacetIndicesByEdgeConnectedComponent(t.createVisitor(0),e);t.setNumWrap(1);const i=new ns;t.reset();let n=0;for(;t.moveToNextFacet();){const s=t.pointCount-1;n++;for(let n=0;n<s;n++)e&&t.edgeVisible[n]||i.addEdge(t.clientPointIndex(n),t.clientPointIndex(n+1),t.currentReadIndex())}const s=[];return i.sortAndCollectClusters(s,s,s,s),this.partitionFacetIndicesBySortableEdgeClusters(s,n)}static sweepLineStringToFacetsXYReturnSweptFacets(t,e){const i=ir.create();return this.announceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,n,s,r)=>{4===r.length?i.addQuadFacet(r):3===r.length&&i.addTriangleFacet(r)})),i.claimPolyface(!0)}static sweepLinestringToFacetsXYreturnSweptFacets(t,e){return this.sweepLineStringToFacetsXYReturnSweptFacets(t,e)}static sweepLineStringToFacets(t,e,i){let n,s=[];void 0===i&&(i=Is.create()),i.assembleChains&&(n=Gn.create());const r=n?(t,e)=>n.addSegment(t,e):(t,e)=>s.push(Te.create(t,e)),o=tt.createZero(),a=e instanceof Gi?e.createVisitor(0):e;if(a.setNumWrap(0),i.searcher&&i.vectorToEye.isParallelTo(tt.unitZ())){const e=ft.createNull(),n=$.createZero(),s=$.createZero();let c;const l=(t,e)=>(a.moveToReadIndex(e)&&(i.collectAll||i.collectFromThisFacetNormal(zr.areaNormalGo(a.point,o)))&&c?.processPolygon(a.point,((t,e)=>r(t,e))),!0);for(let r=1;r<t.length;r++)t.getPoint3dAtUncheckedPointIndex(r-1,n),t.getPoint3dAtUncheckedPointIndex(r,s),(c=ms.createPointPointSweep(n,s,i.vectorToEye))&&(e.setNull(),e.extend(n,s),i.searcher.searchRange2d(e,l))}else{const e=_s.create(t,i.vectorToEye);if(e)for(a.reset();a.moveToNextFacet();)(i.collectAll||i.collectFromThisFacetNormal(zr.areaNormalGo(a.point,o)))&&e.processPolygon(a.point.getArray(),r)}return n&&(n.clusterAndMergeVerticesXYZ(),s=n.collectMaximalChains()),s}static sweepLineStringToFacetsXY(t,e,i){const n=Gn.create(),s=tt.unitZ(),r=ft.create(),o=$.createZero(),a=$.createZero(),c=e instanceof Gi?e.createVisitor(0):e;let l;c.setNumWrap(0);const h=(t,e)=>(c.moveToReadIndex(e)&&l?.processPolygon(c.point,((t,e)=>n.addSegment(t,e))),!0),d=Array.isArray(t)?new he(t):t;for(let t=1;t<d.length;t++)d.getPoint3dAtUncheckedPointIndex(t-1,o),d.getPoint3dAtUncheckedPointIndex(t,a),(l=ms.createPointPointSweep(o,a,s))&&(r.setNull(),r.extend(o,a),i.searchRange2d(r,h));return n.clusterAndMergeVerticesXYZ(),n.collectMaximalChains()}static sweepLinestringToFacetsXYReturnLines(t,e){const i=Is.create(tt.unitZ(),G.createSmallAngle(),!1,!0,!0,!0);return bs.sweepLineStringToFacets(t,e,i)}static sweepLinestringToFacetsXYReturnChains(t,e){return bs.sweepLineStringToFacets(t,e)}static async asyncSweepLinestringToFacetsXYReturnChains(t,e){const i=Gn.create();return await Promise.resolve(this.asyncAnnounceSweepLinestringToConvexPolyfaceXY(t,e,((t,e,n,s,r,o,a)=>{i.addSegment(r[o],r[a])}))),i.clusterAndMergeVerticesXYZ(),i.collectMaximalChains()}static collectRangeLengthData(t){if(t instanceof Gi)return this.collectRangeLengthData(t.createVisitor(0));const e=new Ps;for(t.reset();t.moveToNextFacet();)e.accumulateGrowableXYZArrayRange(t.point);return e}static cloneWithTVertexFixup(t){const e=t.createVisitor(1),i=t.createVisitor(0),n=ys.create(t.data.point,30),s=ir.create(),r=ft.createNull(),o=$.create(),a=$.create(),c=$.create(),l=Te.create(o,a);for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let s=0;s+1<e.point.length;s++){let h;if(e.point.getPoint3dAtUncheckedPointIndex(s,o),e.point.getPoint3dAtUncheckedPointIndex(s+1,a),i.pushDataFrom(e,s),r.setNull(),Te.create(o,a,l),r.extend(o),r.extend(a),r.ensureMinLengths(J.smallMetricDistance),n.announcePointsInRange(r,((e,i,n,s)=>{t.data.point.getPoint3dAtUncheckedPointIndex(e,c);const r=l.closestPoint(c,!1);return void 0!==r&&r.fraction>0&&r.fraction<1&&!r.point.isAlmostEqual(o)&&!r.point.isAlmostEqual(a)&&c.isAlmostEqual(r.point)&&(void 0===h&&(h=[]),r.a=e,h.push(r)),!0})),void 0!==h){h.sort(((t,e)=>t.fraction-e.fraction));for(const t of h)i.pushInterpolatedDataFrom(e,s,t.fraction,s+1)}}s.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return s.claimPolyface()}static compareFacetIndexAndVertexIndices(t,e){if(t.length!==e.length)return t.length-e.length;for(let i=1;i<t.length;i++)if(t[i]!==e[i])return t[i]-e[i];return 0}static announceDuplicateFacetIndices(t,e){const i=t.createVisitor(0),n=[];for(i.reset();i.moveToNextFacet();){const t=[i.currentReadIndex()],e=i.pointIndex,s=e.length;let r=0;for(let t=1;t<i.pointIndex.length;t++)e[t]<e[r]&&(r=t);if(e[(r+1)%s]<e[(r+s-1)%s])for(let i=0;i<s;i++)t.push(e[(r+i)%s]);else for(let i=0;i<s;i++)t.push(e[(r+s-i)%s]);n.push(t)}let s,r;n.sort(((t,e)=>this.compareFacetIndexAndVertexIndices(t,e)));const o=n.length,a=[];for(s=0;s<o;s=r){for(r=s+1,a.length=0,a.push(n[s][0]);r<o&&0===this.compareFacetIndexAndVertexIndices(n[s],n[r]);)a.push(n[r][0]),r++;e(a)}}static collectDuplicateFacetIndices(t,e=!1){const i=[];return this.announceDuplicateFacetIndices(t,(t=>{(e||t.length>1)&&i.push(t.slice())})),i}static cloneByFacetDuplication(t,e,i){const n=ir.create(),s=t.createVisitor(0);return this.announceDuplicateFacetIndices(t,(t=>{let r=0;1===t.length?e&&(r=1):t.length>1&&(i===X.SelectAny?r=1:i===X.SelectAll?r=t.length:i===X.SelectOneByParity&&(r=1&~t.length?0:1));for(let e=0;e<r;e++)s.moveToReadIndex(t[e]),n.addFacetFromVisitor(s)})),n.claimPolyface()}static cloneWithColinearEdgeFixup(t){const e=t.createVisitor(2),i=t.createVisitor(0),n=ir.create(),s=tt.create(),r=tt.create(),o=t.data.point.length,a=new Int32Array(o);for(e.reset();e.moveToNextFacet();)for(let t=0;t+2<e.point.length;t++){e.point.vectorIndexIndex(t,t+1,s),e.point.vectorIndexIndex(t+1,t+2,r);const i=e.clientPointIndex(t+1);a[i]>=0&&(s.angleTo(r).isAlmostZero?a[i]++:a[i]=-1)}for(e.reset();e.moveToNextFacet();){i.clearArrays();for(let t=0;t+2<e.point.length;t++)a[e.clientPointIndex(t)]<0&&i.pushDataFrom(e,t);i.point.length>2&&n.addFacetFromGrowableArrays(i.point,i.normal,i.param,i.color,i.edgeVisible)}return n.claimPolyface()}static setEdgeVisibility(t,e,i){for(const n of e)if(n instanceof is)this.setSingleEdgeVisibility(t,n.facetIndex,n.startVertex,i);else if(Array.isArray(n))for(const e of n)this.setSingleEdgeVisibility(t,e.facetIndex,e.startVertex,i)}static setSingleEdgeVisibility(t,e,i,n){const s=t.data,r=t.facetIndex0(e),o=t.facetIndex1(e);for(let t=r;t<o;t++)s.pointIndex[t]===i&&(s.edgeVisible[t]=n)}static getSingleEdgeVisibility(t,e,i){const n=t.data,s=t.facetIndex0(e),r=t.facetIndex1(e);for(let t=s;t<r;t++)if(n.pointIndex[t]===i)return n.edgeVisible[t]}static collectEdgesByDihedralAngle(t,e,i=!1){if(t instanceof Gi)return this.collectEdgesByDihedralAngle(t.createVisitor(1),e,i);t.setNumWrap(1);const n=[];this.createIndexedEdges(t).sortAndCollectClusters(n),(void 0===e||e.radians<0)&&(e=G.createRadians(J.smallAngleRadians));const s=[],r=tt.create(),o=tt.create();for(const a of n)if(Array.isArray(a)&&2===a.length){const n=a[0],c=a[1];if(void 0!==bs.computeFacetUnitNormal(t,n.facetIndex,r)&&void 0!==bs.computeFacetUnitNormal(t,c.facetIndex,o)){const t=r.smallerUnorientedAngleTo(o);i?t.radians>e.radians&&s.push(a):t.radians<=e.radians&&s.push(a)}}return s}static markPairedEdgesInvisible(t,e){const i=t.createVisitor(1),n=[],s=[];if(this.createIndexedEdges(i).sortAndCollectClusters(n,s,s,s),this.markAllEdgeVisibility(t,!1),this.setEdgeVisibility(t,s,!0),void 0!==e){const s=tt.create(),r=tt.create();for(const o of n)if(Array.isArray(o)&&2===o.length){const n=o[0],a=o[1];void 0!==bs.computeFacetUnitNormal(i,n.facetIndex,s)&&void 0!==bs.computeFacetUnitNormal(i,a.facetIndex,r)&&s.smallerUnorientedAngleTo(r).radians>e.radians&&(this.setSingleEdgeVisibility(t,n.facetIndex,n.startVertex,!0),this.setSingleEdgeVisibility(t,a.facetIndex,a.startVertex,!0))}}}static computeFacetUnitNormal(t,e,i){if(i||(i=tt.create()),t.moveToReadIndex(e)&&zr.unitNormal(t.point,i))return i}static markAllEdgeVisibility(t,e){const i=t.data;for(let t=0;t<i.edgeVisible.length;t++)i.edgeVisible[t]=e}static convertToHalfEdgeGraph(t){const e=new Qn,i=t.createVisitor(0);for(i.reset();i.moveToNextFacet();)e.insertLoop(i.pointIndex);const n=e.graph,s=$.create();return n.announceNodes(((e,i)=>{const n=i.i;return t.data.getPoint(n,s),i.setXYZ(s),!0})),n}static reorientVertexOrderAroundFacetsForConsistentOrientation(t){return rs.doFixup(t)}static buildPerFaceNormals(t){cs.buildPerFaceNormals(t)}static buildAverageNormals(t,e=G.createDegrees(31)){cs.buildFastAverageNormals(t,e)}static cloneOffset(t,e,i=Ss.create()){const n=be.createForFacets(),s=ir.create(n);return gs.buildOffsetMeshWithEdgeChamfers(t,s,e,i),s.claimPolyface()}static _workTriangle;static _workTriDetail;static _workPolyDetail;static _workFacetDetail3;static _workFacetDetailC;static _workFacetDetailNC;static intersectRay3d(t,e,i){if(t instanceof Gi)return bs.intersectRay3d(t.createVisitor(0),e,i);let n;const s=i?[i.distanceTolerance,i.parameterTolerance]:void 0;for(t.setNumWrap(0);t.moveToNextFacet();){const r=t.pointCount,o=t.point;if(3===r){const s=this._workTriangle=on.create(o.getPoint3dAtUncheckedPointIndex(0),o.getPoint3dAtUncheckedPointIndex(1),o.getPoint3dAtUncheckedPointIndex(2),this._workTriangle),r=this._workTriDetail=s.intersectRay3d(e,this._workTriDetail);s.snapLocationToEdge(r,i?.distanceTolerance,i?.parameterTolerance),n=this._workFacetDetail3=$n.create(t.currentReadIndex(),r,this._workFacetDetail3)}else{const i=this._workPolyDetail=zr.intersectRay3d(o,e,s,this._workPolyDetail);n=zr.isConvex(o)?this._workFacetDetailC=es.create(t.currentReadIndex(),r,i,this._workFacetDetailC):this._workFacetDetailNC=ts.create(t.currentReadIndex(),r,i,this._workFacetDetailNC)}if(n.isInsideOrOn){if(i?.needNormal&&t.normal&&n.getNormal(t.normal,o,i?.distanceTolerance),i?.needParam&&t.param&&n.getParam(t.param,o,i?.distanceTolerance),i?.needColor&&t.color&&n.getColor(t.color,o,i?.distanceTolerance),i?.needBarycentricCoordinates&&n.getBarycentricCoordinates(o,i?.distanceTolerance),i?.acceptIntersection&&!i.acceptIntersection(n,t))continue;return n}}}}class As{static hugeVal=1e37;_planes;constructor(t){this._planes=t||[]}toJSON(){const t=[];for(const e of this._planes)t.push(e.toJSON());return t}static fromJSON(t,e){if((e=e||new As)._planes.length=0,!Array.isArray(t))return e;for(const i of t){const t=Vr.fromJSON(i);t&&e._planes.push(t)}return e}isAlmostEqual(t){if(this._planes.length!==t._planes.length)return!1;for(let e=0;e<this._planes.length;e++)if(!this._planes[e].isAlmostEqual(t._planes[e]))return!1;return!0}static createPlanes(t,e){e=e||new As;for(const i of t)if(i instanceof Vr)e._planes.push(i);else if(i instanceof yt){const t=Vr.createPlane(i);e._planes.push(t)}return e}static createRange3dPlanes(t,e=!0,i=!0,n=!0,s=!0,r=!0,o=!0){const a=As.createEmpty();return e&&a.planes.push(Vr.createNormalAndPointXYZXYZ(1,0,0,t.low.x,0,0)),i&&a.planes.push(Vr.createNormalAndPointXYZXYZ(-1,0,0,t.high.x,0,0)),n&&a.planes.push(Vr.createNormalAndPointXYZXYZ(0,1,0,0,t.low.y,0)),s&&a.planes.push(Vr.createNormalAndPointXYZXYZ(0,-1,0,0,t.high.y,0)),r&&a.planes.push(Vr.createNormalAndPointXYZXYZ(0,0,1,0,0,t.low.z)),o&&a.planes.push(Vr.createNormalAndPointXYZXYZ(0,0,-1,0,0,t.high.z)),a}static createEmpty(t){return t?(t._planes.length=0,t):new As}negateAllPlanes(){for(const t of this._planes)t.negateInPlace()}static createXYBox(t,e,i,n,s){(s=s||new As)._planes.length=0;const r=Vr.createNormalAndDistance(tt.create(-1,0,0),-i,!1,!0),o=Vr.createNormalAndDistance(tt.create(1,0,0),t,!1,!0),a=Vr.createNormalAndDistance(tt.create(0,-1,0),-n,!1,!0),c=Vr.createNormalAndDistance(tt.create(0,1,0),e,!1,!0);return r&&o&&a&&c&&s._planes.push(r,o,a,c),s}static createXYPolyLine(t,e,i,n){(n=n||new As)._planes.length=0;for(let s=0;s+1<t.length;s++){const r=tt.createStartEnd(t[s],t[s+1]).unitPerpendicularXY();if(r.z=0,i||r.scaleInPlace(-1),r.normalize()){const i=void 0!==e&&e[s],o=Vr.createNormalAndPoint(r,t[s],i,i);o&&n._planes.push(o)}}return n}static createXYPolyLineInsideLeft(t,e){(e=e||new As)._planes.length=0;for(let i=0;i+1<t.length;i++){const n=tt.createStartEnd(t[i],t[i+1]).unitPerpendicularXY();if(n.z=0,n.normalize()){const s=Vr.createNormalAndPoint(n,t[i],!1,!1);s&&e._planes.push(s)}}return e}static setPlaneAndXYLoopCCW(t,e,i){const n=t.length-1,s=t.length;let r,o,a,c,l=t.getXAtUncheckedPointIndex(n),h=t.getYAtUncheckedPointIndex(n);i._planes.length=0;const d=t.getZAtUncheckedPointIndex(n),u=t.crossProductIndexIndexIndex(0,2,1);if(Vr.createNormalAndPointXYZXYZ(u.x,u.y,u.z,l,h,d,!1,!1,e),u.normalizeInPlace())for(let e=0;e<s;e++,l=r,h=o){r=t.getXAtUncheckedPointIndex(e),o=t.getYAtUncheckedPointIndex(e),a=-(o-h),c=r-l;const n=Vr.createNormalAndPointXYZXYZ(a,c,0,r,o,d);n&&i._planes.push(n)}}clone(t){(t=t||new As)._planes.length=0;for(const e of this._planes)t._planes.push(e.clone());return t}get planes(){return this._planes}hasIntersectionWithRay(t,e,i=J.smallMetricDistance){let n=-J.largeCoordinateResult,s=J.largeCoordinateResult;e&&e.setNull();for(const e of this._planes){const r=e.velocity(t.direction),o=e.altitude(t.origin);if(Math.abs(r)<=1e-13){if(o<-i)return!1}else{const t=-o/r;r<0?t<s&&(s=t):t>n&&(n=t)}}return!(s<n||(e&&(e.extendX(n),e.extendX(s)),0))}multiplyPlanesByMatrix4d(t,e=!0,i=!0){if(e){const e=t.createInverse();return!!e&&this.multiplyPlanesByMatrix4d(e,!1,i)}for(const e of this._planes)e.multiplyPlaneByMatrix4d(t,!1,i);return!0}isPointInside(t){for(const e of this._planes)if(!e.isPointInside(t))return!1;return!0}isPointOnOrInside(t,e=J.smallMetricDistance){const i=Math.abs(e);for(const n of this._planes)if(!n.isPointOnOrInside(t,n.interior?i:e))return!1;return!0}isSphereInside(t,e){const i=Math.abs(e)+J.smallMetricDistance;for(const e of this._planes)if(!e.isPointOnOrInside(t,i))return!1;return!0}announceClippedSegmentIntervals(t,e,i,n,s){let r;if(e<t)return!1;for(const s of this._planes){const o=-s.altitude(i),a=-s.altitude(n);if(r=J.conditionalDivideFraction(-o,a-o),void 0===r){if(o>0)return!1}else if(a>o){if(r<t)return!1;r<e&&(e=r)}else if(o>a){if(r>e)return!1;r>t&&(t=r)}else if(o>0)return!1}return e>=t&&(s&&s(t,e),!0)}static _clipArcFractionArray=new bt;announceClippedArcIntervals(t,e){const i=As._clipArcFractionArray;i.clear();for(const e of this.planes)e.appendIntersectionRadians(t,i);return t.sweep.radiansArrayToPositivePeriodicFractions(i),kn.selectIntervals01(t,i,this,e)}clipUnboundedSegment(t,e,i){return this.announceClippedSegmentIntervals(-Number.MAX_VALUE,Number.MAX_VALUE,t,e,i)}transformInPlace(t){for(const e of this._planes)e.transformInPlace(t)}clipConvexPolygonInPlace(t,e,i=J.smallMetricDistance){for(const n of this._planes)if(n.clipConvexPolygonInPlace(t,e,!0,i),t.length<3)return}clipInsidePushOutside(t,e,i){const n=gt.createNull();let s=i.grabFromCache(),r=i.grabFromCache(),o=i.grabFromCache();o.pushFrom(t);for(const t of this._planes)if(Lr.splitConvexPolygonInsideOutsidePlane(t,o,s,r,n),r.length>0){if(e&&kn.captureOrDrop(r,3,e,i),r=i.grabFromCache(),0===s.length){o.length=0;break}i.dropToCache(o),o=s,s=i.grabFromCache()}if(i.dropToCache(s),i.dropToCache(r),o.length>0)return o;i.dropToCache(o)}classifyPointContainment(t,e){let i=!0;const n=e?1e-8:-1e-8;for(const e of this._planes){let s=0;for(const r of t)e.altitude(r)<(e.interior?1e-8:n)&&(s++,i=!1);if(s===t.length)return R.StronglyOutside}return i?R.StronglyInside:R.Ambiguous}static createSweptPolyline(t,e,i){const n=As.createEmpty();let s=!1;t.length>3&&t[0].isAlmostEqual(t[t.length-1])&&zr.areaNormal(t).dotProduct(e)>0&&(s=!0);for(let r=0;r+1<t.length;r++)if(s){const s=Vr.createEdgeAndUpVector(t[r+1],t[r],e,i);if(!s)return;n.addPlaneToConvexSet(s)}else{const s=Vr.createEdgeAndUpVector(t[r],t[r+1],e,i);if(!s)return;n.addPlaneToConvexSet(s)}return n}addPlaneToConvexSet(t){t instanceof Vr?this._planes.push(t):t instanceof yt&&this._planes.push(Vr.createPlane(t))}clipPointsOnOrInside(t,e,i){e.length=0,i.length=0;for(const n of t)this.isPointOnOrInside(n,0)?e.push(n):i.push(n)}polygonClip(t,e,i,n){t instanceof rt?t.clone(e):rt.create(t,e);for(const t of this._planes)if(n!==t){if(0===e.length)break;t.clipConvexPolygonInPlace(e,i)}}reloadSweptPolygon(t,e,i){this._planes.length=0;const n=t.length;if(n<=2)return 0;const s=zr.areaNormal(t),r=e.dotProduct(s)>0,o=r?1:n-1;for(let i=0;i<n;i++){const s=(i+o)%n,r=t[i],a=t[s];if(r.isAlmostEqual(a))continue;const c=tt.createStartEnd(r,a),l=tt.createCrossProduct(e.x,e.y,e.z,c.x,c.y,c.z).normalize();let h;if(l){h=l.dotProduct(r);const t=Vr.createNormalAndDistance(l,h,!1,!1);t&&this._planes.push(t)}}if(0!==i){let n=s.normalize();if(n){e.dotProduct(n)*i<0&&(n=n.negate());const s=t[0],r=n.dotProduct(s),o=Vr.createNormalAndDistance(n,r,!1,!1);o&&this._planes.push(o)}}return r?1:-1}computePlanePlanePlaneIntersections(t,e,i,n=!0){const s=xt.createIdentity(),r=this._planes,o=r.length;let a=0;for(let c=0;c<o;c++)for(let l=c+1;l<o;l++)for(let h=l+1;h<o;h++)if(xt.createRowValues(r[c].inwardNormalRef.x,r[c].inwardNormalRef.y,r[c].inwardNormalRef.z,r[l].inwardNormalRef.x,r[l].inwardNormalRef.y,r[l].inwardNormalRef.z,r[h].inwardNormalRef.x,r[h].inwardNormalRef.y,r[h].inwardNormalRef.z,s),s.computeCachedInverse(!1)){const o=s.multiplyInverseXYZAsPoint3d(r[c].distance,r[l].distance,r[h].distance);n&&!this.isPointOnOrInside(o,J.smallMetricDistance)||(a++,i&&i.multiplyPoint3d(o,o),t&&t.push(o),e&&e.extendPoint(o))}return a}setInvisible(t){for(const e of this._planes)e.setInvisible(t)}addZClipPlanes(t,e,i){void 0!==e&&this._planes.push(Vr.createNormalAndDistance(tt.create(0,0,1),e,t)),void 0!==i&&this._planes.push(Vr.createNormalAndDistance(tt.create(0,0,-1),-i,t))}appendPolygonClip(t,e,i,n){const s=this.clipInsidePushOutside(t,i,n);s&&e.push(s)}static createConvexPolyface(t,e){e=this.createEmpty(e);let i=0;bs.isPolyfaceClosedByEdgePairing(t)&&(i=bs.sumTetrahedralVolumes(t));const n=i>0?-1:1,s=tt.create(),r=yt.createXYPlane(),o=t instanceof Gi?t.createVisitor(0):t;for(o.setNumWrap(0),o.reset();o.moveToNextFacet();)void 0!==zr.areaNormalGo(o.point,s)&&(s.scaleInPlace(n),void 0!==yt.create(o.point.front(),s,r)&&e.addPlaneToConvexSet(r));return{clipper:e,volume:i}}}class Cs{curves;localToWorld;axis;_xyStrokes;_facets;constructor(t,e,i){if(t instanceof le){const e=t;(t=t.startPoint().isAlmostEqual(t.endPoint())?new oi:new ii).tryAddChild(e)}this.curves=t,this.localToWorld=e,this.axis=i}static createForLinearSweep(t,e){const i=bi.createRightHandedFrame(e,t);if(i)return new Cs(t,i,void 0)}static createForPolygon(t,e){const i=bi.createRightHandedFrame(e,t);if(i){const e=Fe.createArrayOfLineString3d(t),n=[];for(const t of e)t.addClosurePoint(),n.push(oi.create(t));if(1===n.length)return new Cs(n[0],i,void 0);if(n.length>1)return new Cs(Ti.createLoops(n),i,void 0)}}static createForRotation(t,e){const i=bi.createRightHandedFrame(void 0,t,e);if(i)return new Cs(t,i,e.clone())}getCurves(){return this.curves}tryTransformInPlace(t){if(this.curves.tryTransformInPlace(t)){this.axis&&this.axis.transformInPlace(t);const e=void 0!==this.axis?bi.createRightHandedFrame(void 0,this.curves,this.axis):bi.createRightHandedFrame(void 0,this.curves);if(e)return this.localToWorld.setFrom(e),this._xyStrokes=void 0,!0}return!1}clone(){return new Cs(this.curves.clone(),this.localToWorld.clone(),this.axis)}cloneTransformed(t){const e=this.clone();if(e.tryTransformInPlace(t))return e}isAlmostEqual(t){if(!(t instanceof Cs))return!1;if(!this.curves.isAlmostEqual(t.curves))return!1;if(!this.localToWorld.isAlmostEqual(t.localToWorld))return!1;if(this.axis&&t.axis){if(!this.axis.isAlmostEqual(t.axis))return!1}else if(this.axis||t.axis)return!1;return!0}computeXYStrokes(t){this._xyStrokes=void 0;const e=this.localToWorld.inverse();if(e){const i=this.curves.cloneStroked(t);i.tryTransformInPlace(e)&&(this._xyStrokes=i)}}get xyStrokes(){return this._xyStrokes}buildFacets(t){if(this._facets)return;if(!this.curves.isAnyRegion())return;const e=this.localToWorld.inverse();if(!e)return;const i=this.curves.cloneTransformed(e);i&&(this._facets=wr.facetRegionXY(i,t))&&this._facets.tryTransformInPlace(this.localToWorld)}purgeFacets(){this._facets=void 0}emitFacets(t,e,i){this.buildFacets(t.options),this._facets&&t.addIndexedPolyface(this._facets,e,i)}announceFacets(t,e){this.buildFacets(e),this._facets&&t(this._facets)}sweepToUnionOfConvexClipPlaneSets(t,e=!1,i=!1,n){n||(n=be.createForFacets()),t||(e=i=!1,t=this.localToWorld.matrix.columnZ()),n.maximizeConvexFacets=!0,this.buildFacets(n);const s=this._facets;if(s){const n=$.create(),r=$.create(),o=_n.createEmpty(),a=s.createVisitor(1);for(a.reset();a.moveToNextFacet();){const e=a.point.length-1,i=As.createEmpty();for(let s=0;s<e;s++){a.point.getPoint3dAtUncheckedPointIndex(s,n),a.point.getPoint3dAtUncheckedPointIndex(s+1,r);const e=Vr.createEdgeAndUpVector(r,n,t),o=a.edgeVisible[s];e?.setFlags(!o,!o),i.addPlaneToConvexSet(e)}o.addConvexSet(i)}if(e||i){const n=this.localToWorld.matrix.columnZ(),s=this.localToWorld.getOrigin(),r=s.plus(t),a=n.clone(),c=n.negate(),l=As.createEmpty();e&&l.addPlaneToConvexSet(Vr.createNormalAndPoint(a,s)),i&&l.addPlaneToConvexSet(Vr.createNormalAndPoint(c,r)),o.addConvexSet(l)}return o}}}class Ts extends ki{solidPrimitiveType="ruledSweep";_contours;constructor(t,e){super(e),this._contours=t}static create(t,e){const i=[];for(const e of t){const t=Cs.createForLinearSweep(e);if(void 0===t)return;i.push(t)}return new Ts(i,e)}sweepContoursRef(){return this._contours}cloneSweepContours(){const t=[];for(const e of this._contours)t.push(e.clone());return t}cloneContours(){const t=[];for(const e of this._contours)t.push(e.curves.clone());return t}clone(){return new Ts(this.cloneSweepContours(),this.capped)}tryTransformInPlace(t){if(t.matrix.isSingular())return!1;for(const e of this._contours)if(!e.tryTransformInPlace(t))return!1;return!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t)?e:void 0}getConstructiveFrame(){if(0!==this._contours.length)return this._contours[0].localToWorld.cloneRigid()}isSameGeometryClass(t){return t instanceof Ts}isAlmostEqual(t){if(t instanceof Ts){if(this.capped!==t.capped)return!1;if(this._contours.length!==t._contours.length)return!1;for(let e=0;e<this._contours.length;e++)if(!this._contours[e].isAlmostEqual(t._contours[e]))return!1;return!0}return!1}dispatchToGeometryHandler(t){return t.handleRuledSweep(this)}constantVSection(t){const e=this._contours.length;if(e<2)return;const i=t*e;let n=0;n=t>=1?e-1:Math.floor(i),n+1>=e&&(n=e-2);const s=n+1,r=J.clampToStartEnd(i-n,0,1);return Ts.mutatePartners(this._contours[n].curves,this._contours[s].curves,((t,e)=>{const i=Ei.interpolateBetween(t,r,e);if(i instanceof le)return i}))}extendRange(t,e){for(const i of this._contours)i.curves.extendRange(t,e)}static mutatePartners(t,e,i){if(t.isSameGeometryClass(e)){if(t instanceof ti&&e instanceof ti){const n=t,s=e,r=n.cloneEmptyPeer(),o=n.children,a=s.children;if(o.length!==a.length)return;for(let t=0;t<o.length;t++){const e=i(o[t],a[t]);if(!e)return;r.children.push(e)}return r}if(t instanceof $e&&e instanceof $e){const n=t.cloneEmptyPeer(),s=t.children,r=e.children,o=n.children;if(void 0===s||void 0===r||void 0===o||s.length!==r.length)return;for(let t=0;t<s.length;t++){const e=s[t],n=r[t];if(e instanceof le&&n instanceof le){const t=i(e,n);if(!t)return;o.push(t)}else if(e instanceof $e&&n instanceof $e){const t=this.mutatePartners(e,n,i);if(!t)return;t instanceof $e&&o.push(t)}}return n}}}get isClosedVolume(){const t=this._contours.length;return t>1&&(this.capped||this._contours[0].isAlmostEqual(this._contours[t-1]))}}class ws extends ki{solidPrimitiveType="torusPipe";_localToWorld;_radiusA;_radiusB;_sweep;_isReversed;constructor(t,e,i,n,s){super(s),this._localToWorld=t,this._radiusA=e,this._radiusB=i,this._sweep=n,this._isReversed=!1}clone(){const t=new ws(this._localToWorld.clone(),this._radiusA,this._radiusB,this._sweep.clone(),this.capped);return t._isReversed=this._isReversed,t}tryTransformInPlace(t){return!t.matrix.isSingular()&&(t.multiplyTransformTransform(this._localToWorld,this._localToWorld),!0)}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t)?e:void 0}static createInFrame(t,e,i,n,s){if((e=Math.abs(J.correctSmallMetricDistance(e)))<(i=Math.abs(J.correctSmallMetricDistance(i))))return;if(0===e)return;if(0===i)return;if(n.isAlmostZero)return;let r=1,o=1,a=!1;t.matrix.determinant()<0&&(o*=-1);const c=n.clone();n.radians<0&&(c.setRadians(-n.radians),o*=-1,r*=-1,a=!0);const l=t.clone();l.matrix.scaleColumnsInPlace(1,r,o);const h=new ws(l,e,i,c,s);return h._isReversed=a,h}static createDgnTorusPipe(t,e,i,n,s,r,o){const a=e.unitCrossProductWithDefault(i,0,0,1),c=mt.createOriginAndMatrixColumns(t,e,i,a);return ws.createInFrame(c,n,s,r,o)}static createAlongArc(t,e,i){if(G.isAlmostEqualRadiansAllowPeriodShift(0,t.sweep.startRadians)||(t=t.cloneInRotatedBasis(t.sweep.startAngle)),!t.isCircular){const e=t.perpendicularVector.sizedCrossProduct(t.vector0,t.matrixRef.columnXMagnitude());if(!e)return;t=Si.create(t.center,t.vector0,e,t.sweep)}const n=t.toScaledMatrix3d(),s=mt.createOriginAndMatrix(t.center,n.axes);return ws.createInFrame(s,n.r0,e,G.createRadians(t.sweep.sweepRadians),i)}getConstructiveFrame(){return this._localToWorld.cloneRigid()}cloneCenter(){return this._localToWorld.getOrigin()}cloneVectorX(){const t=this._localToWorld.matrix.columnX();return t.normalizeWithDefault(1,0,0,t)}cloneVectorY(){const t=this._localToWorld.matrix.columnY();return t.normalizeWithDefault(0,1,0,t)}cloneVectorZ(){const t=this._localToWorld.matrix.columnZ();return t.normalizeWithDefault(0,0,1,t)}getMajorRadius(){return this._radiusA*this._localToWorld.matrix.columnXMagnitude()}getMinorRadius(){return this._radiusB*this._localToWorld.matrix.columnZMagnitude()}getSweepAngle(){return this._sweep.clone()}getIsReversed(){return this._isReversed}getThetaFraction(){return this._sweep.radians/(2*Math.PI)}cloneLocalToWorld(){return this._localToWorld.clone()}isSameGeometryClass(t){return t instanceof ws}isAlmostEqual(t){return!!(t instanceof ws&&(this._sweep.isFullCircle||this.capped===t.capped)&&this.cloneCenter().isAlmostEqual(t.cloneCenter())&&this.cloneVectorX().isAlmostEqual(t.cloneVectorX())&&this.cloneVectorY().isAlmostEqual(t.cloneVectorY())&&this.cloneVectorZ().isAlmostEqual(t.cloneVectorZ())&&J.isSameCoordinate(this.getMinorRadius(),t.getMinorRadius())&&J.isSameCoordinate(this.getMajorRadius(),t.getMajorRadius())&&this.getSweepAngle().isAlmostEqualNoPeriodShift(t.getSweepAngle()))}vFractionToRadians(t){return this._sweep.radians*t}dispatchToGeometryHandler(t){return t.handleTorusPipe(this)}constantVSection(t){const e=this.vFractionToRadians(t),i=Math.cos(e),n=Math.sin(e),s=this._radiusA,r=this._radiusB,o=this._localToWorld.multiplyXYZ(s*i,s*n,0),a=this._localToWorld.multiplyVectorXYZ(r*i,r*n,0),c=this._localToWorld.multiplyVectorXYZ(0,0,r);return oi.create(Si.create(o,a,c))}constantUSection(t){const e=this._sweep.radians,i=2*t*Math.PI,n=this._radiusA,s=this._radiusB,r=this._localToWorld.matrix,o=this._localToWorld.multiplyXYZ(0,0,s*Math.sin(i)),a=n+s*Math.cos(i),c=r.multiplyXYZ(a,0,0),l=r.multiplyXYZ(0,a,0);return ii.create(Si.create(o,c,l,St.createStartEndRadians(0,e)))}extendRange(t,e){const i=this._sweep.radians,n=this._radiusA,s=this._radiusB,r=this._localToWorld,o=Math.ceil(i/(Math.PI/16));let a=0,c=0,l=0,h=0,d=0,u=0,f=0,g=0,p=0;const m=i/o;for(let i=0;i<=o;i++)if(h=i*m,d=Math.cos(h),u=Math.sin(h),0===i||i===o?(a=-Math.PI,c=2*Math.PI/16,l=16):(a=-.5*Math.PI,c=Math.PI/16,l=31),e)for(p=0;p<=l;p++)g=a+p*c,f=n+s*Math.cos(g),t.extendTransformTransformedXYZ(e,r,d*f,u*f,Math.sin(g)*s);else for(p=0;p<=l;p++)g=a+p*c,f=n+s*Math.cos(g),t.extendTransformedXYZ(r,d*f,u*f,Math.sin(g)*s)}uvFractionToPoint(t,e,i){const n=e*this._sweep.radians,s=t*Math.PI*2,r=Math.cos(n),o=Math.sin(n),a=this._radiusA,c=this._radiusB,l=a+Math.cos(s)*c;return this._localToWorld.multiplyXYZ(l*r,l*o,c*Math.sin(s),i)}uvFractionToPointAndTangents(t,e,i){const n=e*this._sweep.radians,s=t*Math.PI*2,r=this._sweep.radians,o=2*Math.PI,a=Math.cos(n),c=Math.sin(n),l=Math.sin(s),h=Math.cos(s),d=this._radiusA,u=this._radiusB,f=d+Math.cos(s)*u,g=u*l,p=u*h;return Mt.createOriginAndVectors(this._localToWorld.multiplyXYZ(a*f,c*f,g),this._localToWorld.multiplyVectorXYZ(-a*g*o,-c*g*o,p*o),this._localToWorld.multiplyVectorXYZ(-f*c*r,f*a*r,0),i)}maxIsoParametricDistance(){const t=Math.abs(this.getMajorRadius()),e=Math.abs(this.getMinorRadius());return j.create(e*Math.PI*2,(t+e)*this._sweep.radians)}get isClosedVolume(){return this.capped||this._sweep.isFullCircle}}class Es extends le{_spiralType;_designProperties;_activeFractionInterval;get activeFractionInterval(){return this._activeFractionInterval}_localToWorld;get localToWorld(){return this._localToWorld}constructor(t,e,i,n){super(),this._spiralType=t||"unknownSpiralType",this._designProperties=n,this._localToWorld=e,this._activeFractionInterval=i||De.create(0,1)}get spiralType(){return this._spiralType}static radiusToCurvature(t){return 0===t?0:1/t}static curvatureToRadius(t){return Math.abs(t)<J.smallAngleRadians?0:1/t}clonePartialCurve(t,e){const i=this.clone(),n=this._activeFractionInterval.fractionToPoint(t),s=this._activeFractionInterval.fractionToPoint(e);return i._activeFractionInterval.set(n,s),i.refreshComputedProperties(),i}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}static averageCurvature(t){return.5*(Es.radiusToCurvature(t.x0)+Es.radiusToCurvature(t.x1))}static averageCurvatureR0R1(t,e){return.5*(Es.radiusToCurvature(t)+Es.radiusToCurvature(e))}static interpolateCurvatureR0R1(t,e,i){return J.interpolate(Es.radiusToCurvature(t),e,Es.radiusToCurvature(i))}static radiusRadiusSweepRadiansToArcLength(t,e,i){return Math.abs(i/Es.averageCurvatureR0R1(t,e))}static radiusRadiusLengthToSweepRadians(t,e,i){return Es.averageCurvatureR0R1(t,e)*i}static radius0LengthSweepRadiansToRadius1(t,e,i){return Es.curvatureToRadius(2*i/e-Es.radiusToCurvature(t))}static radius1LengthSweepRadiansToRadius0(t,e,i){return Es.curvatureToRadius(2*i/e-Es.radiusToCurvature(t))}get designProperties(){return this._designProperties}applyRigidPartOfTransform(t){const e=t.matrix.factorRigidWithSignedScale();if(void 0!==e){const i=t.multiplyTransformTransform(this.localToWorld),n=e.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);return this._localToWorld=mt.createOriginAndMatrix(i.origin,n),this.designProperties&&this.designProperties.applyScaleFactor(e.scale),e}}constructOffsetXY(t){const e=Ce.create(t),i=new ve(this,e.leftOffsetDistance);return this.emitStrokableParts(i,e.strokeOptions),i.claimResult()}extendRange(t,e){const i=this.rangeBetweenFractions(0,1,e);t.extendRange(i)}rangeBetweenFractions(t,e,i){const n=this.activeStrokes;if(void 0===n)return ft.createNull();let s=Math.ceil(n.numPoints()*Math.abs(e-t));return s=J.clamp(5,s,30),this.rangeBetweenFractionsByCount(t,e,s,i,.5)}projectedParameterRange(t,e){return Me.findExtremeFractionsAlongDirection(this,t,e)}}class ks{constructor(){}static _clothoidEvaluator;static _biquadraticEvaluator;static _blossEvaluator;static _sineEvaluator;static _cosineEvaluator;static findEvaluator(t){return"clothoid"===t?this._clothoidEvaluator?this._clothoidEvaluator:this._clothoidEvaluator=new Fs:"bloss"===t?this._blossEvaluator?this._blossEvaluator:this._blossEvaluator=new Rs:"biquadratic"===t?this._biquadraticEvaluator?this._biquadraticEvaluator:this._biquadraticEvaluator=new Ms:"sine"===t?this._sineEvaluator?this._sineEvaluator:this._sineEvaluator=new Ds:"cosine"===t?this._cosineEvaluator?this._cosineEvaluator:this._cosineEvaluator=new Os:void 0}}class Fs extends ks{constructor(){super()}fractionToCurvatureFraction(t){return t}fractionToCurvatureFractionDerivative(t){return 1}fractionToArea(t){return t*t*.5}}class Rs extends ks{constructor(){super()}fractionToCurvatureFraction(t){return t*t*(3-2*t)}fractionToCurvatureFractionDerivative(t){return 6*t*(1-t)}fractionToArea(t){return t*t*t*(1-.5*t)}}class Ms extends ks{constructor(){super()}integratedBasis(t){return t*t*t*(2/3)}basis(t){return 2*t*t}basisDerivative(t){return 4*t}fractionToCurvatureFraction(t){return t<=.5?this.basis(t):1-this.basis(1-t)}fractionToCurvatureFractionDerivative(t){return t<.5?this.basisDerivative(t):this.basisDerivative(1-t)}fractionToArea(t){if(t<=.5)return this.integratedBasis(t);const e=1-t;return.5-e+this.integratedBasis(e)}}class Ds extends ks{constructor(){super()}fractionToCurvatureFraction(t){const e=2*Math.PI;return t-Math.sin(t*e)/e}fractionToCurvatureFractionDerivative(t){const e=2*Math.PI;return 1-Math.cos(t*e)}fractionToArea(t){const e=2*Math.PI;return.5*t*t+(Math.cos(t*e)-1)/(e*e)}}class Os extends ks{constructor(){super()}fractionToCurvatureFraction(t){const e=Math.PI;return.5*(1-Math.cos(t*e))}fractionToCurvatureFractionDerivative(t){const e=Math.PI;return.5*e*Math.sin(t*e)}fractionToArea(t){const e=Math.PI;return.5*t-.5*Math.sin(t*e)/e}}class Bs{radius0;radius1;bearing0;bearing1;curveLength;constructor(t,e,i,n,s){this.radius0=t,this.radius1=e,this.bearing0=i,this.bearing1=n,this.curveLength=s}numDefinedProperties(){return J.defined01(this.radius0)+J.defined01(this.radius1)+J.defined01(this.bearing0)+J.defined01(this.bearing1)+J.defined01(this.curveLength)}clone(){return new Bs(this.radius0,this.radius1,void 0===this.bearing0?void 0:this.bearing0.clone(),void 0===this.bearing1?void 0:this.bearing1.clone(),this.curveLength)}getIsValidCompleteSet(){if(void 0!==this.curveLength&&void 0!==this.bearing0&&void 0!==this.bearing1&&void 0!==this.radius0&&void 0!==this.radius1){const t=Es.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,this.bearing1.radians-this.bearing0.radians);return J.isSameCoordinate(this.curveLength,t)}return!1}tryResolveAnySingleUnknown(){if(this.getIsValidCompleteSet())return!0;if(this.bearing0&&this.bearing1){const t=this.bearing1.radians-this.bearing0.radians;return void 0===this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1?(this.curveLength=Es.radiusRadiusSweepRadiansToArcLength(this.radius0,this.radius1,t),!0):void 0!==this.curveLength&&void 0===this.radius0&&void 0!==this.radius1?(this.radius0=Es.radius1LengthSweepRadiansToRadius0(this.radius1,this.curveLength,t),!0):void 0!==this.curveLength&&void 0!==this.radius0&&void 0===this.radius1&&(this.radius1=Es.radius0LengthSweepRadiansToRadius1(this.radius0,this.curveLength,t),!0)}return void 0!==this.curveLength&&void 0!==this.radius0&&void 0!==this.radius1&&(this.bearing0?(this.bearing1=G.createRadians(this.bearing0.radians+Es.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0):!!this.bearing1&&(this.bearing0=G.createRadians(this.bearing1.radians-Es.radiusRadiusLengthToSweepRadians(this.radius0,this.radius1,this.curveLength)),!0))}almostEqualCoordinate(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&J.isSameCoordinate(t,e)}almostEqualBearing(t,e){return void 0===t&&void 0===e||void 0!==t&&void 0!==e&&t.isAlmostEqualNoPeriodShift(e)}isAlmostEqual(t){return!!(t&&this.almostEqualCoordinate(this.radius0,t.radius0)&&this.almostEqualCoordinate(this.radius1,t.radius1)&&this.almostEqualBearing(this.bearing0,t.bearing0)&&this.almostEqualBearing(this.bearing1,t.bearing1)&&this.almostEqualCoordinate(this.curveLength,t.curveLength))}applyScaleFactor(t){void 0!==this.radius0&&(this.radius0*=t),void 0!==this.radius1&&(this.radius1*=t),void 0!==this.curveLength&&(this.curveLength*=t)}static areAlmostEqual(t,e){return void 0===t?void 0===e:t.isAlmostEqual(e)}}class Ns extends Es{curvePrimitiveType="transitionSpiral";radius01;bearing01;_globalStrokes;_activeStrokes;get activeStrokes(){return void 0!==this._activeStrokes?this._activeStrokes:this._globalStrokes}_evaluator;_arcLength01;_curvature01;constructor(t,e,i,n,s,r,o,a){super(t,r,s,a),this._evaluator=e,this.radius01=i,this.bearing01=n,this._arcLength01=o,this._globalStrokes=Fe.create(),this._curvature01=De.create(0,1),this.refreshComputedProperties()}static defaultSpiralType="clothoid";globalFractionToBearingRadians(t){const e=this._evaluator.fractionToArea(t),i=this._arcLength01;return this.bearing01.startRadians+e*i*this._curvature01.signedDelta()+t*this._curvature01.x0*i}globalFractionToCurvature(t){const e=this._evaluator.fractionToCurvatureFraction(t);return this._curvature01.fractionToPoint(e)}fractionToBearingRadians(t){const e=this.activeFractionInterval.fractionToPoint(t);return this.bearing01.startRadians+e*this._arcLength01*(this._curvature01.x0+.5*e*(this._curvature01.x1-this._curvature01.x0))}fractionToCurvature(t){return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(t))}static _gaussFraction;static _gaussWeight;static _gaussMapper;static initWorkSpace(){Ns._gaussFraction=new Float64Array(5),Ns._gaussWeight=new Float64Array(5),Ns._gaussMapper=(t,e,i,n)=>oe.setupGauss5(t,e,i,n)}fullSpiralIncrementalIntegral(t,e,i,n){const s=Ns._gaussFraction,r=Ns._gaussWeight,o=Ns._gaussMapper(e,i,s,r),a=this._arcLength01;let c=0,l=0,h=0;for(let t=0;t<o;t++){const e=this.globalFractionToBearingRadians(s[t]);c=r[t]*a,l+=c*Math.cos(e),h+=c*Math.sin(e)}n?xt.xyzPlusMatrixTimesXYZ(t,this.localToWorld.matrix,{x:l,y:h,z:0},t):t.addXYZInPlace(l,h,0)}refreshComputedProperties(){this._curvature01=De.create(Es.radiusToCurvature(this.radius01.x0),Es.radiusToCurvature(this.radius01.x1)),this._globalStrokes.clear();const t=$.create();this._globalStrokes.appendStrokePoint(t);const e=1/16;for(let i=1;i<=16;i++){const n=(i-1)*e,s=i*e;this.fullSpiralIncrementalIntegral(t,n,s,!1),this._globalStrokes.appendStrokePoint(t)}if(this._globalStrokes.tryTransformInPlace(this.localToWorld),!this.activeFractionInterval.isExact01){void 0===this._activeStrokes&&(this._activeStrokes=Fe.create()),this._activeStrokes.clear();for(let t=0;t<=16;t++){const i=t*e;this._activeStrokes.addPoint(this.fractionToPoint(i))}}}static createRadiusRadiusBearingBearing(t,e,i,n,s){const r=Es.radiusRadiusSweepRadiansToArcLength(t.x0,t.x1,e.sweepRadians);void 0===s&&(s="clothoid");const o=ks.findEvaluator(s);if(o)return new Ns(s,o,t.clone(),e.clone(),i.clone(),n.clone(),r,new Bs(t.x0,t.x1,e.startAngle.clone(),e.endAngle.clone(),void 0))}static createFrom4OutOf5(t,e,i,n,s,r,o,a){void 0===t&&(t="clothoid");const c=ks.findEvaluator(t);if(!c)return;const l=new Bs(e,i,n,s,r),h=l.clone();return l.tryResolveAnySingleUnknown()?(void 0===o&&(o=De.create(0,1)),new Ns(t,c,De.create(l.radius0,l.radius1),St.createStartEnd(l.bearing0,l.bearing1),o?o.clone():De.create(0,1),a,l.curveLength,h)):void 0}setFrom(t){return this.localToWorld.setFrom(t.localToWorld),this.radius01.setFrom(t.radius01),this._curvature01.setFrom(t._curvature01),this.bearing01.setFrom(t.bearing01),this.localToWorld.setFrom(t.localToWorld),this.activeFractionInterval.setFrom(t.activeFractionInterval),this._arcLength01=t._arcLength01,this}clone(){return new Ns(this._spiralType,this._evaluator,this.radius01.clone(),this.bearing01.clone(),this.activeFractionInterval.clone(),this.localToWorld.clone(),this._arcLength01,this._designProperties?.clone())}tryTransformInPlace(t){const e=this.applyRigidPartOfTransform(t);return void 0!==e&&(this._curvature01.x0/=e.scale,this._curvature01.x1/=e.scale,this.radius01.x0*=e.scale,this.radius01.x1*=e.scale,this._arcLength01*=e.scale),this.refreshComputedProperties(),!0}startPoint(){return this.activeStrokes.startPoint()}endPoint(){return this.activeStrokes.endPoint()}isInPlane(t){return t.isPointInPlane(this.localToWorld.origin)&&J.isSameCoordinate(0,this.localToWorld.matrix.dotColumnX(t.getNormalRef()))&&J.isSameCoordinate(0,this.localToWorld.matrix.dotColumnY(t.getNormalRef()))}quickLength(){return this.curveLength()}curveLength(){return this._arcLength01*this._activeFractionInterval.absoluteDelta()}curveLengthBetweenFractions(t,e){return this._arcLength01*(this._activeFractionInterval.absoluteDelta()*Math.abs(e-t))}isSameGeometryClass(t){return t instanceof Es}emitStrokes(t,e){this.activeStrokes.emitStrokes(t,e)}emitStrokableParts(t,e){const i=this.computeStrokeCountForOptions(e);t.startParentCurvePrimitive(this);const n=this.activeStrokes;(void 0===t.needPrimaryGeometryForStrokes||!t.needPrimaryGeometryForStrokes())&&i<=n.numPoints()?this.activeStrokes.emitStrokableParts(t,e):t.announceIntervalForUniformStepStrokes(this,i,0,1),t.endParentCurvePrimitive(this)}computeStrokeCountForOptions(t){let e;if(t){const i=Math.min(Math.abs(this.radius01.x0),Math.abs(this.radius01.x1));e=t.applyTolerancesToArc(i,this.bearing01.sweepRadians),e=t.applyMaxEdgeLength(e,this.curveLength()),e=t.applyMinStrokesPerPrimitive(e)}else e=be.applyAngleTol(void 0,4,this.bearing01.sweepRadians);return e}reverseInPlace(){this.activeFractionInterval.reverseInPlace(),void 0===this._activeStrokes&&(this._activeStrokes=this._globalStrokes.clone()),this._activeStrokes.reverseInPlace()}fractionToPoint(t,e){const i=this.activeFractionInterval.fractionToPoint(t),n=this._globalStrokes.packedPoints.length-1;if(t>1){e=this._globalStrokes.packedPoints.back(e);const t=1/n;let s=1,r=s+t;for(;r<i;)this.fullSpiralIncrementalIntegral(e,s,r,!0),s=r,r+=t;this.fullSpiralIncrementalIntegral(e,s,i,!0)}else if(t<0){e=this._globalStrokes.packedPoints.front(e);const t=1/n;let s=0,r=s-t;for(;r>i;)this.fullSpiralIncrementalIntegral(e,s,r,!0),s=r,r-=t;this.fullSpiralIncrementalIntegral(e,s,i,!0)}else{const t=J.clampToStartEnd(i,0,1),s=Math.trunc(t*n),r=s/n;e=this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(s,e),this.fullSpiralIncrementalIntegral(e,r,i,!0)}return e}fractionToPointAndDerivative(t,e){const i=this.activeFractionInterval.fractionToPoint(t);e=e||Rt.createZero(),this.fractionToPoint(t,e.origin);const n=this.globalFractionToBearingRadians(i),s=this._arcLength01*this.activeFractionInterval.signedDelta();return this.localToWorld.matrix.multiplyXY(s*Math.cos(n),s*Math.sin(n),e.direction),e}fractionToFrenetFrame(t,e){const i=this.activeFractionInterval.fractionToPoint(t);(e=e||mt.createIdentity()).origin.setFrom(this.fractionToPoint(t)),xt.createRigidFromMatrix3d(this.localToWorld.matrix,f.XYZ,e.matrix);const n=this.globalFractionToBearingRadians(i),s=Math.cos(n),r=Math.sin(n);return e.matrix.applyGivensColumnOp(0,1,s,r),e}fractionToPointAnd2Derivatives(t,e){const i=this.activeFractionInterval.fractionToPoint(t),n=this.fractionToPoint(t),s=this.globalFractionToBearingRadians(i),r=Math.cos(s),o=Math.sin(s),a=this.activeFractionInterval.signedDelta(),c=a,l=c*a,h=this.localToWorld.matrix.multiplyXY(c*r,c*o),d=this.localToWorld.matrix.multiplyXY(-l*o,l*r);return d.scaleInPlace(this.globalFractionToCurvature(i)),Mt.createCapture(n,h,d,e)}dispatchToGeometryHandler(t){return t.handleTransitionSpiral(this)}isAlmostEqual(t){return t instanceof Ns&&this.radius01.isAlmostEqual(t.radius01)&&this.bearing01.isAlmostEqualAllowPeriodShift(t.bearing01)&&this.localToWorld.isAlmostEqual(t.localToWorld)&&J.isSameCoordinate(this._arcLength01,t._arcLength01)&&this.activeFractionInterval.isAlmostEqual(t.activeFractionInterval)&&this._curvature01.isAlmostEqual(t._curvature01)}}Ns.initWorkSpace(),function(t){t[t.Sections=0]="Sections",t[t.AlsoRuledSweep=1]="AlsoRuledSweep",t[t.AlsoMesh=2]="AlsoMesh"}(z||(z={}));class Xs{static addPartialSegment(t,e,i,n,s,r){(e||r>s)&&(void 0===i||void 0===n||J.isAlmostEqualNumber(s,r)||t.tryAddChild(Te.create(i.interpolate(s,n),i.interpolate(r,n))))}static createArcPointTangentPoint(t,e,i){const n=Si.createCircularStartTangentEnd(t,e,i);return n instanceof Si?n:void 0}static createFilletsInLineString(t,e,i=!0){if(Array.isArray(t))return this.createFilletsInLineString(new he(t),e,i);if(t instanceof Fe)return this.createFilletsInLineString(t.packedPoints,e,i);const n=t.length;if(n<=1)return;const s=t.getPoint3dAtCheckedPointIndex(0),r=t.getPoint3dAtCheckedPointIndex(1),o=[];o.push({fraction10:0,fraction12:0,point:s.clone()});for(let i=1;i+1<n;i++){const n=t.getPoint3dAtCheckedPointIndex(i+1);let a=0;Array.isArray(e)?i<e.length&&(a=e[i]):Number.isFinite(e)&&(a=e),0!==a?o.push(Si.createFilletArc(s,r,n,a)):o.push({fraction10:0,fraction12:0,point:r.clone()}),s.setFromPoint3d(r),r.setFromPoint3d(n)}if(o.push({fraction10:0,fraction12:0,point:r.clone()}),!i)for(let t=1;t+1<n;t++){const e=o[t];(e.fraction10>1||e.fraction12>1||1-e.fraction10<o[t-1].fraction12||e.fraction12>1-o[t+1].fraction10)&&(e.fraction10=0,e.fraction12=0,o[t].arc=void 0)}const a=ii.create();this.addPartialSegment(a,i,o[0].point,o[1].point,o[0].fraction12,1-o[1].fraction10);for(let e=1;e+1<t.length;e++){const t=o[e],n=o[e+1];a.tryAddChild(t.arc),this.addPartialSegment(a,i,t.point,n.point,t.fraction12,1-n.fraction10)}return a}static createRectangleXY(t,e,i,n,s=0,r){let o=J.correctSmallMetricDistance(r);const a=Math.min(t,i),c=Math.max(t,i),l=Math.min(e,n),h=Math.max(e,n);if(o=Math.min(Math.abs(o),.5*(c-a),.5*(h-l)),0===o)return oi.createPolygon([$.create(a,l,s),$.create(c,l,s),$.create(c,h,s),$.create(a,h,s),$.create(a,l,s)]);{const t=tt.create(o,0,0),e=tt.create(0,o,0),i=a+o,n=l+o,r=c-o,d=h-o,u=[$.create(r,d,s),$.create(i,d,s),$.create(i,n,s),$.create(r,n,s)],f=oi.create();for(let i=0;i<4;i++){const n=u[i],s=u[(i+1)%4],r=tt.createStartEnd(n,s),o=Si.create(n,t,e,St.createStartEndDegrees(0,90));f.tryAddChild(o);const a=o.endPoint();r.isAlmostZero||f.tryAddChild(Te.create(a,a.plus(r))),t.rotate90CCWXY(t),e.rotate90CCWXY(e)}return f}}static appendToArcInPlace(t,e,i=!1){if(t.center.isAlmostEqual(e.center)){const n=J.split3WaySign(t.sweep.sweepRadians*e.sweep.sweepRadians,-1,0,1),s=t.angleToPointAndDerivative(t.sweep.fractionToAngle(1));t.sweep.sweepRadians<0&&s.direction.scaleInPlace(-1);const r=e.angleToPointAndDerivative(e.sweep.fractionToAngle(0));if(e.sweep.sweepRadians<0&&r.direction.scaleInPlace(-1),s.isAlmostEqual(r))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians+n*e.sweep.sweepRadians),!0;if(i&&(r.direction.scaleInPlace(-1),s.isAlmostEqual(r)))return t.sweep.setStartEndRadians(t.sweep.startRadians,t.sweep.startRadians+t.sweep.sweepRadians-n*e.sweep.sweepRadians),!0}return!1}static assembleArcChainOnEllipsoid(t,e,i=.5){const n=ii.create();for(let s=0;s+1<e.length;s++){const r=t.sectionArcWithIntermediateNormal(e[s].toAngles(),i,e[s+1].toAngles());n.tryAddChild(r)}return n}static appendGeometryQueryArray(t,e){if(t instanceof zt)e.push(t);else if(Array.isArray(t))for(const i of t)this.appendGeometryQueryArray(i,e)}static createPipeSegments(t,e){if(t instanceof Te)return Fi.createAxisPoints(t.startPoint(),t.endPoint(),e,e,!1);if(t instanceof Si)return ws.createAlongArc(t,e,!1);if(t instanceof le){const i=ir.create();return i.addMiteredPipes(t,e),i.claimPolyface()}if(t instanceof ti){const i=[];for(const n of t.children){const t=this.createPipeSegments(n,e);this.appendGeometryQueryArray(t,i)}return i}}static startPointAndTangent(t){if(t instanceof le)return t.fractionToPointAndDerivative(0);if(t.length<2)return;Array.isArray(t)&&(t=new he(t));const e=Rt.createZero();return t.getPoint3dAtUncheckedPointIndex(0,e.origin),t.vectorIndexIndex(0,1,e.direction),e}static createArcFromSectionData(t,e){const i=Xs.startPointAndTangent(t);if(!i)return;let n;if(e instanceof Si)n=e.clone(),n.center=i.origin;else{const t=tt.create(),s=tt.create(),r="number"==typeof e?e:e.x,o="number"==typeof e?e:e.y,a=xt.createRigidHeadsUp(i.direction,f.ZXY);a.columnX(t).scaleInPlace(r),a.columnY(s).scaleInPlace(o),n=Si.create(i.origin,t,s)}return n.binormalVector().dotProduct(i.direction)<0&&n.reverseInPlace(),n}static createMiteredPipeSections(t,e){const i=Xs.createArcFromSectionData(t,e);if(!i)return[];const n=Xs.createMiteredSweepSections(t,i);return n?n.sections:[]}static strokeSmoothCurve(t,e){let i,n;if(t instanceof le){i=t.fractionToPointAndDerivative(0).direction,n=t.fractionToPointAndDerivative(1).direction;const s=Fe.create();t.emitStrokes(s,e),t=s.packedPoints}else if(t instanceof ti){i=t.startPointAndDerivative()?.direction,n=t.endPointAndDerivative()?.direction;const s=t.getPackedStrokes(e);if(!s)return;t=s}else Array.isArray(t)&&(t=new he(t));return{strokes:t,startTangent:i,endTangent:n}}static alignFirstAndLastBisectorPlanes(t,e,i,n){const s=n?.startTangent??i?.startTangent??t.getNormalRef(),r=n?.endTangent??i?.endTangent??e.getNormalRef();if(n?.wrapIfPhysicallyClosed&&t.getOriginRef().isAlmostEqual(e.getOriginRef())){const i=s.plus(r);if(i.tryNormalizeInPlace())return t.getNormalRef().setFrom(i),void e.getNormalRef().setFrom(i)}s.tryNormalizeInPlace()&&t.getNormalRef().setFrom(s),r.tryNormalizeInPlace()&&e.getNormalRef().setFrom(r)}static alignClosedCurveToPlane(t,e){let i;if(t instanceof le?t.startPoint().isAlmostEqual(t.endPoint())&&(i=oi.create(t)):t.isAnyRegion()&&(i=t),i){const n=xt.createRigidHeadsUp(e).transpose(),s=i.cloneTransformed(mt.createOriginAndMatrix(void 0,n));if(s){const e=wr.computeXYArea(s);e&&e<0&&t.reverseInPlace()}}}static doSweepToPlane(t,e,i,n,s){const r=tt.createStartEnd(e.getOriginRef(),i.getOriginRef()),o=mt.createFlattenAlongVectorToPlane(r,n.getOriginRef(),n.getNormalRef());if(void 0===o)return s;const a=s.cloneTransformed(o);return void 0===a?s:(t.planes.push(n),t.sections.push(a),a)}static createMiteredSweepSections(t,e,i){i||(i={});const n=this.strokeSmoothCurve(t,i.strokeOptions);if(!n)return;const s=Ci.createBisectorPlanesForDistinctPoints(n.strokes);if(!s||s.length<2)return;this.alignFirstAndLastBisectorPlanes(s[0],s[s.length-1],n,i),this.alignClosedCurveToPlane(e,s[0].getNormalRef());const r={sections:[],planes:[]};let o=this.doSweepToPlane(r,s[0],s[1],s[0],e);for(let t=1;t<s.length;t++)o=this.doSweepToPlane(r,s[t-1],s[t],s[t],o);if(i.outputSelect){const t=Ts.create(r.sections,i.capped??!1);if(t&&(r.ruledSweep=t,z.AlsoMesh===i.outputSelect)){const e=ir.create(i.strokeOptions);e.addRuledSweep(t),r.mesh=e.claimPolyface()}}return r}static createArcPointTangentRadius(t,e,i,n,s){return Si.createCircularStartTangentRadius(t,e,i,n,s)}static createLineSpiralSpiralLine(t,e,i,n){const s=tt.createStartEnd(e,i),r=tt.createStartEnd(i,n),o=s.magnitude(),a=Math.atan2(s.y,s.x),c=s.angleToXY(r),l=.5*c.radians,h=a+c.radians,d=xt.createRotationAroundAxisIndex(g.Z,G.createRadians(a)),u=mt.createRefs(e.clone(),d),f=Ns.createFrom4OutOf5(t,0,void 0,G.createRadians(0),G.createRadians(l),o,void 0,u);if(f){const r=a+l,c=tt.createPolar(1,G.createRadians(r)),d=c.dotProductStartEnd(e,i)/c.dotProductStartEnd(e,f.endPoint()),p=Ns.createFrom4OutOf5(t,0,void 0,G.createRadians(0),G.createRadians(l),o*d,void 0,u),m=s.magnitude(),_=tt.createStartEnd(i,n);_.scaleToLength(m,_);const x=i.plus(_),y=xt.createRotationAroundAxisIndex(g.Z,G.createRadians(h+Math.PI)),v=mt.createRefs(x,y),P=Ns.createFrom4OutOf5(t,0,-p.radius01.x1,G.zero(),void 0,p.curveLength(),De.create(1,0),v);return[p,P]}}static createLineSpiralSpiralLineWithSpiralLength(t,e,i,n,s){const r=tt.createStartEnd(e,i),o=tt.createStartEnd(i,n),a=Math.atan2(r.y,r.x),c=r.angleToXY(o),l=.5*c.radians,h=.5*(Math.PI-c.radians),d=Math.atan2(-o.y,-o.x),u=Ns.createFrom4OutOf5(t,0,void 0,G.zero(),G.createRadians(l),s,void 0,mt.createIdentity());if(u){const r=u.fractionToPoint(1),o=e.distance(i),c=n.distance(i),f=r.y/Math.tan(h),p=J.conditionalDivideFraction(o-f-r.x,o),m=J.conditionalDivideFraction(c-f-r.x,c);if(void 0!==p&&void 0!==m){const r=xt.createRotationAroundAxisIndex(g.Z,G.createRadians(a)),o=e.interpolate(p,i),c=mt.createRefs(o,r),h=Ns.createFrom4OutOf5(t,0,void 0,G.zero(),G.createRadians(l),s,void 0,c),u=xt.createRotationAroundAxisIndex(g.Z,G.createRadians(d)),f=n.interpolate(m,i),_=mt.createRefs(f,u);return[h,Ns.createFrom4OutOf5(t,0,void 0,G.zero(),G.createRadians(-l),s,void 0,_)]}}}static createLineSpiralArcSpiralLine(t,e,i,n,s,r,o){const a=tt.createStartEnd(e,i);a.z=0;const c=tt.createStartEnd(n,i);c.z=0;const l=a.normalize(),h=c.normalize();if(void 0===l||void 0===h)return;const d=l.unitPerpendicularXY(),u=h.unitPerpendicularXY(),f=a.angleToXY(c),g=J.split3WaySign(f.radians,1,-1,-1),p=-g,m=g*Math.abs(o),_=p*Math.abs(o),x=Ns.createFrom4OutOf5(t,0,m,G.zero(),void 0,s,void 0,mt.createIdentity()),y=Ns.createFrom4OutOf5(t,0,_,G.zero(),void 0,r,void 0,mt.createIdentity()),v=x.fractionToPointAndUnitTangent(1),P=y.fractionToPointAndUnitTangent(1),I=v.origin.x-m*v.direction.y,S=v.origin.y+m*v.direction.x,b=P.origin.x-_*P.direction.y,A=P.origin.y+_*P.direction.x,C=tt.createAdd2Scaled(l,I,d,S),T=tt.createAdd2Scaled(h,b,u,A),w=j.create();if(Ft.linearSystem2d(l.x,-h.x,l.y,-h.y,T.x-C.x,T.y-C.y,w)){const t=i.plusScaled(l,w.x),e=i.plusScaled(h,w.y),n=mt.createOriginAndMatrixColumns(t,l,d,tt.unitZ()),s=mt.createOriginAndMatrixColumns(e,h,u,tt.unitZ());x.tryTransformInPlace(n),y.tryTransformInPlace(s);const r=x.fractionToPointAndUnitTangent(1),o=y.fractionToPointAndUnitTangent(1);o.direction.scaleInPlace(-1);const a=r.direction.angleToXY(o.direction);return m<0&&a.setRadians(-a.radians),[x,Xs.createArcPointTangentRadius(r.origin,r.direction,m,void 0,a),y]}}static planePlaneIntersectionRay(t,e){const i=t.altitudeXYZ(0,0,0),n=e.altitudeXYZ(0,0,0),s=t.normalX(),r=t.normalY(),o=t.normalZ(),a=e.normalX(),c=e.normalY(),l=e.normalZ(),h=J.crossProductXYXY(r,o,c,l),d=J.crossProductXYXY(o,s,l,a),u=J.crossProductXYXY(s,r,a,c),f=Ft.linearSystem3d(s,r,o,a,c,l,h,d,u,-i,-n,0);if(void 0!==f)return Rt.createXYZUVW(f.x,f.y,f.z,h,d,u)}}class zs extends Se{_perpVector;_maxDistance;_localToWorld;constructor(t){super(),this._perpVector=tt.createZero(),this._maxDistance=0,this._localToWorld=t.toRigidZFrame()}_localPoint=$.create();_worldPoint=$.create();announcePoint(t){this._localToWorld.multiplyInversePoint3d(t,this._localPoint);const e=this._localPoint.magnitudeXY();e>=this._maxDistance&&(this._maxDistance=e,this._perpVector.setFromPoint3d(this._localPoint),this._perpVector.z=0,this._localToWorld.matrix.multiplyXY(this._localPoint.x,this._localPoint.y,this._perpVector))}handleLineSegment3d(t){this.announcePoint(t.startPoint(this._worldPoint)),this.announcePoint(t.endPoint(this._worldPoint))}handleLineString3d(t){for(let e=0;e<t.numPoints();e++)t.pointAt(e,this._worldPoint),this.announcePoint(this._worldPoint)}handleArc3d(t){const e=be.applyAngleTol(void 0,3,t.sweep.sweepRadians,.1),i=1/e;for(let n=0;n<=e;n++)t.fractionToPoint(n*i,this._worldPoint),this.announcePoint(this._worldPoint)}static computeMaxVectorFromRay(t,e){const i=new zs(t);return e.dispatchToGeometryHandler(i),i._perpVector.clone()}static buildRotationalNormalsInLineStrings(t,e,i){if(t instanceof Fe){const n=t.packedPoints,s=t.packedDerivatives,r=t.ensureEmptySurfaceNormals();if(s&&r){const s=tt.create(),o=tt.create(),a=$.create(),c=n.length;for(let l=0;l<c;l++)n.getPoint3dAtUncheckedPointIndex(l,a),e.perpendicularPartOfVectorToTarget(a,s),s.isAlmostZero?e.direction.crossProduct(i,o):e.direction.crossProduct(s,o),t.packedDerivatives.getVector3dAtCheckedVectorIndex(l,s),s.crossProduct(o,o),o.normalizeInPlace(),r.push(o)}}else if(t.children){const n=t.children;for(const t of n)this.buildRotationalNormalsInLineStrings(t,e,i)}}}class Ls{startSweeps(t,e,i){return!0}endSweeps(t,e,i){return!0}}class Ys extends Ls{myMap;constructor(){super(),this.myMap=Xt.createWithComponentIndex()}startPass(t){return 0===t?(this.myMap.numStroke=0,!0):1===t}visit(t,e){return 0===t?(e.numStroke>this.myMap.numStroke&&(this.myMap.numStroke=e.numStroke),!0):1===t&&(e.numStroke=this.myMap.numStroke,!0)}endPass(t){return!0}}class Vs extends Ls{maxCurveLength;constructor(){super(),this.maxCurveLength=0}startPass(t){return 0===t?(this.maxCurveLength=0,!0):1===t}visit(t,e){return 0===t?(this.maxCurveLength=J.maxXY(e.curveLength,this.maxCurveLength),!0):1===t&&(e.a0=0,e.a1=this.maxCurveLength,!0)}endPass(t){return!0}}class Us{maps;parent;options;constructor(t,e){this.parent=t,this.maps=[],this.options=e}static createForCurveChain(t,e){const i=new Us(t,e);i.parent=t;for(const n of t.children)n.computeAndAttachRecursiveStrokeCounts(e),n.strokeData&&i.maps.push(n.strokeData);return i}getStrokes(){const t=Fe.create();this.options&&(this.options.needNormals||this.options.needParams)&&(t.ensureEmptyFractions(),t.ensureEmptyDerivatives(),t.ensureEmptyUVParams());for(const e of this.maps)e.primitive&&e.primitive.addMappedStrokesToLineString3D(e,t);return t}static applySummed01LimitsWithinArray(t,e){let i=e;for(const e of t)e.a0+=i,e.componentData?e.a1=this.applySummed01LimitsWithinArray(e.componentData,e.a0):e.a1+=i,i=e.a1;return i}applySummed01Limits(t){return Us.applySummed01LimitsWithinArray(this.maps,t)}}class qs{chains;parent;constructor(t){this.parent=t,this.chains=[]}static createForParityRegionOrChain(t,e){const i=new qs(t);if(t instanceof Ti)for(const n of t.children){const t=Us.createForCurveChain(n,e);i.chains.push(t)}else t instanceof ti&&i.chains.push(Us.createForCurveChain(t,e));return i}static areSectionsCompatible(t,e){if(t.length<2)return!0;const i=t[0].chains.length;for(let n=1;n<t.length;n++){if(t[n].chains.length!==i)return!1;for(let i=0;i<t[0].chains.length;i++){const s=t[0].chains[i].maps.length;if(t[n].chains[i].maps.length!==s)return!1;for(let r=0;r<s;r++)if(!t[0].chains[i].maps[r].isCompatibleComponentStructure(t[n].chains[i].maps[r],e))return!1}}return!0}static remapa0a1WithinEachChain(t){for(const e of t)for(const t of e.chains)t.applySummed01Limits(0)}static applyMultipassVisitorCallbackNoComponents(t,e,i,n,s){const r=t.length;if(!s.startSweeps(e,i,n))return!1;if(void 0===n)for(let n=0;s.startPass(n);n++){for(let o=0;o<r;o++)if(!s.visit(n,t[o].chains[e].maps[i]))return!1;if(!s.endPass(n))return!1}else for(let o=0;s.startPass(o);o++){for(let a=0;a<r;a++)if(!s.visit(o,t[a].chains[e].maps[i].componentData[n]))return!1;if(!s.endPass(o))return!1}return!!s.endSweeps(e,i,n)}static runMultiPassVisitorAtCorrespondingPrimitives(t,e){const i=t[0].chains.length;for(let n=0;n<i;n++){const i=t[0].chains[n].maps.length;for(let s=0;s<i;s++)if(t[0].chains[n].maps[s].componentData){const i=t[0].chains[n].maps[s].componentData.length;for(let r=0;r<i;r++)if(!this.applyMultipassVisitorCallbackNoComponents(t,n,s,r,e))return!1}else if(!this.applyMultipassVisitorCallbackNoComponents(t,n,s,void 0,e))return!1}return!0}static enforceStrokeCountCompatibility(t){if(t.length<2)return!0;if(!qs.areSectionsCompatible(t,!1))return!1;const e=new Ys;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),!0}static enforceCompatibleDistanceSums(t){if(t.length<2)return!0;if(!qs.areSectionsCompatible(t,!1))return!1;const e=new Vs;return this.runMultiPassVisitorAtCorrespondingPrimitives(t,e),this.remapa0a1WithinEachChain(t),!0}getStrokes(){if(1===this.chains.length)return this.chains[0].getStrokes();{const t=Ti.create();for(const e of this.chains){const i=e.getStrokes();i instanceof Fe&&t.tryAddChild(oi.create(i))}return t}}static extendDistanceRangeBetweenStrokes(t,e,i){if(t instanceof Fe){if(e instanceof Fe&&t.numPoints()===e.numPoints()){const n=t.numPoints(),s=$.create(),r=$.create(),o=t.packedPoints,a=e.packedPoints;for(let t=0;t<n;t++)o.getPoint3dAtCheckedPointIndex(t,s),a.getPoint3dAtCheckedPointIndex(t,r),i.extendX(s.distance(r));return!0}}else if(t instanceof Ti){if(e instanceof Ti){const n=t.children,s=e.children,r=n.length;if(r===s.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(n[t],s[t],i))return!1;return!0}}}else if(t instanceof ti&&e instanceof ti){const n=t.children,s=e.children,r=n.length;if(r===s.length){for(let t=0;t<r;t++)if(!this.extendDistanceRangeBetweenStrokes(n[t],s[t],i))return!1;return!0}}return!1}}class Zs{surface;uv;point;a;constructor(t,e,i){this.surface=t,this.point=i||$.createZero(),this.uv=e||H.createZero(),this.a=0}static createSurfaceUVPoint(t,e,i){const n=new Zs(t);return e&&n.uv.setFrom(e),n.point.setFromPoint3d(i),n}static createSurfaceUVNumbersPoint(t,e,i,n){const s=new Zs(t);return s.uv.x=e,s.uv.y=i,s.point.setFromPoint3d(n),s}}class Ws{curveDetail;surfaceDetail;constructor(t,e){this.curveDetail=t,this.surfaceDetail=e}}class Gs{point00;point10;point01;point11;constructor(t,e,i,n){this.point00=t,this.point10=e,this.point01=i,this.point11=n}static create(t,e,i,n){return new Gs(t.clone(),e.clone(),i.clone(),n.clone())}static createXYZ(t,e,i,n,s,r,o,a,c,l,h,d){return new Gs($.create(t,e,i),$.create(n,s,r),$.create(o,a,c),$.create(l,h,d))}clone(){return new Gs(this.point00.clone(),this.point10.clone(),this.point01.clone(),this.point11.clone())}isAlmostEqual(t){return this.point00.isAlmostEqual(t.point00)&&this.point10.isAlmostEqual(t.point10)&&this.point01.isAlmostEqual(t.point01)&&this.point11.isAlmostEqual(t.point11)}tryTransformInPlace(t){return t.multiplyPoint3d(this.point00,this.point00),t.multiplyPoint3d(this.point10,this.point10),t.multiplyPoint3d(this.point01,this.point01),t.multiplyPoint3d(this.point11,this.point11),!0}cloneTransformed(t){const e=this.clone();return e.tryTransformInPlace(t),e}extendRange(t,e){e?(t.extendTransformedPoint(e,this.point00),t.extendTransformedPoint(e,this.point10),t.extendTransformedPoint(e,this.point01),t.extendTransformedPoint(e,this.point11)):(t.extendPoint(this.point00),t.extendPoint(this.point10),t.extendPoint(this.point01),t.extendPoint(this.point11))}uvFractionToPoint(t,e,i){const n=(1-t)*(1-e),s=t*(1-e),r=(1-t)*e,o=t*e;return $.create(n*this.point00.x+s*this.point10.x+r*this.point01.x+o*this.point11.x,n*this.point00.y+s*this.point10.y+r*this.point01.y+o*this.point11.y,n*this.point00.z+s*this.point10.z+r*this.point01.z+o*this.point11.z,i)}uvFractionToPointAndTangents(t,e,i){const n=1-t,s=1-e,r=n*s,o=t*s,a=n*e,c=t*e;return Mt.createOriginAndVectorsXYZ(r*this.point00.x+o*this.point10.x+a*this.point01.x+c*this.point11.x,r*this.point00.y+o*this.point10.y+a*this.point01.y+c*this.point11.y,r*this.point00.z+o*this.point10.z+a*this.point01.z+c*this.point11.z,s*(this.point10.x-this.point00.x)+e*(this.point11.x-this.point01.x),s*(this.point10.y-this.point00.y)+e*(this.point11.y-this.point01.y),s*(this.point10.z-this.point00.z)+e*(this.point11.z-this.point01.z),n*(this.point01.x-this.point00.x)+t*(this.point11.x-this.point10.x),n*(this.point01.y-this.point00.y)+t*(this.point11.y-this.point10.y),n*(this.point01.z-this.point00.z)+t*(this.point11.z-this.point10.z),i)}static conditionalPivot(t,e,i,n){if(Math.abs(e[n][t])>Math.abs(e[i][t])){const t=e[i];e[i]=e[n],e[n]=t}}intersectRay(t){const e=this.point10.minus(this.point00),i=this.point01.minus(this.point00),n=this.point11.minus(this.point10);n.subtractInPlace(i);const s=[new Float64Array([-t.direction.x,this.point00.x-t.origin.x,e.x,i.x,n.x]),new Float64Array([-t.direction.y,this.point00.y-t.origin.y,e.y,i.y,n.y]),new Float64Array([-t.direction.z,this.point00.z-t.origin.z,e.z,i.z,n.z])];Gs.conditionalPivot(0,s,0,1),Gs.conditionalPivot(0,s,0,2),Ft.eliminateFromPivot(s[0],0,s[1],-1),Ft.eliminateFromPivot(s[0],0,s[2],-1);const r=Ft.solveBilinearPair(s[1][1],s[1][2],s[1][3],s[1][4],s[2][1],s[2][2],s[2][3],s[2][4]);if(r){const e=[];for(const i of r){const n=-(s[0][1]+s[0][2]*i.x+(s[0][3]+s[0][4]*i.x)*i.y)/s[0][0],r=t.fractionToPoint(n);e.push(new Ws(Pt.createRayFractionPoint(t,n,r),Zs.createSurfaceUVPoint(this,i,r)))}return e}}maxUEdgeLength(){return J.maxXY(this.point00.distance(this.point10),this.point01.distance(this.point11))}maxVEdgeLength(){return J.maxXY(this.point00.distance(this.point01),this.point10.distance(this.point11))}}class Qs{static sampledRangeOfOffsetPatch(t,e,i,n){const s=ft.createNull(),r=1/(i=Math.ceil(J.clamp(i,2,500))),o=1/(n=Math.ceil(J.clamp(n,2,500))),a=$.create(),c=Mt.createXYPlane();let l,h;for(let d=0;d<=n;d++){h=d*o;for(let n=0;n<=i;n++)if(l=n*r,void 0!==e){t.uvFractionToPointAndTangents(l,h,c);const i=c.unitNormal();void 0!==i&&(c.origin.addScaledInPlace(i,e),s.extend(c.origin))}else t.uvFractionToPoint(l,h,a),s.extendXYZ(a.x,a.y,a.z)}return s}static sampledRangeOfOffsetEllipsoidPatch(t,e,i){const n=be.applyAngleTol(i,2,t.latitudeSweep.sweepRadians,G.degreesToRadians(5)),s=be.applyAngleTol(i,2,t.longitudeSweep.sweepRadians,G.degreesToRadians(5));return this.sampledRangeOfOffsetPatch(t,e,n,s)}constructor(){}static createLinestringOnUVLine(t,e,i,n,s,r,o=!1,a=!1){const c=Fe.create(),l=$.create();let h,d,u;const f=r+1;for(let g=0;g<f;g++)h=g/r,d=J.interpolate(e,h,n),u=J.interpolate(i,h,s),t.uvFractionToPoint(d,u,l),c.addPoint(l),o&&c.addUVParamAsUV(d,u),a&&c.addFraction(h);return c}}class Hs{static points=[$.create(0,0,0),$.create(1,0,0),$.create(0,1,0),$.create(1,1,0),$.create(0,0,1),$.create(1,0,1),$.create(0,1,1),$.create(1,1,1)];static pointsClone(){const t=[];for(const e of this.points)t.push(e.clone());return t}static primaryCapId=-1;static cornerIndexCCW=[[1,0,2,3],[4,5,7,6],[0,1,5,4],[1,3,7,5],[3,2,6,7],[2,0,4,6]];static partnerFace=[[5,4,3,2],[2,3,4,5],[0,3,1,5],[0,4,1,2],[0,5,1,3],[0,2,1,4]];static faceId=[[Hs.primaryCapId,0],[Hs.primaryCapId,1],[0,0],[0,1],[0,2],[0,3]];static faceDirections=[[[0,1,2],[-1,1,-1]],[[0,1,2],[1,1,1]],[[0,2,1],[1,-1,1]],[[1,2,0],[1,1,1]],[[0,2,1],[-1,1,1]],[[1,2,0],[-1,1,-1]]];static axisEdgeVertex=[[[0,1],[2,3],[4,5],[6,7]],[[0,2],[1,3],[4,6],[5,7]],[[0,4],[1,5],[2,6],[3,7]]]}class js{points;begin;end;constructor(t,e,i){this.points=t,this.begin=e,this.end=i}static createComplete(t){return new this(t,0,t.length)}static createBeginEnd(t,e,i){return new this(t,e,i)}static createBeginLength(t,e,i){return new this(t,e,e+i)}advanceBegin(){return this.begin++,this.begin<this.end}advanceEnd(){return this.end++,this.end>this.points.length&&(this.end=this.points.length),this.begin<this.end}localIndexToParentIndex(t){if(t>=0){const e=this.begin+t;if(e<this.points.length)return e}}get isValidSubset(){return 0===this.length||void 0!==this.localIndexToParentIndex(0)&&void 0!==this.localIndexToParentIndex(this.length-1)}restrictEnd(){this.end>this.points.length&&(this.end=this.points.length)}get isNonEmpty(){return this.begin<this.end}advanceToTail(t){return this.begin=t.end-1,this.isNonEmpty}advanceToHead(t){return this.begin=t.begin,this.isNonEmpty}setFrom(t,e,i){this.points=t.points,this.begin=void 0===e?t.begin:e,this.end=void 0===i?t.end:i,this.restrictEnd()}get length(){return this.end>this.begin?this.end-this.begin:0}get isSingleton(){return this.begin+1===this.end}}class Js extends js{}class Ks extends on{_quality;_isValid;id;constructor(t,e,i,n,s,r){super(t,e,i),this._isValid=r,this._quality=s,this.id=n}setFrom(t){return super.setFrom(t),this._isValid=t._isValid,this._quality=t._quality,this.id=t.id,this}static createFromIndexedXYZ(t,e,i,n,s,r,o,a){a||(a=new Ks($.create(),$.create(),$.create(),o,0,!1)),a.id=o;let c=0;return void 0!==t.getPoint3dAtCheckedPointIndex(e,a.points[0])&&c++,void 0!==i.getPoint3dAtCheckedPointIndex(n,a.points[1])&&c++,void 0!==s.getPoint3dAtCheckedPointIndex(r,a.points[2])&&c++,3===c?a.updateAspectRatio():a.markInvalid(),a}get isValid(){return this._isValid}markInvalid(t){this._isValid=!1,void 0!==t&&(this._quality=t)}updateAspectRatio(){this._quality=super.aspectRatio,this._isValid=this._quality>0}clone(t){return t?t.setFrom(this):new Ks(this.points[0].clone(),this.points[1].clone(),this.points[2].clone(),this.id,this._quality,this._isValid)}static copyWithLowerQuality(t,e,i){if(i=t.clone(i),e.isValid){const n=t.dotProductOfCrossProductsFromOrigin(e);i._quality=J.minXY(t.aspectRatio,e.aspectRatio),n<0&&(i._quality-=1)}return i}static updateIfOtherHasHigherQuality(t,e){e.isValid&&e._quality>t._quality&&t.setFrom(e)}}class $s{_vector1;constructor(t){this._turnRadians=t,this._xyzA=$.create(),this._xyzB=$.create(),this._forwardA=tt.create(),this._forwardB=tt.create(),this._vector1=tt.create(),this._crossA=tt.create(),this._crossB=tt.create()}_turnRadians;isForwardVector(t,e,i){if(t.dotProduct(e)<=0)return!1;const n=t.angleFromPerpendicular(i);return!(Math.abs(n.radians)>this._turnRadians)}isPlanarBase(t,e,i,n,s,r,o,a,c,l){return e+1<t.length&&n+1<i.length&&(t.getPoint3dAtUncheckedPointIndex(e,s),i.getPoint3dAtUncheckedPointIndex(n,a),t.vectorXYAndZIndex(s,e+1,o),i.vectorXYAndZIndex(a,n+1,l),tt.createStartEnd(s,a,this._vector1),this._vector1.crossProduct(o,r),this._vector1.crossProduct(l,c),!s.isAlmostEqual(a)&&r.angleTo(c).radians<this._turnRadians)}advanceToPlanarLimit(t,e,i,n,s,r,o,a){for(e.setFrom(t,t.begin,i);e.end<t.end&&(e.points.vectorXYAndZIndex(n,e.end,this._vector1),this.isForwardVector(this._vector1,r,s))&&this.isForwardVector(this._vector1,a,o)&&(!(e.end>0)||(e.points.vectorIndexIndex(e.end-1,e.end,this._vector1),this.isForwardVector(this._vector1,r,s)));)e.end++}_triangleA1;_triangleB1;_triangleA2;_triangleB2;_triangleA3;_triangleB3;_bestTriangle;_workTriangle;addGreedy(t,e,i,n=!1){for(t.restrictEnd(),e.restrictEnd();t.length>1&&e.length>1;)if(this._triangleA1=Ks.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,1,this._triangleA1),this._triangleA2=Ks.createFromIndexedXYZ(t.points,t.begin+1,t.points,t.begin+2,e.points,e.begin,2,this._triangleA2),this._triangleA3=Ks.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin+1,3,this._triangleA3),this._triangleB1=Ks.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,-1,this._triangleB1),this._triangleB2=Ks.createFromIndexedXYZ(e.points,e.begin+2,e.points,e.begin+1,t.points,t.begin,-2,this._triangleB2),this._triangleB3=Ks.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin+1,-3,this._triangleB3),this._bestTriangle=Ks.copyWithLowerQuality(this._triangleA1,this._triangleB3,this._bestTriangle),this._workTriangle=Ks.copyWithLowerQuality(this._triangleB1,this._triangleA3,this._workTriangle),Ks.updateIfOtherHasHigherQuality(this._bestTriangle,this._workTriangle),this._bestTriangle.id>0){if(t.advanceBegin(),i(this._bestTriangle),n)return}else if(e.advanceBegin(),i(this._bestTriangle),n)return;if(t.isSingleton)for(;e.length>=2;)this._workTriangle=Ks.createFromIndexedXYZ(e.points,e.begin+1,e.points,e.begin,t.points,t.begin,0,this._workTriangle),i(this._workTriangle),e.advanceBegin();if(e.isSingleton)for(;t.length>=2;)this._workTriangle=Ks.createFromIndexedXYZ(t.points,t.begin,t.points,t.begin+1,e.points,e.begin,0,this._workTriangle),i(this._workTriangle),t.advanceBegin()}_xyzA;_xyzB;_forwardA;_forwardB;_crossA;_crossB;emitTriangles(t,e,i){this.emitTrianglesGo(tr(t),tr(e),i)}emitTrianglesGo(t,e,i){const n=Js.createComplete(t),s=Js.createComplete(e),r=Js.createComplete(t),o=Js.createComplete(e);for(;n.length>0&&s.length>0&&(n.length>1||s.length>1);)this.isPlanarBase(t,n.begin,e,s.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(this.advanceToPlanarLimit(n,r,n.begin+1,this._xyzA,this._crossA,this._forwardA,this._crossB,this._forwardB),this.advanceToPlanarLimit(s,o,s.begin+1,this._xyzB,this._crossB,this._forwardB,this._crossA,this._forwardA),this.addGreedy(r,o,i),n.advanceToTail(r),s.advanceToTail(o)):this.isPlanarBase(t,n.begin+1,e,s.begin,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(n,n.begin,n.begin+2),o.setFrom(s,s.begin,s.begin+1),this.addGreedy(r,o,i),n.advanceToTail(r),s.advanceToTail(o)):this.isPlanarBase(t,n.begin,e,s.begin+1,this._xyzA,this._crossA,this._forwardA,this._xyzB,this._crossB,this._forwardB)?(r.setFrom(n,n.begin,n.begin+1),o.setFrom(s,s.begin,s.begin+2),this.addGreedy(r,o,i),n.advanceToTail(r),s.advanceToTail(o)):n.length>1&&s.length>1?(r.setFrom(n,n.begin,n.begin+2),o.setFrom(s,s.begin,s.begin+2),this.addGreedy(r,o,i,!0),n.advanceToHead(r),s.advanceToHead(o)):n.length>1?(r.setFrom(n,n.begin,n.begin+2),o.setFrom(s),this.addGreedy(r,o,i),n.advanceToTail(r),s.advanceToTail(o)):s.length>1&&(r.setFrom(n),o.setFrom(s,s.begin,s.begin+2),this.addGreedy(r,o,i),n.advanceToTail(r),s.advanceToTail(o));this.addGreedy(n,s,i)}static defaultNearColinearAngle=G.createDegrees(15);static createContext(t=this.defaultNearColinearAngle){return new $s(t.radians)}}function tr(t,e=J.smallMetricDistance){let i=!1;const n=t.length;for(let s=0;s+1<n;s++)if(t.distanceIndexIndex(s,s+1)<=e){i=!0;break}if(!i)return t;const s=new rt(n);s.pushXYZ(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0));let r=0;for(let i=1;i<n;i++)t.distanceIndexIndex(r,i)>e&&(s.pushXYZ(t.getXAtUncheckedPointIndex(i),t.getYAtUncheckedPointIndex(i),t.getZAtUncheckedPointIndex(i)),r=i);return t.distanceIndexIndex(0,n-1)<=e&&(s.pop(),s.pushFromGrowableXYZArray(s,0)),s}class er{xyz;xyzIndex;normal;normalIndex;uv;uvIndex;sectionDerivative;constructor(t=!1,e=!1,i=!1){this.xyz=$.create(),this.normalIndex=-1,this.uvIndex=-1,this.xyzIndex=-1,t&&(this.normal=tt.create()),e&&(this.uv=H.create(),this.uvIndex=-1),i&&(this.sectionDerivative=tt.create())}copyContentsFrom(t){this.xyz.setFromPoint3d(t.xyz),this.xyzIndex=t.xyzIndex,this.normal&&this.normal.setFromVector3d(t.normal),this.normalIndex=t.normalIndex,this.uv&&this.uv.setFrom(t.uv),this.uvIndex=t.uvIndex,this.sectionDerivative&&this.sectionDerivative.setFrom(t.sectionDerivative)}loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,e,i,n,s){e.getPoint3dAtCheckedPointIndex(t,this.xyz),this.uv&&n&&void 0!==s&&this.uv.set(n.atUncheckedIndex(t),s),this.xyzIndex=-1,this.normalIndex=-1,this.uvIndex=-1,void 0!==this.sectionDerivative&&void 0!==i&&i.getVector3dAtCheckedVectorIndex(t,this.sectionDerivative)}static suppressSmallUnitVectorComponents(t){const e=J.smallFloatingPoint;Math.abs(t.x)<e&&(t.x=0),Math.abs(t.y)<e&&(t.y=0),Math.abs(t.z)<e&&(t.z=0)}static _edgeVector=tt.create();static computeNormalsAlongRuleLine(t,e){if(t.sectionDerivative&&e.sectionDerivative){const i=er._edgeVector;tt.createStartEnd(t.xyz,e.xyz,i),t.sectionDerivative.crossProduct(i,t.normal),e.sectionDerivative.crossProduct(i,e.normal),t.normal.normalizeInPlace(),e.normal.normalizeInPlace(),er.suppressSmallUnitVectorComponents(t.normal),er.suppressSmallUnitVectorComponents(e.normal)}}}class ir extends Ie{_polyface;_options;get options(){return this._options}_reversed;get reversedFlag(){return this._reversed}claimPolyface(t=!0,e=J.smallMetricDistance){return t&&this._polyface.data.compress(e),this._polyface}toggleReversedFacetFlag(){this._reversed=!this._reversed}constructor(t){super(),this._options=t||be.createForFacets(),this._polyface=Qi.create(this._options.needNormals,this._options.needParams,this._options.needColors,this._options.needTwoSided),this._reversed=!1}static create(t){return new ir(t)}addTransformedUnitBox(t){this.addTransformedRangeMesh(t,ft.createXYZXYZ(0,0,0,1,1,1))}addTransformedRangeMesh(t,e,i){const n=this._polyface.data.pointCount,s=e.corners();for(const e of s)this._polyface.addPoint(t.multiplyPoint3d(e));let r=0;for(const t of Hs.cornerIndexCCW){if(!i||r<i.length&&i[r]){const e=t.map((t=>t+n));this._reversed&&e.reverse(),this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(e[0],e[1],e[2],!1),this.addIndexedTrianglePointIndexes(e[0],e[2],e[3],!1)):this.addIndexedQuadPointIndexes(e[0],e[1],e[3],e[2],!1),this._polyface.terminateFacet()}r++}}addTriangleFan(t,e,i){const n=e.numPoints();if(n>2){i&&this.toggleReversedFacetFlag();const s=this.addPoint(t);let r=this.findOrAddPointInLineString(e,0),o=0;for(let t=1;t<n;t++)o=this.findOrAddPointInLineString(e,t),this.addIndexedTrianglePointIndexes(s,r,o),r=o;i&&this.toggleReversedFacetFlag()}}addTrianglesInUncheckedConvexPolygon(t,e){const i=t.numPoints();if(i>2){let n,s;e&&this.toggleReversedFacetFlag(),this._options.needNormals&&(n=t.quickUnitNormal(ir._workVectorFindOrAdd),e&&n.scaleInPlace(-1),s=this._polyface.addNormal(n));const r=this._options.needParams?t.packedUVParams:void 0;let o=-1,a=-1,c=-1;r&&(o=this.addParamInGrowableXYArray(r,0),a=this.addParamInGrowableXYArray(r,1));const l=this.findOrAddPointInLineString(t,0);let h=this.findOrAddPointInLineString(t,1),d=0,u=i;t.isPhysicallyClosed&&u--;for(let e=2;e<u;e++,h=d,a=c)d=this.findOrAddPointInLineString(t,e),this.addIndexedTrianglePointIndexes(l,h,d,!1),void 0!==s&&this.addIndexedTriangleNormalIndexes(s,s,s),r&&(c=this.addParamInGrowableXYArray(r,e),this.addIndexedTriangleParamIndexes(o,a,c)),this._polyface.terminateFacet();e&&this.toggleReversedFacetFlag()}}addPoint(t){return this._polyface.addPoint(t)}addParamXY(t,e){return this._polyface.addParamUV(t,e)}static _workPointFindOrAddA=$.create();static _workVectorFindOrAdd=tt.create();static _workUVFindOrAdd=H.create();findOrAddPointInLineString(t,e,i,n){const s=t.pointAt(e,ir._workPointFindOrAddA);if(s)return i&&i.multiplyPoint3d(s,s),this._polyface.addPoint(s,n)}findOrAddPointInGrowableXYZArray(t,e,i,n){const s=t.getPoint3dAtCheckedPointIndex(e,ir._workPointFindOrAddA);if(s)return i&&i.multiplyPoint3d(s,s),this._polyface.addPoint(s,n)}findOrAddNormalInGrowableXYZArray(t,e,i,n){const s=t.getVector3dAtCheckedVectorIndex(e,ir._workVectorFindOrAdd);if(s)return i&&i.multiplyVector(s,s),this._polyface.addNormal(s,n)}addParamInGrowableXYArray(t,e){if(!t)return;const i=t.getPoint2dAtCheckedPointIndex(e,ir._workUVFindOrAdd);return i?this._polyface.addParam(i):void 0}findOrAddParamInLineString(t,e,i,n,s){const r=t.fractions&&e<t.fractions.length?t.fractions.atUncheckedIndex(e):e/t.points.length;return this._polyface.addParamUV(r,i,n,s)}findOrAddNormalInLineString(t,e,i,n,s){const r=t.packedSurfaceNormals;if(r){const t=r.getVector3dAtCheckedVectorIndex(e,ir._workVectorFindOrAdd);if(t)return i&&i.multiplyVector(t,t),this._polyface.addNormal(t,n,s)}}addPointXYZ(t,e,i){return this._polyface.addPointXYZ(t,e,i)}getUVTransformForTriangleFacet(t,e,i){const n=t.vectorTo(e),s=t.vectorTo(i),r=xt.createRigidFromColumns(n,s,f.XYZ);return mt.createOriginAndMatrix(t,r).inverse()}getNormalForTriangularFacet(t,e,i){const n=t.vectorTo(e),s=t.vectorTo(i);let r=n.crossProduct(s).normalize();return r=r||tt.create(),r}addQuadFacet(t,e,i,n){if(t instanceof rt&&(t=t.getPoint3dArray()),t.length<4)return;const s=this.options.needParams,r=this.options.needNormals,o=this.options.needColors;let a,c,l,h,d,u,f,g,p,m,_,x,y,v,P,I;if(s)if(void 0!==e&&e.length>3)a=e[0],c=e[1],l=e[2],h=e[3];else{const e=this.getUVTransformForTriangleFacet(t[0],t[1],t[2]);void 0===e?a=c=l=h=H.createZero():(a=H.createFrom(e.multiplyPoint3d(t[0])),c=H.createFrom(e.multiplyPoint3d(t[1])),l=H.createFrom(e.multiplyPoint3d(t[2])),h=H.createFrom(e.multiplyPoint3d(t[3])))}if(r&&(void 0!==i&&i.length>3?(d=i[0],u=i[1],f=i[2],g=i[3]):(d=this.getNormalForTriangularFacet(t[0],t[1],t[2]),u=this.getNormalForTriangularFacet(t[0],t[1],t[2]),f=this.getNormalForTriangularFacet(t[0],t[1],t[2]),g=this.getNormalForTriangularFacet(t[0],t[1],t[2]))),o&&void 0!==n&&n.length>3&&(p=n[0],m=n[1],_=n[2],x=n[3]),this._options.shouldTriangulate){const e=t[0].vectorTo(t[2]),i=t[1].vectorTo(t[3]);e.magnitude()>=i.magnitude()?(this.addTriangleFacet([t[0],t[1],t[2]],s?[a,c,l]:void 0,r?[d,u,f]:void 0,o?[p,m,_]:void 0),this.addTriangleFacet([t[0],t[2],t[3]],s?[a,l,h]:void 0,r?[d,f,g]:void 0,o?[p,_,x]:void 0)):(this.addTriangleFacet([t[0],t[1],t[3]],s?[a,c,h]:void 0,r?[d,u,g]:void 0,o?[p,m,x]:void 0),this.addTriangleFacet([t[1],t[2],t[3]],s?[c,l,h]:void 0,r?[u,f,g]:void 0,o?[m,_,x]:void 0))}else s&&(y=this._polyface.addParam(a),v=this._polyface.addParam(c),P=this._polyface.addParam(l),I=this._polyface.addParam(h),this.addIndexedQuadParamIndexes(y,v,I,P)),r&&(y=this._polyface.addNormal(d),v=this._polyface.addNormal(u),P=this._polyface.addNormal(f),I=this._polyface.addNormal(g),this.addIndexedQuadNormalIndexes(y,v,I,P)),o&&(y=this._polyface.addColor(p),v=this._polyface.addColor(m),P=this._polyface.addColor(_),I=this._polyface.addColor(x),this.addIndexedQuadColorIndexes(y,v,I,P)),y=this.addPoint(t[0]),v=this.addPoint(t[1]),P=this.addPoint(t[2]),I=this.addPoint(t[3]),this.addIndexedQuadPointIndexes(y,v,I,P)}addIndexedQuadPointIndexes(t,e,i,n,s=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(n),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(n),this._polyface.addPointIndex(i)),s&&this._polyface.terminateFacet()}addIndexedQuadParamIndexes(t,e,i,n){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(n),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(n),this._polyface.addParamIndex(i))}addIndexedQuadNormalIndexes(t,e,i,n){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(n),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(n),this._polyface.addNormalIndex(i))}addIndexedQuadColorIndexes(t,e,i,n){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(n),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(n),this._polyface.addColorIndex(i))}addTriangleFacet(t,e,i,n){if(t.length<3)return;let s,r,o,a,c,l;if(t instanceof rt?(a=t.getPoint3dAtCheckedPointIndex(0),c=t.getPoint3dAtCheckedPointIndex(1),l=t.getPoint3dAtCheckedPointIndex(2)):(a=t[0],c=t[1],l=t[2]),this._options.needParams){if(e&&e.length>=3)s=this._polyface.addParam(e[0]),r=this._polyface.addParam(e[1]),o=this._polyface.addParam(e[2]);else{const t=this.getUVTransformForTriangleFacet(a,c,l);s=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(a):void 0)),r=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(c):void 0)),o=this._polyface.addParam(H.createFrom(t?t.multiplyPoint3d(c):void 0))}this.addIndexedTriangleParamIndexes(s,r,o)}if(this._options.needNormals){if(void 0!==i&&i.length>2)s=this._polyface.addNormal(i[0]),r=this._polyface.addNormal(i[1]),o=this._polyface.addNormal(i[2]);else{const t=this.getNormalForTriangularFacet(a,c,l);s=this._polyface.addNormal(t),r=this._polyface.addNormal(t),o=this._polyface.addNormal(t)}this.addIndexedTriangleNormalIndexes(s,r,o)}this._options.needColors&&void 0!==n&&n.length>2&&(s=this._polyface.addColor(n[0]),r=this._polyface.addColor(n[1]),o=this._polyface.addColor(n[2]),this.addIndexedTriangleColorIndexes(s,r,o)),s=this.addPoint(a),r=this.addPoint(c),o=this.addPoint(l),this.addIndexedTrianglePointIndexes(s,r,o)}addIndexedTrianglePointIndexes(t,e,i,n=!0){this._reversed?(this._polyface.addPointIndex(t),this._polyface.addPointIndex(i),this._polyface.addPointIndex(e)):(this._polyface.addPointIndex(t),this._polyface.addPointIndex(e),this._polyface.addPointIndex(i)),n&&this._polyface.terminateFacet()}addIndexedTriangleParamIndexes(t,e,i){this._reversed?(this._polyface.addParamIndex(t),this._polyface.addParamIndex(i),this._polyface.addParamIndex(e)):(this._polyface.addParamIndex(t),this._polyface.addParamIndex(e),this._polyface.addParamIndex(i))}addIndexedTriangleNormalIndexes(t,e,i){this._reversed?(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(i),this._polyface.addNormalIndex(e)):(this._polyface.addNormalIndex(t),this._polyface.addNormalIndex(e),this._polyface.addNormalIndex(i))}addIndexedTriangleColorIndexes(t,e,i){this._reversed?(this._polyface.addColorIndex(t),this._polyface.addColorIndex(i),this._polyface.addColorIndex(e)):(this._polyface.addColorIndex(t),this._polyface.addColorIndex(e),this._polyface.addColorIndex(i))}setSectorIndices(t){t.xyzIndex=this.addPoint(t.xyz),t.normal&&(t.normalIndex=this._polyface.addNormal(t.normal)),t.uv&&(t.uvIndex=this._polyface.addParam(t.uv))}addSectorTriangle(t,e,i){t.xyz.isAlmostEqual(e.xyz)||e.xyz.isAlmostEqual(i.xyz)||i.xyz.isAlmostEqual(t.xyz)||(this._options.needNormals&&this.addIndexedTriangleNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex),this._options.needParams&&this.addIndexedTriangleParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex),this.addIndexedTrianglePointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex,!0))}addSectorQuadA01B01(t,e,i,n){t.xyz.isAlmostEqual(e.xyz)&&i.xyz.isAlmostEqual(n.xyz)||(this._options.shouldTriangulate?(this.addSectorTriangle(t,e,n),this.addSectorTriangle(n,i,t)):(this._options.needNormals&&this.addIndexedQuadNormalIndexes(t.normalIndex,e.normalIndex,i.normalIndex,n.normalIndex),this._options.needParams&&this.addIndexedQuadParamIndexes(t.uvIndex,e.uvIndex,i.uvIndex,n.uvIndex),this.addIndexedQuadPointIndexes(t.xyzIndex,e.xyzIndex,i.xyzIndex,n.xyzIndex,!0)))}addBetweenLineStringsWithRuleEdgeNormals(t,e,i,n,s=!1){const r=t.packedPoints,o=i.packedPoints,a=t.packedDerivatives,c=i.packedDerivatives,l=t.fractions,h=i.fractions,d=this._options.needNormals,u=this._options.needParams,f=new er(d,u,d),g=new er(d,u,d),p=new er(d,u,d),m=new er(d,u,d),_=new er(d,u,d),x=new er(d,u,d),y=r.length;if(!(y<2||y!==o.length)){f.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,r,a,l,e),p.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0,o,c,h,n),d&&er.computeNormalsAlongRuleLine(f,p),this.setSectorIndices(f),this.setSectorIndices(p),_.copyContentsFrom(f),x.copyContentsFrom(p);for(let t=1;t<y;t++)g.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,r,a,l,e),m.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(t,o,a,h,n),er.computeNormalsAlongRuleLine(g,m),this.setSectorIndices(g),this.setSectorIndices(m),this.addSectorQuadA01B01(f,g,p,m),f.copyContentsFrom(g),p.copyContentsFrom(m);s&&this.addSectorQuadA01B01(f,_,p,x)}}addBetweenLineStringsWithStoredIndices(t,e){const i=t.pointIndices,n=e.pointIndices;let s=t.normalIndices,r=e.normalIndices;this._options.needNormals||(s=void 0,r=void 0);let o=t.paramIndices,a=e.paramIndices;this._options.needParams||(o=void 0,a=void 0);const c=i.length;for(let t=1;t<c;t++)this.options.shouldTriangulate?(sr(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),n.atUncheckedIndex(t))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),n.atUncheckedIndex(t),!1),s&&r&&this.addIndexedTriangleNormalIndexes(s.atUncheckedIndex(t-1),s.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1))),sr(n.atUncheckedIndex(t),n.atUncheckedIndex(t-1),i.atUncheckedIndex(t-1))&&(this.addIndexedTrianglePointIndexes(i.atUncheckedIndex(t-1),n.atUncheckedIndex(t),n.atUncheckedIndex(t-1),!1),s&&r&&this.addIndexedTriangleNormalIndexes(s.atUncheckedIndex(t-1),r.atUncheckedIndex(t),r.atUncheckedIndex(t-1)),o&&a&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t-1),a.atUncheckedIndex(t),a.atUncheckedIndex(t-1)))):i.atUncheckedIndex(t-1)===i.atUncheckedIndex(t)&&n.atUncheckedIndex(t-1)===n.atUncheckedIndex(t)||(this.addIndexedQuadPointIndexes(i.atUncheckedIndex(t-1),i.atUncheckedIndex(t),n.atUncheckedIndex(t-1),n.atUncheckedIndex(t),!1),s&&r&&this.addIndexedQuadNormalIndexes(s.atUncheckedIndex(t-1),s.atUncheckedIndex(t),r.atUncheckedIndex(t-1),r.atUncheckedIndex(t)),o&&a&&this.addIndexedQuadParamIndexes(o.atUncheckedIndex(t-1),o.atUncheckedIndex(t),a.atUncheckedIndex(t-1),a.atUncheckedIndex(t))),this._polyface.terminateFacet()}addBetweenTransformedLineStrings(t,e,i,n=!1){if(t instanceof Fe){const s=t.points.length;let r=this.findOrAddPointInLineString(t,0,e),o=this.findOrAddPointInLineString(t,0,i);const a=r,c=o;let l=0,h=0;for(let n=1;n<s;n++)l=this.findOrAddPointInLineString(t,n,e),h=this.findOrAddPointInLineString(t,n,i),this.addIndexedQuadPointIndexes(r,l,o,h),r=l,o=h;n&&this.addIndexedQuadPointIndexes(r,a,o,c)}else{const n=t.children;if(n)for(const t of n)this.addBetweenTransformedLineStrings(t,e,i)}}addBetweenStrokeSetPair(t,e,i,n){if(t instanceof Fe&&i instanceof Fe)this.addBetweenLineStringsWithRuleEdgeNormals(t,e,i,n,!1);else if(t instanceof Ti&&i instanceof Ti){if(t.children.length===i.children.length)for(let s=0;s<t.children.length;s++)this.addBetweenStrokeSetPair(t.children[s],e,i.children[s],n)}else if(t instanceof ti&&i instanceof ti){const s=t.children,r=i.children;if(s.length===r.length)for(let t=0;t<s.length;t++){const i=s[t],o=r[t];i instanceof Fe&&o instanceof Fe&&this.addBetweenLineStringsWithRuleEdgeNormals(i,e,o,n)}}}addCone(t){let e=16;this._options&&(e=this._options.applyTolerancesToArc(t.getMaxRadius()));let i=1;const n=t.strokeConstantVSection(0,e,this._options),s=t.strokeConstantVSection(1,e,this._options);if(this._options){const t=rt.distanceRangeBetweenCorrespondingPoints(n.packedPoints,s.packedPoints);i=this._options.applyMaxEdgeLength(1,t.low)}const r=t.maxIsoParametricDistance();this.addUVGridBody(t,e,i,De.create(0,r.x),De.create(0,r.y)),this.endFace(),t.capped&&(J.isSmallMetricDistance(t.getRadiusA())||(this.addTrianglesInUncheckedConvexPolygon(n,!0),this.endFace()),J.isSmallMetricDistance(t.getRadiusB())||(this.addTrianglesInUncheckedConvexPolygon(s,!1),this.endFace()))}addTorusPipe(t,e,i){const n=t.getThetaFraction();let s=J.clamp(J.resolveNumber(e,8),4,64),r=J.clamp(J.resolveNumber(i,Math.ceil(16*n)),2,64);this._options&&(s=this._options.applyTolerancesToArc(t.getMinorRadius()),r=this._options.applyTolerancesToArc(t.getMajorRadius(),t.getSweepAngle().radians)),this.toggleReversedFacetFlag();const o=t.maxIsoParametricDistance();if(this.addUVGridBody(t,s,r,De.create(0,o.x),De.create(0,o.y)),this.toggleReversedFacetFlag(),t.capped&&n<1){const e=t.getConstructiveFrame(),i=t.getMinorRadius(),n=t.getMajorRadius(),r=2*i,o=n-i,a=n+i,c=-i,l=mt.createRowValues(r,0,0,o,0,0,-1,0,0,r,0,c),h=e.multiplyTransformTransform(l).inverse();if(h){const e=Qs.createLinestringOnUVLine(t,0,0,1,0,s,!1,!0);e.computeUVFromXYZTransform(h),this.addTrianglesInUncheckedConvexPolygon(e,!1)}const d=t.getSweepAngle().radians,u=Math.cos(d),f=Math.sin(d),g=mt.createRowValues(-u*r,0,-f,a*u,-f*r,0,u,a*f,0,r,0,c),p=e.multiplyTransformTransform(g).inverse();if(p){const e=Qs.createLinestringOnUVLine(t,1,1,0,1,s,!1,!0);e.computeUVFromXYZTransform(p),this.addTrianglesInUncheckedConvexPolygon(e,!1)}}}addLinearSweepLineStringsXYZOnly(t,e){if(t instanceof Fe){let i=$.create(),n=$.create(),s=0,r=0,o=0,a=0;const c=t.numPoints();for(let l=0;l<c;l++)i=t.pointAt(l,i),n=i.plus(e,n),r=this.addPoint(i),a=this.addPoint(n),l>0&&this.addIndexedQuadPointIndexes(s,r,o,a),s=r,o=a}else if(t instanceof ti)for(const i of t.children)this.addLinearSweepLineStringsXYZOnly(i,e)}addRotationalSweep(t){const e=t.getSweepContourRef(),i=qs.createForParityRegionOrChain(e.getCurves(),this._options).getStrokes(),n=t.cloneAxisRay(),s=t.getSweep();s.radians<0&&(n.direction.scaleInPlace(-1),s.setRadians(-s.radians));const r=zs.computeMaxVectorFromRay(n,i),o=n.direction.crossProduct(r),a=e.localToWorld.matrix.dotColumnZ(o)>0;a||i.reverseInPlace(),this._options.needNormals&&zs.buildRotationalNormalsInLineStrings(i,n,o);const c=r.magnitude(),l=Math.abs(c*s.radians);let h=be.applyAngleTol(this._options,1,s.radians,void 0);h=be.applyMaxEdgeLength(this._options,h,l);for(let e=1;e<=h;e++){const n=t.getFractionalRotationTransform((e-1)/h),s=t.getFractionalRotationTransform(e/h);this.addBetweenRotatedStrokeSets(i,n,e-1,s,e)}if(t.capped){e.purgeFacets();const i=a;e.emitFacets(this,i,void 0),e.emitFacets(this,!i,t.getFractionalRotationTransform(1))}}addTriangulatedRegion(t){const e=Cs.createForLinearSweep(t);e&&e.emitFacets(this,this.reversedFlag,void 0)}applyStrokeCountsToCurvePrimitives(t){const e=this._options;if(t instanceof le)t.computeStrokeCountForOptions(e);else if(t instanceof $e){const e=t.children;if(e)for(const t of e)this.applyStrokeCountsToCurvePrimitives(t)}}addBetweenStrokeSetsWithRuledNormals(t,e,i){const n=[t],s=[0];for(let r=1;r<i;r++){const o=r/i,a=Ei.interpolateBetween(t,r/i,e);n.push(a),s.push(o)}n.push(e),s.push(1);for(let t=0;t<i;t++)this.addBetweenStrokeSetPair(n[t],s[t],n[t+1],s[t+1])}createIndicesInLineString(t,e,i){const n=t.numPoints(),s=t.ensureEmptyPointIndices(),r=this.findOrAddPointInLineString(t,0,i);if(s.push(r),n>1){let e,o=r;for(let r=1;r+1<n;r++)e=this.findOrAddPointInLineString(t,r,i,o),s.push(e),o=e;e=this.findOrAddPointInLineString(t,n-1,i,r),s.push(e)}if(this._options.needNormals&&void 0!==t.packedSurfaceNormals){const e=t.ensureEmptyNormalIndices(),s=this.findOrAddNormalInLineString(t,0,i);if(e.push(s),n>1){let r,o=s;for(let s=1;s+1<n;s++)r=this.findOrAddNormalInLineString(t,s,i,o),e.push(r),o=r;r=this.findOrAddNormalInLineString(t,n-1,i,s,o),e.push(r)}}if(this._options.needParams&&void 0!==t.packedUVParams){const i=t.ensureEmptyUVIndices(),s=this.findOrAddParamInLineString(t,0,e);if(i.push(s),n>1){let r,o=s;for(let s=1;s+1<n;s++)r=this.findOrAddParamInLineString(t,s,e,o),i.push(r),o=r;r=this.findOrAddParamInLineString(t,n-1,e,o,s),i.push(r)}}}addBetweenRotatedStrokeSets(t,e,i,n,s){if(t instanceof Fe){const r=t.cloneTransformed(e);this.createIndicesInLineString(r,i);const o=t.cloneTransformed(n);this.createIndicesInLineString(o,s),this.addBetweenLineStringsWithStoredIndices(r,o)}else if(t instanceof Ti)for(const r of t.children)this.addBetweenRotatedStrokeSets(r,e,i,n,s);else if(t instanceof ti)for(const r of t.children)r instanceof Fe&&this.addBetweenRotatedStrokeSets(r,e,i,n,s)}addLinearSweep(t){const e=t.getCurvesRef(),i=qs.createForParityRegionOrChain(e,this._options).getStrokes(),n=t.cloneSweepVector(),s=mt.createTranslation(n),r=i.cloneTransformed(s),o=this._options.applyMaxEdgeLength(1,n.magnitude());if(this.addBetweenStrokeSetsWithRuledNormals(i,r,o),t.capped&&e.isAnyRegionType){const e=t.getSweepContourRef();e.purgeFacets();const i=e.localToWorld.matrix.dotColumnZ(n)>0;e.emitFacets(this,i,void 0),e.emitFacets(this,!i,s)}}addRuledSweep(t){const e=t.sweepContoursRef();let i,n;const s=[];for(const t of e)s.push(qs.createForParityRegionOrChain(t.curves,this._options));if(qs.enforceStrokeCountCompatibility(s)){qs.enforceCompatibleDistanceSums(s);for(let t=0;t<e.length;t++){if(n=s[t].getStrokes(),n||(n=e[t].curves.cloneStroked()),t>0&&i&&n){const t=gt.createNull();if(qs.extendDistanceRangeBetweenStrokes(i,n,t)&&!t.isNull){const e=this._options.applyMaxEdgeLength(1,t.high);this.addBetweenStrokeSetsWithRuledNormals(i,n,e)}}i=n}}return t.capped&&e[0].curves.isAnyRegionType&&(e[0].purgeFacets(),e[0].emitFacets(this,!0,void 0),e[e.length-1].purgeFacets(),e[e.length-1].emitFacets(this,!1,void 0)),!0}addSphere(t,e){let i=e||this.options.applyTolerancesToArc(t.maxAxisRadius());J.isOdd(i)&&(i+=1);const n=J.clampToStartEnd(Math.abs(i*t.latitudeSweepFraction),1,Math.ceil(.5*i)),s=t.strokeConstantVSection(0,i,this._options);t.capped&&!J.isSmallMetricDistance(s.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(s,!0),this.endFace());const r=t.maxIsoParametricDistance();this.addUVGridBody(t,i,n,De.create(0,r.x),De.create(0,r.y)),this.endFace();const o=t.strokeConstantVSection(1,i,this._options);t.capped&&!J.isSmallMetricDistance(o.quickLength())&&(this.addTrianglesInUncheckedConvexPolygon(o,!1),this.endFace())}addBox(t){const e=t.getCorners(),i=J.maxXY(t.getBaseX(),t.getBaseX()),n=J.maxXY(t.getBaseY(),t.getTopY());let s=0;for(let t=0;t<4;t++)s=J.maxXY(s,e[t].distance(e[t+4]));const r=this._options.applyMaxEdgeLength(1,i),o=this._options.applyMaxEdgeLength(1,n),a=this._options.applyMaxEdgeLength(1,s),c=De.create(0,i),l=De.create(0,s);this.addUVGridBody(Gs.create(e[0],e[1],e[4],e[5]),r,a,c,l),c.shift(i),this.addUVGridBody(Gs.create(e[1],e[3],e[5],e[7]),o,a,c,l),c.shift(n),this.addUVGridBody(Gs.create(e[3],e[2],e[7],e[6]),r,a,c,l),c.shift(i),this.addUVGridBody(Gs.create(e[2],e[0],e[6],e[4]),o,a,c,l),this.endFace(),t.capped&&(c.set(0,i),l.set(0,n),this.addUVGridBody(Gs.create(e[4],e[5],e[6],e[7]),r,o,c,l),this.endFace(),c.set(0,i),l.set(0,n),this.addUVGridBody(Gs.create(e[2],e[3],e[0],e[1]),r,o,c,l),this.endFace())}addPolygon(t,e){for(void 0===e&&(e=t.length);e>1&&t[e-1].isAlmostEqual(t[0]);)e--;let i=0;if(this._reversed)for(let n=e;--n>=0;)i=this.addPoint(t[n]),this._polyface.addPointIndex(i);else for(let n=0;n<e;n++)i=this.addPoint(t[n]),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}addPolygonGrowableXYZArray(t){let e=t.length;for(;e>2&&J.isSmallMetricDistance(t.distanceIndexIndex(0,e-1));)e--;for(;e>2&&J.isSmallMetricDistance(t.distanceIndexIndex(e-2,e-1));)e--;if(3===e){const i=t.crossProductIndexIndexIndex(0,1,2).magnitude(),n=t.distanceIndexIndex(0,1)+t.distanceIndexIndex(0,2)+t.distanceIndexIndex(1,2);i<J.smallMetricDistance*n&&(e=0)}if(e>2){let i=0;if(this._reversed)for(let n=e;--n>=0;)i=this.findOrAddPointInGrowableXYZArray(t,n),this._polyface.addPointIndex(i);else for(let n=0;n<e;n++)i=this.findOrAddPointInGrowableXYZArray(t,n),this._polyface.addPointIndex(i);this._polyface.terminateFacet()}}addFacetFromGrowableArrays(t,e,i,n,s){let r=t.length;for(;r>1&&J.isSmallMetricDistance(t.distanceIndexIndex(0,r-1));)r--;let o=0;if(e&&e.length<r&&(e=void 0),i&&i.length<r&&(i=void 0),n&&n.length<r&&(n=void 0),s&&s.length<r&&(s=void 0),this._reversed)for(let s=r;--s>=0;)o=this.findOrAddPointInGrowableXYZArray(t,s),this._polyface.addPointIndex(o),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,s),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,s),this._polyface.addParamIndex(o)),n&&(o=this._polyface.addColor(n[s]),this._polyface.addColorIndex(o));else for(let a=0;a<r;a++)o=this.findOrAddPointInGrowableXYZArray(t,a),this._polyface.addPointIndex(o,!s||s[a]),e&&(o=this.findOrAddNormalInGrowableXYZArray(e,a),this._polyface.addNormalIndex(o)),i&&(o=this.addParamInGrowableXYArray(i,a),this._polyface.addParamIndex(o)),n&&(o=this._polyface.addColor(n[a]),this._polyface.addColorIndex(o));this._polyface.terminateFacet()}addFacetFromVisitor(t){this.addFacetFromGrowableArrays(t.point,t.normal,t.param,t.color,t.edgeVisible)}addFacetsFromVisitor(t){for(t.reset();t.moveToNextFacet();)this.addFacetFromVisitor(t)}addFacetFromIndexedVisitor(t,e){if(e.length>t.pointIndex.length)return!1;const i=new rt(e.length),n=t.normal?new rt(e.length):void 0,s=t.param?new Ee(e.length):void 0,r=t.color?new Array(e.length):void 0,o=t.edgeVisible?new Array(e.length):void 0;for(let a=0;a<e.length;++a){const c=e[a];if(c<0||c>=t.point.length)return!1;i.pushXYZ(t.point.getXAtUncheckedPointIndex(c),t.point.getYAtUncheckedPointIndex(c),t.point.getZAtUncheckedPointIndex(c)),t.normal&&n&&n.pushXYZ(t.normal.getXAtUncheckedPointIndex(c),t.normal.getYAtUncheckedPointIndex(c),t.normal.getZAtUncheckedPointIndex(c)),t.param&&s&&s.pushXY(t.param.getXAtUncheckedPointIndex(c),t.param.getYAtUncheckedPointIndex(c)),t.color&&r&&(r[a]=t.color[c]),t.edgeVisible&&o&&(o[a]=t.edgeVisible[c])}return this.addFacetFromGrowableArrays(i,n,s,r,o),!0}addIndexedPolyface(t,e=!1,i){this._polyface.addIndexedPolyface(t,e,i)}endFace(){return this._polyface.setNewFaceData()}handleCone(t){return this.addCone(t)}handleTorusPipe(t){return this.addTorusPipe(t)}handleSphere(t){return this.addSphere(t)}handleBox(t){return this.addBox(t)}handleLinearSweep(t){return this.addLinearSweep(t)}handleRotationalSweep(t){return this.addRotationalSweep(t)}handleRuledSweep(t){return this.addRuledSweep(t)}handleLoop(t){return this.addTriangulatedRegion(t)}handleParityRegion(t){return this.addTriangulatedRegion(t)}handleUnionRegion(t){return this.addTriangulatedRegion(t)}addGeometryQuery(t){t.dispatchToGeometryHandler(this)}addGraph(t,e=t=>ln.testNodeMaskNotExterior(t),i=t=>ln.testMateMaskExterior(t)){let n=0;const s=this._options.needNormals,r=this._options.needParams;let o=0;s&&(o=this._polyface.addNormalXYZ(0,0,1)),t.announceFaceLoops(((t,a)=>{if(e(a)&&a.countEdgesAroundFace()>2){let t=a;do{n=this.addPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(n,void 0===i||i(t)),r&&(n=this.addParamXY(t.x,t.y),this._polyface.addParamIndex(n)),s&&this._polyface.addNormalIndex(o),t=t.faceSuccessor}while(t!==a);this._polyface.terminateFacet()}return!0}))}addGraphFaces(t){let e=0;for(const i of t){let t=i;do{e=this.addPointXYZ(t.x,t.y,t.z),this._polyface.addPointIndex(e),t=t.faceSuccessor}while(t!==i);this._polyface.terminateFacet()}}static graphToPolyface(t,e,i=t=>ln.testNodeMaskNotExterior(t),n=t=>ln.testMateMaskExterior(t)){const s=ir.create(e);return s.addGraph(t,i,n),s.endFace(),s.claimPolyface()}static graphFacesToPolyface(t){const e=ir.create();return e.addGraphFaces(t),e.endFace(),e.claimPolyface()}static polygonToTriangulatedPolyface(t,e){if(e||(e=bi.createFrameWithCCWPolygon(t)),e){const i=e.multiplyInversePoint3dArray(t);zr.areaXY(i)<0&&i.reverse();const n=Ln.createTriangulatedGraphFromSingleLoop(i);if(n){const t=this.graphToPolyface(n);return t.tryTransformInPlace(e),t}}}addCoordinateFacets(t,e,i,n=!1){for(let n=0;n<t.length;n++){const s=e?e[n]:void 0,r=i?i[n]:void 0;3===t[n].length?this.addTriangleFacet(t[n],s,r):4===t[n].length&&this.addQuadFacet(t[n],s,r)}n&&this.endFace()}addUVGridBody(t,e,i,n,s){let r,o,a,c,l=new bt(e),h=new bt(e);const d=this._reversed,u=this.options.needNormals;u&&(a=new bt(e),c=new bt(e));const f=this.options.needParams;let g;f&&(r=new bt(e),o=new bt(e)),l.ensureCapacity(e),h.ensureCapacity(e);const p=H.create(),m=tt.create(),_=1/e,x=1/i,y=Mt.createXYPlane();for(let v=0;v<=i;v++){h.clear(),u&&c.clear(),f&&o.clear();for(let i=0;i<=e;i++){const e=i*_,r=v*x;t.uvFractionToPointAndTangents(e,r,y),h.push(this._polyface.addPoint(y.origin)),u&&(y.vectorU.crossProduct(y.vectorV,m),m.normalizeInPlace(),d&&m.scaleInPlace(-1),c.push(this._polyface.addNormal(m))),f&&o.push(this._polyface.addParam(H.create(n?n.fractionToPoint(e):e,s?s.fractionToPoint(r):r,p)))}if(v>0)for(let t=0;t<e;t++)this._options.shouldTriangulate?(this.addIndexedTrianglePointIndexes(l.atUncheckedIndex(t),l.atUncheckedIndex(t+1),h.atUncheckedIndex(t),!1),u&&this.addIndexedTriangleNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t)),f&&this.addIndexedTriangleParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t)),this._polyface.terminateFacet(),this.addIndexedTrianglePointIndexes(h.atUncheckedIndex(t),l.atUncheckedIndex(t+1),h.atUncheckedIndex(t+1),!1),u&&this.addIndexedTriangleNormalIndexes(c.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t+1)),f&&this.addIndexedTriangleParamIndexes(o.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet()):(this.addIndexedQuadPointIndexes(l.atUncheckedIndex(t),l.atUncheckedIndex(t+1),h.atUncheckedIndex(t),h.atUncheckedIndex(t+1),!1),u&&this.addIndexedQuadNormalIndexes(a.atUncheckedIndex(t),a.atUncheckedIndex(t+1),c.atUncheckedIndex(t),c.atUncheckedIndex(t+1)),f&&this.addIndexedQuadParamIndexes(r.atUncheckedIndex(t),r.atUncheckedIndex(t+1),o.atUncheckedIndex(t),o.atUncheckedIndex(t+1)),this._polyface.terminateFacet());g=h,h=l,l=g,f&&(g=o),o=r,r=g,u&&(g=c),c=a,a=g}l.clear(),h.clear()}static pointsToTriangulatedPolyface(t,e){const i=Ln.createTriangulatedGraphFromPoints(t,N.ReplaceIfLarger,e?.chordTol);if(i)return ir.graphToPolyface(i,e)}addGreedyTriangulationBetweenLineStrings(t,e){$s.createContext().emitTriangles(nr(t),nr(e),(t=>{this.addTriangleFacet(t.points)}))}addMiteredPipes(t,e,i=12,n=!1){const s=Xs.createArcFromSectionData(t,e);if(!s)return;i<3&&(i=3);const r=Fe.create();r.appendFractionalStrokePoints(s,i,0,1,!0);const o={strokeOptions:this._options.clone(),capped:n,outputSelect:z.AlsoMesh,startTangent:e instanceof Si?s.binormalVector():void 0},a=Xs.createMiteredSweepSections(t,r,o);a&&a.mesh&&this.addIndexedPolyface(a.mesh)}getEdgeIndices(t){let e=-1,i=-1;for(let n=this._polyface.facetIndex0(t.facetIndex);n<this._polyface.facetIndex1(t.facetIndex);++n)t.startVertex===this._polyface.data.pointIndex[n]?e=n:t.endVertex===this._polyface.data.pointIndex[n]&&(i=n);return e<0||i<0?void 0:{edgeIndexA:e,edgeIndexB:i}}addSweptFace(t,e){const i=this.getEdgeIndices(t);if(void 0===i)return!1;const n=e+t.facetIndex;if(!this._polyface.isValidFacetIndex(n))return!1;const s=this._polyface.numEdgeInFacet(t.facetIndex);if(s!==this._polyface.numEdgeInFacet(n))return!1;const r=this._polyface.facetIndex0(t.facetIndex),o=this._polyface.facetIndex0(n),a=s-1-(i.edgeIndexA-r),c=s-1-(i.edgeIndexB-r),l=[i.edgeIndexB,i.edgeIndexA,o+a,o+c],h=[];let d;void 0!==this.options.needColors&&void 0!==this._polyface.data.color&&void 0!==this._polyface.data.colorIndex&&(d=[]);for(let t=0;t<4;++t){const e=this._polyface.data.getPoint(this._polyface.data.pointIndex[l[t]]);if(void 0===e)return!1;if(h.push(e),void 0!==d){const e=this._polyface.data.getColor(this._polyface.data.colorIndex[l[t]]);if(void 0===e)return!1;d.push(e)}}return this.addQuadFacet(h,void 0,void 0,d),!0}addSweptIndexedPolyface(t,e,i=!1){let n=!0;const s=bs.sumFacetAreas(t,e);J.isAlmostEqualNumber(0,s)&&(n=!1);const r=bs.partitionFacetIndicesByVisibilityVector(t,e,G.createDegrees(.001)),o=r[0].length,a=r[1].length;r[2].length>0&&(n=!1),o>0&&a>0&&(n=!1);const c=o>0,l=this._polyface.facetCount;this.addIndexedPolyface(t,c);const h=this._polyface.facetCount;this.addIndexedPolyface(t,!c,mt.createTranslation(e));const d=h-l,u=Array.from({length:d},((t,e)=>l+e)),f=Zi.createSubsetVisitor(this._polyface,u,1),g=[];bs.createIndexedEdges(f).sortAndCollectClusters(void 0,g,void 0,void 0);const p=this._options.shouldTriangulate;this._options.shouldTriangulate=i;for(const t of g)if(t instanceof is)this.addSweptFace(t,d);else if(Array.isArray(t))for(const e of t)this.addSweptFace(e,d);return this._options.shouldTriangulate=p,n}}function nr(t){return Array.isArray(t)?new he(t):t instanceof Fe?t.packedPoints:t}function sr(t,e,i){return t!==e&&e!==i&&i!==t}class rr{_activeMomentData;_gaussMapper;constructor(t=5){this._activeMomentData=wi.create(),this._activeMomentData.needOrigin=!0,this._gaussMapper=new ae(t)}get momentData(){return this._activeMomentData}startParentCurvePrimitive(t){}startCurvePrimitive(t){}endCurvePrimitive(t){}endParentCurvePrimitive(t){}announceIntervalForUniformStepStrokes(t,e,i,n){this.startCurvePrimitive(t),e<1&&(e=1);const s=1/e;let r,o;for(let a=1;a<=e;a++){const c=J.interpolate(i,(a-1)*s,n),l=a===e?n:J.interpolate(i,a*s,n),h=this._gaussMapper.mapXAndW(c,l);for(let e=0;e<h;e++){o=this._gaussMapper.gaussX[e];const i=t.fractionToPointAndDerivative(o);r=this._gaussMapper.gaussW[e]*i.direction.magnitude(),this._activeMomentData.accumulateScaledOuterProduct(i.origin,r)}}}announceSegmentInterval(t,e,i,n,s,r){this._activeMomentData.accumulateLineMomentsXYZ(e,i)}announcePointTangent(t,e,i){}visitLeaves(t){if(t instanceof le)t.emitStrokableParts(this);else if(t instanceof $e)for(const e of t.children)this.visitLeaves(e)}}class or{_chains;_makeClones;static _staticPointA;static _staticPointB;pushNewChain(t){const e=[];t&&e.push(t),this._chains.push(e)}findOrCreateTailChain(){return 0===this._chains.length&&this.pushNewChain(),this._chains[this._chains.length-1]}_xyzWork0;findAnyChainToConnect(t){for(let e=0;e<this._chains.length;e++){const i=this._chains[e];if(this._xyzWork1=i[i.length-1].endPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!0};if(this._xyzWork1=i[0].startPoint(this._xyzWork1),this._xyzWork1.isAlmostEqual(t))return{chainIndex:e,atEnd:!1}}}constructor(t){this._chains=[],this._makeClones=t}_xyzWork1;announceCurvePrimitive(t,e=!1){if(t){if(this._makeClones){const e=t.clone();if(!(e&&e instanceof le))return;this.transferMarkup(t,e),t=e}if(e){this._xyzWork0=t.startPoint(this._xyzWork0);let e=this.findAnyChainToConnect(this._xyzWork0);e?e.atEnd?this._chains[e.chainIndex].push(t):(t.reverseInPlace(),this._chains[e.chainIndex].splice(0,0,t)):(this._xyzWork0=t.endPoint(this._xyzWork0),e=this.findAnyChainToConnect(this._xyzWork0),e?e.atEnd?(t.reverseInPlace(),this._chains[e.chainIndex].push(t)):this._chains[e.chainIndex].splice(0,0,t):this._chains.push([t]))}else{const e=this.findOrCreateTailChain();0!==e.length&&or.needBreakBetweenPrimitives(e[e.length-1],t)?this.pushNewChain(t):e.push(t)}}}transferMarkup(t,e){t&&e&&(e.startCut=t.startCut,e.endCut=t.endCut)}promoteArrayToCurves(t,e){if(0!==t.length)return e&&(or._staticPointA=t[0].startPoint(or._staticPointA),or._staticPointB=t[t.length-1].endPoint(or._staticPointB),or._staticPointA.isAlmostEqual(or._staticPointB))?oi.createArray(t):1===t.length?t[0]:ii.createArray(t)}grabResult(t=!1){const e=this._chains;if(0===e.length)return;if(1===e.length)return this.promoteArrayToCurves(e[0],t);const i=ei.create();for(const n of e){const e=this.promoteArrayToCurves(n,t);i.tryAddChild(e)}return i}static needBreakBetweenPrimitives(t,e,i=!1){return void 0===t||void 0===e||void 0!==t.endCut||void 0!==e.startCut||(or._staticPointA=t.endPoint(or._staticPointA),or._staticPointB=e.startPoint(or._staticPointB),i?!or._staticPointA.isAlmostEqualXY(or._staticPointB):!or._staticPointA.isAlmostEqual(or._staticPointB))}}class ar extends Ge{constructor(){super(void 0)}doClone(t){return t instanceof Si&&t.sweep.isFullCircle?[t.clonePartialCurve(0,.5),t.clonePartialCurve(.5,1)]:t}static clone(t){const e=new ar;return t.announceToCurveProcessor(e),e._result}}class cr extends Ie{_options;constructor(t){super(),this._options=t||new kr}handleCurveChain(t){const e=t.children.length,i=[];let n=0;for(let s=0;s<e;){const r=t.children[s];if(this._options.consolidateLinearGeometry&&(r instanceof Te||r instanceof Fe)){i.length=0;let o=s;for(;o<t.children.length;o++){const e=t.children[o];if(e instanceof Te)i.push(e.startPoint()),i.push(e.endPoint());else{if(!(e instanceof Fe))break;{const t=e.packedPoints;for(let e=0;e<t.length;e++)i.push(t.getPoint3dAtUncheckedPointIndex(e))}}}if(i.length<=1)t.children[n++]=r;else if(this._options.disableLinearCompression){const e=Ci.compressShortEdges(i,J.smallFloatingPoint);t.children[n++]=Fe.createPoints(e)}else{const r=Ci.compressShortEdges(i,this._options.duplicatePointTolerance),a=Ci.compressByPerpendicularDistance(r,this._options.colinearPointTolerance);0===s&&o===e&&Ai.compressColinearWrapInPlace(a,this._options.duplicatePointTolerance,this._options.colinearPointTolerance),a.length<2?t.children[n++]=Fe.create(a[0]):2===a.length?t.children[n++]=Te.create(a[0],a[1]):t.children[n++]=Fe.createPoints(a)}s=o}else if(this._options.consolidateCompatibleArcs&&r instanceof Si){for(;++s<t.children.length;){const e=t.children[s];if(!(e instanceof Si))break;if(!Xs.appendToArcInPlace(r,e))break}t.children[n++]=r}else t.children[n++]=r,s++}t.children.length=n}handlePath(t){return this.handleCurveChain(t)}handleLoop(t){return this.handleCurveChain(t)}handleParityRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}handleUnionRegion(t){for(const e of t.children)e.dispatchToGeometryHandler(this)}}class lr{fraction;otherCurveDetail;constructor(t,e){this.fraction=t,this.otherCurveDetail=e}setFrom(t,e){e&&this.isSameFraction(t)&&(this.otherCurveDetail=t.otherCurveDetail?t.otherCurveDetail:this.otherCurveDetail),this.fraction=t.fraction}isSameFraction(t){return J.isSmallAngleRadians(this.fraction-t.fraction)}set(t,e){this.fraction=t,this.otherCurveDetail=e}}class hr{static hasInteriorDetailAIntersections(t,e=J.smallAngleRadians){if(0===t.length)return!1;for(const i of t)if(i.detailA.fraction>e||i.detailA.fraction<1-e)return!0;return!1}collectFragmentAndAdvanceCut(t,e,i,n){if(!e.isSameFraction(i)){const s=t.clonePartialCurve(e.fraction,i.fraction);void 0!==s&&(s.startCut=e.otherCurveDetail,s.endCut=i.otherCurveDetail,n.push(s))}e.setFrom(i,!0)}collectSinglePrimitiveFragments(t,e,i){if(void 0===e||!hr.hasInteriorDetailAIntersections(e))return void i.push(t.clone());e.sort(((t,e)=>t.detailA.fraction-e.detailA.fraction));const n=new lr(0,void 0),s=new lr(1,void 0);for(const r of e)s.set(r.detailA.fraction,r.detailB),this.collectFragmentAndAdvanceCut(t,n,s,i);s.set(1,void 0),this.collectFragmentAndAdvanceCut(t,n,s,i)}static cloneCurvesWithXYSplits(t,e){const i=new hr;if(t instanceof le){const n=[],s=Ki.intersectionXYPairs(t,!1,e,!1);return i.collectSinglePrimitiveFragments(t,s,n),1===n.length?n[0]:ii.createArray(n)}if(t instanceof ti){const n=[];for(const s of t.children){const t=Ki.intersectionXYPairs(s,!1,e,!1);i.collectSinglePrimitiveFragments(s,t,n)}return ii.createArray(n)}}}class dr{static testPointInOnOutLoopXY(t,e,i){let n;const s=$.create(e,i);for(let r=0;Math.abs(r)<6;r=-1.2313*(r+.3212897)){n=yt.createXYAngle(e,i,G.createRadians(r));const o=n.getNormalRef(),a=[];for(const e of t.children)e instanceof le&&e.appendPlaneIntersectionPoints(n,a);le.snapAndRestrictDetails(a,!1,!0);let c,l,h=0,d=0,u=0;for(const t of a){if(t.intervalRole!==v.isolated&&void 0!==t.intervalRole&&u++,c=t.point.x-e,l=t.point.y-i,J.isSameCoordinateXY(c,l,0,0))return 0;const n=J.crossProductXYXY(o.x,o.y,c,l);if(s.isAlmostEqualXY(t.point))return 0;n<0?h++:n>0&&d++}if(0!==u)continue;const f=1&h;if(f===(1&d))return 1===f?1:-1}return-1}static testPointInOnOutParityRegionXY(t,e,i){let n=-1;for(const s of t.children)if(s instanceof oi){const t=this.testPointInOnOutLoopXY(s,e,i);if(0===t)return 0;t>0&&(n=-n)}return n}static testPointInOnOutUnionRegionXY(t,e,i){for(const n of t.children){const t=this.testPointInOnOutRegionXY(n,e,i);if(t>=0)return t}return-1}static testPointInOnOutRegionXY(t,e,i){return t instanceof oi?this.testPointInOnOutLoopXY(t,e,i):t instanceof Ti?this.testPointInOnOutParityRegionXY(t,e,i):t instanceof gn?this.testPointInOnOutUnionRegionXY(t,e,i):-1}}class ur{primitiveToPair=new Map;primitiveToIndex=new Map;_numIndexedPrimitives=0;assignPrimitiveIndex(t){void 0!==t&&void 0===this.primitiveToIndex.get(t)&&this.primitiveToIndex.set(t,this._numIndexedPrimitives++)}insertPrimitiveToPair(t,e){if(t){const i=this.primitiveToPair.get(t);this.assignPrimitiveIndex(t),i?i.push(e):this.primitiveToPair.set(t,[e])}}insertPair(t){const e=t.detailA.curve;e&&this.insertPrimitiveToPair(e,t);const i=t.detailB.curve;i&&this.insertPrimitiveToPair(i,t)}splitAndAppendMissingClosedPrimitives(t,e=J.smallMetricDistance){for(const i of t){let t=!1;if(i instanceof Si?t=i.sweep.isFullCircle:i instanceof Te||i instanceof Fe||(t=i.startPoint().isAlmostEqualXY(i.endPoint(),e)),t&&!this.primitiveToPair.has(i)){const t=i.clonePartialCurve(0,.5),e=i.clonePartialCurve(.5,1);t&&e&&(this.insertPair(It.createCapture(Pt.createCurveEvaluatedFraction(t,0),Pt.createCurveEvaluatedFraction(e,1))),this.insertPair(It.createCapture(Pt.createCurveEvaluatedFraction(t,1),Pt.createCurveEvaluatedFraction(e,0))))}}}}class fr{static assembleHalfEdgeGraph(t,e,i=J.smallMetricDistance){const n=new ur;for(const t of e)n.insertPair(t);t.length>n.primitiveToPair.size&&n.splitAndAppendMissingClosedPrimitives(t,i);const s=new hn;for(const t of n.primitiveToPair.entries()){const e=t[0],n=t[1].reduce(((t,i)=>{if(!i.detailA.hasFraction1)return[...t,i];const n=mr(i,e),s=Pt.createCurveFractionPoint(e,n.fraction,n.point),r=Pt.createCurveFractionPoint(e,n.fraction1,n.point1);return[...t,It.createCapture(s,s),It.createCapture(r,r)]}),[]);n.sort(((t,i)=>pr(t,e)-pr(i,e)));let r={point:e.startPoint(),fraction:0};for(const t of n){const n=mr(t,e),o=J.restrictToInterval(n.fraction,0,1);r=this.addHalfEdge(s,e,r.point,r.fraction,n.point,o,i)}this.addHalfEdge(s,e,r.point,r.fraction,e.endPoint(),1,i)}return Zn.clusterAndMergeXYTheta(s,(t=>t.sortAngle)),s}static addHalfEdge(t,e,i,n,s,r,o=J.smallMetricDistance){if(i.isAlmostEqualXY(s,o))return{point:i,fraction:n};const a=t.createEdgeXYAndZ(i,0,s,0),c=Pt.createCurveEvaluatedFractionFraction(e,n,r),l=a.edgeMate;return a.edgeTag=c,a.sortData=1,l.edgeTag=c,l.sortData=-1,a.sortAngle=gr(e,n,!1),l.sortAngle=gr(e,r,!0),{point:s,fraction:r}}static collectSignedLoop(t,e,i=1e-10,n){let s=n?0:wr.computeXYArea(t);return void 0===s&&(s=0),Math.abs(s)<i&&(s=0),t.computedAreaInPlanarSubdivision=s,s>0?e.positiveAreaLoops.push(t):s<0?e.negativeAreaLoops.push(t):e.slivers.push(t),s}static createLoopInFace(t,e){let i=t;const n=oi.create();do{const t=i.edgeTag;if(t){let s;s=i.sortData>0?t.curve.clonePartialCurve(t.fraction,t.fraction1):t.curve.clonePartialCurve(t.fraction1,t.fraction),s&&(void 0!==e&&e(i,s,n),n.tryAddChild(s))}i=i.faceSuccessor}while(i!==t);return n}static isNullFace(t){const e=t.faceSuccessor.faceSuccessor===t;let i=!1;if(e){const e=Zn.curvatureSortKey(t),n=Zn.curvatureSortKey(t.faceSuccessor.edgeMate);J.isSameCoordinate(e,n)||(i=!0)}return e&&!i}static nonNullEdgeMate(t,e){if(this.isNullFace(e))return;let i=e.edgeMate;for(;this.isNullFace(i);)if(i=i.faceSuccessor.edgeMate,i===e)return;return i}static collectSignedLoopSetsInHalfEdgeGraph(t,e=1e-10){const i=Jn.collectConnectedComponentsWithExteriorParityMasks(t,void 0),n=[],s=new Map;for(const r of i){const i={positiveAreaLoops:[],negativeAreaLoops:[],slivers:[]},o=[];for(const n of r){const r=this.isNullFace(n),a=this.createLoopInFace(n,((e,i,n)=>{if(!r){const r=this.nonNullEdgeMate(t,e);if(void 0!==r){const t=s.get(r);if(void 0===t){const t=new ai(n,i,void 0,void 0);s.set(e,t)}else t instanceof ai&&(t.setB(n,i),o.push(t),s.delete(r))}}}));this.collectSignedLoop(a,i,e,r)}i.edges=o,n.push(i),s.clear()}return n}}function gr(t,e,i){const n=t.fractionToPointAndDerivative(e),s=i?-1:1;return Math.atan2(s*n.direction.y,s*n.direction.x)}function pr(t,e){return t.detailA.curve===e?t.detailA.fraction:t.detailB.curve===e?t.detailB.fraction:void 0}function mr(t,e){return t.detailA.curve===e?t.detailA:t.detailB.curve===e?t.detailB:void 0}class _r extends Ie{_activeMomentData;_point0=$.create();_point1=$.create();handleArc3d(t){const e=this._activeMomentData,i=t.sweep.sweepRadians,n=.5*i;let s=Math.sin(n),r=Math.cos(n),o=Math.sin(i);G.isFullCircleRadians(i)&&(s=0,r=-1,o=0);const a=2*s*s*s*r/(n-s*r),c=s*s*s,l=.5*(i-o),h=.25*l*(1+a)-c*c*4/(9*l),d=.25*l*(1-a/3),u=4*s*s*s/(3*(i-o)),f=t.sweep.fractionToRadians(.5),g=t.radiansToRotatedBasis(f),p=g.origin.plusScaled(g.vectorU,u);e.accumulateXYProductsInCentroidalFrame(h,0,d,l,p,g.vectorU,g.vectorV);const m=t.fractionToPoint(0),_=t.fractionToPoint(1);e.accumulateTriangleMomentsXY(void 0,m,_)}handleLineString3d(t){this._activeMomentData.accumulateTriangleToLineStringMomentsXY(void 0,t.packedPoints)}handleLineSegment3d(t){const e=this._activeMomentData;t.startPoint(this._point0),t.endPoint(this._point1),e.accumulateTriangleMomentsXY(void 0,this._point0,this._point1)}handleLoop(t){const e=this._activeMomentData=wi.create();e.needOrigin=!1;for(const e of t.children)e.dispatchToGeometryHandler(this);return this._activeMomentData=void 0,e}handleAnyRegion(t){const e=wr.regionBooleanXY(t,void 0,Y.Union);if(!e)return;if(e instanceof oi)return this.handleLoop(e);const i=wi.create();for(const t of e.children){const e=t.dispatchToGeometryHandler(this);if(e){const t=e.signFactor(1);i.accumulateProducts(e,t)}}return i}handleParityRegion(t){return this.handleAnyRegion(t)}handleUnionRegion(t){return this.handleAnyRegion(t)}_strokeOptions;getStrokeOptions(){if(this._strokeOptions)return this._strokeOptions;const t=be.createForCurves();return t.angleTol=G.createDegrees(5),this._strokeOptions=t,t}handleCurvePrimitive(t){const e=Fe.create(),i=this.getStrokeOptions();t.emitStrokes(e,i),this.handleLineString3d(e)}handleBSplineCurve3d(t){this.handleCurvePrimitive(t)}handleBSplineCurve3dH(t){this.handleCurvePrimitive(t)}handleTransitionSpiral(t){this.handleCurvePrimitive(t)}}class xr{startComponent(t){return!0}finishComponent(t){return!0}enterFace(t,e){return!0}leaveFace(t,e){return!0}}class yr extends xr{_faceSelectFunction;_inComponent;_exteriorMask;constructor(t,e){super(),this._inComponent=[!1,!1,!1],this._exteriorMask=e,this._faceSelectFunction=t}startComponent(t){return t.setMaskAroundFace(this._exteriorMask),!0}enterFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),this._faceSelectFunction(this._inComponent[1],this._inComponent[2])||e.setMaskAroundFace(this._exteriorMask),!0}leaveFace(t,e){const i=e.edgeTag;return 1!==e.edgeTag&&2!==e.edgeTag||(this._inComponent[i]=!this._inComponent[i]),!0}}class vr{static faceToFaceSearchFromOuterLoop(t,e,i,n,s){if(e.isMaskSet(i))return;if(!s.startComponent(e))return;const r=[];e.setMaskAroundFace(i);let o=e;do{let t=o,e=o.edgeMate;if(!e.isMaskSet(i)){r.push(o),r.push(e);let a=e.faceSuccessor;if(e.setMaskAroundFace(i),t=e,s.enterFace(r,e))for(;;){if(e=a.edgeMate,!e.isMaskSet(i)){if(e.setMaskAroundFace(i),!s.enterFace(r,e))return;r.push(a),r.push(e),a=e,t=e}if(a.setMask(n),a=a.faceSuccessor,a===t){if(s.leaveFace(r,a),r.length<=2)break;r.pop(),a=r[r.length-1],r.pop(),t=r[r.length-1]}if(a.isMaskSet(n))return}}o=o.faceSuccessor}while(o!==e);s.finishComponent(e)}static doPolygonBoolean(t,e,i,n){const s=new hn,r=E.BOUNDARY_EDGE|E.PRIMARY_EDGE,o=wr.addLoopsWithEdgeTagToGraph(s,t,r,1),a=wr.addLoopsWithEdgeTagToGraph(s,e,r,2);if(n&&n("unmerged loops",s,"U"),o||a){Zn.splitIntersectingEdges(s),n&&n("After splitIntersectingEdges",s,"S"),Zn.clusterAndMergeXYTheta(s),n&&n("After clusterAndMergeXYTheta",s,"M"),new fn(s).regularizeGraph(!0,!0),n&&n("After regularize",s,"MR");const t=Jn.findMinimumAreaFace(s);if(void 0===t)return;const e=E.EXTERIOR,r=s.grabMask(),o=s.grabMask(),a=e|r|o;s.clearMask(a);const c=new yr(i,e);return this.faceToFaceSearchFromOuterLoop(s,t,r,o,c),n&&n("After faceToFaceSearchFromOuterLoop",s,"MRX"),s.dropMask(r),s.dropMask(o),s}}static doBinaryBooleanBetweenMultiLoopInputs(t,e,i,n,s,r){const o=new hn,a=E.BOUNDARY_EDGE|E.PRIMARY_EDGE,c=Sr.create(e,s);c.graph=o,c.faceAreaFunction=t=>Jn.signedFaceArea(t);for(const e of t)if(e.length>2){const t=new Pr(e,c.groupA);wr.addLoopsWithEdgeTagToGraph(o,e,a,t)}for(const t of n)if(t.length>2){const e=new Pr(t,c.groupB);wr.addLoopsWithEdgeTagToGraph(o,t,a,e)}return Zn.splitIntersectingEdges(o),Zn.clusterAndMergeXYTheta(o),new fn(o).regularizeGraph(!0,!0),c.runClassificationSweep(i),r&&c.unmaskMaskedNullFaces(E.EXTERIOR),o}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.NonBounding=-1]="NonBounding"}(L||(L={}));class Pr{region;sweepState;parentGroup;constructor(t,e){this.region=t,this.parentGroup=e,this.sweepState=0}clearState(){this.sweepState=0}}class Ir{members;groupOpType;parent;_numIn;constructor(t,e){this.members=[],this.parent=t,this.groupOpType=e,this._numIn=0}clearState(){for(const t of this.members)t.clearState();this._numIn=0}range(){const t=ft.createNull();for(const e of this.members)if(e.region instanceof zt)e.region.extendRange(t);else{const i=ft.createFromVariantData(e.region);t.extendRange(i)}return t}getInOut(){return this.groupOpType===L.Union?this._numIn>0:this.groupOpType===L.Parity?J.isOdd(this._numIn):this.groupOpType===L.Intersection&&this._numIn===this.members.length}addMember(t,e=!1){if(t instanceof oi||t instanceof Ti){let e=t.clone();wr.consolidateAdjacentPrimitives(e),e=ar.clone(e),this.members.push(new Pr(e,this))}else if(t instanceof gn)for(const e of t.children)this.addMember(e);else if(Array.isArray(t))for(const e of t)this.addMember(e);else e&&t instanceof Te&&this.members.push(new Pr(t,this))}recordMemberStateChange(t,e){const i=J.isOdd(t),n=J.isOdd(e);!i&&n?this._numIn++:i&&!n&&this._numIn--}}class Sr{groupA;groupB;extraGeometry;graph;faceAreaFunction;binaryOp;constructor(t,e){this.groupA=new Ir(this,t),this.groupB=new Ir(this,e),this.extraGeometry=new Ir(this,L.NonBounding),this.binaryOp=Y.Union}static create(t,e){return new Sr(t,e)}addMembers(t,e){this.groupA.addMember(t),this.groupB.addMember(e),this.addConnectives()}_workSegment;static _bridgeDirection=tt.createNormalized(1,-.12328974132467);addConnectives(){const t=this.groupA.range(),e=this.groupB.range(),i=t.union(e),n=wr.computeXYAreaTolerance(i);let s=.1;this._workSegment=Me.findExtremePointsInDirection(i.corners(),Sr._bridgeDirection,this._workSegment),this._workSegment&&(s*=this._workSegment.point0Ref.distanceXY(this._workSegment.point1Ref));const r=[],o=t=>{const e=wr.computeXYArea(t);void 0===e||Math.abs(e)<n||(this._workSegment=Me.findExtremePointsInDirection(t,Sr._bridgeDirection,this._workSegment),this._workSegment&&r.push(this._workSegment.point1Ref))};for(const t of[this.groupA.members,this.groupB.members])for(const e of t)if(e.region instanceof oi)o(e.region);else if(e.region instanceof Ti)for(const t of e.region.children)o(t);const a=Rt.createZero();for(const t of r){const e=s+Rt.create(t,Sr._bridgeDirection,a).intersectionWithRange3d(i).high,n=$.createAdd2Scaled(t,1,Sr._bridgeDirection,e),r=Te.createXYXY(t.x,t.y,n.x,n.y);this.extraGeometry.addMember(r,!0)}}annotateAndMergeCurvesInGraph(t=J.smallMetricDistance){const e=[];for(const t of[this.groupA,this.groupB,this.extraGeometry])for(const i of t.members){let t=e.length;if(i.region instanceof zt)for(wr.collectCurvePrimitives(i.region,e,!0,!0);t<e.length;t++)e[t].parent=i}const i=Ki.allIntersectionsAmongPrimitivesXY(e,t),n=fr.assembleHalfEdgeGraph(e,i,t);this.graph=n,this.faceAreaFunction=Ar}_announceFaceFunction;runClassificationSweep(t,e){this._announceFaceFunction=e,this.binaryOp=t,this.graph.clearMask(E.EXTERIOR);for(const t of[this.groupA,this.groupB])t.clearState();const i=this.graph.grabMask(),n=this.graph.grabMask(),s=Tr.create(this.graph);for(const t of s.components){const e=Jn.findMinimumAreaFace(t.faces,this.faceAreaFunction);if(e){const t=E.EXTERIOR|i|n;this.graph.clearMask(t),vr.faceToFaceSearchFromOuterLoop(this.graph,e,i,n,this)}}this.graph.dropMask(i),this.graph.dropMask(n)}unmaskMaskedNullFaces(t){for(const e of this.graph.allHalfEdges){const i=e.faceSuccessor;i.faceSuccessor===e&&e.getMask(t)&&i.getMask(t)&&(e.edgeMate.getMask(t)&&i.edgeMate.getMask(t)||(e.clearMask(t),i.clearMask(t)))}}getInOut(){return this.binaryOp===Y.Union?this.groupA.getInOut()||this.groupB.getInOut():this.binaryOp===Y.Intersection?this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===Y.AMinusB?this.groupA.getInOut()&&!this.groupB.getInOut():this.binaryOp===Y.BMinusA?!this.groupA.getInOut()&&this.groupB.getInOut():this.binaryOp===Y.Parity&&this.groupA.getInOut()!==this.groupB.getInOut()}recordTransitionAcrossEdge(t,e){const i=t=>{if(t.parentGroup.groupOpType===L.NonBounding)return t;if(0!==e){const i=t.sweepState;t.sweepState+=e,t.parentGroup.recordMemberStateChange(i,t.sweepState)}return t},n=t.edgeTag;if(n instanceof Pr)return i(n);if(n instanceof Pt){const t=n.curve.parent;if(t instanceof Pr)return i(t)}}startComponent(t){return t.setMaskAroundFace(E.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,t,-1,Ar(t)),!0}finishComponent(t){return!0}enterFace(t,e){this.recordTransitionAcrossEdge(e,1);const i=this.getInOut();return i||e.setMaskAroundFace(E.EXTERIOR),this._announceFaceFunction&&this._announceFaceFunction(this.graph,e,i?1:0,Ar(e)),!0}leaveFace(t,e){return this.recordTransitionAcrossEdge(e,-1),!0}}function br(t,e,i,n){let s;s=t&&t.point1?-(t.point1.x-t.point.x)*(.5*(t.point.y+t.point1.y)-n.y):-(i.x-e.x)*(.5*(e.y+i.y)-n.y);let r=0;return t&&t.curve&&t.hasFraction1&&(t.curve instanceof Te||t.curve instanceof Si&&(r=t.curve.areaToChordXY(t.fraction,t.fraction1))),s+r}function Ar(t){let e=0,i=t;do{e+=i.sortData*br(i.edgeTag,i,i.faceSuccessor,t)}while((i=i.faceSuccessor)!==t);return e}class Cr{faces;faceAreas;range;constructor(t){this.faces=t,this.range=pt.createNull(),this.faceAreas=[]}buildFaceData(t,e){const i=e=>(t?t(e,this.range):this.range.extendXY(e.x,e.y),0);this.range.setNull();for(const t of this.faces)t.sumAroundFace(i);this.faceAreas.length=0,e||(e=t=>Jn.signedFaceArea(t));for(const t of this.faces)this.faceAreas.push(e(t))}}class Tr{components;graph;constructor(t){this.graph=t,this.components=[]}static create(t,e){const i=new Tr(t),n=Jn.collectConnectedComponentsWithExteriorParityMasks(t,void 0);for(const t of n){const n=new Cr(t);n.buildFaceData(e,Ar),i.components.push(n)}return i}}!function(t){t[t.Union=0]="Union",t[t.Parity=1]="Parity",t[t.Intersection=2]="Intersection",t[t.AMinusB=3]="AMinusB",t[t.BMinusA=4]="BMinusA"}(Y||(Y={}));class wr{static computeXYAreaMoments(t){const e=new _r,i=t.dispatchToGeometryHandler(e);if(i instanceof wi)return i.shiftOriginAndSumsToCentroidOfSums(),i}static computeXYAreaTolerance(t,e=J.smallMetricDistance){const i=.5*e;return i*(t.xLength()+t.yLength()+i)}static computeXYArea(t){const e=new _r,i=t.dispatchToGeometryHandler(e);if(i instanceof wi)return i.quantitySum}static computeXYZWireMomentSums(t){const e=new rr;e.visitLeaves(t);const i=e.momentData;return i.shiftOriginAndSumsToCentroidOfSums(),i}static centroidAreaNormal(t,e){const i=bi.createRightHandedFrame(void 0,t);if(!i)return;const n=i.matrix.columnZ(e?.direction),s=n.isParallelTo(tt.unitZ(),!0);let r=t;if(!s&&(r=t.cloneTransformed(i.inverse()),!r))return;const o=wr.computeXYAreaMoments(r);if(!o)return;const a=o.origin.clone(e?.origin);s||i.multiplyPoint3d(a,a);let c=o.sums.weight();return c<0&&(c=-c,n.scale(-1,n)),e||(e=Rt.createCapture(a,n)),e.a=c,e}static addLoopsToGraph(t,e,i){if(e instanceof oi){const n=e.getPackedStrokes();n&&this.addLoopsToGraph(t,n,i)}else if(e instanceof Ti)for(const n of e.children){const e=n.getPackedStrokes();e&&this.addLoopsToGraph(t,e,i)}else if(e instanceof nt){const n=Ln.directCreateFaceLoopFromCoordinates(t,e);void 0!==n&&i(t,n)}else if(Array.isArray(e)&&e.length>0)if($.isAnyImmediatePointType(e[0])){const n=Ln.directCreateFaceLoopFromCoordinates(t,e);void 0!==n&&i(t,n)}else if(e[0]instanceof nt)for(const n of e){const e=Ln.directCreateFaceLoopFromCoordinates(t,n);void 0!==e&&i(t,e)}else for(const n of e)Array.isArray(n)&&this.addLoopsToGraph(t,n,i)}static addLoopsWithEdgeTagToGraph(t,e,i,n){const s=[];if(this.addLoopsToGraph(t,e,((t,e)=>{e&&(s.push(e),e.setMaskAndEdgeTagAroundFace(i,n,!0))})),s.length>0)return s}static finishGraphToPolyface(t,e){if(t)return e&&(Ln.triangulateAllPositiveAreaFaces(t),Ln.flipTriangles(t)),ir.graphToPolyface(t)}static polygonXYAreaIntersectLoopsToPolyface(t,e,i=!1){const n=vr.doPolygonBoolean(t,e,((t,e)=>t&&e),this._graphCheckPointFunction);return this.finishGraphToPolyface(n,i)}static polygonXYAreaUnionLoopsToPolyface(t,e,i=!1){const n=vr.doPolygonBoolean(t,e,((t,e)=>t||e),this._graphCheckPointFunction);return this.finishGraphToPolyface(n,i)}static polygonXYAreaDifferenceLoopsToPolyface(t,e,i=!1){const n=vr.doPolygonBoolean(t,e,((t,e)=>t&&!e),this._graphCheckPointFunction);return this.finishGraphToPolyface(n,i)}static simplifyRegionType(t){if(t instanceof gn){if(1===t.children.length)return this.simplifyRegionType(t.children[0])}else if(t instanceof Ti&&1===t.children.length)return t.children[0];return t}static regionBooleanXY(t,e,i,n=J.smallMetricDistance){const s=gn.create(),r=Sr.create(L.Union,L.Union);r.addMembers(t,e),r.annotateAndMergeCurvesInGraph(n);const o=r.groupA.range().union(r.groupB.range()),a=this.computeXYAreaTolerance(o,n);return r.runClassificationSweep(i,((t,e,i,n)=>{if(!(e.countEdgesAroundFace()<2||Math.abs(n)<a||1!==i)){const t=fr.createLoopInFace(e);t&&s.tryAddChild(t)}})),s?this.simplifyRegionType(s):void 0}static polygonBooleanXYToPolyface(t,e,i,n=!1){const s=vr.doBinaryBooleanBetweenMultiLoopInputs(t,L.Union,e,i,L.Union,!0);return this.finishGraphToPolyface(s,n)}static polygonBooleanXYToLoops(t,e,i){const n=vr.doBinaryBooleanBetweenMultiLoopInputs(t,L.Union,e,i,L.Union,!0);if(!n)return;const s=Jn.collectExtendedBoundaryLoopsInGraph(n,E.EXTERIOR),r=[];for(const t of s){const e=new rt;for(const i of t)e.pushXYZ(i.x,i.y,i.z);e.pushWrap(1);const i=oi.create();i.tryAddChild(Fe.createCapture(e)),r.push(i)}return wr.sortOuterAndHoleLoopsXY(r)}static constructPolygonWireXYOffset(t,e,i){return(new en).constructPolygonWireXYOffset(t,e,i)}static constructCurveXYOffset(t,e){const i=Ce.create(e);return sn.constructCurveXYOffset(t,i)}static testPointInOnOutRegionXY(t,e,i){return dr.testPointInOnOutRegionXY(t,e,i)}static createLoopPathOrBagOfCurves(t,e=!0,i=!1){const n=t.length;if(0===n)return;let s,r=0,o=!1;e&&(r=J.maxXY(r,t[0].startPoint().distance(t[n-1].endPoint())));for(let e=0;e+1<n;e++)r=J.maxXY(r,t[e].endPoint().distance(t[e+1].startPoint()));J.isSmallMetricDistance(r)?(s=e?oi.create():ii.create(),o=!0):s=ei.create();for(const e of t)s.tryAddChild(e);return o&&i&&wr.consolidateAdjacentPrimitives(s),s}static _graphCheckPointFunction;static setCheckPointFunction(t){this._graphCheckPointFunction=t}static cloneCurvesWithXYSplits(t,e){return hr.cloneCurvesWithXYSplits(t,e)}static splitToPathsBetweenBreaks(t,e){if(void 0===t)return;if(t instanceof le)return t;const i=t.collectCurvePrimitives(),n=new or(e);for(const t of i)n.announceCurvePrimitive(t);return n.grabResult()}static collectInsideAndOutsideOffsets(t,e,i){return sn.collectInsideAndOutsideXYOffsets(t,e,i)}static collectChains(t,e=J.smallMetricDistance){return sn.collectChains(t,e)}static splitPathsByRegionInOnOutXY(t,e){const i={insideParts:[],outsideParts:[],coincidentParts:[]},n=wr.cloneCurvesWithXYSplits(t,e),s=wr.splitToPathsBetweenBreaks(n,!0);if(s instanceof $e)for(const t of s.children){const n=$e.createCurveLocationDetailOnAnyCurvePrimitive(t);n&&Er(t,wr.testPointInOnOutRegionXY(e,n.point.x,n.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}else if(s instanceof le){const t=$e.createCurveLocationDetailOnAnyCurvePrimitive(s);t&&Er(s,wr.testPointInOnOutRegionXY(e,t.point.x,t.point.y),i.outsideParts,i.coincidentParts,i.insideParts)}return i}static rectangleEdgeTransform(t,e=!0){if(t instanceof Fe)return this.rectangleEdgeTransform(t.packedPoints);if(t instanceof nt){let i;if(e&&5===t.length){if(!J.isSmallMetricDistance(t.distanceIndexIndex(0,4)))return;i=t}else if(e||4!==t.length){if(t.length<(e?5:4))return;if(i=rt.create(t),Ai.compressInPlaceByShortEdgeLength(i,J.smallMetricDistance),i.length<(e?5:4))return}else i=t;const n=i.vectorIndexIndex(0,1),s=i.vectorIndexIndex(0,3),r=i.vectorIndexIndex(1,2),o=n.crossProduct(s);if(o.normalizeInPlace()&&r.isAlmostEqual(s)&&n.isPerpendicularTo(s))return mt.createOriginAndMatrixColumns(i.getPoint3dAtUncheckedPointIndex(0),n,s,o)}else{if(Array.isArray(t))return this.rectangleEdgeTransform(new he(t),e);if(t instanceof oi&&1===t.children.length&&t.children[0]instanceof Fe)return this.rectangleEdgeTransform(t.children[0].packedPoints,!0);if(t instanceof ii&&1===t.children.length&&t.children[0]instanceof Fe)return this.rectangleEdgeTransform(t.children[0].packedPoints,e);if(t instanceof ti&&!t.checkForNonLinearPrimitives()){const e=t.getPackedStrokes();if(e)return this.rectangleEdgeTransform(e)}}}static consolidateAdjacentPrimitives(t,e){const i=new cr(e);t.dispatchToGeometryHandler(i)}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)if(i instanceof oi)Dr.pushLoop(e,i);else if(i instanceof nt){const t=oi.createPolygon(i);Dr.pushLoop(e,t)}return Dr.sortAsAnyRegion(e)}static constructAllXYRegionLoops(t,e=J.smallMetricDistance){let i=wr.collectCurvePrimitives(t,void 0,!0,!0);i=ar.clone(ei.create(...i)).children;const n=this.curveArrayRange(i),s=this.computeXYAreaTolerance(n,e),r=Ki.allIntersectionsAmongPrimitivesXY(i,e),o=fr.assembleHalfEdgeGraph(i,r,e);return fr.collectSignedLoopSetsInHalfEdgeGraph(o,s)}static collectCurvePrimitives(t,e,i=!1,n=!1){const s=void 0===e?[]:e;if(t instanceof le)t.collectCurvePrimitives(s,i,n);else if(t instanceof $e)t.collectCurvePrimitives(s,i,n);else if(Array.isArray(t))for(const e of t)this.collectCurvePrimitives(e,s,i,n);return s}static expandLineStrings(t){const e=[];for(const i of t)if(i instanceof Fe)for(let t=0;t+1<i.packedPoints.length;t++){const n=i.getIndexedSegment(t);void 0!==n&&e.push(n)}else e.push(i);return e}static curveArrayRange(t,e){const i=ft.create();if(t instanceof zt)t.extendRange(i,e);else if(Array.isArray(t))for(const n of t)n instanceof zt?n.extendRange(i,e):n instanceof $?i.extendPoint(n,e):n instanceof rt?i.extendRange(n.getRange(e)):Array.isArray(n)&&i.extendRange(this.curveArrayRange(n,e));return i}static triangulateStrokedRegionComponent(t){let e;if(Array.isArray(t)){if(0===t.length)return;const i=t[0];if($.isAnyImmediatePointType(i))e=Ln.createTriangulatedGraphFromSingleLoop(t);else if(t.length>1){let n;if(i instanceof st)n=t;else{n=[];for(const e of t)n.push(rt.create(e))}const s=zr.sortOuterAndHoleLoopsXY(n);1===s.length&&(e=Ln.createTriangulatedGraphFromLoops(s[0]))&&Ln.flipTriangles(e)}else e=Ln.createTriangulatedGraphFromSingleLoop(i)}else e=Ln.createTriangulatedGraphFromSingleLoop(t);return e||(e=vr.doPolygonBoolean(t,[],((t,e)=>t)))&&Ln.triangulateAllPositiveAreaFaces(e)&&Ln.flipTriangles(e),e}static strokeRegionComponent(t,e){const i=t.cloneStroked(e),n=[];if(i instanceof oi)i.children.length>0&&i.children[0]instanceof Fe&&n.push(i.children[0].packedPoints);else if(i instanceof Ti)for(const t of i.children)t.children.length>0&&t.children[0]instanceof Fe&&n.push(t.children[0].packedPoints);return n}static triangulateRegionComponent(t,e){const i=this.strokeRegionComponent(t,e);return this.triangulateStrokedRegionComponent(i)}static facetRegionXY(t,e){let i;if(t instanceof gn)for(const n of t.children){const t=wr.triangulateRegionComponent(n,e);t&&(i?i.allHalfEdges.push(...t.allHalfEdges):i=t)}else i=this.triangulateRegionComponent(t,e);if(i)return e?.maximizeConvexFacets&&qn.expandConvexFaces(i),ir.graphToPolyface(i,e)}static convexDecomposePolygonXY(t,e=!0){const i=wr.triangulateStrokedRegionComponent(t);if(!i)return;e&&qn.expandConvexFaces(i);const n=[];return i.announceFaceLoops(((t,e)=>(e.isMaskSet(E.EXTERIOR)||n.push(rt.create(e.collectAroundFace((t=>t.getPoint3d())))),!0))),n}}function Er(t,e,i,n,s){e>0?s.push(t):e<0?i.push(t):n.push(t)}class kr{consolidateLinearGeometry=!0;consolidateCompatibleArcs=!0;disableLinearCompression=!1;duplicatePointTolerance=J.smallMetricDistance;colinearPointTolerance=J.smallMetricDistance}class Fr{}class Rr extends Fr{data;_signedArea;get signedArea(){return this._signedArea}constructor(t){super(),this.data=t,this._signedArea=zr.areaXY(t)}classifyPointXY(t){return zr.classifyPointInPolygonXY(t.x,t.y,this.data)}getAnyInteriorPoint(){for(let t=0;t<this.data.length;t++){const e=this.constructInteriorPointNearEdge(t,.2349);if(void 0!==e)return e}}grabPolygon(){return this.data}grabLoop(){return oi.createPolygon(this.data)}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseInPlace(),this._signedArea*=-1)}constructInteriorPointNearEdge(t,e){if(t+1<this.data.length){const i=this.data.getPoint3dAtUncheckedPointIndex(t),n=this.data.getPoint3dAtUncheckedPointIndex(t+1),s=i.vectorTo(n),r=i.interpolate(e,n);if(s.rotate90CCWXY(s),s.normalizeInPlace()){this._signedArea<0&&s.scaleInPlace(-1);const t=Math.sqrt(Math.abs(this._signedArea));for(let e=1e-5;e<3;e*=5){const i=r.plusScaled(s,e*t);if(1===this.classifyPointXY(i))return i}}}}}class Mr extends Fr{data;_signedArea;get signedArea(){return this._signedArea}constructor(t){super(),this.data=t;const e=wr.computeXYAreaMoments(t);this._signedArea=void 0!==e?e.quantitySum:0}classifyPointXY(t){return wr.testPointInOnOutRegionXY(this.data,t.x,t.y)}constructInteriorPointNearChild(t,e){if(t<this.data.children.length){const i=this.data.children[t].fractionToPointAndUnitTangent(e);i.direction.rotate90CCWXY(i.direction),this._signedArea<0&&i.direction.scaleInPlace(-1);const n=Math.sqrt(Math.abs(this._signedArea));for(let t=1e-5;t<3;t*=5){const e=i.fractionToPoint(t*n);if(1===this.classifyPointXY(e))return e}}}getAnyInteriorPoint(){for(let t=0;t<this.data.children.length;t++){const e=this.constructInteriorPointNearChild(t,.2349);if(void 0!==e)return e}}grabPolygon(){const t=this.data.cloneStroked();if(t instanceof ti){const e=Fe.create();for(const i of t.children)i instanceof le&&i.emitStrokes(e);return e.numPoints()>0?e.packedPoints:void 0}}grabLoop(){return this.data}reverseForAreaSign(t){t*this._signedArea<0&&(this.data.reverseChildrenInPlace(),this._signedArea*=-1)}}class Dr{_loopCarrier;anyPoint;sortKey;range;parentIndex;isHole;outputSetIndex;constructor(t,e){this._loopCarrier=t instanceof st?new Rr(t):new Mr(t),this.range=e,this.sortKey=Math.abs(this._loopCarrier.signedArea),this.isHole=!1}static pushPolygon(t,e){const i=e.getRange(),n=new Dr(e,i);return n.sortKey>0&&(t.push(n),!0)}static pushLoop(t,e){const i=e.range(),n=new Dr(e,i);return n.sortKey>0&&(t.push(n),!0)}static assignParentsAndDepth(t){t.sort(((t,e)=>e.sortKey-t.sortKey));for(let e=t.length;e-- >0;){const i=t[e],n=i._loopCarrier.getAnyInteriorPoint();if(void 0!==n){t[e].parentIndex=void 0,t[e].outputSetIndex=void 0;for(let s=e;s-- >0;){const e=t[s];if(e.range.containsXY(n.x,n.y)&&1===e._loopCarrier.classifyPointXY(n)){i.parentIndex=s;break}}}}}static assemblePolygonSet(t){const e=[];for(const i of t){i.isHole=!1;const n=i.parentIndex;void 0!==n&&(i.isHole=!t[n].isHole),i.isHole?(i._loopCarrier.reverseForAreaSign(-1),e[t[n].outputSetIndex].push(i._loopCarrier.grabPolygon())):(i._loopCarrier.reverseForAreaSign(1),i.outputSetIndex=e.length,e.push([]),e[i.outputSetIndex].push(i._loopCarrier.grabPolygon()))}return e}static assembleLoopSet(t){const e=[],i=t.length;for(let n=0;n<i;n++){const s=t[n],r=s.parentIndex;if(s.isHole=void 0!==r&&!t[r].isHole,!s.isHole){s._loopCarrier.reverseForAreaSign(1);const r=s._loopCarrier.grabLoop();let o;for(let e=n+1;e<i;e++){const i=t[e];i.parentIndex===n&&(void 0===o?(o=Ti.create(),o.tryAddChild(r),i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())):(i._loopCarrier.reverseForAreaSign(-1),o.tryAddChild(i._loopCarrier.grabLoop())))}void 0!==o?e.push(o):void 0!==r&&e.push(r)}}return e}static sortAsAnyRegion(t){this.assignParentsAndDepth(t);const e=this.assembleLoopSet(t);if(1===e.length)return e[0];{const t=gn.create();for(const i of e)t.tryAddChild(i);return t}}static sortAsArrayOfArrayOfPolygons(t){return this.assignParentsAndDepth(t),this.assemblePolygonSet(t)}grabPolygon(){return this._loopCarrier.grabPolygon()}grabLoop(){return this._loopCarrier.grabLoop()}reverseForAreaSign(t){this._loopCarrier.reverseForAreaSign(t)}getAnyInteriorPoint(){return this._loopCarrier.getAnyInteriorPoint()}}class Or{point;a;v;code;closestEdgeIndex;closestEdgeParam;constructor(){this.point=new $,this.a=0,this.v=new tt,this.code=_.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}invalidate(){this.point.setZero(),this.a=0,this.v.setZero(),this.code=_.Unknown,this.closestEdgeIndex=0,this.closestEdgeParam=0}static create(t){return void 0===t?t=new Or:t.invalidate(),t}copyContentsFrom(t){this.point.setFrom(t.point),this.a=t.a,this.v.setFrom(t.v),this.code=t.code,this.closestEdgeIndex=t.closestEdgeIndex,this.closestEdgeParam=t.closestEdgeParam}get isValid(){return this.code!==_.Unknown}get isInsideOrOn(){return this.code===_.InsidePolygon||this.code===_.OnPolygonVertex||this.code===_.OnPolygonEdgeInterior||this.code===_.InsidePolygonProjectsToVertex||this.code===_.InsidePolygonProjectsToEdgeInterior}static createAtVertexOrEdge(t,e,i=0){const n=new Or;return n.point.setFrom(t),n.closestEdgeIndex=e,n.closestEdgeParam=i,i=J.clamp(i,0,1),n.code=i>0&&i<1?_.OnPolygonEdgeInterior:_.OnPolygonVertex,n}}class Br{detailA;detailB;constructor(t,e){this.detailA=t||Or.create(),this.detailB=e||Or.create()}static create(t,e,i){return i?(i.detailA=t,i.detailB=e,i):new Br(t,e)}clone(t){return(t=t||new Br).detailA.copyContentsFrom(this.detailA),t.detailB.copyContentsFrom(this.detailB),t}swapDetails(){const t=this.detailA;this.detailA=this.detailB,this.detailB=t}}class Nr{xyz;edge;sortCoordinate0;sortCoordinate1;sortDelta;isNotch;constructor(t){this.xyz=t,this.edge=void 0,this.sortCoordinate0=this.sortCoordinate1=0,this.sortDelta=0,this.isNotch=!1}static createCaptureWithReturnEdge(t){const e=new Nr(t);return t.length>=2&&(e.edge=Rt.createStartEnd(t.front(),t.back())),e}setSortCoordinates(t){this.sortDelta=this.edge.direction.dotProduct(t.direction);const e=t.dotProductToPoint(this.edge.origin);this.sortDelta>=0?(this.sortCoordinate0=e,this.sortCoordinate1=e+this.sortDelta):(this.sortCoordinate0=e+this.sortDelta,this.sortCoordinate1=e)}containsSortLimits(t){return t.sortCoordinate0>=this.sortCoordinate1||t.sortCoordinate0<=this.sortCoordinate0||t.sortCoordinate1<=this.sortCoordinate0||t.sortCoordinate1>=this.sortCoordinate1?0:this.sortDelta*t.sortDelta>0?1:-1}absorb(t){this.xyz.pushFromGrowableXYZArray(t.xyz),this.sortCoordinate0=t.sortCoordinate1}static sortFunction(t,e){return t.sortCoordinate0-e.sortCoordinate0>0?1:-1}front(t){return this.xyz.front(t)}back(t){return this.xyz.back(t)}}class Xr{inputLoops;outputLoops;constructor(){this.inputLoops=[],this.outputLoops=[]}mostDistantPoint(t,e,i){let n,s=-1;i.setZero();for(const r of this.inputLoops)r.front(e),n=e.distanceSquared(t),n>s&&(s=n,i.setFromPoint3d(e)),r.back(e),n=e.distanceSquared(t),n>s&&(s=n,i.setFromPoint3d(e))}sortInputs(){if(this.inputLoops.length>0&&this.inputLoops[0].xyz.length>0){const t=this.inputLoops[0].xyz.front(),e=$.create(),i=$.create();this.mostDistantPoint(t,e,i),this.mostDistantPoint(i,e,t);const n=Rt.createStartEnd(t,i);n.direction.normalizeInPlace();for(const t of this.inputLoops)t.setSortCoordinates(n);this.inputLoops.sort(((t,e)=>Nr.sortFunction(t,e)))}}sortAndMergeLoops(){this.sortInputs();const t=this.inputLoops,e=this.outputLoops,i=[];e.length=0;for(const n of t){for(n.isNotch=!1;i.length>0;){const t=i[i.length-1],s=t.containsSortLimits(n);if(0!==s){if(1===s){n.isNotch=!1;break}t.absorb(n),n.isNotch=!0;break}t.isNotch||e.push(t),i.pop()}i.push(n)}for(const t of i)t.isNotch||e.push(t)}}class zr{static sumTriangleAreas(t){let e=0;const i=t.length;if(Array.isArray(t)){if(i>=3){const n=t[0],s=n.vectorTo(t[1]);let r=tt.create();for(let o=2;o<i;o++)r=n.vectorTo(t[o],r),e+=s.crossProductMagnitude(r),s.setFrom(r)}return.5*e}const n=tt.create();for(let s=2;s<i;s++)t.crossProductIndexIndexIndex(0,s-1,s,n),e+=n.magnitude();return.5*e}static sumTriangleAreasPerpendicularToUpVector(t,e){let i=e.magnitude();i<J.smallMetricDistance&&(e=tt.create(0,0,1),i=1);let n=0;const s=t.length;if(Array.isArray(t)){if(s>=3){const i=t[0],r=i.vectorTo(t[1]);let o=tt.create();for(let a=2;a<s;a++)o=i.vectorTo(t[a],o),n+=r.tripleProduct(o,e),r.setFrom(o)}return.5*n/i}const r=tt.create();for(let i=2;i<s;i++)t.crossProductIndexIndexIndex(0,i-1,i,r),n+=r.dotProduct(e);return.5*n/i}static sumTriangleAreasXY(t){let e=0;const i=t.length;if(i>=3){const n=t[0],s=n.vectorTo(t[1]);let r=tt.create();for(let o=2;o<i;o++)r=n.vectorTo(t[o],r),e+=s.crossProductXY(r),s.setFrom(r)}return e*=.5,e}static _triangleMomentWeights=Bt.createRowValues(2/24,1/24,0,4/24,1/24,2/24,0,4/24,0,0,0,0,4/24,4/24,0,.5);static _tetrahedralMomentWeights=Bt.createRowValues(1/60,1/120,1/120,1/24,1/120,1/60,1/120,1/24,1/120,1/120,1/60,1/24,1/24,1/24,1/24,1/6);static _vector0=tt.create();static _vector1=tt.create();static _vector2=tt.create();static _vectorOrigin=tt.create();static _normal=tt.create();static _matrixA=Bt.createIdentity();static _matrixB=Bt.createIdentity();static _matrixC=Bt.createIdentity();static areaNormalGo(t,e){e?e.setZero():e=new tt;const i=t.length;if(3===i)t.crossProductIndexIndexIndex(0,1,2,e);else if(i>3)for(let n=2;n<i;n++)t.accumulateCrossProductIndexIndexIndex(0,n-1,n,e);return e.scaleInPlace(.5),e.isZero?void 0:e}static areaNormal(t,e){return e||(e=tt.create()),zr.areaNormalGo(new he(t),e),e}static area(t){return zr.areaNormal(t).magnitude()}static areaXY(t){let e=0;if(t instanceof nt){if(t.length>2){const i=t.getXAtUncheckedPointIndex(0),n=t.getYAtUncheckedPointIndex(0);let s,r,o=t.getXAtUncheckedPointIndex(1)-i,a=t.getYAtUncheckedPointIndex(1)-n;for(let c=2;c+1<t.length;c++,o=s,a=r)s=t.getXAtUncheckedPointIndex(c)-i,r=t.getYAtUncheckedPointIndex(c)-n,e+=J.crossProductXYXY(o,a,s,r)}}else for(let i=1;i+1<t.length;i++)e+=t[0].crossProductToPointsXY(t[i],t[i+1]);return.5*e}static sumAreaXY(t){let e=0;for(const i of t)e+=this.areaXY(i);return e}static centroidAreaNormal(t,e){if(Array.isArray(t)){const i=new he(t);return this.centroidAreaNormal(i,e)}const i=t.length;if(3===i){const i=t.crossProductIndexIndexIndex(0,1,2,e?.direction),n=.5*i.magnitude(),s=t.getPoint3dAtCheckedPointIndex(0,e?.origin);return t.accumulateScaledXYZ(1,1,s),t.accumulateScaledXYZ(2,1,s),s.scaleInPlace(1/3),e||(e=Rt.createCapture(s,i)),e.tryNormalizeInPlaceWithAreaWeight(n)?e:void 0}if(i>=3){const n=tt.createZero();for(let e=2;e<i;e++)t.accumulateCrossProductIndexIndexIndex(0,e-1,e,n);n.normalizeInPlace();const s=t.getPoint3dAtCheckedPointIndex(0),r=tt.create(),o=tt.create();t.vectorXYAndZIndex(s,1,r);let a=tt.create();const c=tt.createZero(),l=tt.createZero(e?.direction);let h;for(let e=2;e<i;e++){t.vectorXYAndZIndex(s,e,o),a=r.crossProduct(o,a),h=n.dotProduct(a),l.addInPlace(a);const i=h/6;c.plus2Scaled(r,i,o,i,c),r.setFrom(o)}const d=.5*l.magnitude(),u=J.conditionalDivideFraction(1,d);if(void 0!==u){const t=s.plusScaled(c,u,e?.origin);return e||(e=Rt.createCapture(t,l)),e.tryNormalizeInPlaceWithAreaWeight(d),e}}}static centroidAndAreaXY(t,e){let i=0;if(e.set(0,0),t.length<3)return;const n=t[0];let s=j.create(0,0),r=0;for(let e=1;e+1<t.length;e++){const i=n.vectorTo(t[e]),o=n.vectorTo(t[e+1]),a=i.crossProduct(o);s=s.plus(i.plus(o).scale(a)),r+=a}i=.5*r;const o=J.conditionalDivideFraction(1,6*i);if(void 0!==o)return e.setFrom(n.plusScaled(s,o)),i;e.setFrom(n)}static unitNormal(t,e){e.setZero();let i=t.length;return i>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(i-1))&&--i,3===i?(t.crossProductIndexIndexIndex(0,1,2,e),e.normalizeInPlace()):4===i?(t.vectorIndexIndex(0,2,zr._vector0),t.vectorIndexIndex(1,3,zr._vector1),zr._vector0.crossProduct(zr._vector1,e),e.normalizeInPlace()):(zr.areaNormalGo(t,e),e.normalizeInPlace())}static addSecondMomentAreaProducts(t,e,i){this.addSecondMomentTransformedProducts(zr._triangleMomentWeights,t,e,2,i)}static addSecondMomentVolumeProducts(t,e,i){this.addSecondMomentTransformedProducts(zr._tetrahedralMomentWeights,t,e,3,i)}static addSecondMomentTransformedProducts(t,e,i,n,s){const r=zr._normal;if(zr.unitNormal(e,r)){const o=zr._vector0,a=zr._vector1,c=zr._vector2,l=zr._matrixA,h=zr._matrixB,d=zr._matrixC,u=e.vectorXYAndZIndex(i,0,zr._vectorOrigin),f=e.length;let g=0;for(let p=2;p<f;p++)2===n?(e.vectorIndexIndex(0,p-1,o),e.vectorIndexIndex(0,p,a),g=r.tripleProduct(o,a),l.setOriginAndVectors(u,o,a,r),l.multiplyMatrixMatrix(t,h),h.multiplyMatrixMatrixTranspose(l,d),s.addScaledInPlace(d,g)):3===n&&(e.vectorXYAndZIndex(i,0,o),e.vectorXYAndZIndex(i,p-1,a),e.vectorXYAndZIndex(i,p,c),g=o.tripleProduct(a,c),l.setOriginAndVectors(i,o,a,c),l.multiplyMatrixMatrix(t,h),h.multiplyMatrixMatrixTranspose(l,d),s.addScaledInPlace(d,g))}}static volumeBetweenPolygonAndPlane(t,e,i){let n,s,r=0,o=0;const a=t.evaluateUncheckedIndexPlaneAltitude(0,e);for(let n=1;n+1<t.length;n++){const s=t.crossProductIndexIndexIndex(0,n,n+1,i?.workVector),c=t.evaluateUncheckedIndexPlaneAltitude(n,e),l=t.evaluateUncheckedIndexPlaneAltitude(n+1,e),h=s.dotProductXYZ(e.normalX(),e.normalY(),e.normalZ());r+=h,o+=h*(a+c+l)}return i?.skipMoments||(n=t.getPoint3dAtUncheckedPointIndex(0,i?.workPoint0),s=Bt.createZero(i?.workMatrix),t.mapPoint(((t,n,s)=>e.projectXYZToPlane(t,n,s,i?.workPoint1))),zr.addSecondMomentAreaProducts(t,n,s)),{volume6:o,area2:r,origin:n,products:s}}static testXYPolygonTurningDirections(t){let e=t.length,i=e-1;for(;i>1&&t[i].x===t[0].x&&t[i].y===t[0].y;)e=i--;if(e>2){let n=H.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y);const s=H.create(t[0].x-t[i].x,t[0].y-t[i].y),r=n.x*s.y-n.y*s.x;for(let i=1;i<e;i++)if(n=s.clone(),H.create(t[i].x-t[i-1].x,t[i].y-t[i-1].y,s),(n.x*s.y-n.y*s.x)*r<=0)return 0;return r>0?1:-1}return 0}static isConvex(t){if(!(t instanceof nt))return this.isConvex(new he(t));let e=t.length;e>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(e-1))&&--e;const i=tt.create();if(!this.unitNormal(t,i))return!1;let n=0,s=0;const r=this._vector0;let o=tt.createStartEnd(t.getPoint3dAtUncheckedPointIndex(e-1),t.getPoint3dAtUncheckedPointIndex(0),this._vector1);for(let a=1;a<=e;a++){r.setFromVector3d(o),o=tt.createStartEnd(t.getPoint3dAtUncheckedPointIndex(a-1),t.getPoint3dAtUncheckedPointIndex(a%e),o);const c=i.tripleProduct(r,o);c>=0?n+=c:s+=c}return Math.abs(s)<J.smallMetricDistanceSquared*n}static classifyPointInPolygon(t,e,i){const n=new Nt(t,e);let s=0;const r=i.length;let o,a=-1;for(s=0;s<r;s++)if(o=s+1,o>=r&&(o=0),n.tryStartEdge(i[s].x,i[s].y,i[o].x,i[o].y)){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!n.advance(i[o].x,i[o].y))return n.classifyCounts();return n.classifyCounts()}}static classifyPointInPolygonXY(t,e,i){const n=new Nt(t,e);let s=0;const r=i.length;let o,a=-1;for(s=0;s<r;s++)if(o=s+1,o>=r&&(o=0),n.tryStartEdge(i.getXAtUncheckedPointIndex(s),i.getYAtUncheckedPointIndex(s),i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o))){a=o;break}if(!(a<0)){for(let t=1;t<=r;t++)if(o=a+t,o>=r&&(o-=r),!n.advance(i.getXAtUncheckedPointIndex(o),i.getYAtUncheckedPointIndex(o)))return n.classifyCounts();return n.classifyCounts()}}static orientLoopsCCWForOutwardNormalInPlace(t,e){if(t instanceof nt)return this.orientLoopsCCWForOutwardNormalInPlace([t],e);const i=tt.create();let n=0;for(const s of t)this.unitNormal(s,i)&&i.dotProduct(e)<0&&(s.reverseInPlace(),n++);return n}static sortOuterAndHoleLoopsXY(t){const e=[];for(const i of t)Dr.pushPolygon(e,i);return Dr.sortAsArrayOfArrayOfPolygons(e)}static sortOuterAndHoleLoops(t,e){const i=bi.createRightHandedFrame(e,t),n=i?.inverse(),s=[];if(void 0!==n)for(const e of t){const t=new rt(e.length);for(const i of e.points)t.push(n.multiplyPoint3d(i));s.push(t)}const r=zr.sortOuterAndHoleLoopsXY(s),o=[];if(void 0!==i)for(const t of r){const e=[];for(const n of t){const t=new rt(n.length);for(const e of n.points)t.push(i.multiplyPoint3d(e));e.push(t)}o.push(e)}return o}static closestPointOnBoundary(t,e,i=J.smallMetricDistance,n){if(!(t instanceof nt))return this.closestPointOnBoundary(new he(t),e,i,n);const s=Array.isArray(i)?i[0]:i,r=Array.isArray(i)?Math.abs(i[1]):0,o=s*s;let a=t.length;for(;a>1&&!(t.distanceSquaredIndexIndex(0,a-1)>o);)--a;if(n=Or.create(n),0===a)return n;const c=i=>(t.getPoint3dAtUncheckedPointIndex(i,n.point),n.a=n.point.distance(e),n.v.setZero(),n.code=_.OnPolygonVertex,n.closestEdgeIndex=i,n.closestEdgeParam=0,n);if(1===a)return c(0);const l=i=>{let n=!1,s=0,r=0,c=0;if(i>=0&&i<a){let l=i+1;l===a&&(l=0),r=t.distanceSquaredIndexIndex(i,l),r>o&&(c=t.distanceSquaredIndexXYAndZ(i,e),s=t.dotProductIndexIndexXYAndZ(i,l,e)/r,n=!0)}return{isValid:n,edgeParam:s,uDotU:r,vDotV:c}};let h=!1,d=a-1;for(;d>0;--d){const t=l(d);if(t.isValid){h=t.edgeParam>1+r;break}}if(d<=0)return c(0);let u=J.largeCoordinateResult;for(let i=0;i<a;++i){let s=i+1;s===a&&(s=0);const c=l(i);if(c.isValid){if(c.edgeParam<=r){const e=c.vDotV;if(e<=o)return t.getPoint3dAtUncheckedPointIndex(i,n.point),n.a=Math.sqrt(e),n.v.setZero(),n.code=_.OnPolygonVertex,n.closestEdgeIndex=i,n.closestEdgeParam=0,n;e<u&&h&&(t.getPoint3dAtUncheckedPointIndex(i,n.point),n.a=Math.sqrt(e),t.crossProductIndexIndexIndex(i,d,s,n.v),n.code=_.OnPolygonVertex,n.closestEdgeIndex=i,n.closestEdgeParam=0,u=e),h=!1}else if(c.edgeParam<=1+r){c.edgeParam=J.clamp(c.edgeParam,0,1);const r=c.vDotV-c.edgeParam*c.edgeParam*c.uDotU;if(r<=o){const e=c.vDotV;if(c.edgeParam<=.5&&e<=o)return t.getPoint3dAtUncheckedPointIndex(i,n.point),n.a=Math.sqrt(e),n.v.setZero(),n.code=_.OnPolygonVertex,n.closestEdgeIndex=i,n.closestEdgeParam=0,n;const a=r+(1-c.edgeParam)*(1-c.edgeParam)*c.uDotU;return c.edgeParam>.5&&a<=o?(t.getPoint3dAtUncheckedPointIndex(s,n.point),n.a=Math.sqrt(a),n.v.setZero(),n.code=_.OnPolygonVertex,n.closestEdgeIndex=s,n.closestEdgeParam=0,n):(t.interpolateIndexIndex(i,c.edgeParam,s,n.point),n.a=Math.sqrt(r),n.v.setZero(),n.code=_.OnPolygonEdgeInterior,n.closestEdgeIndex=i,n.closestEdgeParam=c.edgeParam,n)}r<u&&(t.interpolateIndexIndex(i,c.edgeParam,s,n.point),n.a=Math.sqrt(r),t.crossProductIndexIndexXYAndZ(i,s,e,n.v),n.code=c.edgeParam<1?_.OnPolygonEdgeInterior:_.OnPolygonVertex,n.closestEdgeIndex=i,n.closestEdgeParam=c.edgeParam,u=r),h=!1}else h=!0;d=i}}return n}static closestPoint(t,e,i=J.smallMetricDistance,n){if(!(t instanceof nt))return this.closestPoint(new he(t),e,i,n);if(!this.unitNormal(t,this._normal))return Or.create(n);const s=this._workPlane=yt.createXYZUVW(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane),r=this._workXYZ=s.projectPointToPlane(e,this._workXYZ);return(n=this.closestPointOnBoundary(t,r,i,n)).isValid&&(n.v.dotProduct(this._normal)>0&&(n.point.setFrom(r),_.OnPolygonVertex===n.code?n.code=_.InsidePolygonProjectsToVertex:_.OnPolygonEdgeInterior===n.code&&(n.code=_.InsidePolygonProjectsToEdgeInterior)),n.a=e.distance(n.point),n.v.setZero()),n}static _workXYZ;static _workXY0;static _workXY1;static _workXY2;static _workRay;static _workMatrix3d;static _workPlane;static intersectRay3d(t,e,i=J.smallMetricDistance,n){if(!(t instanceof nt))return this.intersectRay3d(new he(t),e,i,n);if(!this.unitNormal(t,this._normal))return Or.create(n);this._workPlane=yt.createXYZUVW(t.getXAtUncheckedPointIndex(0),t.getYAtUncheckedPointIndex(0),t.getZAtUncheckedPointIndex(0),this._normal.x,this._normal.y,this._normal.z,this._workPlane);const s=this._workXYZ=$.createZero(this._workXYZ),r=e.intersectionWithPlane(this._workPlane,s);if(void 0===r)return Or.create(n);if((n=this.closestPointOnBoundary(t,s,i,n)).isValid){n.point.setFrom(s),n.a=r;const t=n.v.dotProduct(this._normal);0===t||(_.OnPolygonVertex===n.code?n.code=t>0?_.InsidePolygonProjectsToVertex:_.OutsidePolygonProjectsToVertex:_.OnPolygonEdgeInterior===n.code&&(n.code=t>0?_.InsidePolygonProjectsToEdgeInterior:_.OutsidePolygonProjectsToEdgeInterior))}return n}static intersectSegment(t,e,i,n=J.smallMetricDistance,s){return this._workRay=Rt.createStartEnd(e,i,this._workRay),this.intersectRay3d(t,this._workRay,n,s)}static computeEdgeDataXY(t,e,i,n,s=J.smallMetricDistance,r){const o=e%t.length,a=(o+1)%t.length;t.vectorIndexIndex(o,a,n).unitPerpendicularXY(n).negate(n);const c=t.getXAtUncheckedPointIndex(o)-i.x,l=t.getYAtUncheckedPointIndex(o)-i.y;let h=J.dotProductXYXY(c,l,n.x,n.y);const d=J.crossProductXYXY(c,l,n.x,n.y),u=J.distanceXYXY(t.getXAtUncheckedPointIndex(o),t.getYAtUncheckedPointIndex(o),t.getXAtUncheckedPointIndex(a),t.getYAtUncheckedPointIndex(a));let f=J.safeDivideFraction(d,u,0);return J.isSameCoordinate(0,h,s)&&(h=0),J.isSameCoordinate(0,f,s)?f=0:J.isSameCoordinate(1,f,s)&&(f=1),H.create(h,f,r)}static convexBarycentricCoordinatesOnEdge(t,e,i,n,s,r,o,a){const c=!i.isZero&&0===n.x&&J.isIn01(n.y),l=!r.isZero&&0===o.x&&J.isIn01(o.y);if(c&&l)return a.fill(0),a[s]=1,a;const h=t.length;if(c){a.fill(0);const t=e,i=s,r=n.y;return a[t]=1-r,a[i]=r,a}if(l){a.fill(0);const t=s,e=(s+1)%h,i=o.y;return a[t]=1-i,a[e]=i,a}}static convexBarycentricCoordinates(t,e,i=J.smallMetricDistance){if(Array.isArray(t))return this.convexBarycentricCoordinates(new he(t),e);let n=t.length;for(;n>1&&t.getPoint3dAtUncheckedPointIndex(0).isExactEqual(t.getPoint3dAtUncheckedPointIndex(n-1));)--n;if(n<3||!zr.unitNormal(t,this._normal))return;const s=this._workMatrix3d=xt.createRigidHeadsUp(this._normal,f.ZXY,this._workMatrix3d),r=new rt(n);for(let e=0;e<n;++e)r.push(s.multiplyInverseXYZAsPoint3d(t.getXAtUncheckedPointIndex(e),t.getYAtUncheckedPointIndex(e),t.getZAtUncheckedPointIndex(e),this._workXYZ));const o=this._workXYZ=s.multiplyInverseXYZAsPoint3d(e.x,e.y,e.z,this._workXYZ);let a=n-1;const c=this._vector0,l=this._workXY0=this.computeEdgeDataXY(r,a,o,c,i,this._workXY0);if(l.x<0)return;const h=tt.createFrom(c,this._vector1),d=this._workXY1=H.createFrom(l,this._workXY1),u=Array(t.length).fill(0),g=i>0?1/(i*i):J.largeCoordinateResult;let p=0;for(let t=0;t<n;++t){const e=tt.createFrom(c,this._vector2),s=this._workXY2=t<n-1?this.computeEdgeDataXY(r,t,o,e,i,this._workXY2):H.createFrom(l,this._workXY2);if(s.x<0)return;if(void 0!==this.convexBarycentricCoordinatesOnEdge(r,a,h,d,t,e,s,u))return u;if(0===e.x&&0===e.y)continue;if(0===d.x||0===s.x)continue;const f=Math.abs(h.crossProductXY(e)),m=J.conditionalDivideCoordinate(f,d.x*s.x,g);u[t]=m,p+=m,h.setFrom(e),d.setFrom(s),a=t}const m=J.conditionalDivideCoordinate(1,p);for(let t=0;t<n;++t)u[t]*=m;return u}static forceClosure(t,e=J.smallMetricDistance){t.length>=2&&(t instanceof rt?t.forceClosure(e):t[0].distance(t[t.length-1])>e?t.push(t[0].clone()):t[t.length-1].setFromPoint3d(t[0]))}static ensureClosed(t,e=J.smallMetricDistance){if(t.length>=2){let i=!1;if(i=t instanceof nt?!t.almostEqualIndexIndex(0,t.length-1,0):!t[0].isExactEqual(t[t.length-1]),i){const i=rt.create(t);this.forceClosure(i,e),t=i}}return t}static _workCLDPair;static closestApproach(t,e,i=Number.MAX_VALUE,n=!1){let s;const r=this.ensureClosed(t),o=this.ensureClosed(e),a=this._workCLDPair=Ci.closestApproach(r,!1,o,!1,i,this._workCLDPair);return a&&a.detailA.childDetail&&a.detailB.childDetail&&(s=Br.create(Or.createAtVertexOrEdge(a.detailA.point,a.detailA.childDetail.a,a.detailA.childDetail.fraction),Or.createAtVertexOrEdge(a.detailB.point,a.detailB.childDetail.a,a.detailB.childDetail.fraction)),s.detailA.a=s.detailB.a=a.detailA.a),s}}class Lr{static _xyz0Work=$.create();static _xyz1Work=$.create();static _xyz2Work=$.create();static splitConvexPolygonInsideOutsidePlane(t,e,i,n,s){const r=Lr._xyz0Work,o=Lr._xyz1Work,a=Lr._xyz2Work,c=e.length;if(i.clear(),n.clear(),c>2){e.back(r),s.setNull();let l=t.altitude(r);s.extendX(l);for(let h=0;h<c;h++){e.getPoint3dAtUncheckedPointIndex(h,o);const c=t.altitude(o);s.extendX(c);let d=!1;if(l*c<0){const t=-l/(c-l);t>1-1e-8&&c>=0?d=!0:(r.interpolate(t,o,a),i.push(a),n.push(a))}(c>=0||d)&&i.push(o),(c<=0||d)&&n.push(o),r.setFromPoint3d(o),l=c}}}static clipConvexPolygonInPlace(t,e,i,n=!0,s=J.smallMetricDistance){i.clear();const r=n?1:-1,o=e.length;let a=0;const c=-s;let l=0;if(e.length>1){let n,h=e.length-1,d=r*e.evaluateUncheckedIndexPlaneAltitude(h,t);Math.abs(d)<s&&(d=0);for(let u=0;u<o;d=n,h=u++){if(n=r*e.evaluateUncheckedIndexPlaneAltitude(u,t),Math.abs(n)<s&&(n=0),n<0&&a++,d*n<0){const t=-d/(n-d);t>1-1e-8&&n>=0||(i.pushInterpolatedFromGrowableXYZArray(e,h,t,u),n>0&&l++)}n>=c&&(i.pushFromGrowableXYZArray(e,u),d<-c&&l++),h=u,d=n}}return i.length<=2?e.clear():a>0&&(e.clear(),e.pushFromGrowableXYZArray(i)),i.clear(),l}static polygonPlaneCrossings(t,e,i){if(i.length=0,e.length>=2){const n=this._xyz0Work;e.getPoint3dAtUncheckedPointIndex(e.length-1,n);let s=t.altitude(n);const r=this._xyz1Work;for(let o=0;o<e.length;o++){e.getPoint3dAtUncheckedPointIndex(o,r);const a=t.altitude(r);if(s*a<0){const t=-s/(a-s);i.push(n.interpolate(t,r))}0===a&&i.push(r.clone()),n.setFromPoint3d(r),s=a}}}static gatherCutLoopsFromPlaneClip(t,e,i=3,n=J.smallMetricDistance){const s=new Xr;let r=0;const o=e.length;for(;r<o;r++){const i=e.evaluateUncheckedIndexPlaneAltitude(r,t);if(Math.abs(i)<=n)break}if(r===o)return s;let a=r;for(;a<o;){const c=new rt;c.pushFromGrowableXYZArray(e,a);let l=a+1;for(;l<o;){c.pushFromGrowableXYZArray(e,l);const i=e.evaluateUncheckedIndexPlaneAltitude(l,t);if(Math.abs(i)<=n)break;l++}if(l===o)for(let t=0;t<=r;t++)c.pushFromGrowableXYZArray(e,t);c.length>=i&&s.inputLoops.push(Nr.createCaptureWithReturnEdge(c)),a=l}return s}static reorderCutLoops(t){if(1!==t.inputLoops.length){if(2===t.inputLoops.length){if(t.inputLoops[0].edge.direction.dotProduct(t.inputLoops[1].edge.direction)>0)return t.outputLoops.push(t.inputLoops[0]),void t.outputLoops.push(t.inputLoops[1]);const e=t.inputLoops[1].xyz;return t.inputLoops[0].xyz.pushFromGrowableXYZArray(e),void t.outputLoops.push(t.inputLoops[0])}t.sortAndMergeLoops()}}static intersectRangeConvexPolygonInPlace(t,e){if(t.isNull)return;const i=new rt,n=Ot.create();return n.set(0,0,-1,t.high.z),this.clipConvexPolygonInPlace(n,e,i,!0),0!==e.length&&(n.set(0,0,1,-t.low.z),this.clipConvexPolygonInPlace(n,e,i,!0),0!==e.length&&(n.set(0,-1,0,t.high.y),this.clipConvexPolygonInPlace(n,e,i,!0),0!==e.length&&(n.set(0,1,0,-t.low.y),this.clipConvexPolygonInPlace(n,e,i,!0),0!==e.length&&(n.set(-1,0,0,t.high.x),this.clipConvexPolygonInPlace(n,e,i,!0),0!==e.length&&(n.set(1,0,0,-t.low.x),this.clipConvexPolygonInPlace(n,e,i,!0),0!==e.length)))))?e:void 0}}class Yr{static _xyz0Work=$.create();static convexPolygonSplitInsideOutsidePlane(t,e,i,n,s){const r=new he(e),o=new he(i),a=new he(n);Lr.splitConvexPolygonInsideOutsidePlane(t,r,o,a,s)}static polygonPlaneCrossings(t,e,i){const n=new he(e);return Lr.polygonPlaneCrossings(t,n,i)}static convexPolygonClipInPlace(t,e,i,n=J.smallMetricDistance){void 0===i&&(i=[]),i.length=0;let s=0;const r=-n;if(e.length>2){let n=e[e.length-1],o=t.altitude(n);for(const a of e){const e=t.altitude(a);if(e<0&&s++,o*e<0){const t=-o/(e-o);t>1-1e-8&&e>=0||i.push(n.interpolate(t,a))}e>=r&&i.push(a),n=$.createFrom(a),o=e}}if(i.length<=2)e.length=0;else if(s>0){e.length=0;for(const t of i)e.push(t);i.length=0}}}class Vr extends et{_inwardNormal;_distanceFromOrigin;_invisible;_interior;constructor(t,e,i,n){super(),this._invisible=i,this._interior=n,this._inwardNormal=t,this._distanceFromOrigin=e}isAlmostEqual(t){return J.isSameCoordinate(this._distanceFromOrigin,t._distanceFromOrigin)&&this._inwardNormal.isAlmostEqual(t._inwardNormal)&&this._interior===t._interior&&this._invisible===t._invisible}clone(){return new Vr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior)}cloneNegated(){const t=new Vr(this._inwardNormal.clone(),this._distanceFromOrigin,this._invisible,this._interior);return t.negateInPlace(),t}static createPlane(t,e=!1,i=!1,n){const s=t.getNormalRef().dotProduct(t.getOriginRef());return n?(n._invisible=e,n._interior=i,n._inwardNormal=t.getNormalRef().clone(),n._distanceFromOrigin=s,n):new Vr(t.getNormalRef().clone(),s,e,i)}static createNormalAndDistance(t,e,i=!1,n=!1,s){const r=t.normalize();if(r)return s&&(s._invisible=i,s._interior=n,s._inwardNormal=r,s._distanceFromOrigin=e),new Vr(r,e,i,n)}static createNormalAndPoint(t,e,i=!1,n=!1,s){const r=t.normalize();if(r){const t=r.dotProduct(e);return s&&(s._invisible=i,s._interior=n,s._inwardNormal=r,s._distanceFromOrigin=t),new Vr(r,t,i,n)}}static createOriginAndVectors(t,e,i,n=!1,s=!1,r){const o=i.crossProduct(e);return this.createNormalAndPoint(o,t,n,s,r)}static createNormalAndPointXYZXYZ(t,e,i,n,s,r,o=!1,a=!1,c){const l=J.hypotenuseXYZ(t,e,i),h=J.conditionalDivideFraction(1,l);if(void 0!==h){if(c)return c._inwardNormal.set(t*h,e*h,i*h),c._distanceFromOrigin=c._inwardNormal.dotProductXYZ(n,s,r),c._invisible=o,c._interior=a,c;const l=tt.create(t*h,e*h,i*h);return new Vr(l,l.dotProductXYZ(n,s,r),o,a)}}toJSON(){const t={normal:this.inwardNormalRef.toJSON(),dist:this.distance};return this.interior&&(t.interior=!0),this.invisible&&(t.invisible=!0),t}static fromJSON(t,e){return t&&t.normal&&void 0!==t.dist&&Number.isFinite(t.dist)?Vr.createNormalAndDistance(tt.fromJSON(t.normal),t.dist,!!t.invisible,!!t.interior):Vr.createNormalAndDistance(tt.unitZ(),0,!1,!1,e)}setFlags(t,e){this._invisible=t,this._interior=e}get distance(){return this._distanceFromOrigin}get inwardNormalRef(){return this._inwardNormal}get interior(){return this._interior}get invisible(){return this._invisible}static createEdgeAndUpVector(t,e,i,n,s){const r=tt.createFrom(e.minus(t));let o=i.crossProduct(r).normalize();if(o){if(void 0!==n&&!n.isAlmostZero){const t=tt.createRotateVectorAroundVector(o,r,n);t&&(o=t.clone())}return o.negate(o),Vr.createNormalAndPoint(o,t,!1,!1,s)}}static createEdgeXY(t,e,i){const n=tt.create(t.y-e.y,e.x-t.x);if(n.normalizeInPlace())return Vr.createNormalAndPoint(n,t,!1,!1,i)}getPlane3d(){const t=this._distanceFromOrigin;return yt.create($.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),this._inwardNormal)}getPlane4d(){return Ot.create(this._inwardNormal.x,this._inwardNormal.y,this._inwardNormal.z,-this._distanceFromOrigin)}setPlane4d(t){const e=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z),i=0===e?1:1/e;this._inwardNormal.x=i*t.x,this._inwardNormal.y=i*t.y,this._inwardNormal.z=i*t.z,this._distanceFromOrigin=-i*t.w}weightedAltitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-t.w*this._distanceFromOrigin}altitude(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z-this._distanceFromOrigin}altitudeXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z-this._distanceFromOrigin}normalX(){return this._inwardNormal.x}normalY(){return this._inwardNormal.y}normalZ(){return this._inwardNormal.z}velocity(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}velocityXYZ(t,e,i){return t*this._inwardNormal.x+e*this._inwardNormal.y+i*this._inwardNormal.z}dotProductPlaneNormalPoint(t){return t.x*this._inwardNormal.x+t.y*this._inwardNormal.y+t.z*this._inwardNormal.z}isPointOnOrInside(t,e=J.smallMetricDistance){let i=this.altitude(t);return e&&(i+=e),i>=0}isPointInside(t,e=J.smallMetricDistance){let i=this.altitude(t);return e&&(i-=e),i>0}isPointOn(t,e=J.smallMetricDistance){return Math.abs(this.altitude(t))<=e}appendIntersectionRadians(t,e){const i=t.toVectors(),n=this.altitude(t.center),s=this.velocity(i.vector0),r=this.velocity(i.vector90);Ct.appendImplicitLineUnitCircleIntersections(n,s,r,void 0,void 0,e)}static _clipArcFractionArray=new bt;announceClippedArcIntervals(t,e){const i=Vr._clipArcFractionArray;return i.clear(),this.appendIntersectionRadians(t,i),t.sweep.radiansArrayToPositivePeriodicFractions(i),kn.selectIntervals01(t,i,this,e)}getBoundedSegmentSimpleIntersection(t,e){const i=this.altitude(t),n=this.altitude(e);if(!(i*n>0||0===i&&0===n))return-i/(n-i)}transformInPlace(t){const e=this.getPlane3d(),i=t.matrix,n=t.multiplyPoint3d(e.getOriginRef()),s=i.multiplyInverseTranspose(e.getNormalRef());if(!s)return!1;e.set(n,s);const r=e.getNormalRef().normalize();return!!r&&(this._inwardNormal=r,this._distanceFromOrigin=this._inwardNormal.dotProduct(e.getOriginRef()),!0)}setInvisible(t){this._invisible=t}negateInPlace(){this._inwardNormal=this._inwardNormal.negate(),this._distanceFromOrigin=-this._distanceFromOrigin}offsetDistance(t){this._distanceFromOrigin+=t}clipConvexPolygonInPlace(t,e,i=!0,n=J.smallMetricDistance){return Lr.clipConvexPolygonInPlace(this,t,e,i,n)}multiplyPlaneByMatrix4d(t,e=!0,i=!0){const n=this.getPlane4d();if(e){const e=t.createInverse();return!!e&&this.multiplyPlaneByMatrix4d(e,!1,i)}return i?t.multiplyTransposePoint4d(n,n):t.multiplyPoint4d(n,n),this.setPlane4d(n),!0}announceClippedSegmentIntervals(t,e,i,n,s){if(e<t)return!1;const r=-this.altitude(i),o=-this.altitude(n)-r,a=J.conditionalDivideFraction(-r,o);return void 0===a?r<=0&&(s&&s(t,e),!0):(o>0?a<e&&(e=a):a>t&&(t=a),!(e<t||(s&&s(t,e),0)))}getFrame(){const t=this._distanceFromOrigin,e=$.create(this._inwardNormal.x*t,this._inwardNormal.y*t,this._inwardNormal.z*t),i=xt.createRigidHeadsUp(this._inwardNormal,f.ZXY);return mt.createOriginAndMatrix(e,i)}intersectRange(t,e=!1){if(t.isNull)return;const i=t.corners(),n=this.getFrame();n.multiplyInversePoint3dArrayInPlace(i);const s=ft.createArray(i);if(s.low.z*s.high.z>0)return;const r=new rt;return r.pushXYZ(s.low.x,s.low.y,0),r.pushXYZ(s.high.x,s.low.y,0),r.pushXYZ(s.high.x,s.high.y,0),r.pushXYZ(s.low.x,s.high.y,0),r.multiplyTransformInPlace(n),Lr.intersectRangeConvexPolygonInPlace(t,r),0!==r.length?(e&&r.pushWrap(1),r):void 0}appendPolygonClip(t,e,i,n){const s=gt.createNull(),r=n.grabFromCache(),o=n.grabFromCache();Lr.splitConvexPolygonInsideOutsidePlane(this,t,r,o,s),kn.captureOrDrop(r,3,e,n),kn.captureOrDrop(o,3,i,n)}projectPointToPlane(t,e){return this.projectXYZToPlane(t.x,t.y,t.z,e)}projectXYZToPlane(t,e,i,n){const s=-this.altitudeXYZ(t,e,i);return $.create(t+s*this._inwardNormal.x,e+s*this._inwardNormal.y,i+s*this._inwardNormal.z,n)}}const Ur={aliceBlue:16775408,amber:49151,antiqueWhite:14150650,aqua:16776960,aquamarine:13959039,azure:16777200,beige:14480885,bisque:12903679,black:0,blanchedAlmond:13495295,blue:16711680,blueViolet:14822282,brown:2763429,burlyWood:8894686,cadetBlue:10526303,chartreuse:65407,chocolate:1993170,coral:5275647,cornflowerBlue:15570276,cornSilk:14481663,crimson:3937500,cyan:16776960,darkBlue:9109504,darkBrown:2179941,darkCyan:9145088,darkGoldenrod:755384,darkGray:11119017,darkGreen:25600,darkGrey:11119017,darkKhaki:7059389,darkMagenta:9109643,darkOliveGreen:3107669,darkOrange:36095,darkOrchid:13382297,darkRed:139,darkSalmon:8034025,darkSeagreen:9419919,darkSlateBlue:9125192,darkSlateGray:5197615,darkSlateGrey:5197615,darkTurquoise:13749760,darkViolet:13828244,deepPink:9639167,deepSkyBlue:16760576,dimGray:6908265,dimGrey:6908265,dodgerBlue:16748574,fireBrick:2237106,floralWhite:15792895,forestGreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostWhite:16775416,gold:55295,goldenrod:2139610,gray:8421504,green:32768,greenYellow:3145645,grey:8421504,honeydew:15794160,hotPink:11823615,indianRed:6053069,indigo:8519755,ivory:15794175,khaki:9234160,lavender:16443110,lavenderBlush:16118015,lawnGreen:64636,lemonChiffon:13499135,lightBlue:15128749,lightCoral:8421616,lightCyan:16777184,lightGoldenrodYellow:13826810,lightGray:13882323,lightGreen:9498256,lightGrey:13882323,lightPink:12695295,lightSalmon:8036607,lightSeagreen:11186720,lightSkyBlue:16436871,lightSlateGray:10061943,lightSlateGrey:10061943,lightSteelBlue:14599344,lightyellow:14745599,lime:65280,limeGreen:3329330,linen:15134970,magenta:16711935,maroon:128,mediumAquamarine:11193702,mediumBlue:13434880,mediumOrchid:13850042,mediumPurple:14381203,mediumSeaGreen:7451452,mediumSlateBlue:15624315,mediumSpringGreen:10156544,mediumTurquoise:13422920,mediumVioletRed:8721863,midnightBlue:7346457,mintCream:16449525,mistyRose:14804223,moccasin:11920639,navajoWhite:11394815,navy:8388608,oldLace:15136253,olive:32896,oliveDrab:2330219,orange:42495,orangeRed:17919,orchid:14053594,paleGoldenrod:11200750,paleGreen:10025880,paleTurquoise:15658671,paleVioletRed:9662683,papayaWhip:14020607,peachPuff:12180223,peru:4163021,pink:13353215,plum:14524637,powderBlue:15130800,purple:8388736,rebeccaPurple:10040166,red:255,rosyBrown:9408444,royalBlue:14772545,saddleBrown:1262987,salmon:7504122,sandyBrown:6333684,seaGreen:5737262,seaShell:15660543,sienna:2970272,silver:12632256,skyBlue:15453831,slateBlue:13458026,slateGray:9470064,slateGrey:9470064,snow:16448255,springGreen:8388352,steelBlue:11829830,tan:9221330,teal:8421376,thistle:14204888,tomato:4678655,turquoise:13688896,violet:15631086,wheat:11788021,white:16777215,whiteSmoke:16119285,yellow:65535,yellowGreen:3329434};class qr{h;s;l;constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.l=i}clone(t,e,i){return new qr(t??this.h,e??this.s,i??this.l)}toColorDef(t=0){return Hr.fromHSL(this.h,this.s,this.l,t)}static fromColorDef(t){return t.toHSL()}}var Zr;!function(t){t[t.VISIBILITY_GOAL=40]="VISIBILITY_GOAL",t[t.HSV_SATURATION_WEIGHT=4]="HSV_SATURATION_WEIGHT",t[t.HSV_VALUE_WEIGHT=2]="HSV_VALUE_WEIGHT"}(Zr||(Zr={}));class Wr{h;s;v;constructor(t=0,e=0,i=0){this.h=t,this.s=e,this.v=i}clone(t,e,i){return new Wr(t??this.h,e??this.s,i??this.v)}toColorDef(t=0){return Hr.fromHSV(this,t)}static fromColorDef(t){return t.toHSV()}adjusted(t,e){let i;if(t){if(i=e*Zr.HSV_VALUE_WEIGHT,this.v>=i)return new Wr(this.h,this.s,this.v-i);i-=this.v;const t=Math.min(this.s+i,100);return new Wr(this.h,t,0)}if(i=e*Zr.HSV_SATURATION_WEIGHT,this.s>=i)return new Wr(this.h,this.s-i,this.v);i-=this.s;const n=Math.min(this.v+i,100);return new Wr(this.h,0,n)}}const Gr=new Uint8Array(4),Qr=new Uint32Array(Gr.buffer);class Hr{_tbgr;constructor(t){Qr[0]=t,this._tbgr=Qr[0]}static create(t){return this.fromTbgr(this.computeTbgr(t))}static computeTbgr(t){switch(typeof t){case"number":return t;case"string":return this.computeTbgrFromString(t);default:return 0}}toJSON(){return this._tbgr}static fromJSON(t){return this.create(t)}static from(t,e,i,n){return this.fromTbgr(this.computeTbgrFromComponents(t,e,i,n))}static computeTbgrFromComponents(t,e,i,n){return Gr[0]=t,Gr[1]=e,Gr[2]=i,Gr[3]=n||0,Qr[0]}static fromTbgr(t){switch(t){case Ur.black:return this.black;case Ur.white:return this.white;case Ur.red:return this.red;case Ur.green:return this.green;case Ur.blue:return this.blue;default:return new Hr(t)}}static fromAbgr(t){return this.fromTbgr(this.getAbgr(t))}static fromString(t){return this.fromTbgr(this.computeTbgrFromString(t))}static isValidColor(t){return"number"==typeof t?t>=0&&t<=4294967295&&Math.floor(t)===t:void 0!==this.tryComputeTbgrFromString(t)}static computeTbgrFromString(t){return this.tryComputeTbgrFromString(t)??0}static tryComputeTbgrFromString(t){if("string"!=typeof t)return;t=t.toLowerCase();let e=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t);if(e){let t;const i=e[1],n=e[2],s=t=>"%"===t[t.length-1],r=t=>{const e=parseFloat(t);return 255*J.clamp(s(t)?e/100:e,0,1)},o=t=>{const e=s(t)?parseFloat(t)/100*255:parseInt(t,10);return J.clamp(e,0,255)};switch(i){case"rgb":case"rgba":if(t=/^(\d+%*)\s*[, ]\s*(\d+%*)\s*[, ]\s*(\d+%*)\s*([,\/]\s*([0-9]*\.?[0-9]+%*)\s*)?$/.exec(n),t)return this.computeTbgrFromComponents(o(t[1]),o(t[2]),o(t[3]),"string"==typeof t[5]?255-r(t[5]):0);break;case"hsl":case"hsla":if(t=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n),t){const e=parseFloat(t[1])/360,i=parseInt(t[2],10)/100,n=parseInt(t[3],10)/100,s="string"==typeof t[5]?255-r(t[5]):0;return this.computeTbgrFromHSL(e,i,n,s)}}}else if(e=/^\#([a-f0-9]+)$/.exec(t)){const t=e[1],i=t.length;if(3===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(0),16),parseInt(t.charAt(1)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(2),16),0);if(6===i)return this.computeTbgrFromComponents(parseInt(t.charAt(0)+t.charAt(1),16),parseInt(t.charAt(2)+t.charAt(3),16),parseInt(t.charAt(4)+t.charAt(5),16),0)}if(t&&t.length>0)for(const[e,i]of Object.entries(Ur))if(e.toLowerCase()===t)return i}get colors(){return Hr.getColors(this._tbgr)}static getColors(t){return Qr[0]=t,{b:Gr[2],g:Gr[1],r:Gr[0],t:Gr[3]}}get tbgr(){return this._tbgr}getAbgr(){return Hr.getAbgr(this._tbgr)}static getAbgr(t){return Qr[0]=t,Gr[3]=255-Gr[3],Qr[0]}getRgb(){return Hr.getRgb(this._tbgr)}static getRgb(t){return Qr[0]=t,(Gr[0]<<16)+(Gr[1]<<8)+Gr[2]}withAlpha(t){const e=Hr.withAlpha(this._tbgr,t);return e===this._tbgr?this:Hr.fromTbgr(e)}static withAlpha(t,e){return Qr[0]=t,Gr[3]=255-(0|e),Qr[0]}getAlpha(){return Hr.getAlpha(this._tbgr)}static getAlpha(t){return Qr[0]=t,255-Gr[3]}get isOpaque(){return Hr.isOpaque(this._tbgr)}static isOpaque(t){return 255===this.getAlpha(t)}getTransparency(){return Hr.getTransparency(this._tbgr)}static getTransparency(t){return Qr[0]=t,Gr[3]}withTransparency(t){const e=Hr.withTransparency(this._tbgr,t);return e===this._tbgr?this:Hr.fromTbgr(e)}static withTransparency(t,e){return this.withAlpha(t,255-e)}get name(){return Hr.getName(this.tbgr)}static getName(t){for(const[e,i]of Object.entries(Ur))if(i===t)return e}toHexString(){return Hr.toHexString(this.tbgr)}static toHexString(t){return`#${`000000${this.getRgb(t).toString(16)}`.slice(-6)}`}static getColorsString(t){const e=this.getColors(t);return`${e.r},${e.g},${e.b}`}toRgbString(){return Hr.toRgbString(this.tbgr)}static toRgbString(t){return`rgb(${this.getColorsString(t)})`}toRgbaString(){return Hr.toRgbaString(this.tbgr)}static toRgbaString(t){return`rgba(${this.getColorsString(t)},${this.getAlpha(t)/255})`}lerp(t,e){return Hr.fromTbgr(Hr.lerp(this.tbgr,t.tbgr,e))}static lerp(t,e,i){const n=this.getColors(t),s=this.getColors(e);return n.r+=(s.r-n.r)*i,n.g+=(s.g-n.g)*i,n.b+=(s.b-n.b)*i,this.computeTbgrFromComponents(n.r,n.g,n.b,n.t)}inverse(){return Hr.fromTbgr(Hr.inverse(this.tbgr))}static inverse(t){const e=this.getColors(t);return this.computeTbgrFromComponents(255-e.r,255-e.g,255-e.b)}static fromHSL(t,e,i,n=0){return this.fromTbgr(this.computeTbgrFromHSL(t,e,i,n))}static computeTbgrFromHSL(t,e,i,n=0){const s=(t,e,i)=>Math.round(255*((t,e,i)=>(i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+6*(e-t)*(2/3-i):t))(t,e,i));if(t=(t%1+1)%1,e=J.clamp(e,0,1),i=J.clamp(i,0,1),0===e)return i*=255,this.computeTbgrFromComponents(i,i,i,n);const r=i<=.5?i*(1+e):i+e-i*e,o=2*i-r;return this.computeTbgrFromComponents(s(o,r,t+1/3),s(o,r,t),s(o,r,t-1/3),n)}toHSL(){const t=this.colors;t.r/=255,t.g/=255,t.b/=255;const e=Math.max(t.r,t.g,t.b),i=Math.min(t.r,t.g,t.b);let n,s=0;const r=(i+e)/2;if(i===e)n=0;else{const o=e-i;switch(n=r<=.5?o/(e+i):o/(2-e-i),e){case t.r:s=(t.g-t.b)/o+(t.g<t.b?6:0);break;case t.g:s=(t.b-t.r)/o+2;break;case t.b:s=(t.r-t.g)/o+4}s/=6}return new qr(s,n,r)}toHSV(){const{r:t,g:e,b:i}=this.colors;let n=t<e?t:e;i<n&&(n=i);let s=t>e?t:e;i>s&&(s=i);const r=Math.floor(s/255*100+.5),o=s-n,a=0!==s?Math.floor(o/s*100+.5):0;let c=0;if(a){const n=(s-t)/o,r=(s-e)/o,a=(s-i)/o;let l;l=t===s?a-r:e===s?2+n-a:4+r-n,l*=60,l<0&&(l+=360),c=Math.floor(l+.5),c>=360&&(c=0)}else c=0;return new Wr(c,a,r)}static fromHSV(t,e=0){if(!t.s||-1===t.h){const e=255&Math.floor(255*t.v/100+.5+3e-14);return Hr.from(e,e,e,0)}let i=t.h,n=t.s,s=t.v;360===i&&(i=0),i/=60;const r=Math.floor(i),o=i-r;s/=100,n/=100;const a=255&Math.floor(s*(1-n)*255+.5),c=255&Math.floor(s*(1-n*o)*255+.5),l=255&Math.floor(s*(1-n*(1-o))*255+.5),h=255&Math.floor(255*s+.5);let d=0,u=0,f=0;switch(r){case 0:d=h,f=l,u=a;break;case 1:d=c,f=h,u=a;break;case 2:d=a,f=h,u=l;break;case 3:d=a,f=c,u=h;break;case 4:d=l,f=a,u=h;break;case 5:d=h,f=a,u=c}return Hr.from(d,f,u,e)}visibilityCheck(t){const e=this.colors,i=t.colors;return.3*Math.abs(e.r-i.r)+.59*Math.abs(e.g-i.g)+.11*Math.abs(e.b-i.b)}adjustedForContrast(t,e){const i=this.visibilityCheck(t);if(Zr.VISIBILITY_GOAL<=i)return void 0!==e?this.withAlpha(e):this;const n=Math.floor((Zr.VISIBILITY_GOAL-i)/255*100);let s=this.toHSV(),r=s.clone();s=s.adjusted(!0,n),r=r.adjusted(!1,n),void 0===e&&(e=this.getAlpha());const o=Hr.fromHSV(s).withAlpha(e),a=Hr.fromHSV(r).withAlpha(e);return a.getRgb()===t.getRgb()?o:o.getRgb()===t.getRgb()||a.visibilityCheck(t)>=o.visibilityCheck(t)?a:o}equals(t){return this._tbgr===t._tbgr}static black=new Hr(Ur.black);static white=new Hr(Ur.white);static red=new Hr(Ur.red);static green=new Hr(Ur.green);static blue=new Hr(Ur.blue)}class jr{r;g;b;constructor(t,e,i){this.r=t,this.g=e,this.b=i,this.r=Math.max(0,Math.min(this.r,255)),this.g=Math.max(0,Math.min(this.g,255)),this.b=Math.max(0,Math.min(this.b,255))}static fromColorDef(t){const e=t.colors;return new jr(e.r,e.g,e.b)}toColorDef(t=0){return Hr.from(this.r,this.g,this.b,t)}toJSON(){return{r:this.r,g:this.g,b:this.b}}static fromJSON(t){let e=255,i=255,n=255;return void 0!==t&&("number"==typeof t.r&&(e=t.r),"number"==typeof t.g&&(i=t.g),"number"==typeof t.b&&(n=t.b)),new jr(e,i,n)}equals(t){return this.r===t.r&&this.g===t.g&&this.b===t.b}compareTo(e){return t(this.r,e.r)||t(this.g,e.g)||t(this.b,e.b)}toHexString(){return this.toColorDef().toHexString()}}class Jr{value;index;constructor(t,e){this.value=t,this.index=e}}class Kr{_array=[];_compareValues;_clone;_maximumSize;constructor(t,e=Number.MAX_SAFE_INTEGER,i=V){this._compareValues=t,this._clone=i,this._maximumSize=e}get length(){return this._array.length}get isFull(){return this.length>=this._maximumSize}get isEmpty(){return 0===this.length}clear(){this._array=[]}insert(t,e){const i=this.lowerBound(t);if(i.equal)return this._array[i.index].index;if(this.isFull)return-1;const n=new Jr(this._clone(t),this._array.length);return void 0!==e&&e(n.value),this._array.splice(i.index,0,n),n.index}indexOf(t){const e=this.lowerBound(t);return e.equal?this._array[e.index].index:-1}lowerBound(t){return U(t,this._array,((t,e)=>this._compareValues(t,e.value)))}toArray(){const t=[];for(const e of this._array)t[e.index]=e.value;return t}}var $r,to,eo;!function(t){t[t.Never=0]="Never",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Blanking=3]="Blanking"}($r||($r={})),function(t){t[t.None=0]="None",t[t.Solid=1]="Solid",t[t.Outline=2]="Outline"}(to||(to={})),function(t){t[t.Primary=0]="Primary",t[t.Construction=1]="Construction",t[t.Dimension=2]="Dimension",t[t.Pattern=3]="Pattern"}(eo||(eo={}));class io{data;batchModelId;batchModelIdPair;numFeatures;anyDefined;type;animationNodeIds;get byteLength(){return this.data.byteLength}constructor(t,e,i,n,s){switch(this.data=t,this.batchModelId=e,this.batchModelIdPair=c.getUint32Pair(e),this.numFeatures=i,this.type=n,this.animationNodeIds=s,this.numFeatures){case 0:this.anyDefined=!1;break;case 1:this.anyDefined=lo.isDefined(this.getFeature(0,lo.create()));break;default:this.anyDefined=!0}this.data.length,this._subCategoriesOffset,void 0===this.animationNodeIds||(this.animationNodeIds.length,this.numFeatures)}static pack(t){const e=new Map;for(const i of t.getArray())void 0===e.get(i.value.subCategoryId.toString())&&e.set(i.value.subCategoryId,e.size);const i=3*t.length,n=i+2*e.size,s=new Uint32Array(n);for(const i of t.getArray()){const t=i.value,n=3*i.index;let r=e.get(t.subCategoryId);r|=t.geometryClass<<24,s[n+0]=c.getLowerUint32(t.elementId),s[n+1]=c.getUpperUint32(t.elementId),s[n+2]=r}return e.forEach(((t,e,n)=>{const r=i+2*t;s[r+0]=c.getLowerUint32(e),s[r+1]=c.getUpperUint32(e)})),new io(s,t.modelId,t.length,t.type)}getFeature(t,e){const i=this.getPackedFeature(t,oo);return lo.unpack(i,e,this.batchModelId)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,e){e=e??{lower:0,upper:0},this.numFeatures;const i=3*t;return e.lower=this.data[i],e.upper=this.data[i+1],e}getSubCategoryIdPair(t){const e=3*t;let i=this.data[e+2];return i=(16777215&i)>>>0,i=2*i+this._subCategoriesOffset,{lower:this.data[i],upper:this.data[i+1]}}getAnimationNodeId(t){return void 0!==this.animationNodeIds&&t<this.numFeatures?this.animationNodeIds[t]:0}getPackedFeature(t,e){this.numFeatures;const i=3*t;e.elementId.lower=this.data[i],e.elementId.upper=this.data[i+1];const n=this.data[i+2];e.geometryClass=n>>>24&255;let s=(16777215&n)>>>0;return s=2*s+this._subCategoriesOffset,e.subCategoryId.lower=this.data[s],e.subCategoryId.upper=this.data[s+1],e.animationNodeId=this.getAnimationNodeId(t),e.modelId.lower=this.batchModelIdPair.lower,e.modelId.upper=this.batchModelIdPair.upper,e}getModelIdPair(t,e){return e.lower=this.batchModelIdPair.lower,e.upper=this.batchModelIdPair.upper,e}findElementId(t){return t>=this.numFeatures?void 0:this.readId(3*t)}get isUniform(){return 1===this.numFeatures}getUniform(t){return this.isUniform?this.getFeature(0,t):void 0}get isVolumeClassifier(){return uo.VolumeClassifier===this.type}get isPlanarClassifier(){return uo.VolumeClassifier===this.type}get isClassifier(){return this.isVolumeClassifier||this.isPlanarClassifier}unpack(){const t=new go(this.numFeatures,this.batchModelId),e=lo.create();for(let i=0;i<this.numFeatures;i++)this.getFeature(i,e),t.insertWithIndex(new co(e.elementId,e.subCategoryId,e.geometryClass),i);return t}populateAnimationNodeIds(t,e){this.animationNodeIds,this.animationNodeIds=ao(this,t,e)}*iterator(t){for(let e=0;e<this.numFeatures;e++)this.getPackedFeature(e,t),t.index=e,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}get _subCategoriesOffset(){return 3*this.numFeatures}readId(t){return c.fromUint32Pair(this.data[t],this.data[t+1])}}const no={lastFeatureIndex:-1,idLower:-1,idUpper:-1};class so{_data;constructor(t){this._data=t,this._data.length}get length(){return this._data.length/3}get byteLength(){return this._data.byteLength}getLastFeatureIndex(t){return this._data[3*t]}getEntry(t,e){if(t>=this.length)return e.idLower=e.idUpper=0,e.lastFeatureIndex=Number.MAX_SAFE_INTEGER,e;const i=3*t;return e.lastFeatureIndex=this._data[i+0],e.idLower=this._data[i+1],e.idUpper=this._data[i+2],e}getModelIdPair(t,e){e?e.lower=e.upper=0:e={lower:0,upper:0};let i=0;const n=this.length;let s=n;for(;s>0;){const e=Math.floor(s/2),n=i+e;t>this.getLastFeatureIndex(n)?(i=n+1,s-=e+1):s=e}return i<n&&(e.lower=this._data[3*i+1],e.upper=this._data[3*i+2]),e}}class ro{_features;_models;constructor(t,e){this._features=t,this._models=e}static create(t,e,i,n,s){const r=3*i+2*s,o=t.subarray(0,r),a=new io(o,e,i,n),c=t.subarray(r),l=new so(c);return new ro(a,l)}get batchModelId(){return this._features.batchModelId}get batchModelIdPair(){return this._features.batchModelIdPair}get numFeatures(){return this._features.numFeatures}get type(){return this._features.type}get animationNodeIds(){return this._features.animationNodeIds}set animationNodeIds(t){this._features.animationNodeIds=t}get byteLength(){return this._features.byteLength+this._models.byteLength}getPackedFeature(t,e){return this._features.getPackedFeature(t,e),this._models.getModelIdPair(t,e.modelId),e}getFeature(t,e){const i=this.getPackedFeature(t,oo);return lo.unpack(i,e)}findFeature(t,e){return t<this.numFeatures?this.getFeature(t,e):void 0}getElementIdPair(t,e){return this._features.getElementIdPair(t,e)}getModelIdPair(t,e){return this._models.getModelIdPair(t,e),e}findElementId(t){return this._features.findElementId(t)}*iterator(t){let e=0;const i=this._models.getEntry(e,no);for(let n=0;n<this.numFeatures;n++)n>i.lastFeatureIndex&&this._models.getEntry(++e,i),this._features.getPackedFeature(n,t),t.modelId.lower=i.idLower,t.modelId.upper=i.idUpper,t.index=n,yield t}iterable(t){return{[Symbol.iterator]:()=>this.iterator(t)}}getAnimationNodeId(t){return this._features.getAnimationNodeId(t)}populateAnimationNodeIds(t,e){this._features.animationNodeIds=ao(this,t,e)}}const oo=function(){const t={upper:0,lower:0};return{modelId:{...t},elementId:{...t},subCategoryId:{...t},geometryClass:eo.Primary,animationNodeId:0}}();function ao(t,e,i){let n;const s=ho.createWithIndex();for(const r of t.iterable(s)){const s=e(r);if(0!==s){if(!n){const e=t.numFeatures;n=i<256?new Uint8Array(e):i<65536?new Uint16Array(e):new Uint32Array(e)}n[r.index]=s}}return n}class co{elementId;subCategoryId;geometryClass;constructor(t=c.invalid,e=c.invalid,i=eo.Primary){this.elementId=t,this.subCategoryId=e,this.geometryClass=i}get isDefined(){return!c.isInvalid(this.elementId)||!c.isInvalid(this.subCategoryId)||this.geometryClass!==eo.Primary}get isUndefined(){return!this.isDefined}equals(t){return 0===this.compare(t)}compare(e){if(this===e)return 0;let n=t(this.geometryClass,e.geometryClass);return 0===n&&(n=i(this.elementId,e.elementId),0===n&&(n=i(this.subCategoryId,e.subCategoryId))),n}}var lo,ho,uo,fo;!function(t){t.create=function(){return{modelId:c.invalid,elementId:c.invalid,subCategoryId:c.invalid,geometryClass:eo.Primary}},t.isDefined=function(t){return!c.isInvalid(t.modelId)||!c.isInvalid(t.elementId)||!c.isInvalid(t.subCategoryId)||t.geometryClass!==eo.Primary},t.unpack=function(t,e,i){return e.modelId=i??c.fromUint32PairObject(t.modelId),e.elementId=c.fromUint32PairObject(t.elementId),e.subCategoryId=c.fromUint32PairObject(t.subCategoryId),e.geometryClass=t.geometryClass,e}}(lo||(lo={})),function(t){function e(){const t={upper:0,lower:0};return{modelId:{...t},elementId:{...t},subCategoryId:{...t},geometryClass:eo.Primary,animationNodeId:0}}t.create=e,t.createWithIndex=function(){const t=e();return t.index=0,t}}(ho||(ho={})),function(t){t[t.Primary=0]="Primary",t[t.VolumeClassifier=1]="VolumeClassifier",t[t.PlanarClassifier=2]="PlanarClassifier"}(uo||(uo={}));class go extends Kr{modelId;type;constructor(t,e=c.invalid,i=uo.Primary){super(((t,e)=>t.compare(e)),t),this.modelId=e,this.type=i}get maxFeatures(){return this._maximumSize}get anyDefined(){return this.length>1||1===this.length&&this._array[0].value.isDefined}get isUniform(){return 1===this.length}get uniform(){return 1===this.length?this._array[0].value:void 0}get isVolumeClassifier(){return uo.VolumeClassifier===this.type}get isPlanarClassifier(){return uo.PlanarClassifier===this.type}findFeature(t){for(const e of this._array)if(e.index===t)return e.value}insertWithIndex(t,e){const i=this.lowerBound(t);i.equal,this.isFull;const n=new Jr(t,e);this._array.splice(i.index,0,n)}getArray(){return this._array}pack(){return io.pack(this)}}function po(t,e){return t===e||!(!t||!e)&&t.equals(e)}function mo(t,e){return t===e||void 0!==t&&void 0!==e&&Math.floor(255*t)===Math.floor(255*e)}function _o(t){if(void 0===t)return;const e=1e-4;return 1-(t=Math.max(0,Math.min(t,1)))<e?t=1:t<e&&(t=0),t}class xo{rgb;lineRgb;weight;transparency;lineTransparency;linePixels;ignoresMaterial;nonLocatable;emphasized;viewDependentTransparency;static defaults=new xo({});static fromJSON(t){return!t||function(t){return!(t.rgb||t.lineRgb||void 0!==t.weight||void 0!==t.linePixels||void 0!==t.transparency||void 0!==t.lineTransparency||t.ignoresMaterial||t.nonLocatable||t.emphasized)}(t)?this.defaults:new xo(t)}static fromRgb(t){return new xo({rgb:jr.fromColorDef(t)})}static fromRgba(t,e=!1){return new xo({rgb:jr.fromColorDef(t),transparency:t.colors.t/255,viewDependentTransparency:!!e||void 0})}static fromTransparency(t,e=!1){return new xo({transparency:t,viewDependentTransparency:!!e||void 0})}static fromSubCategoryOverride(t){const e=void 0!==t.color?jr.fromColorDef(t.color):void 0,i=t.transparency,n=t.weight,s=!(void 0===t.material||!c.isValid(t.material))||void 0;return this.fromJSON({rgb:e,transparency:i,weight:n,ignoresMaterial:s,viewDependentTransparency:!0})}get matchesDefaults(){return this.equals(xo.defaults)}get overridesRgb(){return void 0!==this.rgb}get overridesTransparency(){return void 0!==this.transparency}get overridesLinePixels(){return void 0!==this.linePixels}get overridesWeight(){return void 0!==this.weight}getLineRgb(){return!1!==this.lineRgb?this.lineRgb??this.rgb:void 0}getLineTransparency(){return!1!==this.lineTransparency?this.lineTransparency??this.transparency:void 0}get overridesSymbology(){return this.overridesRgb||this.overridesTransparency||this.overridesWeight||this.overridesLinePixels||!!this.ignoresMaterial||this.emphasized||this.overridesNonLocatable||void 0!==this.getLineRgb()||void 0!==this.getLineTransparency()}get overridesNonLocatable(){return void 0!==this.nonLocatable}get isFullyTransparent(){const t=this.transparency??0,e=this.getLineTransparency()??0;return t>=1&&e>=1}get anyOverridden(){return this.overridesSymbology||this.overridesNonLocatable}equals(t){return this===t||po(this.rgb,t.rgb)&&this.weight===t.weight&&mo(this.transparency,t.transparency)&&this.linePixels===t.linePixels&&this.ignoresMaterial===t.ignoresMaterial&&this.nonLocatable===t.nonLocatable&&this.emphasized===t.emphasized&&this.viewDependentTransparency===t.viewDependentTransparency&&((e=this.lineTransparency)===(i=t.lineTransparency)||"number"==typeof e&&"number"==typeof i&&mo(e,i))&&function(t,e){return t===e||t instanceof jr&&e instanceof jr&&po(t,e)}(this.lineRgb,t.lineRgb);var e,i}toJSON(){const t={};return this.rgb&&(t.rgb=this.rgb.toJSON()),void 0!==this.weight&&(t.weight=this.weight),void 0!==this.transparency&&(t.transparency=this.transparency,this.viewDependentTransparency&&(t.viewDependentTransparency=!0)),void 0!==this.linePixels&&(t.linePixels=this.linePixels),!0===this.ignoresMaterial&&(t.ignoresMaterial=!0),!0===this.nonLocatable&&(t.nonLocatable=!0),!0===this.emphasized&&(t.emphasized=!0),void 0!==this.lineTransparency&&(t.lineTransparency=this.lineTransparency),this.lineRgb&&(t.lineRgb=this.lineRgb,this.viewDependentTransparency&&(t.viewDependentTransparency=!0)),t}cloneProps(t){return{...this.toJSON(),...t}}clone(t){return xo.fromJSON(this.cloneProps(t))}extendAppearance(t){if(!this.overridesSymbology)return t;const e=t.toJSON();return void 0===e.rgb&&(e.rgb=this.rgb),void 0===e.transparency&&(e.transparency=this.transparency),void 0===e.linePixels&&(e.linePixels=this.linePixels),void 0===e.weight&&(e.weight=this.weight),void 0===e.ignoresMaterial&&this.ignoresMaterial&&(e.ignoresMaterial=!0),void 0===e.nonLocatable&&this.nonLocatable&&(e.nonLocatable=!0),void 0===e.emphasized&&this.emphasized&&(e.emphasized=!0),e.lineRgb||(e.lineRgb=this.lineRgb),void 0===e.lineTransparency&&(e.lineTransparency=this.lineTransparency),!this.viewDependentTransparency||void 0===e.transparency&&void 0===e.lineTransparency||(e.viewDependentTransparency=!0),xo.fromJSON(e)}constructor(t){this.rgb=void 0!==t.rgb?jr.fromJSON(t.rgb):void 0,this.lineRgb="object"==typeof t.lineRgb?jr.fromJSON(t.lineRgb):!1!==t.lineRgb&&void 0,this.transparency=_o(t.transparency),this.lineTransparency="number"==typeof t.lineTransparency?_o(t.lineTransparency):!1!==t.lineTransparency&&void 0,this.weight=t.weight,this.linePixels=t.linePixels,this.ignoresMaterial=t.ignoresMaterial,this.nonLocatable=t.nonLocatable,this.emphasized=t.emphasized,void 0!==this.weight&&(this.weight=Math.max(1,Math.min(this.weight,32))),!t.viewDependentTransparency||void 0===this.transparency&&void 0===this.getLineTransparency()||(this.viewDependentTransparency=!0)}}function yo(t,e,i){return t+i*(e-t)}function vo(e,i){return t(e.x,i.x)||t(e.y,i.y)||t(e.z,i.z)}xo.fromJSON({weight:1}),function(t){t.supplement=function(t){return{getFeatureAppearance:(e,i,n,s,r,o,a,c,l,h)=>{const d=e.getAppearance(i,n,s,r,o,a,c,l,h);return d?t(d):d}}},t.chain=function(t,e){return t===e?t:{getFeatureAppearance:(i,n,s,r,o,a,c,l,h,d)=>e.getFeatureAppearance(function(t,e){return{getAppearance:(i,n,s,r,o,a,c,l,h)=>e.getFeatureAppearance(t,i,n,s,r,o,a,c,l,h)}}(i,t),n,s,r,o,a,c,l,h,d)}}}(fo||(fo={}));const Po=new tt,Io=new tt;function So(e,i){return t(e.low,i.low)||t(e.high,i.high)}var bo,Ao,Co,To,wo,Eo,ko,Fo,Ro,Mo,Do,Oo,Bo,No,Xo,zo,Lo,Yo,Vo,Uo,qo,Zo,Wo,Go,Qo,Ho,jo,Jo,Ko,$o,ta,ea,ia,na,sa,ra,oa,aa,ca;function la(t,e){e&&t.add(e.buffer)}function ha(t,e){if("pattern"!==e.type)switch(la(t,e.params.vertices.data),"instances"===e.modifier?.type&&(la(t,e.modifier.transforms),la(t,e.modifier.featureIds),la(t,e.modifier.symbologyOverrides)),e.type){case"point":la(t,e.params.indices);break;case"polyline":la(t,e.params.polyline.indices),la(t,e.params.polyline.prevIndices),la(t,e.params.polyline.nextIndicesAndParams);break;case"mesh":la(t,e.params.surface.indices);const i=e.params.edges;i&&(la(t,i.segments?.indices),la(t,i.segments?.endPointAndQuadIndices),la(t,i.silhouettes?.indices),la(t,i.silhouettes?.endPointAndQuadIndices),la(t,i.silhouettes?.normalPairs),la(t,i.polylines?.indices),la(t,i.polylines?.prevIndices),la(t,i.polylines?.nextIndicesAndParams),la(t,i.indexed?.indices),la(t,i.indexed?.edges.data))}else la(t,e.params.xyOffsets)}function da(t){const e=new Set,i=t=>{t&&e.add(t.buffer)};i(t.binaryData),i(t.featureTable.data),i(t.featureTable.animationNodeIds);for(const i of t.nodes)if(void 0!==i.groupId)for(const t of i.nodes)for(const i of t.primitives)ha(e,i);else for(const t of i.primitives)ha(e,t);for(const i of t.patterns.values())for(const t of i)ha(e,t);return Array.from(e)}!function(s){let r;!function(t){t[t.Step=1]="Step",t[t.Linear=2]="Linear"}(r=s.Interpolation||(s.Interpolation={}));class o{time;interpolation;constructor(t){this.time=t.time,this.interpolation=t.interpolation===r.Linear?t.interpolation:r.Step}toJSON(){const t={time:this.time};return this.interpolation===r.Linear&&(t.interpolation=this.interpolation),t}compareTo(e){return t(this.interpolation,e.interpolation)||t(this.time,e.time)}equals(t){return 0===this.compareTo(t)}}s.TimelineEntry=o;class a extends o{value;constructor(t){super(t),"number"!=typeof t.value?this.value=100:this.value=Math.max(0,Math.min(100,t.value))}toJSON(){const t=super.toJSON();return 100!==this.value&&(t.value=this.value),t}compareTo(e){return super.compareTo(e)||t(this.value,e.value)}}s.VisibilityEntry=a;class l extends o{value;constructor(t){super(t),t.value&&(this.value=new jr(t.value.red,t.value.green,t.value.blue))}toJSON(){const t=super.toJSON();return this.value&&(t.value={red:this.value.r,green:this.value.g,blue:this.value.b}),t}compareTo(t){return super.compareTo(t)||n(((t,e)=>t.compareTo(e)),this.value,t.value)}}s.ColorEntry=l;class d{pivot;orientation;position;constructor(t,e,i){this.position=t,this.pivot=e,this.orientation=i}static fromJSON(t){return t.pivot&&t.position&&t.orientation?new d(tt.fromJSON(t.position),tt.fromJSON(t.pivot),Ot.fromJSON(t.orientation)):void 0}toJSON(){return{position:[this.position.x,this.position.y,this.position.z],pivot:[this.pivot.x,this.pivot.y,this.pivot.z],orientation:[this.orientation.x,this.orientation.y,this.orientation.z,this.orientation.w]}}compareTo(e){return vo(this.pivot,e.pivot)||vo(this.position,e.position)||(i=this.orientation,n=e.orientation,t(i.x,n.x)||t(i.y,n.y)||t(i.z,n.z)||t(i.w,n.w));var i,n}equals(t){return this.pivot.isAlmostEqual(t.pivot)&&this.position.isAlmostEqual(t.position)&&this.orientation.isAlmostEqual(t.orientation)}}s.TransformComponents=d;class f extends o{value;components;constructor(t){super(t),this.value=t.value?mt.fromJSON(t.value.transform):mt.identity,t.value&&(this.components=d.fromJSON(t.value))}toJSON(){const t=super.toJSON();return this.components?(t.value=this.components.toJSON(),t.value.transform=this.value.toRows()):t.value={transform:this.value.toRows()},t}compareTo(t){const e=super.compareTo(t);return 0!==e?e:this.components||t.components?this.components&&t.components?this.components.compareTo(t.components):this.components?1:-1:vo(this.value.origin,t.value.origin)||(i=this.value.matrix,n=t.value.matrix,vo(i.columnX(Po),n.columnX(Io))||vo(i.columnY(Po),n.columnY(Io))||vo(i.columnZ(Po),n.columnZ(Io)));var i,n}}s.TransformEntry=f;class g{position;direction;visible;hidden;constructor(t){this.position=$.fromJSON(t.position),this.direction=$.fromJSON(t.direction),this.hidden=!0===t.hidden,this.visible=!0===t.visible}toJSON(){const t={position:[this.position.x,this.position.y,this.position.z],direction:[this.direction.x,this.direction.y,this.direction.z]};return this.visible&&(t.visible=!0),this.hidden&&(t.hidden=!0),t}compareTo(t){return vo(this.position,t.position)||vo(this.direction,t.direction)||e(this.visible,t.visible)||e(this.hidden,t.hidden)}equals(t){return 0===this.compareTo(t)}}s.CuttingPlane=g;class p extends o{value;constructor(t){super(t),t.value&&(this.value=new g(t.value))}toJSON(){const t=super.toJSON();return this.value&&(t.value=this.value.toJSON()),t}compareTo(t){return super.compareTo(t)||n(((t,e)=>t.compareTo(e)),this.value,t.value)}}s.CuttingPlaneEntry=p;class m{lowerIndex;upperIndex;fraction;constructor(t=0,e=0,i=0){this.init(t,e,i)}init(t=0,e=0,i=0){this.lowerIndex=t,this.upperIndex=e,this.fraction=i}}s.Interval=m;class _{_entries;duration;constructor(t,e){this.duration=gt.createNull(),this._entries=t.map((t=>{const i=new e(t);return this.duration.extendX(i.time),i}))}get length(){return this._entries.length}[Symbol.iterator](){return this._entries[Symbol.iterator]()}getEntry(t){return this._entries[t]}getValue(t){return this.getEntry(t)?.value}toJSON(){return this._entries.map((t=>t.toJSON()))}compareTo(e){let i=t(this._entries.length,e._entries.length)||So(this.duration,e.duration);if(0===i)for(let t=0;t<this.length&&0===(i=this._entries[t].compareTo(e._entries[t]));t++);return i}equals(t){return 0===this.compareTo(t)}findInterval(t,e){if(0===this.length)return;if(e=e??new m,t<this._entries[0].time)return e.init(0,0,0),e;const i=this.length-1;if(t>=this._entries[i].time)return e.init(i,i,0),e;for(let n=0;n<i;n++){const i=this._entries[n].time,s=this._entries[n+1].time;if(i<=t&&s>=t){let o;return o=r.Linear===this._entries[n].interpolation?(t-i)/(s-i):0,e.init(n,n+1,o),e}}}}s.TimelineEntryList=_;const x=new m;class y extends _{getValue(t){return super.getValue(t)??100}}s.VisibilityTimelineEntries=y;class v extends _{getValue(t){return super.getValue(t)??mt.identity}}s.TransformTimelineEntries=v;class P{visibility;color;transform;cuttingPlane;duration;constructor(t){this.duration=gt.createNull(),t.visibilityTimeline&&(this.visibility=new y(t.visibilityTimeline,a),this.duration.extendRange(this.visibility.duration)),t.colorTimeline&&(this.color=new _(t.colorTimeline,l),this.duration.extendRange(this.color.duration)),t.transformTimeline&&(this.transform=new v(t.transformTimeline,f),this.duration.extendRange(this.transform.duration)),t.cuttingPlaneTimeline&&(this.cuttingPlane=new _(t.cuttingPlaneTimeline,p),this.duration.extendRange(this.cuttingPlane.duration))}toJSON(){return{visibilityTimeline:this.visibility?.toJSON(),colorTimeline:this.color?.toJSON(),transformTimeline:this.transform?.toJSON(),cuttingPlaneTimeline:this.cuttingPlane?.toJSON()}}compareTo(t){const e=So(this.duration,t.duration);return 0!==e?e:!!this.visibility!=!!t.visibility?this.visibility?1:-1:!!this.color!=!!t.color?this.color?1:-1:!!this.transform!=!!t.transform?this.transform?1:-1:!!this.cuttingPlane!=!!t.cuttingPlane?this.cuttingPlane?1:-1:n(((t,e)=>t.compareTo(e)),this.visibility,t.visibility)||n(((t,e)=>t.compareTo(e)),this.color,t.color)||n(((t,e)=>t.compareTo(e)),this.transform,t.transform)||n(((t,e)=>t.compareTo(e)),this.cuttingPlane,t.cuttingPlane)}equals(t){return 0===this.compareTo(t)}getVisibility(t){let e;if(!this.visibility||!(e=this.visibility.findInterval(t,x)))return 100;let i=this.visibility.getValue(e.lowerIndex)??100;return e.fraction>0&&(i=yo(i,this.visibility.getValue(e.upperIndex)??100,e.fraction)),i}getColor(t){let e;if(!this.color||!(e=this.color.findInterval(t,x)))return;const i=this.color.getValue(e.lowerIndex);if(i&&e.fraction>0){const t=this.color.getValue(e.upperIndex);if(t)return function(t,e,i){return new jr(yo(t.r,e.r,i),yo(t.g,e.g,i),yo(t.b,e.b,i))}(i,t,e.fraction)}return i}getAnimationTransform(t){let e;if(!this.transform||!(e=this.transform.findInterval(t,x)))return mt.identity;let i=this.transform.getValue(e.lowerIndex);if(e.fraction>0){const t=this.transform.getEntry(e.lowerIndex)?.components,n=this.transform.getEntry(e.upperIndex)?.components;if(t&&n){const s=Ot.interpolateQuaternions(t.orientation,e.fraction,n.orientation),r=xt.createFromQuaternion(s),o=mt.createTranslation(t.pivot),a=mt.createTranslation(t.position.interpolate(e.fraction,n.position)).multiplyTransformMatrix3d(r);a.multiplyTransformTransform(o,a),i=a}else{const t=this.transform.getValue(e.upperIndex),n=i.matrix.inverse()?.toQuaternion(),s=t.matrix.inverse()?.toQuaternion();if(n&&s){const r=Ot.interpolateQuaternions(n,e.fraction,s),o=xt.createFromQuaternion(r),a=tt.createFrom(i.origin),c=tt.createFrom(t.origin);i=mt.createRefs(a.interpolate(e.fraction,c),o)}}}return i}getCuttingPlane(t){let e;if(!this.cuttingPlane||!(e=this.cuttingPlane.findInterval(t,x)))return;const i=this.cuttingPlane.getValue(e.lowerIndex);if(!i)return;const n=$.createFrom(i.position),s=tt.createFrom(i.direction),r=e.fraction>0?this.cuttingPlane.getValue(e.upperIndex):void 0;if(r)n.interpolate(e.fraction,r.position,n),s.interpolate(e.fraction,r.direction,s);else if(i.hidden||i.visible)return;return s.negate(s),s.normalizeInPlace(),yt.create(n,s)}getClipVector(t){const e=this.getCuttingPlane(t);if(!e)return;const i=Vr.createPlane(e),n=_n.createConvexSets([As.createPlanes([i])]),s=Sn.createCapture(n);return wn.createCapture([s])}getFeatureAppearance(t,e){const i=t<100?1-t/100:void 0,n=this.getColor(e);return void 0!==n||void 0!==i?xo.fromJSON({rgb:n,transparency:i}):void 0}}s.Timeline=P;class I extends P{batchId;_elementIds;constructor(t){super(t),this.batchId=t.batchId,this._elementIds=t.elementIds}static fromJSON(t){return new I(t??{elementIds:[],batchId:0})}toJSON(){return{...super.toJSON(),batchId:this.batchId,elementIds:this._elementIds}}get containsElementIds(){return this._elementIds.length>0}compareElementIds(n){if(typeof this._elementIds==typeof n._elementIds){const e=t(this._elementIds.length,n._elementIds.length);if(0!==e)return e;if("string"==typeof this._elementIds)return n._elementIds,i(this._elementIds,n._elementIds)}const s=this.elementIds[Symbol.iterator](),r=n.elementIds[Symbol.iterator]();for(;;){const t=s.next(),n=r.next();if(t.done!==n.done)return e(!!t.done,!!n.done);if(t.done)return 0;const o=i(t.value,n.value);if(0!==o)return o}}compareTo(e){return t(this.batchId,e.batchId)||this.compareElementIds(e)||super.compareTo(e)}static getElementIds(t){return"string"==typeof t?u.iterable(t):Array.isArray(t)?t:[]}get elementIds(){return I.getElementIds(this._elementIds)}get containsFeatureOverrides(){return void 0!==this.visibility||void 0!==this.color}get requiresBatching(){return!!this.cuttingPlane||0!==this.batchId&&(void 0!==this.color||void 0!==this.visibility)}get containsTransform(){return void 0!==this.transform}addSymbologyOverrides(t,e){this.batchId;const i=this.getVisibility(e);if(i<=0)return void t.setAnimationNodeNeverDrawn(this.batchId);const n=this.getFeatureAppearance(i,e);n&&t.overrideAnimationNode(this.batchId,n)}}s.ElementTimeline=I;class S extends P{modelId;realityModelUrl;elementTimelines;transformBatchIds;containsFeatureOverrides;containsModelClipping;requiresBatching;containsTransform;omitsElementIds;_maxBatchId;_cachedComparisons=new WeakMap;_idPairToElementTimeline;_discreteBatchIds;constructor(t){super(t),this.modelId=t.modelId,this.realityModelUrl=t.realityModelUrl,this.containsModelClipping=void 0!==this.cuttingPlane;let e=void 0!==this.visibility||void 0!==this.color,i=!1,n=!1;const s=[],r=[];let o=!1;for(const a of t.elementTimelines){const t=I.fromJSON(a);r.push(t),this.duration.extendRange(t.duration),t.containsTransform&&(n=!0,t.batchId&&s.push(t.batchId)),e||=t.containsFeatureOverrides,i||=t.requiresBatching,o=o||t.containsElementIds}this.elementTimelines=r,this.transformBatchIds=s,this.omitsElementIds=r.length>0&&!o,this.containsFeatureOverrides=e,this.requiresBatching=i,this.containsTransform=n}static fromJSON(t){return new S(t??{elementTimelines:[],modelId:c.invalid})}toJSON(){return{...super.toJSON(),modelId:this.modelId,realityModelUrl:this.realityModelUrl,elementTimelines:this.elementTimelines.map((t=>t.toJSON()))}}compareTo(s){if(this===s)return 0;const r=this._cachedComparisons.get(s);if(void 0!==r)return r;let o=i(this.modelId,s.modelId)||n(i,this.realityModelUrl,s.realityModelUrl)||t(this.elementTimelines.length,s.elementTimelines.length)||e(this.containsFeatureOverrides,s.containsFeatureOverrides)||e(this.containsModelClipping,s.containsModelClipping)||e(this.containsTransform,s.containsTransform)||super.compareTo(s);if(0===o)for(let t=0;t<this.elementTimelines.length&&0===(o=this.elementTimelines[t].compareTo(s.elementTimelines[t]));t++);return this._cachedComparisons.set(s,o),s._cachedComparisons.set(this,-o),o}findByBatchId(t){return this.elementTimelines.find((e=>e.batchId===t))}addSymbologyOverrides(t,e){const i=this.getFeatureAppearance(this.getVisibility(e),e);i&&t.override({modelId:this.modelId,appearance:i});for(const i of this.elementTimelines)i.addSymbologyOverrides(t,e)}getTransform(t,e){return this.findByBatchId(t)?.getAnimationTransform(e)}get maxBatchId(){if(void 0===this._maxBatchId){this._maxBatchId=0;for(const t of this.elementTimelines)this._maxBatchId=Math.max(this._maxBatchId,t.batchId)}return this._maxBatchId}getTimelineForElement(t,e){if(!this._idPairToElementTimeline){this._idPairToElementTimeline=new c.Uint32Map;for(const t of this.elementTimelines)for(const e of t.elementIds)this._idPairToElementTimeline.setById(e,t)}return this._idPairToElementTimeline.get(t,e)}get discreteBatchIds(){if(!this._discreteBatchIds){this._discreteBatchIds=new Set(this.transformBatchIds);for(const t of this.elementTimelines)t.containsTransform||void 0===t.cuttingPlane||this._discreteBatchIds.add(t.batchId)}return this._discreteBatchIds}getBatchIdForFeature(t){c.fromUint32PairObject(t.modelId),this.modelId;const e=this.getTimelineForElement(t.elementId.lower,t.elementId.upper);return e?.batchId??0}}s.ModelTimeline=S;class b{modelTimelines;containsModelClipping;requiresBatching;containsTransform;containsFeatureOverrides;duration;transformBatchIds;_cachedComparisons=new WeakMap;_discreteBatchIds;_lastFeatureModelTimeline;_maxBatchId;compareTo(i){if(this===i)return 0;const n=this._cachedComparisons.get(i);if(void 0!==n)return n;let s=t(this.modelTimelines.length,i.modelTimelines.length)||e(this.containsModelClipping,i.containsModelClipping)||e(this.requiresBatching,i.requiresBatching)||e(this.containsTransform,i.containsTransform)||e(this.containsFeatureOverrides,i.containsFeatureOverrides)||So(this.duration,i.duration);if(0===s)for(let t=0;t<this.modelTimelines.length&&0===(s=this.modelTimelines[t].compareTo(i.modelTimelines[t]));t++);return this._cachedComparisons.set(i,s),i._cachedComparisons.set(this,-s),s}equals(t){return 0===this.compareTo(t)}constructor(t){this.duration=gt.createNull();const e=new Set,i=[];let n=!1,s=!1,r=!1,o=!1;for(const a of t){const t=S.fromJSON(a);i.push(t),this.duration.extendRange(t.duration),n||=t.containsModelClipping,s||=t.requiresBatching,r||=t.containsTransform,o||=t.containsFeatureOverrides;for(const i of t.transformBatchIds)e.add(i)}this.modelTimelines=i,this.containsModelClipping=n,this.containsTransform=r,this.requiresBatching=s||this.containsTransform,this.containsFeatureOverrides=o,this.transformBatchIds=e}static fromJSON(t){if(Array.isArray(t)&&0!==t.length)return new b(t)}toJSON(){return this.modelTimelines.map((t=>t.toJSON()))}find(t){return this.modelTimelines.find((e=>e.modelId===t))}getTransformBatchIds(t){return this.find(t)?.transformBatchIds}getTransform(t,e,i){return this.find(t)?.getTransform(e,i)}addSymbologyOverrides(t,e){for(const i of this.modelTimelines)i.addSymbologyOverrides(t,e)}discloseIds(t){for(const e of this.modelTimelines){t.addModel(e.modelId);for(const i of e.elementTimelines)for(const e of i.elementIds)t.addElement(e)}}modelRequiresBatching(t){return this.requiresBatching&&this.modelTimelines.some((e=>e.modelId===t&&e.requiresBatching))}get discreteBatchIds(){if(this._discreteBatchIds)return this._discreteBatchIds;this._discreteBatchIds=new Set;for(const t of this.modelTimelines)for(const e of t.discreteBatchIds)this._discreteBatchIds.add(e);return this._discreteBatchIds}getBatchIdForFeature(t){let e;const i=this._lastFeatureModelTimeline;if(i&&i.idLower===t.modelId.lower&&i.idUpper===t.modelId.upper)e=i.timeline;else{const i=c.fromUint32PairObject(t.modelId);e=this.find(i),this._lastFeatureModelTimeline={timeline:e,idLower:t.modelId.lower,idUpper:t.modelId.upper}}return e?.getBatchIdForFeature(t)??0}get maxBatchId(){return this._maxBatchId??(this._maxBatchId=this.modelTimelines.reduce(((t,e)=>Math.max(t,e.maxBatchId)),0))}static removeScheduleScriptElementIds(t){return t.forEach((t=>{t.elementTimelines.forEach((t=>{t.elementIds&&(t.elementIds="")}))})),t}}s.Script=b,s.ScriptReference=class{sourceId;script;constructor(t,e){"string"==typeof t?(this.sourceId=t,this.script=e):(this.script=t,this.sourceId=c.invalid)}};class A{visibility;color;transform;cuttingPlane;addVisibility(t,e,i=r.Linear){this.visibility||(this.visibility=[]),this.visibility.push({time:t,value:e,interpolation:i})}addColor(t,e,i=r.Linear){this.color||(this.color=[]);const n=e instanceof jr?{red:e.r,green:e.g,blue:e.b}:e;this.color.push({time:t,value:n,interpolation:i})}addCuttingPlane(t,e,i=r.Linear){let n;this.cuttingPlane||(this.cuttingPlane=[]),e&&(n={position:[e.position.x,e.position.y,e.position.z],direction:[e.direction.x,e.direction.y,e.direction.z]},e.visible&&(n.visible=!0),e.hidden&&(n.hidden=!0)),this.cuttingPlane.push({time:t,value:n,interpolation:i})}addTransform(t,e,i,n=r.Linear){this.transform||(this.transform=[]);const s={transform:e?.toRows()};i&&(s.pivot=[i.pivot.x,i.pivot.y,i.pivot.z],s.orientation=i.orientation.toJSON(),s.position=[i.position.x,i.position.y,i.position.z]),this.transform.push({time:t,value:s,interpolation:n})}finish(){const t={};return this.visibility?.length&&(t.visibilityTimeline=this.visibility),this.color?.length&&(t.colorTimeline=this.color),this.transform?.length&&(t.transformTimeline=this.transform),this.cuttingPlane?.length&&(t.cuttingPlaneTimeline=this.cuttingPlane),t}}s.TimelineBuilder=A;class C extends A{batchId;elementIds;constructor(t,e){super(),this.batchId=t,this.elementIds=e}finish(){const t=super.finish();return t.batchId=this.batchId,t.elementIds=this.elementIds,t}}s.ElementTimelineBuilder=C;class T extends A{modelId;realityModelUrl;_obtainNextBatchId;_elements=[];constructor(t,e){super(),this.modelId=t,this._obtainNextBatchId=e}addElementTimeline(t){const e=this._obtainNextBatchId();let i;if("string"==typeof t&&c.isValidId64(t)&&(t=[t]),"string"==typeof t)i=t;else{const e=Array.from(t);h.sortArray(e),i=u.compressIds(e)}const n=new C(e,i);return this._elements.push(n),n}finish(){const t=super.finish();return t.modelId=this.modelId,void 0!==this.realityModelUrl&&(t.realityModelUrl=this.realityModelUrl),t.elementTimelines=this._elements.map((t=>t.finish())),t}}s.ModelTimelineBuilder=T,s.ScriptBuilder=class{_nextBatchId=1;_models=[];addModelTimeline(t){const e=new T(t,(()=>this._nextBatchId++));return this._models.push(e),e}finish(){return this._models.map((t=>t.finish()))}}}(bo||(bo={})),function(t){function e(t){return null!==t&&"object"==typeof t}function i(t){return e(t)&&0===Object.keys(t).length}function n(t){return void 0===t||i(t)}function s(t){return null==t}t.asBool=function(t,e=!1){return s(t)?e:!!t},t.asInt=function(t,e=0){return"number"==typeof t?Math.trunc(t):e},t.asDouble=function(t,e=0){return"number"==typeof t?t:e},t.asString=function(t,e=""){return s(t)?e:t.toString()},t.asArray=function(t){return Array.isArray(t)?t:void 0},t.asObject=function(t){return"object"==typeof t?t:void 0},t.setOrRemoveNumber=function(t,e,i,n){i===n?delete t[e]:t[e]=i},t.setOrRemoveBoolean=function(t,e,i,n){i===n?delete t[e]:t[e]=i},t.isObject=e,t.isEmptyObject=i,t.isEmptyObjectOrUndefined=n,t.isNonEmptyObject=function(t){return!n(t)},t.toObject=function t(e){if("boolean"==typeof e||"number"==typeof e||"string"==typeof e)return e;if("object"!=typeof e)return;if(void 0!==e.toJSON)return t(e.toJSON());if(Array.isArray(e)){const i=new Array(e.length);return e.forEach(((e,n)=>i[n]=t(e))),i}const i={};return Object.getOwnPropertyNames(e).forEach((n=>{const s=t(e[n]);void 0!==s&&(i[n]=s)})),i}}(Ao||(Ao={}));class ua{_view;_byteOffset;_curPos=0;constructor(t,e){void 0!==e?(this._view=new DataView(t,e.byteOffset,e.byteLength),this._byteOffset=e.byteOffset):(this._view=new DataView(t),this._byteOffset=0)}static fromUint8Array(t){const{byteOffset:e,byteLength:i}=t;return new ua(t.buffer,{byteOffset:e,byteLength:i})}static fromArrayBuffer(t,e){return new ua(t,e)}get length(){return this._view.byteLength}get remainingLength(){return this.length-this.curPos}get isPastTheEnd(){return this.curPos>this.length}get isAtTheEnd(){return this.curPos===this.length}get curPos(){return this._curPos}set curPos(t){this._curPos=t,this.isPastTheEnd}advance(t){return this.curPos=this.curPos+t,!this.isPastTheEnd}rewind(t){return!(this.curPos-t<0||(this.curPos=this.curPos-t,0))}reset(){this.curPos=0}readUint8(){return this.read(1,(t=>t.getUint8(this.curPos)))}readUint16(){return this.read(2,(t=>t.getUint16(this.curPos,!0)))}readUint32(){return this.read(4,(t=>t.getUint32(this.curPos,!0)))}readInt32(){return this.read(4,(t=>t.getInt32(this.curPos,!0)))}readFloat32(){return this.read(4,(t=>t.getFloat32(this.curPos,!0)))}readFloat64(){return this.read(8,(t=>t.getFloat64(this.curPos,!0)))}readId64(){return c.fromUint32Pair(this.readUint32(),this.readUint32())}readUint24(){return this.readUint8()|this.readUint8()<<8|this.readUint8()<<16}nextBytes(t){const e=new Uint8Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(t),e}readBytes(t,e){return new Uint8Array(this.arrayBuffer,t+this._byteOffset,e)}nextUint32s(t){const e=4*t,i=new Uint32Array(this.arrayBuffer,this.curPos+this._byteOffset,t);return this.advance(e),i}get arrayBuffer(){return this._view.buffer}read(t,e){const i=e(this._view);return this.advance(t),i}}!function(t){t[t.Readonly=1]="Readonly",t[t.ReadWrite=2]="ReadWrite"}(Co||(Co={})),function(t){t[t.Delete=9]="Delete",t[t.Insert=18]="Insert",t[t.Update=23]="Update"}(To||(To={})),function(t){t[t.BE_SQLITE_OK=0]="BE_SQLITE_OK",t[t.BE_SQLITE_ERROR=1]="BE_SQLITE_ERROR",t[t.BE_SQLITE_INTERNAL=2]="BE_SQLITE_INTERNAL",t[t.BE_SQLITE_PERM=3]="BE_SQLITE_PERM",t[t.BE_SQLITE_ABORT=4]="BE_SQLITE_ABORT",t[t.BE_SQLITE_BUSY=5]="BE_SQLITE_BUSY",t[t.BE_SQLITE_LOCKED=6]="BE_SQLITE_LOCKED",t[t.BE_SQLITE_NOMEM=7]="BE_SQLITE_NOMEM",t[t.BE_SQLITE_READONLY=8]="BE_SQLITE_READONLY",t[t.BE_SQLITE_INTERRUPT=9]="BE_SQLITE_INTERRUPT",t[t.BE_SQLITE_IOERR=10]="BE_SQLITE_IOERR",t[t.BE_SQLITE_CORRUPT=11]="BE_SQLITE_CORRUPT",t[t.BE_SQLITE_NOTFOUND=12]="BE_SQLITE_NOTFOUND",t[t.BE_SQLITE_FULL=13]="BE_SQLITE_FULL",t[t.BE_SQLITE_CANTOPEN=14]="BE_SQLITE_CANTOPEN",t[t.BE_SQLITE_PROTOCOL=15]="BE_SQLITE_PROTOCOL",t[t.BE_SQLITE_EMPTY=16]="BE_SQLITE_EMPTY",t[t.BE_SQLITE_SCHEMA=17]="BE_SQLITE_SCHEMA",t[t.BE_SQLITE_TOOBIG=18]="BE_SQLITE_TOOBIG",t[t.BE_SQLITE_CONSTRAINT_BASE=19]="BE_SQLITE_CONSTRAINT_BASE",t[t.BE_SQLITE_MISMATCH=20]="BE_SQLITE_MISMATCH",t[t.BE_SQLITE_MISUSE=21]="BE_SQLITE_MISUSE",t[t.BE_SQLITE_NOLFS=22]="BE_SQLITE_NOLFS",t[t.BE_SQLITE_AUTH=23]="BE_SQLITE_AUTH",t[t.BE_SQLITE_FORMAT=24]="BE_SQLITE_FORMAT",t[t.BE_SQLITE_RANGE=25]="BE_SQLITE_RANGE",t[t.BE_SQLITE_NOTADB=26]="BE_SQLITE_NOTADB",t[t.BE_SQLITE_ROW=100]="BE_SQLITE_ROW",t[t.BE_SQLITE_DONE=101]="BE_SQLITE_DONE",t[t.BE_SQLITE_IOERR_READ=266]="BE_SQLITE_IOERR_READ",t[t.BE_SQLITE_IOERR_SHORT_READ=522]="BE_SQLITE_IOERR_SHORT_READ",t[t.BE_SQLITE_IOERR_WRITE=778]="BE_SQLITE_IOERR_WRITE",t[t.BE_SQLITE_IOERR_FSYNC=1034]="BE_SQLITE_IOERR_FSYNC",t[t.BE_SQLITE_IOERR_DIR_FSYNC=1290]="BE_SQLITE_IOERR_DIR_FSYNC",t[t.BE_SQLITE_IOERR_TRUNCATE=1546]="BE_SQLITE_IOERR_TRUNCATE",t[t.BE_SQLITE_IOERR_FSTAT=1802]="BE_SQLITE_IOERR_FSTAT",t[t.BE_SQLITE_IOERR_UNLOCK=2058]="BE_SQLITE_IOERR_UNLOCK",t[t.BE_SQLITE_IOERR_RDLOCK=2314]="BE_SQLITE_IOERR_RDLOCK",t[t.BE_SQLITE_IOERR_DELETE=2570]="BE_SQLITE_IOERR_DELETE",t[t.BE_SQLITE_IOERR_BLOCKED=2826]="BE_SQLITE_IOERR_BLOCKED",t[t.BE_SQLITE_IOERR_NOMEM=3082]="BE_SQLITE_IOERR_NOMEM",t[t.BE_SQLITE_IOERR_ACCESS=3338]="BE_SQLITE_IOERR_ACCESS",t[t.BE_SQLITE_IOERR_CHECKRESERVEDLOCK=3594]="BE_SQLITE_IOERR_CHECKRESERVEDLOCK",t[t.BE_SQLITE_IOERR_LOCK=3850]="BE_SQLITE_IOERR_LOCK",t[t.BE_SQLITE_IOERR_CLOSE=4106]="BE_SQLITE_IOERR_CLOSE",t[t.BE_SQLITE_IOERR_DIR_CLOSE=4362]="BE_SQLITE_IOERR_DIR_CLOSE",t[t.BE_SQLITE_IOERR_SHMOPEN=4618]="BE_SQLITE_IOERR_SHMOPEN",t[t.BE_SQLITE_IOERR_SHMSIZE=4874]="BE_SQLITE_IOERR_SHMSIZE",t[t.BE_SQLITE_IOERR_SHMLOCK=5130]="BE_SQLITE_IOERR_SHMLOCK",t[t.BE_SQLITE_IOERR_SHMMAP=5386]="BE_SQLITE_IOERR_SHMMAP",t[t.BE_SQLITE_IOERR_SEEK=5642]="BE_SQLITE_IOERR_SEEK",t[t.BE_SQLITE_IOERR_DELETE_NOENT=5898]="BE_SQLITE_IOERR_DELETE_NOENT",t[t.BE_SQLITE_ERROR_FileExists=16777226]="BE_SQLITE_ERROR_FileExists",t[t.BE_SQLITE_ERROR_AlreadyOpen=33554442]="BE_SQLITE_ERROR_AlreadyOpen",t[t.BE_SQLITE_ERROR_NoPropertyTable=50331658]="BE_SQLITE_ERROR_NoPropertyTable",t[t.BE_SQLITE_ERROR_FileNotFound=67108874]="BE_SQLITE_ERROR_FileNotFound",t[t.BE_SQLITE_ERROR_NoTxnActive=83886090]="BE_SQLITE_ERROR_NoTxnActive",t[t.BE_SQLITE_ERROR_BadDbProfile=100663306]="BE_SQLITE_ERROR_BadDbProfile",t[t.BE_SQLITE_ERROR_InvalidProfileVersion=117440522]="BE_SQLITE_ERROR_InvalidProfileVersion",t[t.BE_SQLITE_ERROR_ProfileUpgradeFailed=134217738]="BE_SQLITE_ERROR_ProfileUpgradeFailed",t[t.BE_SQLITE_ERROR_ProfileTooOldForReadWrite=150994954]="BE_SQLITE_ERROR_ProfileTooOldForReadWrite",t[t.BE_SQLITE_ERROR_ProfileTooOld=167772170]="BE_SQLITE_ERROR_ProfileTooOld",t[t.BE_SQLITE_ERROR_ProfileTooNewForReadWrite=184549386]="BE_SQLITE_ERROR_ProfileTooNewForReadWrite",t[t.BE_SQLITE_ERROR_ProfileTooNew=201326602]="BE_SQLITE_ERROR_ProfileTooNew",t[t.BE_SQLITE_ERROR_ChangeTrackError=218103818]="BE_SQLITE_ERROR_ChangeTrackError",t[t.BE_SQLITE_ERROR_InvalidChangeSetVersion=234881034]="BE_SQLITE_ERROR_InvalidChangeSetVersion",t[t.BE_SQLITE_ERROR_SchemaUpgradeRequired=251658250]="BE_SQLITE_ERROR_SchemaUpgradeRequired",t[t.BE_SQLITE_ERROR_SchemaTooNew=268435466]="BE_SQLITE_ERROR_SchemaTooNew",t[t.BE_SQLITE_ERROR_SchemaTooOld=285212682]="BE_SQLITE_ERROR_SchemaTooOld",t[t.BE_SQLITE_ERROR_SchemaLockFailed=301989898]="BE_SQLITE_ERROR_SchemaLockFailed",t[t.BE_SQLITE_ERROR_SchemaUpgradeFailed=318767114]="BE_SQLITE_ERROR_SchemaUpgradeFailed",t[t.BE_SQLITE_ERROR_SchemaImportFailed=335544330]="BE_SQLITE_ERROR_SchemaImportFailed",t[t.BE_SQLITE_ERROR_CouldNotAcquireLocksOrCodes=352321546]="BE_SQLITE_ERROR_CouldNotAcquireLocksOrCodes",t[t.BE_SQLITE_ERROR_SchemaUpgradeRecommended=369098762]="BE_SQLITE_ERROR_SchemaUpgradeRecommended",t[t.BE_SQLITE_ERROR_DataTransformRequired=385875978]="BE_SQLITE_ERROR_DataTransformRequired",t[t.BE_SQLITE_LOCKED_SHAREDCACHE=262]="BE_SQLITE_LOCKED_SHAREDCACHE",t[t.BE_SQLITE_BUSY_RECOVERY=261]="BE_SQLITE_BUSY_RECOVERY",t[t.BE_SQLITE_CANTOPEN_NOTEMPDIR=270]="BE_SQLITE_CANTOPEN_NOTEMPDIR",t[t.BE_SQLITE_CANTOPEN_ISDIR=526]="BE_SQLITE_CANTOPEN_ISDIR",t[t.BE_SQLITE_CANTOPEN_FULLPATH=782]="BE_SQLITE_CANTOPEN_FULLPATH",t[t.BE_SQLITE_CORRUPT_VTAB=267]="BE_SQLITE_CORRUPT_VTAB",t[t.BE_SQLITE_READONLY_RECOVERY=264]="BE_SQLITE_READONLY_RECOVERY",t[t.BE_SQLITE_READONLY_CANTLOCK=520]="BE_SQLITE_READONLY_CANTLOCK",t[t.BE_SQLITE_READONLY_ROLLBACK=776]="BE_SQLITE_READONLY_ROLLBACK",t[t.BE_SQLITE_ABORT_ROLLBACK=516]="BE_SQLITE_ABORT_ROLLBACK",t[t.BE_SQLITE_CONSTRAINT_CHECK=275]="BE_SQLITE_CONSTRAINT_CHECK",t[t.BE_SQLITE_CONSTRAINT_COMMITHOOK=531]="BE_SQLITE_CONSTRAINT_COMMITHOOK",t[t.BE_SQLITE_CONSTRAINT_FOREIGNKEY=787]="BE_SQLITE_CONSTRAINT_FOREIGNKEY",t[t.BE_SQLITE_CONSTRAINT_FUNCTION=1043]="BE_SQLITE_CONSTRAINT_FUNCTION",t[t.BE_SQLITE_CONSTRAINT_NOTNULL=1299]="BE_SQLITE_CONSTRAINT_NOTNULL",t[t.BE_SQLITE_CONSTRAINT_PRIMARYKEY=1555]="BE_SQLITE_CONSTRAINT_PRIMARYKEY",t[t.BE_SQLITE_CONSTRAINT_TRIGGER=1811]="BE_SQLITE_CONSTRAINT_TRIGGER",t[t.BE_SQLITE_CONSTRAINT_UNIQUE=2067]="BE_SQLITE_CONSTRAINT_UNIQUE",t[t.BE_SQLITE_CONSTRAINT_VTAB=2323]="BE_SQLITE_CONSTRAINT_VTAB"}(wo||(wo={})),function(t){t[t.Success=0]="Success",t[t.ServerUnavailable=86017]="ServerUnavailable",t[t.LockAlreadyHeld=86018]="LockAlreadyHeld",t[t.SyncError=86019]="SyncError",t[t.InvalidResponse=86020]="InvalidResponse",t[t.PendingTransactions=86021]="PendingTransactions",t[t.LockUsed=86022]="LockUsed",t[t.CannotCreateChangeSet=86023]="CannotCreateChangeSet",t[t.InvalidRequest=86024]="InvalidRequest",t[t.ChangeSetRequired=86025]="ChangeSetRequired",t[t.CodeUnavailable=86026]="CodeUnavailable",t[t.CodeNotReserved=86027]="CodeNotReserved",t[t.CodeUsed=86028]="CodeUsed",t[t.LockNotHeld=86029]="LockNotHeld",t[t.RepositoryIsLocked=86030]="RepositoryIsLocked",t[t.ChannelConstraintViolation=86031]="ChannelConstraintViolation"}(Eo||(Eo={})),function(t){function e(t){const e=new Error(t.message);return Object.assign(e,t),e.name=t.iTwinErrorId.key,e}t.create=e,t.throwError=function(t){throw e(t)},t.isError=function(t,e,i){return Ao.isObject(t)&&"iTwinErrorId"in t&&Ao.isObject(t.iTwinErrorId)&&t.iTwinErrorId.scope===e&&(void 0===i||t.iTwinErrorId.key===i)}}(ko||(ko={})),function(t){t[t.SUCCESS=0]="SUCCESS",t[t.ERROR=32768]="ERROR"}(Fo||(Fo={})),function(t){t[t.IMODEL_ERROR_BASE=65536]="IMODEL_ERROR_BASE",t[t.Success=0]="Success",t[t.AlreadyLoaded=65537]="AlreadyLoaded",t[t.AlreadyOpen=65538]="AlreadyOpen",t[t.BadArg=65539]="BadArg",t[t.BadElement=65540]="BadElement",t[t.BadModel=65541]="BadModel",t[t.BadRequest=65542]="BadRequest",t[t.BadSchema=65543]="BadSchema",t[t.CannotUndo=65544]="CannotUndo",t[t.CodeNotReserved=65545]="CodeNotReserved",t[t.DeletionProhibited=65546]="DeletionProhibited",t[t.DuplicateCode=65547]="DuplicateCode",t[t.DuplicateName=65548]="DuplicateName",t[t.ElementBlockedChange=65549]="ElementBlockedChange",t[t.FileAlreadyExists=65550]="FileAlreadyExists",t[t.FileNotFound=65551]="FileNotFound",t[t.FileNotLoaded=65552]="FileNotLoaded",t[t.ForeignKeyConstraint=65553]="ForeignKeyConstraint",t[t.IdExists=65554]="IdExists",t[t.InDynamicTransaction=65555]="InDynamicTransaction",t[t.InvalidCategory=65556]="InvalidCategory",t[t.InvalidCode=65557]="InvalidCode",t[t.InvalidCodeSpec=65558]="InvalidCodeSpec",t[t.InvalidId=65559]="InvalidId",t[t.InvalidName=65560]="InvalidName",t[t.InvalidParent=65561]="InvalidParent",t[t.InvalidProfileVersion=65562]="InvalidProfileVersion",t[t.IsCreatingChangeSet=65563]="IsCreatingChangeSet",t[t.LockNotHeld=65564]="LockNotHeld",t[t.Mismatch2d3d=65565]="Mismatch2d3d",t[t.MismatchGcs=65566]="MismatchGcs",t[t.MissingDomain=65567]="MissingDomain",t[t.MissingHandler=65568]="MissingHandler",t[t.MissingId=65569]="MissingId",t[t.NoGeometry=65570]="NoGeometry",t[t.NoMultiTxnOperation=65571]="NoMultiTxnOperation",t[t.NotEnabled=65573]="NotEnabled",t[t.NotFound=65574]="NotFound",t[t.NotOpen=65575]="NotOpen",t[t.NotOpenForWrite=65576]="NotOpenForWrite",t[t.NotSameUnitBase=65577]="NotSameUnitBase",t[t.NothingToRedo=65578]="NothingToRedo",t[t.NothingToUndo=65579]="NothingToUndo",t[t.ParentBlockedChange=65580]="ParentBlockedChange",t[t.ReadError=65581]="ReadError",t[t.ReadOnly=65582]="ReadOnly",t[t.ReadOnlyDomain=65583]="ReadOnlyDomain",t[t.RepositoryManagerError=65584]="RepositoryManagerError",t[t.SQLiteError=65585]="SQLiteError",t[t.TransactionActive=65586]="TransactionActive",t[t.UnitsMissing=65587]="UnitsMissing",t[t.UnknownFormat=65588]="UnknownFormat",t[t.UpgradeFailed=65589]="UpgradeFailed",t[t.ValidationFailed=65590]="ValidationFailed",t[t.VersionTooNew=65591]="VersionTooNew",t[t.VersionTooOld=65592]="VersionTooOld",t[t.ViewNotFound=65593]="ViewNotFound",t[t.WriteError=65594]="WriteError",t[t.WrongClass=65595]="WrongClass",t[t.WrongIModel=65596]="WrongIModel",t[t.WrongDomain=65597]="WrongDomain",t[t.WrongElement=65598]="WrongElement",t[t.WrongHandler=65599]="WrongHandler",t[t.WrongModel=65600]="WrongModel",t[t.ConstraintNotUnique=65601]="ConstraintNotUnique",t[t.NoGeoLocation=65602]="NoGeoLocation",t[t.ServerTimeout=65603]="ServerTimeout",t[t.NoContent=65604]="NoContent",t[t.NotRegistered=65605]="NotRegistered",t[t.FunctionNotFound=65606]="FunctionNotFound",t[t.NoActiveCommand=65607]="NoActiveCommand",t[t.Aborted=65608]="Aborted"}(Ro||(Ro={})),function(t){t[t.BRIEFCASE_STATUS_BASE=131072]="BRIEFCASE_STATUS_BASE",t[t.CannotAcquire=131072]="CannotAcquire",t[t.CannotDownload=131073]="CannotDownload",t[t.CannotUpload=131074]="CannotUpload",t[t.CannotCopy=131075]="CannotCopy",t[t.CannotDelete=131076]="CannotDelete",t[t.VersionNotFound=131077]="VersionNotFound",t[t.CannotApplyChanges=131078]="CannotApplyChanges",t[t.DownloadCancelled=131079]="DownloadCancelled",t[t.ContainsDeletedChangeSets=131080]="ContainsDeletedChangeSets"}(Mo||(Mo={})),function(t){t[t.Success=0]="Success",t[t.RPC_INTERFACE_ERROR_BASE=135168]="RPC_INTERFACE_ERROR_BASE",t[t.IncompatibleVersion=135168]="IncompatibleVersion"}(Do||(Do={})),function(t){t[t.Success=0]="Success",t[t.CHANGESET_ERROR_BASE=90112]="CHANGESET_ERROR_BASE",t[t.ApplyError=90113]="ApplyError",t[t.ChangeTrackingNotEnabled=90114]="ChangeTrackingNotEnabled",t[t.CorruptedChangeStream=90115]="CorruptedChangeStream",t[t.FileNotFound=90116]="FileNotFound",t[t.FileWriteError=90117]="FileWriteError",t[t.HasLocalChanges=90118]="HasLocalChanges",t[t.HasUncommittedChanges=90119]="HasUncommittedChanges",t[t.InvalidId=90120]="InvalidId",t[t.InvalidVersion=90121]="InvalidVersion",t[t.InDynamicTransaction=90122]="InDynamicTransaction",t[t.IsCreatingChangeSet=90123]="IsCreatingChangeSet",t[t.IsNotCreatingChangeSet=90124]="IsNotCreatingChangeSet",t[t.MergePropagationError=90125]="MergePropagationError",t[t.NothingToMerge=90126]="NothingToMerge",t[t.NoTransactions=90127]="NoTransactions",t[t.ParentMismatch=90128]="ParentMismatch",t[t.SQLiteError=90129]="SQLiteError",t[t.WrongDgnDb=90130]="WrongDgnDb",t[t.CouldNotOpenDgnDb=90131]="CouldNotOpenDgnDb",t[t.MergeSchemaChangesOnOpen=90132]="MergeSchemaChangesOnOpen",t[t.ReverseOrReinstateSchemaChanges=90133]="ReverseOrReinstateSchemaChanges",t[t.ProcessSchemaChangesOnOpen=90134]="ProcessSchemaChangesOnOpen",t[t.CannotMergeIntoReadonly=90135]="CannotMergeIntoReadonly",t[t.CannotMergeIntoMaster=90136]="CannotMergeIntoMaster",t[t.CannotMergeIntoReversed=90137]="CannotMergeIntoReversed",t[t.DownloadCancelled=90138]="DownloadCancelled"}(Oo||(Oo={})),function(t){t[t.Success=0]="Success",t[t.Info=94209]="Info",t[t.Redirection=94210]="Redirection",t[t.ClientError=94211]="ClientError",t[t.ServerError=94212]="ServerError"}(Bo||(Bo={})),function(t){t[t.Success=0]="Success",t[t.IMODELHUBERROR_BASE=102400]="IMODELHUBERROR_BASE",t[t.IMODELHUBERROR_REQUESTERRORBASE=102656]="IMODELHUBERROR_REQUESTERRORBASE",t[t.Unknown=102401]="Unknown",t[t.MissingRequiredProperties=102402]="MissingRequiredProperties",t[t.InvalidPropertiesValues=102403]="InvalidPropertiesValues",t[t.UserDoesNotHavePermission=102404]="UserDoesNotHavePermission",t[t.UserDoesNotHaveAccess=102405]="UserDoesNotHaveAccess",t[t.InvalidBriefcase=102406]="InvalidBriefcase",t[t.BriefcaseDoesNotExist=102407]="BriefcaseDoesNotExist",t[t.BriefcaseDoesNotBelongToUser=102408]="BriefcaseDoesNotBelongToUser",t[t.AnotherUserPushing=102409]="AnotherUserPushing",t[t.ChangeSetAlreadyExists=102410]="ChangeSetAlreadyExists",t[t.ChangeSetDoesNotExist=102411]="ChangeSetDoesNotExist",t[t.FileIsNotUploaded=102412]="FileIsNotUploaded",t[t.iModelIsNotInitialized=102413]="iModelIsNotInitialized",t[t.ChangeSetPointsToBadSeed=102414]="ChangeSetPointsToBadSeed",t[t.OperationFailed=102415]="OperationFailed",t[t.PullIsRequired=102416]="PullIsRequired",t[t.MaximumNumberOfBriefcasesPerUser=102417]="MaximumNumberOfBriefcasesPerUser",t[t.MaximumNumberOfBriefcasesPerUserPerMinute=102418]="MaximumNumberOfBriefcasesPerUserPerMinute",t[t.DatabaseTemporarilyLocked=102419]="DatabaseTemporarilyLocked",t[t.iModelIsLocked=102420]="iModelIsLocked",t[t.CodesExist=102421]="CodesExist",t[t.LocksExist=102422]="LocksExist",t[t.iModelAlreadyExists=102423]="iModelAlreadyExists",t[t.iModelDoesNotExist=102424]="iModelDoesNotExist",t[t.FileDoesNotExist=102425]="FileDoesNotExist",t[t.FileAlreadyExists=102426]="FileAlreadyExists",t[t.LockDoesNotExist=102427]="LockDoesNotExist",t[t.LockOwnedByAnotherBriefcase=102428]="LockOwnedByAnotherBriefcase",t[t.CodeStateInvalid=102429]="CodeStateInvalid",t[t.CodeReservedByAnotherBriefcase=102430]="CodeReservedByAnotherBriefcase",t[t.CodeDoesNotExist=102431]="CodeDoesNotExist",t[t.EventTypeDoesNotExist=102432]="EventTypeDoesNotExist",t[t.EventSubscriptionDoesNotExist=102433]="EventSubscriptionDoesNotExist",t[t.EventSubscriptionAlreadyExists=102434]="EventSubscriptionAlreadyExists",t[t.ITwinIdIsNotSpecified=102435]="ITwinIdIsNotSpecified",t[t.FailedToGetITwinPermissions=102436]="FailedToGetITwinPermissions",t[t.FailedToGetITwinMembers=102437]="FailedToGetITwinMembers",t[t.ChangeSetAlreadyHasVersion=102438]="ChangeSetAlreadyHasVersion",t[t.VersionAlreadyExists=102439]="VersionAlreadyExists",t[t.JobSchedulingFailed=102440]="JobSchedulingFailed",t[t.ConflictsAggregate=102441]="ConflictsAggregate",t[t.FailedToGetITwinById=102442]="FailedToGetITwinById",t[t.DatabaseOperationFailed=102443]="DatabaseOperationFailed",t[t.SeedFileInitializationFailed=102444]="SeedFileInitializationFailed",t[t.FailedToGetAssetPermissions=102445]="FailedToGetAssetPermissions",t[t.FailedToGetAssetMembers=102446]="FailedToGetAssetMembers",t[t.ITwinDoesNotExist=102447]="ITwinDoesNotExist",t[t.LockChunkDoesNotExist=102449]="LockChunkDoesNotExist",t[t.CheckpointAlreadyExists=102450]="CheckpointAlreadyExists",t[t.CheckpointDoesNotExist=102451]="CheckpointDoesNotExist",t[t.UndefinedArgumentError=102657]="UndefinedArgumentError",t[t.InvalidArgumentError=102658]="InvalidArgumentError",t[t.MissingDownloadUrlError=102659]="MissingDownloadUrlError",t[t.NotSupportedInBrowser=102660]="NotSupportedInBrowser",t[t.FileHandlerNotSet=102661]="FileHandlerNotSet",t[t.FileNotFound=102662]="FileNotFound",t[t.InitializationTimeout=102663]="InitializationTimeout"}(No||(No={})),function(t){t[t.Success=0]="Success",t[t.GEOSERVICESTATUS_BASE=147456]="GEOSERVICESTATUS_BASE",t[t.NoGeoLocation=65602]="NoGeoLocation",t[t.OutOfUsefulRange=147457]="OutOfUsefulRange",t[t.OutOfMathematicalDomain=147458]="OutOfMathematicalDomain",t[t.NoDatumConverter=147459]="NoDatumConverter",t[t.VerticalDatumConvertError=147460]="VerticalDatumConvertError",t[t.CSMapError=147461]="CSMapError",t[t.Pending=147462]="Pending"}(Xo||(Xo={})),function(t){t[t.Success=0]="Success",t[t.REALITYDATA_ERROR_BASE=151552]="REALITYDATA_ERROR_BASE",t[t.InvalidData=151553]="InvalidData"}(zo||(zo={}));class fa extends Error{errorNumber;static iTwinErrorScope="bentley-error";_metaData;constructor(t,e,i){super(e),this.errorNumber=t,this.errorNumber=t,this._metaData=i,this.name=this._initName()}get iTwinErrorId(){return{scope:fa.iTwinErrorScope,key:this.name}}get loggingMetadata(){return this.getMetaData()}static isError(t,e){return ko.isError(t,fa.iTwinErrorScope)&&"number"==typeof t.errorNumber&&(void 0===e||t.errorNumber===e)}get hasMetaData(){return void 0!==this._metaData}getMetaData(){return fa.getMetaData(this._metaData)}static getMetaData(t){return"function"==typeof t?t():t}_initName(){return fa.getErrorKey(this.errorNumber)}static getErrorKey(t){switch(t){case Ro.AlreadyLoaded:return"Already Loaded";case Ro.AlreadyOpen:return"Already Open";case Ro.BadArg:return"Bad Arg";case Ro.BadElement:return"Bad Element";case Ro.BadModel:return"Bad Model";case Ro.BadRequest:return"Bad Request";case Ro.BadSchema:return"Bad Schema";case Ro.CannotUndo:return"Can not Undo";case Ro.CodeNotReserved:return"Code Not Reserved";case Ro.DeletionProhibited:return"Deletion Prohibited";case Ro.DuplicateCode:return"Duplicate Code";case Ro.DuplicateName:return"Duplicate Name";case Ro.ElementBlockedChange:return"Element Blocked Change";case Ro.FileAlreadyExists:return"File Already Exists";case Ro.FileNotFound:return"File Not Found";case Ro.FileNotLoaded:return"File Not Loaded";case Ro.ForeignKeyConstraint:return"ForeignKey Constraint";case Ro.IdExists:return"Id Exists";case Ro.InDynamicTransaction:return"InDynamicTransaction";case Ro.InvalidCategory:return"Invalid Category";case Ro.InvalidCode:return"Invalid Code";case Ro.InvalidCodeSpec:return"Invalid CodeSpec";case Ro.InvalidId:return"Invalid Id";case Ro.InvalidName:return"Invalid Name";case Ro.InvalidParent:return"Invalid Parent";case Ro.InvalidProfileVersion:return"Invalid Profile Version";case Ro.IsCreatingChangeSet:return"IsCreatingChangeSet";case Ro.LockNotHeld:return"Lock Not Held";case Ro.Mismatch2d3d:return"Mismatch 2d3d";case Ro.MismatchGcs:return"Mismatch Gcs";case Ro.MissingDomain:return"Missing Domain";case Ro.MissingHandler:return"Missing Handler";case Ro.MissingId:return"Missing Id";case Ro.NoGeometry:return"No Geometry";case Ro.NoMultiTxnOperation:return"NoMultiTxnOperation";case Ro.NotEnabled:return"Not Enabled";case Ro.NotFound:return"Not Found";case Ro.NotOpen:return"Not Open";case Ro.NotOpenForWrite:return"Not Open For Write";case Ro.NotSameUnitBase:return"Not Same Unit Base";case Ro.NothingToRedo:return"Nothing To Redo";case Ro.NothingToUndo:return"Nothing To Undo";case Ro.ParentBlockedChange:return"Parent Blocked Change";case Ro.ReadError:return"Read Error";case Ro.ReadOnly:return"ReadOnly";case Ro.ReadOnlyDomain:return"ReadOnlyDomain";case Ro.RepositoryManagerError:return"RepositoryManagerError";case Ro.SQLiteError:return"SQLiteError";case Ro.TransactionActive:return"Transaction Active";case Ro.UnitsMissing:return"Units Missing";case Ro.UnknownFormat:return"Unknown Format";case Ro.UpgradeFailed:return"Upgrade Failed";case Ro.ValidationFailed:return"Validation Failed";case Ro.VersionTooNew:return"Version Too New";case Ro.VersionTooOld:return"Version Too Old";case Ro.ViewNotFound:return"View Not Found";case Ro.WriteError:return"Write Error";case Ro.WrongClass:return"Wrong Class";case Ro.WrongIModel:return"Wrong IModel";case Ro.WrongDomain:return"Wrong Domain";case Ro.WrongElement:return"Wrong Element";case Ro.WrongHandler:return"Wrong Handler";case Ro.WrongModel:return"Wrong Model";case wo.BE_SQLITE_ERROR:return"BE_SQLITE_ERROR";case wo.BE_SQLITE_INTERNAL:return"BE_SQLITE_INTERNAL";case wo.BE_SQLITE_PERM:return"BE_SQLITE_PERM";case wo.BE_SQLITE_ABORT:return"BE_SQLITE_ABORT";case wo.BE_SQLITE_BUSY:return"Db is busy";case wo.BE_SQLITE_LOCKED:return"Db is Locked";case wo.BE_SQLITE_NOMEM:return"BE_SQLITE_NOMEM";case wo.BE_SQLITE_READONLY:return"Readonly";case wo.BE_SQLITE_INTERRUPT:return"BE_SQLITE_INTERRUPT";case wo.BE_SQLITE_IOERR:return"BE_SQLITE_IOERR";case wo.BE_SQLITE_CORRUPT:return"BE_SQLITE_CORRUPT";case wo.BE_SQLITE_NOTFOUND:return"Not Found";case wo.BE_SQLITE_FULL:return"BE_SQLITE_FULL";case wo.BE_SQLITE_CANTOPEN:return"Can't open";case wo.BE_SQLITE_PROTOCOL:return"BE_SQLITE_PROTOCOL";case wo.BE_SQLITE_EMPTY:return"BE_SQLITE_EMPTY";case wo.BE_SQLITE_SCHEMA:return"BE_SQLITE_SCHEMA";case wo.BE_SQLITE_TOOBIG:return"BE_SQLITE_TOOBIG";case wo.BE_SQLITE_MISMATCH:return"BE_SQLITE_MISMATCH";case wo.BE_SQLITE_MISUSE:return"BE_SQLITE_MISUSE";case wo.BE_SQLITE_NOLFS:return"BE_SQLITE_NOLFS";case wo.BE_SQLITE_AUTH:return"BE_SQLITE_AUTH";case wo.BE_SQLITE_FORMAT:return"BE_SQLITE_FORMAT";case wo.BE_SQLITE_RANGE:return"BE_SQLITE_RANGE";case wo.BE_SQLITE_NOTADB:return"Not a Database";case wo.BE_SQLITE_IOERR_READ:return"BE_SQLITE_IOERR_READ";case wo.BE_SQLITE_IOERR_SHORT_READ:return"BE_SQLITE_IOERR_SHORT_READ";case wo.BE_SQLITE_IOERR_WRITE:return"BE_SQLITE_IOERR_WRITE";case wo.BE_SQLITE_IOERR_FSYNC:return"BE_SQLITE_IOERR_FSYNC";case wo.BE_SQLITE_IOERR_DIR_FSYNC:return"BE_SQLITE_IOERR_DIR_FSYNC";case wo.BE_SQLITE_IOERR_TRUNCATE:return"BE_SQLITE_IOERR_TRUNCATE";case wo.BE_SQLITE_IOERR_FSTAT:return"BE_SQLITE_IOERR_FSTAT";case wo.BE_SQLITE_IOERR_UNLOCK:return"BE_SQLITE_IOERR_UNLOCK";case wo.BE_SQLITE_IOERR_RDLOCK:return"BE_SQLITE_IOERR_RDLOCK";case wo.BE_SQLITE_IOERR_DELETE:return"BE_SQLITE_IOERR_DELETE";case wo.BE_SQLITE_IOERR_BLOCKED:return"BE_SQLITE_IOERR_BLOCKED";case wo.BE_SQLITE_IOERR_NOMEM:return"BE_SQLITE_IOERR_NOMEM";case wo.BE_SQLITE_IOERR_ACCESS:return"BE_SQLITE_IOERR_ACCESS";case wo.BE_SQLITE_IOERR_CHECKRESERVEDLOCK:return"BE_SQLITE_IOERR_CHECKRESERVEDLOCK";case wo.BE_SQLITE_IOERR_LOCK:return"BE_SQLITE_IOERR_LOCK";case wo.BE_SQLITE_IOERR_CLOSE:return"BE_SQLITE_IOERR_CLOSE";case wo.BE_SQLITE_IOERR_DIR_CLOSE:return"BE_SQLITE_IOERR_DIR_CLOSE";case wo.BE_SQLITE_IOERR_SHMOPEN:return"BE_SQLITE_IOERR_SHMOPEN";case wo.BE_SQLITE_IOERR_SHMSIZE:return"BE_SQLITE_IOERR_SHMSIZE";case wo.BE_SQLITE_IOERR_SHMLOCK:return"BE_SQLITE_IOERR_SHMLOCK";case wo.BE_SQLITE_IOERR_SHMMAP:return"BE_SQLITE_IOERR_SHMMAP";case wo.BE_SQLITE_IOERR_SEEK:return"BE_SQLITE_IOERR_SEEK";case wo.BE_SQLITE_IOERR_DELETE_NOENT:return"BE_SQLITE_IOERR_DELETE_NOENT";case wo.BE_SQLITE_ERROR_DataTransformRequired:return"Schema update require to transform data";case wo.BE_SQLITE_ERROR_FileExists:return"File Exists";case wo.BE_SQLITE_ERROR_AlreadyOpen:return"Already Open";case wo.BE_SQLITE_ERROR_NoPropertyTable:return"No Property Table";case wo.BE_SQLITE_ERROR_FileNotFound:return"File Not Found";case wo.BE_SQLITE_ERROR_NoTxnActive:return"No Txn Active";case wo.BE_SQLITE_ERROR_BadDbProfile:return"Bad Db Profile";case wo.BE_SQLITE_ERROR_InvalidProfileVersion:return"Invalid Profile Version";case wo.BE_SQLITE_ERROR_ProfileUpgradeFailed:return"Profile Upgrade Failed";case wo.BE_SQLITE_ERROR_ProfileTooOldForReadWrite:return"Profile Too Old For ReadWrite";case wo.BE_SQLITE_ERROR_ProfileTooOld:return"Profile Too Old";case wo.BE_SQLITE_ERROR_ProfileTooNewForReadWrite:return"Profile Too New For ReadWrite";case wo.BE_SQLITE_ERROR_ProfileTooNew:return"Profile Too New";case wo.BE_SQLITE_ERROR_ChangeTrackError:return"ChangeTrack Error";case wo.BE_SQLITE_ERROR_InvalidChangeSetVersion:return"Invalid ChangeSet Version";case wo.BE_SQLITE_ERROR_SchemaUpgradeRequired:return"Schema Upgrade Required";case wo.BE_SQLITE_ERROR_SchemaTooNew:return"Schema Too New";case wo.BE_SQLITE_ERROR_SchemaTooOld:return"Schema Too Old";case wo.BE_SQLITE_ERROR_SchemaLockFailed:return"Schema Lock Failed";case wo.BE_SQLITE_ERROR_SchemaUpgradeFailed:return"Schema Upgrade Failed";case wo.BE_SQLITE_ERROR_SchemaImportFailed:return"Schema Import Failed";case wo.BE_SQLITE_ERROR_CouldNotAcquireLocksOrCodes:return"Could Not Acquire Locks Or Codes";case wo.BE_SQLITE_ERROR_SchemaUpgradeRecommended:return"Recommended that the schemas found in the database be upgraded";case wo.BE_SQLITE_LOCKED_SHAREDCACHE:return"BE_SQLITE_LOCKED_SHAREDCACHE";case wo.BE_SQLITE_BUSY_RECOVERY:return"BE_SQLITE_BUSY_RECOVERY";case wo.BE_SQLITE_CANTOPEN_NOTEMPDIR:return"SQLite No Temp Dir";case wo.BE_SQLITE_CANTOPEN_ISDIR:return"BE_SQLITE_CANTOPEN_ISDIR";case wo.BE_SQLITE_CANTOPEN_FULLPATH:return"BE_SQLITE_CANTOPEN_FULLPATH";case wo.BE_SQLITE_CORRUPT_VTAB:return"BE_SQLITE_CORRUPT_VTAB";case wo.BE_SQLITE_READONLY_RECOVERY:return"BE_SQLITE_READONLY_RECOVERY";case wo.BE_SQLITE_READONLY_CANTLOCK:return"BE_SQLITE_READONLY_CANTLOCK";case wo.BE_SQLITE_READONLY_ROLLBACK:return"BE_SQLITE_READONLY_ROLLBACK";case wo.BE_SQLITE_ABORT_ROLLBACK:return"BE_SQLITE_ABORT_ROLLBACK";case wo.BE_SQLITE_CONSTRAINT_CHECK:return"BE_SQLITE_CONSTRAINT_CHECK";case wo.BE_SQLITE_CONSTRAINT_COMMITHOOK:return"CommitHook Constraint Error";case wo.BE_SQLITE_CONSTRAINT_FOREIGNKEY:return"Foreign Key Constraint Error";case wo.BE_SQLITE_CONSTRAINT_FUNCTION:return"Function Constraint Error";case wo.BE_SQLITE_CONSTRAINT_NOTNULL:return"NotNull Constraint Error";case wo.BE_SQLITE_CONSTRAINT_PRIMARYKEY:return"Primary Key Constraint Error";case wo.BE_SQLITE_CONSTRAINT_TRIGGER:return"Trigger Constraint Error";case wo.BE_SQLITE_CONSTRAINT_UNIQUE:return"Unique Constraint Error";case wo.BE_SQLITE_CONSTRAINT_VTAB:return"VTable Constraint Error";case Fo.ERROR:return"Error";case Mo.CannotAcquire:return"CannotAcquire";case Mo.CannotDownload:return"CannotDownload";case Mo.CannotCopy:return"CannotCopy";case Mo.CannotDelete:return"CannotDelete";case Mo.VersionNotFound:return"VersionNotFound";case Mo.DownloadCancelled:return"DownloadCancelled";case Mo.ContainsDeletedChangeSets:return"ContainsDeletedChangeSets";case Do.IncompatibleVersion:return"RpcInterfaceStatus.IncompatibleVersion";case Oo.ApplyError:return"Error applying a change set";case Oo.ChangeTrackingNotEnabled:return"Change tracking has not been enabled. The ChangeSet API mandates this";case Oo.CorruptedChangeStream:return"Contents of the change stream are corrupted and does not match the ChangeSet";case Oo.FileNotFound:return"File containing the changes was not found";case Oo.FileWriteError:return"Error writing the contents of the change set to the backing change stream file";case Oo.HasLocalChanges:return"Cannot perform the operation since the Db has local changes";case Oo.HasUncommittedChanges:return"Cannot perform the operation since current transaction has uncommitted changes";case Oo.InvalidId:return"Invalid ChangeSet Id";case Oo.InvalidVersion:return"Invalid version of the change set";case Oo.InDynamicTransaction:return"Cannot perform the operation since system is in the middle of a dynamic transaction";case Oo.IsCreatingChangeSet:return"Cannot perform operation since system is in the middle of a creating a change set";case Oo.IsNotCreatingChangeSet:return"Cannot perform operation since the system is not creating a change set";case Oo.MergePropagationError:return"Error propagating the changes after the merge";case Oo.NothingToMerge:return"No change sets to merge";case Oo.NoTransactions:return"No transactions are available to create a change set";case Oo.ParentMismatch:return"Parent change set of the Db does not match the parent id of the change set";case Oo.SQLiteError:return"Error performing a SQLite operation on the Db";case Oo.WrongDgnDb:return"ChangeSet originated in a different Db";case Oo.CouldNotOpenDgnDb:return"Could not open the DgnDb to merge change set";case Oo.MergeSchemaChangesOnOpen:return"Cannot merge changes in in an open DgnDb. Close the DgnDb, and process the operation when it is opened";case Oo.ReverseOrReinstateSchemaChanges:return"Cannot reverse or reinstate schema changes.";case Oo.ProcessSchemaChangesOnOpen:return"Cannot process changes schema changes in an open DgnDb. Close the DgnDb, and process the operation when it is opened";case Oo.CannotMergeIntoReadonly:return"Cannot merge changes into a Readonly DgnDb";case Oo.CannotMergeIntoMaster:return"Cannot merge changes into a Master DgnDb";case Oo.CannotMergeIntoReversed:return"Cannot merge changes into a DgnDb that has reversed change sets";case Oo.DownloadCancelled:return"ChangeSet(s) download was cancelled.";case Eo.ServerUnavailable:return"ServerUnavailable";case Eo.LockAlreadyHeld:return"LockAlreadyHeld";case Eo.SyncError:return"SyncError";case Eo.InvalidResponse:return"InvalidResponse";case Eo.PendingTransactions:return"PendingTransactions";case Eo.LockUsed:return"LockUsed";case Eo.CannotCreateChangeSet:return"CannotCreateChangeSet";case Eo.InvalidRequest:return"InvalidRequest";case Eo.ChangeSetRequired:return"ChangeSetRequired";case Eo.CodeUnavailable:return"CodeUnavailable";case Eo.CodeNotReserved:return"CodeNotReserved";case Eo.CodeUsed:return"CodeUsed";case Eo.LockNotHeld:return"LockNotHeld";case Eo.RepositoryIsLocked:return"RepositoryIsLocked";case Eo.ChannelConstraintViolation:return"ChannelConstraintViolation";case Bo.Info:return"HTTP Info";case Bo.Redirection:return"HTTP Redirection";case Bo.ClientError:return"HTTP Client error";case Bo.ServerError:return"HTTP Server error";case No.Unknown:return"Unknown error";case No.MissingRequiredProperties:return"Missing required properties";case No.InvalidPropertiesValues:return"Invalid properties values";case No.UserDoesNotHavePermission:return"User does not have permission";case No.UserDoesNotHaveAccess:return"User does not have access";case No.InvalidBriefcase:return"Invalid briefcase";case No.BriefcaseDoesNotExist:return"Briefcase does not exist";case No.BriefcaseDoesNotBelongToUser:return"Briefcase does not belong to user";case No.AnotherUserPushing:return"Another user pushing";case No.ChangeSetAlreadyExists:return"ChangeSet already exists";case No.ChangeSetDoesNotExist:return"ChangeSet does not exist";case No.FileIsNotUploaded:return"File is not uploaded";case No.iModelIsNotInitialized:return"iModel is not initialized";case No.ChangeSetPointsToBadSeed:return"ChangeSet points to a bad seed file";case No.OperationFailed:return"iModelHub operation has failed";case No.PullIsRequired:return"Pull is required";case No.MaximumNumberOfBriefcasesPerUser:return"Limit of briefcases per user was reached";case No.MaximumNumberOfBriefcasesPerUserPerMinute:return"Limit of briefcases per user per minute was reached";case No.DatabaseTemporarilyLocked:return"Database is temporarily locked";case No.iModelIsLocked:return"iModel is locked";case No.CodesExist:return"Code already exists";case No.LocksExist:return"Lock already exists";case No.iModelAlreadyExists:return"iModel already exists";case No.iModelDoesNotExist:return"iModel does not exist";case No.LockDoesNotExist:return"Lock does not exist";case No.LockChunkDoesNotExist:return"Lock chunk does not exist";case No.LockOwnedByAnotherBriefcase:return"Lock is owned by another briefcase";case No.CodeStateInvalid:return"Code state is invalid";case No.CodeReservedByAnotherBriefcase:return"Code is reserved by another briefcase";case No.CodeDoesNotExist:return"Code does not exist";case No.FileDoesNotExist:return"File does not exist";case No.FileAlreadyExists:return"File already exists";case No.EventTypeDoesNotExist:return"Event type does not exist";case No.EventSubscriptionDoesNotExist:return"Event subscription does not exist";case No.EventSubscriptionAlreadyExists:return"Event subscription already exists";case No.ITwinIdIsNotSpecified:return"ITwin Id is not specified";case No.FailedToGetITwinPermissions:return"Failed to get iTwin permissions";case No.FailedToGetITwinMembers:return"Failed to get iTwin members";case No.FailedToGetAssetPermissions:return"Failed to get asset permissions";case No.FailedToGetAssetMembers:return"Failed to get asset members";case No.ChangeSetAlreadyHasVersion:return"ChangeSet already has version";case No.VersionAlreadyExists:return"Version already exists";case No.JobSchedulingFailed:return"Failed to schedule a background job";case No.ConflictsAggregate:return"Codes or locks are owned by another briefcase";case No.FailedToGetITwinById:return"Failed to query iTwin by its id";case No.DatabaseOperationFailed:return"Database operation has failed";case No.ITwinDoesNotExist:return"ITwin does not exist";case No.UndefinedArgumentError:return"Undefined argument";case No.InvalidArgumentError:return"Invalid argument";case No.MissingDownloadUrlError:return"Missing download url";case No.NotSupportedInBrowser:return"Not supported in browser";case No.FileHandlerNotSet:return"File handler is not set";case No.FileNotFound:return"File not found";case Xo.NoGeoLocation:return"No GeoLocation";case Xo.OutOfUsefulRange:return"Out of useful range";case Xo.OutOfMathematicalDomain:return"Out of mathematical domain";case Xo.NoDatumConverter:return"No datum converter";case Xo.VerticalDatumConvertError:return"Vertical datum convert error";case Xo.CSMapError:return"CSMap error";case Xo.Pending:return"Pending";case zo.InvalidData:return"Invalid or unknown data";case wo.BE_SQLITE_OK:case wo.BE_SQLITE_ROW:case wo.BE_SQLITE_DONE:case Fo.SUCCESS:return"Success";default:return`Error (${t})`}}static getErrorMessage(t){if("string"==typeof t)return t;if(t instanceof Error)return t.toString();if(Ao.isObject(t)){if("string"==typeof t.message)return t.message;if("string"==typeof t.msg)return t.msg;if("[object Object]"!==t.toString())return t.toString()}return""}static getErrorStack(t){if(Ao.isObject(t)&&"string"==typeof t.stack)return t.stack}static getErrorMetadata(t){if(Ao.isObject(t)&&"function"==typeof t.getMetaData){const e=t.getMetaData();if("object"==typeof e&&null!==e)return e}}static getErrorProps(t){const e={message:fa.getErrorMessage(t)},i=fa.getErrorStack(t);i&&(e.stack=i);const n=fa.getErrorMetadata(t);return n&&(e.metadata=n),e}}!function(t){t[t.Unknown=0]="Unknown",t[t.B3dm=1835283298]="B3dm",t[t.Gltf=1179937895]="Gltf",t[t.Pnts=1937010288]="Pnts",t[t.IModel=1818512745]="IModel",t[t.Cmpt=1953525091]="Cmpt",t[t.I3dm=1835283305]="I3dm",t[t.A3x=5780289]="A3x"}(Lo||(Lo={})),function(t){t[t.Success=0]="Success",t[t.InvalidTileData=1]="InvalidTileData",t[t.InvalidHeader=2]="InvalidHeader",t[t.InvalidBatchTable=3]="InvalidBatchTable",t[t.InvalidScene=4]="InvalidScene",t[t.InvalidFeatureTable=5]="InvalidFeatureTable",t[t.NewerMajorVersion=6]="NewerMajorVersion",t[t.Canceled=7]="Canceled"}(Yo||(Yo={}));class ga{_format;version;constructor(t){this._format=function(t){const e=t;return function(t){switch(t){case Lo.Unknown:case Lo.B3dm:case Lo.Gltf:case Lo.IModel:case Lo.Pnts:case Lo.Cmpt:case Lo.I3dm:case Lo.A3x:return!0;default:return!1}}(e)?e:Lo.Unknown}(t.readUint32()),this.version=t.readUint32()}get format(){return this._format}invalidate(){this._format=Lo.Unknown}}function pa(t,e){const i=t.readFloat64(),n=t.readFloat64(),s=t.readFloat64();return void 0===e?new $(i,n,s):(e.set(i,n,s),e)}!function(t){t[t.Version1=1]="Version1",t[t.Version2=2]="Version2",t[t.CurrentVersion=1]="CurrentVersion",t[t.Gltf1SceneFormat=0]="Gltf1SceneFormat"}(Vo||(Vo={})),function(t){t[t.JSON=1313821514]="JSON",t[t.Binary=5130562]="Binary"}(Uo||(Uo={}));class ma{type;_guid;get isTileSection(){return ma.Type.TileSection===this.type}get isGlyph(){return ma.Type.Glyph===this.type}get isSkyBox(){return ma.Type.SkyBox===this.type}constructor(t){this.type=t,this._guid=l.createValue()}[Symbol.dispose](){this.dispose()}compare(t){return i(this._guid,t._guid)}}!function(t){let e;!function(t){t[t.Normal=0]="Normal",t[t.Glyph=1]="Glyph",t[t.TileSection=2]="TileSection",t[t.SkyBox=3]="SkyBox",t[t.FilteredTileSection=4]="FilteredTileSection",t[t.ThematicGradient=5]="ThematicGradient"}(e=t.Type||(t.Type={}))}(ma||(ma={}));class _a{key;textureMapping;_guid;constructor(t){this.key=t.key,this.textureMapping=t.textureMapping,this._guid=l.createValue()}get hasTexture(){return void 0!==this.textureMapping?.texture}compare(t){return i(this._guid,t._guid)}}class xa{key;diffuseColor;specularColor;emissiveColor;reflectColor;textureMapping;diffuse=.6;specular=.4;specularExponent=13.5;reflect=0;refract=1;ambient=.3;shadows=!0;_alpha;constructor(t){this.key=t}static defaults=new xa;get alpha(){return this._alpha}set alpha(t){var e;this._alpha=void 0!==t?(e=t,Math.max(0,Math.min(1,e))):void 0}static fromColors(t,e,i,n,s,r){const o=new xa;return o.key=t,o.diffuseColor=e,o.specularColor=i,o.emissiveColor=n,o.reflectColor=s,o.textureMapping=r,o}}Object.freeze(xa.defaults),function(t){function e(e,i=t.rangeScale16){return e>=0&&e<i+1}function i(e,i,n,s=t.rangeScale16){return Math.floor(Math.max(0,Math.min(s,.5+(e-i)*n)))}t.rangeScale16=65535,t.rangeScale8=255,t.computeScale=function(e,i=t.rangeScale16){return 0===e?e:i/e},t.isInRange=e,t.quantize=i,t.isQuantizable=function(n,s,r,o=t.rangeScale16){return e(i(n,s,r,o))},t.unquantize=function(t,e,i){return 0===i?e:e+t/i},t.isQuantized=function(t){return e(t)&&t===Math.floor(t)}}(qo||(qo={}));class ya{origin=new H;scale=new H;constructor(t=0,e=0,i=0,n=0){this.setFrom(t,e,i,n)}setFrom(t,e,i,n){this.origin.x=t,this.origin.y=e,this.scale.x=i,this.scale.y=n}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}clone(t){const e=void 0!==t?t:new ya;return e.copyFrom(this),e}setFromRange(t,e=qo.rangeScale16){t.isNull?this.origin.x=this.origin.y=this.scale.x=this.scale.y=0:this.setFrom(t.low.x,t.low.y,qo.computeScale(t.high.x-t.low.x,e),qo.computeScale(t.high.y-t.low.y,e))}static fromRange(t,e,i=qo.rangeScale16){const n=void 0!==e?e:new ya;return n.setFromRange(t,i),n}unquantize(t,e,i){return(i=i??new H).x=qo.unquantize(t,this.origin.x,this.scale.x),i.y=qo.unquantize(e,this.origin.y,this.scale.y),i}static fromNormalizedRange(t=qo.rangeScale16){return ya.fromRange(pt.createArray([H.create(-1,-1),H.create(1,1)]),void 0,t)}static fromZeroToOne(t=qo.rangeScale16){return ya.fromRange(pt.createArray([H.create(0,0),H.create(1,1)]),void 0,t)}static fromOriginAndScale(t,e,i,n){return new ya(t,e,i,n)}get rangeDiagonal(){return j.createFrom({x:0===this.scale.x?0:qo.rangeScale16/this.scale.x,y:0===this.scale.y?0:qo.rangeScale16/this.scale.y})}isQuantizable(t){return qo.isQuantizable(t.x,this.origin.x,this.scale.x)&&qo.isQuantizable(t.y,this.origin.y,this.scale.y)}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y},scale:{x:this.scale.x,y:this.scale.y}}}static fromJSON(t){return this.fromOriginAndScale(t.origin.x,t.origin.y,t.scale.x,t.scale.y)}}class va{_x=0;_y=0;get x(){return this._x}set x(t){qo.isQuantized(t),this._x=t}get y(){return this._y}set y(t){qo.isQuantized(t),this._y=t}constructor(){}init(t,e){this.x=qo.quantize(t.x,e.origin.x,e.scale.x),this.y=qo.quantize(t.y,e.origin.y,e.scale.y)}static create(t,e){const i=new va;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y}clone(t){const e=void 0!==t?t:new va;return e.copyFrom(this),e}setFromScalars(t,e){this.x=t,this.y=e}static fromScalars(t,e){const i=new va;return i.setFromScalars(t,e),i}unquantize(t,e){const i=void 0!==e?e:new H;return i.x=qo.unquantize(this.x,t.origin.x,t.scale.x),i.y=qo.unquantize(this.y,t.origin.y,t.scale.y),i}}!function(t){const e=new va;function i(t,e,i){const n=2*e,s=t[n+0],r=t[n+1];if(void 0===s||void 0===r)throw new Error("Index out of range");return(i=i??new va).setFromScalars(s,r),i}t.getQPoint=i,t.unquantizePoint=function(t,n,s){return i(t.points,n,e).unquantize(t.params,s)}}(Zo||(Zo={}));class Pa{origin=new $;scale=new $;constructor(t=0,e=0,i=0,n=0,s=0,r=0){this.setFrom(t,e,i,n,s,r)}setFrom(t,e,i,n,s,r){this.origin.x=t,this.origin.y=e,this.origin.z=i,this.scale.x=n,this.scale.y=s,this.scale.z=r}copyFrom(t){this.setFrom(t.origin.x,t.origin.y,t.origin.z,t.scale.x,t.scale.y,t.scale.z)}clone(t){const e=void 0!==t?t:new Pa;return e.copyFrom(this),e}setFromOriginAndScale(t,e){this.setFrom(t.x,t.y,t.z,e.x,e.y,e.z)}setFromRange(t,e=qo.rangeScale16){t.isNull?(this.origin.x=this.origin.y=this.origin.z=0,this.scale.x=this.scale.y=this.scale.z=0):this.setFrom(t.low.x,t.low.y,t.low.z,qo.computeScale(t.high.x-t.low.x,e),qo.computeScale(t.high.y-t.low.y,e),qo.computeScale(t.high.z-t.low.z,e))}unquantize(t,e,i,n){const s=void 0!==n?n:new $;return s.x=qo.unquantize(t,this.origin.x,this.scale.x),s.y=qo.unquantize(e,this.origin.y,this.scale.y),s.z=qo.unquantize(i,this.origin.z,this.scale.z),s}static fromRange(t,e,i=qo.rangeScale16){const n=void 0!==e?e:new Pa;return n.setFromRange(t,i),n}static fromOriginAndScale(t,e,i){const n=void 0!==i?i:new Pa;return n.setFromOriginAndScale(t,e),n}static fromNormalizedRange(t=qo.rangeScale16){return Pa.fromRange(ft.createArray([$.create(-1,-1,-1),$.create(1,1,1)]),void 0,t)}static fromZeroToOne(t=qo.rangeScale16){return Pa.fromRange(ft.createArray([$.create(0,0,0),$.create(1,1,1)]),void 0,t)}get rangeDiagonal(){return tt.createFrom({x:0===this.scale.x?0:qo.rangeScale16/this.scale.x,y:0===this.scale.y?0:qo.rangeScale16/this.scale.y,z:0===this.scale.z?0:qo.rangeScale16/this.scale.z})}isQuantizable(t){return qo.isQuantizable(t.x,this.origin.x,this.scale.x)&&qo.isQuantizable(t.y,this.origin.y,this.scale.y)&&qo.isQuantizable(t.z,this.origin.z,this.scale.z)}computeRange(t){const e=ft.createNull(t);return e.extendPoint(this.origin),e.extendPoint(this.origin.plus(this.rangeDiagonal)),e}toJSON(){return{origin:{x:this.origin.x,y:this.origin.y,z:this.origin.z},scale:{x:this.scale.x,y:this.scale.y,z:this.scale.z}}}static fromJSON(t,e){return this.fromOriginAndScale($.fromJSON(t.origin),$.fromJSON(t.scale),e)}}class Ia{_x=0;_y=0;_z=0;get x(){return this._x}set x(t){qo.isQuantized(t),this._x=t}get y(){return this._y}set y(t){qo.isQuantized(t),this._y=t}get z(){return this._z}set z(t){qo.isQuantized(t),this._z=t}constructor(){}init(t,e){this.x=qo.quantize(t.x,e.origin.x,e.scale.x),this.y=qo.quantize(t.y,e.origin.y,e.scale.y),this.z=qo.quantize(t.z,e.origin.z,e.scale.z)}static create(t,e){const i=new Ia;return i.init(t,e),i}copyFrom(t){this.x=t.x,this.y=t.y,this.z=t.z}clone(t){const e=void 0!==t?t:new Ia;return e.copyFrom(this),e}setFromScalars(t,e,i){this.x=t,this.y=e,this.z=i}static fromScalars(t,e,i,n){const s=void 0===n?new Ia:n;return s.setFromScalars(t,e,i),s}unquantize(t,e){const i=void 0!==e?e:new $;return i.x=qo.unquantize(this.x,t.origin.x,t.scale.x),i.y=qo.unquantize(this.y,t.origin.y,t.scale.y),i.z=qo.unquantize(this.z,t.origin.z,t.scale.z),i}equals(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}compare(t){let e=this.x-t.x;return 0===e&&(e=this.y-t.y,0===e&&(e=this.z-t.z)),e}}!function(t){const e=new Ia;function i(t,e,i){const n=3*e,s=t[n+0],r=t[n+1],o=t[n+2];if(void 0===s||void 0===r||void 0===o)throw new Error("Index out of range");return(i=i??new Ia).setFromScalars(s,r,o),i}t.getQPoint=i,t.unquantizePoint=function(t,n,s){return i(t.points,n,e).unquantize(t.params,s)}}(Wo||(Wo={})),Symbol.iterator,function(t){t[t.None=0]="None",t[t.ContainsCurves=1]="ContainsCurves",t[t.Incomplete=4]="Incomplete",t[t.DisallowMagnification=8]="DisallowMagnification",t[t.MultiModelFeatureTable=16]="MultiModelFeatureTable"}(Go||(Go={})),function(t){t[t.Major=37]="Major",t[t.Minor=0]="Minor",t[t.Combined=2424832]="Combined"}(Qo||(Qo={}));class Sa extends ga{headerLength;flags;contentRange;tolerance;numElementsIncluded;numElementsExcluded;tileLength;emptySubRanges;get versionMajor(){return this.version>>>16}get versionMinor(){return(65535&this.version)>>>0}get isValid(){return Lo.IModel===this.format}get isReadableVersion(){return this.versionMajor<=Qo.Major}constructor(t){super(t),this.headerLength=t.readUint32(),this.flags=t.readUint32(),this.contentRange=new ft,pa(t,this.contentRange.low),pa(t,this.contentRange.high),this.tolerance=t.readFloat64(),this.numElementsIncluded=t.readUint32(),this.numElementsExcluded=t.readUint32(),this.tileLength=t.readUint32(),this.emptySubRanges=this.versionMajor>=2?t.readUint32():0;const e=this.headerLength-t.curPos;t.advance(e),t.isPastTheEnd&&this.invalidate()}}class ba{length;numSubCategories;count;static readFrom(t){const e=t.readUint32(),i=t.readUint32(),n=t.readUint32();return t.isPastTheEnd?void 0:new ba(e,i,n)}static sizeInBytes=12;constructor(t,e,i){this.length=t,this.numSubCategories=e,this.count=i}}!function(t){t[t.Normal=0]="Normal",t[t.Edge=1]="Edge",t[t.Outline=2]="Outline"}(Ho||(Ho={}));class Aa{texture;normalMapParams;params;constructor(t,e){this.texture=t,this.params=e}computeUVParams(t,e=mt.createIdentity()){return this.params.computeUVParams(t,e)}compare(e){return this===e?0:this.texture.compare(e.texture)||this.params.compare(e.params)||n(((e,i)=>{return o=i,n(((t,e)=>t.compare(e)),(r=e).normalMap,o.normalMap)||s(r.greenUp,o.greenUp)||function(e,i){return n(t,e,i)}(r.scale,o.scale)||s(r.useConstantLod,o.useConstantLod);var r,o}),this.normalMapParams,e.normalMapParams)}}!function(i){let n;!function(t){t[t.None=-1]="None",t[t.Parametric=0]="Parametric",t[t.ElevationDrape=1]="ElevationDrape",t[t.Planar=2]="Planar",t[t.DirectionalDrape=3]="DirectionalDrape",t[t.Cubic=4]="Cubic",t[t.Spherical=5]="Spherical",t[t.Cylindrical=6]="Cylindrical",t[t.Solid=7]="Solid",t[t.FrontProject=8]="FrontProject"}(n=i.Mode||(i.Mode={}));class s{transform;constructor(t=1,e=0,i=0,n=0,s=1,r=0){const o=new $(i,r,0),a=xt.createRowValues(t,e,0,n,s,0,0,0,1);this.transform=mt.createRefs(o,a)}static identity=new s;compare(e){if(this===e)return 0;const i=t(this.transform.origin.x,e.transform.origin.x)||t(this.transform.origin.y,e.transform.origin.y);if(0!==i)return i;for(const i of[0,1,3,4]){const n=t(this.transform.matrix.coffs[i],e.transform.matrix.coffs[i]);if(0!==n)return n}return 0}}i.Trans2x3=s,i.Params=class{textureMatrix;weight;mode;worldMapping;useConstantLod;constantLodParams;constructor(t){this.textureMatrix=t?.textureMat2x3??s.identity,this.weight=t?.textureWeight??1,this.mode=t?.mapMode??n.Parametric,this.worldMapping=t?.worldMapping??!1,this.useConstantLod=t?.useConstantLod??!1,this.constantLodParams={repetitions:t?.constantLodProps?.repetitions??1,offset:t?.constantLodProps?.offset??{x:0,y:0},minDistClamp:t?.constantLodProps?.minDistClamp??1,maxDistClamp:t?.constantLodProps?.maxDistClamp??4294967296}}compare(i){return this===i?0:t(this.weight,i.weight)||t(this.mode,i.mode)||e(this.worldMapping,i.worldMapping)||e(this.useConstantLod,i.useConstantLod)||this.textureMatrix.compare(i.textureMatrix)||(n=this.constantLodParams,s=i.constantLodParams,t(n.repetitions,s.repetitions)||t(n.offset.x,s.offset.x)||t(n.offset.y,s.offset.y)||t(n.minDistClamp,s.minDistClamp)||t(n.maxDistClamp,s.maxDistClamp));var n,s}computeUVParams(t,e=mt.createIdentity()){switch(this.mode){default:case i.Mode.Parametric:return this.computeParametricUVParams(t,this.textureMatrix.transform,!this.worldMapping);case i.Mode.Planar:{const e=t.normalIndex;if(!e)return;return this.worldMapping&&(void 0===t.normalIndex||e[0]===e[1]&&e[0]===e[2])?this.computePlanarUVParams(t,this.textureMatrix.transform):this.computeParametricUVParams(t,this.textureMatrix.transform,!this.worldMapping)}case i.Mode.ElevationDrape:return this.computeElevationDrapeUVParams(t,this.textureMatrix.transform,e)}}computeParametricUVParams(t,e,i){const n=[];for(let s=0;s<t.numEdgesThisFacet;s++){let r=H.create();!i&&t.tryGetDistanceParameter(s,r)||t.tryGetNormalizedParameter(s,r)||(r=t.getParam(s)),n.push(e.multiplyPoint2d(r))}return n}computePlanarUVParams(t,e){const i=[],n=t.point;let s;if(s=void 0===t.normal?n.getPoint3dAtUncheckedPointIndex(0).crossProductToPoints(n.getPoint3dAtUncheckedPointIndex(1),n.getPoint3dAtUncheckedPointIndex(2)):t.normal.getVector3dAtCheckedVectorIndex(0),!s.normalize(s))return;s.scale(-1,s);const r=tt.create(s.y,-s.x,0),o=r.magnitude();r.normalize(r),o<.001&&(s.set(0,0,-1),r.set(1,0,0));const a=r.crossProduct(s).normalize();if(!a)return;const c=t.numEdgesThisFacet;for(let t=0;t<c;t++){const s=tt.createFrom(n.getPoint3dAtUncheckedPointIndex(t));i.push(H.create(s.dotProduct(r),s.dotProduct(a))),e.multiplyPoint2d(i[t],i[t])}return i}computeElevationDrapeUVParams(t,e,i){const n=[],s=t.numEdgesThisFacet;for(let r=0;r<s;r++){const s=t.point.getPoint3dAtUncheckedPointIndex(r);void 0!==i&&i.multiplyPoint3d(s,s),n.push(H.createFrom(s)),e.multiplyPoint2d(n[r],n[r])}return n}}}(Aa||(Aa={})),Object.freeze(Aa.Trans2x3.identity),(ca=jo||(jo={}))[ca.Solid=0]="Solid",ca[ca.Code0=0]="Code0",ca[ca.Code1=2155905152]="Code1",ca[ca.Code2=4177066232]="Code2",ca[ca.Code3=4292935648]="Code3",ca[ca.Code4=4262526480]="Code4",ca[ca.Code5=3772834016]="Code5",ca[ca.Code6=4169726088]="Code6",ca[ca.Code7=4279828248]="Code7",ca[ca.HiddenLine=3435973836]="HiddenLine",ca[ca.Invisible=1]="Invisible",ca[ca.Invalid=-1]="Invalid",function(t){t[t.None=0]="None",t[t.ByView=1]="ByView",t[t.Always=2]="Always",t[t.Behind=4]="Behind",t[t.Blanking=6]="Blanking",t[t.Background=8]="Background"}(Jo||(Jo={})),function(t){t[t.Rgba=0]="Rgba",t[t.Rgb=2]="Rgb",t[t.Alpha=5]="Alpha"}(Ko||(Ko={}));class Ca{data;format;width;get numBytesPerPixel(){return Ca.getNumBytesPerPixel(this.format)}static getNumBytesPerPixel(t){switch(t){case Ko.Alpha:return 1;case Ko.Rgb:return 3;default:return 4}}get height(){return Ca.computeHeight(this.data,this.format,this.width)}static create(t,e,i){if(!this.isValidData(t,e,i))throw new Error("The number of bytes supplied for ImageBuffer do not match its width and format.");return new Ca(t,e,i)}static isValidData(t,e,i){const n=this.computeHeight(t,e,i);return i>0&&n>0&&Math.floor(i)===i&&Math.floor(n)===n}static computeHeight(t,e,i){return t.length/(i*this.getNumBytesPerPixel(e))}constructor(t,e,i){this.data=t,this.format=e,this.width=i}}!function(t){t[t.Jpeg=0]="Jpeg",t[t.Png=2]="Png",t[t.Svg=3]="Svg"}($o||($o={})),function(t){t[t.Opaque=0]="Opaque",t[t.Translucent=1]="Translucent",t[t.Mixed=2]="Mixed"}(ta||(ta={})),function(t){t[t.Smooth=0]="Smooth",t[t.Stepped=1]="Stepped",t[t.SteppedWithDelimiter=2]="SteppedWithDelimiter",t[t.IsoLines=3]="IsoLines"}(ea||(ea={})),function(t){t[t.SurfaceOnly=0]="SurfaceOnly",t[t.MultiplySurfaceAndGradient=1]="MultiplySurfaceAndGradient"}(ia||(ia={})),function(t){t[t.BlueRed=0]="BlueRed",t[t.RedBlue=1]="RedBlue",t[t.Monochrome=2]="Monochrome",t[t.Topographic=3]="Topographic",t[t.SeaMountain=4]="SeaMountain",t[t.Custom=5]="Custom"}(na||(na={}));class Ta{mode;stepCount;marginColor;colorScheme;customKeys;colorMix;transparencyMode;static get margin(){return.001}static get contentRange(){return 1-2*Ta.margin}static get contentMax(){return 1-Ta.margin}static defaults=new Ta({});static _defaultCustomKeys=[[0,255,255,255],[1,0,0,0]];get textureTransparency(){let t=ta.Opaque;if(na.Custom===this.colorScheme){let e=!1,i=!1;for(const t of this.customKeys){const n=t.color.isOpaque;e=e||n,i=i||!n}i&&(t=e?ta.Mixed:ta.Translucent)}return t!==ta.Mixed&&this.marginColor.isOpaque!==(t===ta.Opaque)&&(t=ta.Mixed),t}equals(t){return!(this.mode!==t.mode||this.stepCount!==t.stepCount||!this.marginColor.equals(t.marginColor)||this.colorScheme!==t.colorScheme||this.customKeys.length!==t.customKeys.length||this.colorMix!==t.colorMix||this.transparencyMode!==t.transparencyMode)&&this.customKeys.every(((e,i)=>ra.keyColorEquals(e,t.customKeys[i])))}static compare(e,i){let n=0;if(0!==(n=t(e.mode,i.mode)))return n;if(0!==(n=t(e.stepCount,i.stepCount)))return n;if(0!==(n=t(e.marginColor.tbgr,i.marginColor.tbgr)))return n;if(0!==(n=t(e.colorScheme,i.colorScheme)))return n;if(0!==(n=t(e.colorMix,i.colorMix)))return n;if(0!==(n=t(e.customKeys.length,i.customKeys.length)))return n;if(0!==(n=t(e.transparencyMode,i.transparencyMode)))return n;for(let s=0;s<e.customKeys.length;s++)if(0!==(n=t(e.customKeys[s].color.tbgr,i.customKeys[s].color.tbgr)))return n;return n}constructor(t){if(this.customKeys=[],void 0===t)this.mode=ea.Smooth,this.stepCount=10,this.marginColor=Hr.fromJSON(),this.colorScheme=na.BlueRed,this.colorMix=0,this.transparencyMode=ia.SurfaceOnly;else{if(this.mode=void 0!==t.mode&&null!==t.mode?t.mode:ea.Smooth,(this.mode<ea.Smooth||this.mode>ea.IsoLines)&&(this.mode=ea.Smooth),this.stepCount="number"==typeof t.stepCount?t.stepCount:10,this.stepCount<2&&(this.stepCount=2),this.marginColor=Hr.fromJSON(t.marginColor),this.colorScheme=void 0!==t.colorScheme&&null!==t.colorScheme?t.colorScheme:na.BlueRed,(this.colorScheme<na.BlueRed||this.colorScheme>na.Custom)&&(this.colorScheme=na.BlueRed),void 0!==t.customKeys&&null!==t.customKeys&&t.customKeys.forEach((t=>this.customKeys.push(new ra.KeyColor(t)))),this.colorScheme===na.Custom&&this.customKeys.length<2){this.customKeys=[];for(const t of Ta._defaultCustomKeys)this.customKeys.push(new ra.KeyColor({value:t[0],color:Hr.computeTbgrFromComponents(t[1],t[3],t[2])}))}this.colorMix=t.colorMix??0,this.transparencyMode=t.transparencyMode??ia.SurfaceOnly}}static fromJSON(t){return t?new Ta(t):this.defaults}toJSON(){const t={};ea.Smooth!==this.mode&&(t.mode=this.mode),10!==this.stepCount&&(t.stepCount=this.stepCount);const e=this.marginColor.toJSON();return 0!==e&&(t.marginColor=e),na.BlueRed!==this.colorScheme&&(t.colorScheme=this.colorScheme),0!==this.colorMix&&(t.colorMix=this.colorMix),ia.SurfaceOnly!==this.transparencyMode&&(t.transparencyMode=this.transparencyMode),this.customKeys.length>0&&(t.customKeys=this.customKeys.map((t=>({value:t.value,color:t.color.toJSON()})))),t}clone(t){if(void 0===t)return Ta.fromJSON(this.toJSON());const e={mode:void 0!==t.mode?t.mode:this.mode,stepCount:void 0!==t.stepCount?t.stepCount:this.stepCount,marginColor:void 0!==t.marginColor?t.marginColor:this.marginColor.tbgr,colorScheme:void 0!==t.colorScheme?t.colorScheme:this.colorScheme,customKeys:void 0!==t.customKeys?t.customKeys:this.customKeys.map((t=>({value:t.value,color:t.color.tbgr}))),colorMix:void 0!==t.colorMix?t.colorMix:this.colorMix,transparencyMode:t.transparencyMode??this.transparencyMode};return Ta.fromJSON(e)}}!function(t){t[t.Height=0]="Height",t[t.InverseDistanceWeightedSensors=1]="InverseDistanceWeightedSensors",t[t.Slope=2]="Slope",t[t.HillShade=3]="HillShade"}(sa||(sa={})),function(t){let e,i;!function(t){t[t.None=0]="None",t[t.Invert=1]="Invert",t[t.Outline=2]="Outline"}(e=t.Flags||(t.Flags={})),function(t){t[t.None=0]="None",t[t.Linear=1]="Linear",t[t.Curved=2]="Curved",t[t.Cylindrical=3]="Cylindrical",t[t.Spherical=4]="Spherical",t[t.Hemispherical=5]="Hemispherical",t[t.Thematic=6]="Thematic"}(i=t.Mode||(t.Mode={}));class n{value;color;constructor(t){this.value=t.value,this.color=Hr.fromJSON(t.color)}}t.KeyColor=n,t.keyColorEquals=function(t,e){return t.value===e.value&&t.color.equals(e.color)};class s{mode=i.None;flags=e.None;angle;tint;shift=0;thematicSettings;keys=[];static fromJSON(t){const i=new s;return t?(i.mode=t.mode,i.flags=void 0===t.flags?e.None:t.flags,i.angle=t.angle?G.fromJSON(t.angle):void 0,i.tint=t.tint,i.shift=t.shift?t.shift:0,t.keys.forEach((t=>i.keys.push(new n(t)))),i.thematicSettings=void 0===t.thematicSettings?void 0:Ta.fromJSON(t.thematicSettings),i):i}static _fixedSchemeKeys=[[[0,0,255,0],[.25,0,255,255],[.5,0,0,255],[.75,255,0,255],[1,255,0,0]],[[0,255,0,0],[.25,255,0,255],[.5,0,0,255],[.75,0,255,255],[1,0,255,0]],[[0,0,0,0],[1,255,255,255]],[[0,152,148,188],[.5,204,160,204],[1,152,72,128]],[[0,0,255,0],[.2,72,96,160],[.4,152,96,160],[.6,128,32,104],[.7,148,180,128],[1,240,240,240]]];static _fixedCustomKeys=[[0,255,0,0],[1,0,255,0]];static createThematic(e){const r=new s;if(r.mode=i.Thematic,r.thematicSettings=e,e.colorScheme<na.Custom)for(const i of t.Symb._fixedSchemeKeys[e.colorScheme])r.keys.push(new n({value:i[0],color:Hr.computeTbgrFromComponents(i[1],i[3],i[2])}));else if(e.customKeys.length,e.customKeys.length>1)e.customKeys.forEach((t=>r.keys.push(t)));else for(const e of t.Symb._fixedCustomKeys)r.keys.push(new n({value:e[0],color:Hr.from(e[1],e[3],e[2]).toJSON()}));return r}toJSON(){return{...this,thematicSettings:this.thematicSettings?.toJSON(),keys:this.keys.map((t=>({value:t.value,color:t.color.toJSON()})))}}clone(){return s.fromJSON(this.toJSON())}equals(t){return 0===s.compareSymb(this,t)}static compareSymb(t,e){if(t===e)return 0;if(t.mode!==e.mode)return t.mode-e.mode;if(t.flags!==e.flags)return void 0===t.flags?-1:void 0===e.flags?1:t.flags-e.flags;if(t.tint!==e.tint)return void 0===t.tint?-1:void 0===e.tint?1:t.tint-e.tint;if(t.shift!==e.shift)return void 0===t.shift?-1:void 0===e.shift?1:t.shift-e.shift;if(void 0===t.angle!=(void 0===e.angle))return void 0===t.angle?-1:1;if(t.angle&&!t.angle.isAlmostEqualNoPeriodShift(e.angle))return t.angle.radians-e.angle.radians;if(t.keys.length!==e.keys.length)return t.keys.length-e.keys.length;for(let i=0;i<t.keys.length;i++){if(t.keys[i].value!==e.keys[i].value)return t.keys[i].value-e.keys[i].value;if(!t.keys[i].color.equals(e.keys[i].color))return t.keys[i].color.tbgr-e.keys[i].color.tbgr}if(t.thematicSettings!==e.thematicSettings){if(void 0===t.thematicSettings)return-1;if(void 0===e.thematicSettings)return 1;{const i=Ta.compare(t.thematicSettings,e.thematicSettings);if(0!==i)return i}}return 0}compare(e){return t.Symb.compareSymb(this,e)}roundToByte(t){return 255&Math.min(t+.5,255)}mapColor(t){t<0?t=0:t>1&&(t=1),this.flags&e.Invert&&(t=1-t);let i,n,s,r=0;if(this.keys.length<=2)n=1-t,s=t;else{for(;r<this.keys.length-2&&t>this.keys[r+1].value;)r++;i=this.keys[r+1].value-this.keys[r].value,s=i<1e-4?0:(t-this.keys[r].value)/i,n=1-s}const o=this.keys[r].color,a=this.keys[r+1].color,c=o.colors,l=a.colors,h=n*c.r+s*l.r,d=n*c.g+s*l.g,u=n*c.b+s*l.b,f=n*c.t+s*l.t;return Hr.from(this.roundToByte(h),this.roundToByte(d),this.roundToByte(u),this.roundToByte(f))}get hasTranslucency(){for(const t of this.keys)if(!t.color.isOpaque)return!0;return!1}get isOutlined(){return!!(this.flags&e.Outline)}getThematicImageForRenderer(t){i.Thematic,this.mode;let e=this.thematicSettings;void 0===e&&(e=Ta.defaults);const n=Math.min(e.stepCount,t),s=ea.Smooth===e.mode?t:n,r=new Uint8Array(1*s*4);let o=r.length-1;function a(t){r[o--]=t.getAlpha(),r[o--]=t.colors.b,r[o--]=t.colors.g,r[o--]=t.colors.r}switch(e.mode){case ea.Smooth:for(let t=0;t<s;t++){const e=1-t/s;a(this.mapColor(e))}break;case ea.SteppedWithDelimiter:case ea.IsoLines:case ea.Stepped:e.stepCount;for(let t=0;t<s;t++){const e=1-t/(s-1);a(this.mapColor(e))}}return Ca.create(r,Ko.Rgba,1)}getImage(t,e){return this.mode===i.Thematic&&(t=1),this.produceImage({width:t,height:e,includeThematicMargin:!0})}produceImage(t){const{width:e,height:n,includeThematicMargin:s}={...t},r=void 0===this.angle?0:this.angle.radians,o=Math.cos(r),a=Math.sin(r),c=new Uint8Array(e*n*4);let l=c.length-1;const h=Math.min(1,Math.abs(this.shift));switch(this.mode){case i.Linear:case i.Cylindrical:{const t=.5-.25*h*o,s=.5-.25*h*a;let r,d,u=r=0;for(let e=0;e<2;e++)for(let i=0;i<2;i++)d=(i-t)*o+(e-s)*a,d<u&&(u=d),d>r&&(r=d);for(let h=0;h<n;h++){const f=h/n-s;for(let n=0;n<e;n++){let s;d=(n/e-t)*o+f*a,s=this.mode===i.Linear?d>0?.5+.5*d/r:.5-.5*d/u:d>0?Math.sin(Math.PI/2*(1-d/r)):Math.sin(Math.PI/2*(1-d/u));const h=this.mapColor(s);c[l--]=h.getAlpha(),c[l--]=h.colors.b,c[l--]=h.colors.g,c[l--]=h.colors.r}}break}case i.Curved:{const t=.5+.5*a-.25*h*o,i=.5-.5*o-.25*h*a;for(let s=0;s<n;s++){const r=s/n-i;for(let i=0;i<e;i++){const n=i/e-t,s=.8*(n*o+r*a),h=r*o-n*a,d=Math.sin(Math.PI/2*(1-Math.sqrt(s*s+h*h))),u=this.mapColor(d);c[l--]=u.getAlpha(),c[l--]=u.colors.b,c[l--]=u.colors.g,c[l--]=u.colors.r}}break}case i.Spherical:{const t=.5+.125*Math.sin(2*r),i=.5*h*(o+a)*t,s=.5*h*(a-o)*t;for(let r=0;r<n;r++){const o=s+r/n-.5;for(let n=0;n<e;n++){const s=i+n/e-.5,r=Math.sin(Math.PI/2*(1-Math.sqrt(s*s+o*o)/t)),a=this.mapColor(r);c[l--]=a.getAlpha(),c[l--]=a.colors.b,c[l--]=a.colors.g,c[l--]=a.colors.r}}break}case i.Hemispherical:{const t=.5+.5*a-.5*h*o,i=.5-.5*o-.5*h*a;for(let s=0;s<n;s++){const r=s/n-i;for(let i=0;i<e;i++){const n=i/e-t,s=Math.sin(Math.PI/2*(1-Math.sqrt(n*n+r*r))),o=this.mapColor(s);c[l--]=o.getAlpha(),c[l--]=o.colors.b,c[l--]=o.colors.g,c[l--]=o.colors.r}}break}case i.Thematic:{const t=this.thematicSettings??Ta.defaults;for(let i=0;i<n;i++){let r,o=1-i/n;if(s&&(o<Ta.margin||o>Ta.contentMax))r=t.marginColor;else switch(o=(o-Ta.margin)/Ta.contentRange,t.mode){case ea.SteppedWithDelimiter:case ea.IsoLines:case ea.Stepped:if(t.stepCount>1){const e=Math.floor(o*t.stepCount-1e-5)/(t.stepCount-1);r=this.mapColor(e)}break;case ea.Smooth:r=this.mapColor(o)}for(let t=0;t<e;t++)c[l--]=r.getAlpha(),c[l--]=r.colors.b,c[l--]=r.colors.g,c[l--]=r.colors.r}}}return Ca.create(c,Ko.Rgba,e)}}t.Symb=s}(ra||(ra={})),function(t){t[t.Mesh=0]="Mesh",t[t.Polyline=1]="Polyline",t[t.Point=2]="Point"}(oa||(oa={})),function(t){t[t.Unlit=0]="Unlit",t[t.Lit=1]="Lit",t[t.Textured=2]="Textured",t[t.TexturedLit=3]="TexturedLit",t[t.VolumeClassifier=4]="VolumeClassifier"}(aa||(aa={}));class wa{static minTransparency=15;type=wa.Type.Mesh;material;gradient;_textureMapping;lineColor;fillColor;width;linePixels;fillFlags;ignoreLighting;constructor(t,e,i,n=0,s=jo.Solid,r=Jo.None,o,a,c=!1,l){this.type=t,this.material=o,this.gradient=a,this.lineColor=wa.adjustTransparency(e),this.fillColor=wa.adjustTransparency(i),this.width=n,this.linePixels=s,this.fillFlags=r,this.ignoreLighting=c,this._textureMapping=l}static createForType(t,e,i,n=!1){const s=wa.adjustTransparency(e.lineColor);switch(t){case wa.Type.Mesh:{let r;if(void 0!==e.gradient&&void 0!==i){const t=i(e.gradient);void 0!==t&&(r=new Aa(t,new Aa.Params))}return new wa(t,s,wa.adjustTransparency(e.fillColor),e.rasterWidth,e.linePixels,e.fillFlags,e.material,e.gradient,n,r)}case wa.Type.Linear:return new wa(t,s,s,e.rasterWidth,e.linePixels);default:return new wa(t,s,s,0,jo.Solid,Jo.Always,void 0,void 0,!0)}}static createForMesh(t,e,i){return wa.createForType(wa.Type.Mesh,t,i,e)}static createForLinear(t){return wa.createForType(wa.Type.Linear,t)}static createForText(t){return wa.createForType(wa.Type.Text,t)}get regionEdgeType(){return this.hasBlankingFill?wa.RegionEdgeType.None:void 0!==this.gradient&&void 0!==this.gradient.flags?this.gradient.flags&ra.Flags.Outline||Jo.None===(this.fillFlags&Jo.Always)?wa.RegionEdgeType.Outline:wa.RegionEdgeType.None:this.fillColor.equals(this.lineColor)?wa.RegionEdgeType.Default:wa.RegionEdgeType.Outline}get wantRegionOutline(){return wa.RegionEdgeType.Outline===this.regionEdgeType}get hasBlankingFill(){return Jo.Blanking===(this.fillFlags&Jo.Blanking)}get hasFillTransparency(){return 255!==this.fillColor.getAlpha()}get hasLineTransparency(){return 255!==this.lineColor.getAlpha()}get textureMapping(){return void 0!==this.material?this.material.textureMapping:this._textureMapping}get isTextured(){return void 0!==this.textureMapping}equals(t,e=wa.ComparePurpose.Strict){return wa.ComparePurpose.Merge===e?0===this.compareForMerge(t):t===this||this.type===t.type&&this.ignoreLighting===t.ignoreLighting&&this.width===t.width&&this.linePixels===t.linePixels&&this.fillFlags===t.fillFlags&&this.wantRegionOutline===t.wantRegionOutline&&this.material===t.material&&this.textureMapping===t.textureMapping&&!!this.fillColor.equals(t.fillColor)&&!!this.lineColor.equals(t.lineColor)}compareForMerge(i){if(i===this)return 0;let s=t(this.type,i.type);return 0===s&&(s=e(this.ignoreLighting,i.ignoreLighting),0===s&&(s=t(this.width,i.width),0===s&&(s=t(this.linePixels,i.linePixels),0===s&&(s=t(this.fillFlags,i.fillFlags),0===s&&(s=e(this.wantRegionOutline,i.wantRegionOutline),0===s&&(s=e(this.hasFillTransparency,i.hasFillTransparency),0===s&&(s=e(this.hasLineTransparency,i.hasLineTransparency),0===s&&(s=function(t,e){return n(((t,e)=>t.compare(e)),t,e)}(this.material,i.material),0===s&&void 0===this.material&&this.isTextured&&(s=function(t,e){return n(((t,e)=>t.compare(e)),t,e)}(this.textureMapping,i.textureMapping)))))))))),s}static adjustTransparency(t){return t.colors.t<wa.minTransparency?t.withTransparency(0):t}}!function(t){let e,i,n;!function(t){t[t.Mesh=0]="Mesh",t[t.Linear=1]="Linear",t[t.Text=2]="Text"}(e=t.Type||(t.Type={})),function(t){t[t.None=0]="None",t[t.Default=1]="Default",t[t.Outline=2]="Outline"}(i=t.RegionEdgeType||(t.RegionEdgeType={})),function(t){t[t.Merge=0]="Merge",t[t.Strict=1]="Strict"}(n=t.ComparePurpose||(t.ComparePurpose={}))}(wa||(wa={}));const Ea=new Uint16Array(1);function ka(t){return Fa(.5+255*(.5*function(t){return t<-1?-1:t>1?1:t}(t)+.5))}function Fa(t){return Ea[0]=t,Ea[0]}function Ra(t){return t<0?-1:1}class Ma{value;constructor(t){this.value=Fa(t)}static encode(t){return this.encodeXYZ(t.x,t.y,t.z)}static encodeXYZ(t,e,i){const n=Math.abs(t)+Math.abs(e)+Math.abs(i);let s=t/n,r=e/n;if(i<0){const t=s,e=r;s=(1-Math.abs(e))*Ra(t),r=(1-Math.abs(t))*Ra(e)}return ka(r)<<8|ka(s)}static fromVector(t){return new Ma(this.encode(t))}decode(){return Ma.decodeValue(this.value)}static decodeValue(t,e){let i=255&t,n=t>>8;i=i/255*2-1,n=n/255*2-1;const s=1-(Math.abs(i)+Math.abs(n));let r;if(void 0===e?r=new tt(i,n,s):(r=e,r.x=i,r.y=n,r.z=s),r.z<0){const t=r.x,e=r.y;r.x=(1-Math.abs(e))*Ra(t),r.y=(1-Math.abs(t))*Ra(e)}return r.normalizeInPlace(),r}}function Da(t,e,i,n){const s=Math.ceil(t*e)+i;if(s<=n)return{width:s,height:1};let r=Math.ceil(Math.sqrt(s));const o=r%e;0!==o&&(r+=e-o);const a=Math.ceil(s/r);return Math.floor(a),Math.floor(r),{width:r,height:a}}class Oa{name;inputs;indices;constructor(t){this.name=t.name,this.inputs=t.inputs,this.indices=t.indices}toJSON(){return{name:this.name,inputs:this.inputs,indices:this.indices}}}class Ba extends Oa{qOrigin;qScale;constructor(t){super(t),this.qOrigin=Float32Array.from(t.qOrigin),this.qScale=Float32Array.from(t.qScale)}toJSON(){return{...super.toJSON(),qOrigin:Array.from(this.qOrigin),qScale:Array.from(this.qScale)}}}class Na extends Oa{qOrigin;qScale;constructor(t){super(t),this.qOrigin=t.qOrigin[0],this.qScale=t.qScale[0]}toJSON(){return{...super.toJSON(),qOrigin:[this.qOrigin],qScale:[this.qScale]}}}class Xa{data;width;height;numVertices;numBytesPerVertex;displacements;normals;params;constructor(t,e,i,n){this.data=t.data,this.width=t.width,this.height=t.height,this.numVertices=t.count,this.numBytesPerVertex=t.numBytesPerVertex,this.displacements=e,this.normals=i,this.params=n}static fromJSON(t){let e,i,n;if(void 0!==t.displacements&&0<t.displacements.length){e=[];for(const i of t.displacements)e.push(new Ba(i))}if(void 0!==t.normals&&0<t.normals.length){i=[];for(const e of t.normals)i.push(new Oa(e))}if(void 0!==t.params&&0<t.params.length){n=[];for(const e of t.params)n.push(new Na(e))}return void 0!==e||void 0!==i||void 0!==n?new Xa(t,e,i,n):void 0}toJSON(){return{data:this.data,width:this.width,height:this.height,count:this.numVertices,numBytesPerVertex:this.numBytesPerVertex,displacements:this.displacements?.map((t=>t.toJSON())),normals:this.normals?.map((t=>t.toJSON())),params:this.params?.map((t=>t.toJSON()))}}static fromChannels(t,e,i){return La.buildAuxChannelTable(t,e,i)}}function za(t){return 0!==t&&(t=1/t),t}class La{_view;_props;_numBytesPerVertex;constructor(t,e){this._props=t,this._numBytesPerVertex=e,this._view=new DataView(t.data.buffer)}static buildAuxChannelTable(t,e,i){const n=t.reduce(((t,e)=>t+Ya(e)),0);if(!n)return;const s=Math.floor((n+3)/4);let r;r=0!==4*s-n?Da(Math.floor((e+1)/2),n/2,0,i):Da(e,s,0,i);const o={data:new Uint8Array(r.width*r.height*4),width:r.width,height:r.height,count:e,numBytesPerVertex:n};return new La(o,n).build(t),Xa.fromJSON(o)}build(t){let e=0;for(const i of t)C.Normal===i.dataType?this.addNormals(i,e):C.Vector===i.dataType?this.addDisplacements(i,e):this.addParams(i,e),e+=Ya(i)}addNormals(t,e){const i=[],n=[],s=new tt;for(let r=0;r<t.data.length;r++){let o=e+2*r;n.push(o/2);const a=t.data[r];i.push(a.input);for(let t=0;t<a.values.length;t+=3){s.x=a.values[t],s.y=a.values[t+1],s.z=a.values[t+2],s.normalizeInPlace();const e=Ma.encode(s);this._view.setUint16(o,e,!0),o+=this._numBytesPerVertex}}(this._props.normals??(this._props.normals=[])).push({name:t.name??"",inputs:i,indices:n})}addParams(t,e){const i=[],n=[],s=gt.createNull();for(const e of t.data)i.push(e.input),s.extendArray(e.values);const r=qo.computeScale(s.high-s.low);for(let i=0;i<t.data.length;i++){let o=e+2*i;n.push(o/2);for(const e of t.data[i].values){const t=qo.quantize(e,s.low,r);this._view.setUint16(o,t,!0),o+=this._numBytesPerVertex}}(this._props.params??(this._props.params=[])).push({inputs:i,indices:n,name:t.name??"",qOrigin:[s.low],qScale:[za(r)]})}addDisplacements(t,e){const i=[],n=[],s=new $,r=ft.createNull();for(const e of t.data){i.push(e.input);for(let t=0;t<e.values.length;t+=3)s.set(e.values[t],e.values[t+1],e.values[t+2]),r.extend(s)}const o=Pa.fromRange(r),a=new Ia;for(let i=0;i<t.data.length;i++){let r=e+6*i;n.push(r/2);const c=t.data[i];for(let t=0;t<c.values.length;t+=3)s.set(c.values[t],c.values[t+1],c.values[t+2]),a.init(s,o),this._view.setUint16(r+0,a.x,!0),this._view.setUint16(r+2,a.y,!0),this._view.setUint16(r+4,a.z,!0),r+=this._numBytesPerVertex}(this._props.displacements??(this._props.displacements=[])).push({inputs:i,indices:n,name:t.name??"",qOrigin:o.origin.toArray(),qScale:o.scale.toArray().map((t=>za(t)))})}}function Ya(t){const e=t.data.length;switch(t.dataType){case C.Vector:return 6*e;case C.Normal:case C.Distance:case C.Scalar:return 2*e}}class Va{_constructor;_data;_length;growthFactor;constructor(t,e){this._constructor=t,this._data=new t(e?.initialCapacity??0),this.growthFactor=Math.max(1,e?.growthFactor??1.5),this._length=0}get length(){return this._length}get capacity(){return this._data.length}at(t){t<0&&(t=this.length-t);return this._data[t]}ensureCapacity(t){if(this.capacity>=t)return this.capacity;this.growthFactor,t=Math.ceil(t*this.growthFactor);const e=this._data;return this._data=new this._constructor(t),this._data.set(e,0),this.capacity,this.capacity}push(t){this.ensureCapacity(this.length+1),this._data[this.length]=t,++this._length}append(t){const e=this.length+t.length;this.ensureCapacity(e),this._data.set(t,this.length),this._length=e}toTypedArray(t=!1){if(t)return this._data;const e=this._data.subarray(0,this.length);return this._constructor,e.buffer,this._data.buffer,e}}class Ua extends Va{constructor(t){super(Uint8Array,t)}}class qa extends Va{constructor(t){super(Uint32Array,t)}toUint8Array(t=!1){return t?new Uint8Array(this._data.buffer):new Uint8Array(this._data.buffer,0,4*this.length)}}function Za(t,e,i){let n=Math.ceil(1.5*t+2.5*e);const s=6*t;let r=0,o=n,a=1;if(n>=i){o=Math.ceil(Math.sqrt(n));const i=o%15;0!==i&&(o+=15-i),e>0&&t>0&&(r=(60-s%60)%10,n+=Math.ceil(r/4)),a=Math.ceil(n/o),o*a<n&&a++}return{width:o,height:a,silhouettePadding:r,silhouetteStartByteIndex:s}}class Wa{data;constructor(t){this.data=t,this.data.length}get length(){return this.data.length/3}static fromArray(t){const e=new Uint8Array(3*t.length);for(let i=0;i<t.length;i++)this.encodeIndex(t[i],e,3*i);return new Wa(e)}static encodeIndex(t,e,i){e.length,e[i+0]=255&t,e[i+1]=(65280&t)>>8,e[i+2]=(16711680&t)>>16}setNthIndex(t,e){Wa.encodeIndex(e,this.data,3*t)}decodeIndex(t){this.length;const e=3*t;return this.data[e]|this.data[e+1]<<8|this.data[e+2]<<16}decodeIndices(){const t=[];for(let e=0;e<this.length;e++)t.push(this.decodeIndex(e));return t}[Symbol.iterator](){return function*(t){for(let e=0;e<t.length;e++)yield t.decodeIndex(e)}(this)}}class Ga{_builder;_index32=new Uint32Array(1);_index8=new Uint8Array(this._index32.buffer,0,3);constructor(t=3){this._builder=new Ua({initialCapacity:3*t})}get numIndices(){return this._builder.length,this._builder.length/3}push(t){this._index32[0]=t,this._builder.append(this._index8)}toVertexIndices(){return new Wa(this._builder.toTypedArray())}}class Qa{_builder;_source;constructor(t){this._source=t,this._builder=new qa({initialCapacity:3*t.numRgbaPerVertex})}get length(){return this._builder.length,this.vertexSize,this._builder.length/this.vertexSize}get vertexSize(){return this._source.numRgbaPerVertex}push(t){t.length,this.vertexSize,this._builder.append(t)}buildVertexTable(t,e,i){const n=this._source,s=(e=e??n.uniformColor)instanceof Uint32Array?e.length:0,r=i instanceof Uint32Array?i.length:0,o=Da(this.length,this.vertexSize,s+r,t);let a=this._builder.toTypedArray();if(o.width*o.height>a.length){const t=a;a=new Uint32Array(o.width*o.height),a.set(t,0)}let c=this.vertexSize*this.length;return e instanceof Uint32Array&&(a.set(e,c),c+=e.length),i instanceof Uint32Array&&a.set(i,c),{data:new Uint8Array(a.buffer,a.byteOffset,a.byteLength),usesUnquantizedPositions:n.usesUnquantizedPositions,qparams:n.qparams,width:o.width,height:o.height,hasTranslucency:n.hasTranslucency,uniformColor:e instanceof Hr?e:void 0,featureIndexType:n.featureIndexType,uniformFeatureID:n.uniformFeatureID,numVertices:this.length,numRgbaPerVertex:n.numRgbaPerVertex,uvParams:n.uvParams}}}class Ha{_remappedIndices=new Map;_colorTable;colors=[];_32=new Uint32Array(1);_16=new Uint16Array(this._32.buffer);constructor(t){this._colorTable=t}remap(t,e){const i=e?4:1,n=e?0:1;this._32[0]=t[i];const s=this._16[n];let r=this._remappedIndices.get(s);if(void 0===r){r=this.colors.length,this._remappedIndices.set(s,r);const t=this._colorTable[s];this.colors.push(t)}this._16[n]=r,t[i]=this._32[0]}buildColorTable(){return this.colors.length,this.colors.length>1?new Uint32Array(this.colors):Hr.fromAbgr(this.colors[0])}}class ja{_remappedIndices=new Map;_atlasTable;_createMaterial;materials=[];_32=new Uint32Array(1);_8=new Uint8Array(this._32.buffer);constructor(t,e){this._atlasTable=t,this._createMaterial=e}remap(t,e){const i=e?3:2;this._32[0]=t[i];const n=this._8[3];let s=this._remappedIndices.get(n);if(void 0===s){s=this.materials.length/4,this._remappedIndices.set(n,s);let t=4*n;this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t++]),this.materials.push(this._atlasTable[t])}this._8[3]=s,t[i]=this._32[0]}unpackFloat(t){this._32[0]=t;const e=this._32[0],i=(e>>>24)/2;let n=Math.floor(i),s=2*(i-n);return s=-(2*s-1),n-=38,s*(16777215&e)/16777216*Math.pow(10,n)}materialFromAtlasEntry(t){const e=!!(16777216&t[1]),i={alpha:33554432&t[1]?(t[0]>>>24)/255:void 0,diffuse:{color:e?Hr.fromTbgr(16777215&t[0]):void 0,weight:(t[1]>>>8&255)/255},specular:{color:Hr.fromTbgr(t[2]),weight:(t[1]>>>16&255)/255,exponent:this.unpackFloat(t[3])}};return void 0===(n=this._createMaterial(i))?void 0:{isAtlas:!1,material:n};var n}buildAtlasTable(){this.materials.length;const t=new Uint32Array(this.materials);return this.materials.length>4?t:this.materialFromAtlasEntry(t)}}class Ja{vertices;remappedIndices=new Map;indices=new Ga;colors;atlas;usesUnquantizedPositions;constructor(t,e){if(this.vertices=new Qa(t),void 0===t.uniformColor&&(this.colors=new Ha(new Uint32Array(t.data.buffer,t.data.byteOffset+4*t.numVertices*t.numRgbaPerVertex))),e){const i=4*(t.numVertices*t.numRgbaPerVertex+e.offset);this.atlas=new ja(new Uint32Array(t.data.buffer,t.data.byteOffset+i),e.createMaterial)}this.usesUnquantizedPositions=t.usesUnquantizedPositions}addVertex(t,e){let i=this.remappedIndices.get(t);void 0===i&&(i=this.vertices.length,this.remappedIndices.set(t,i),this.colors?.remap(e,this.usesUnquantizedPositions),this.atlas?.remap(e,this.usesUnquantizedPositions),this.vertices.push(e)),this.indices.push(i)}buildOutput(t,e){const i=this.atlas?.buildAtlasTable();let n;if(i instanceof Uint32Array){const t=void 0!==this.colors?.colors.length&&this.colors?.colors.length>1?this.colors?.colors.length:0;n={isAtlas:!0,hasTranslucency:(e?.isAtlas&&e?.hasTranslucency)??!1,overridesAlpha:(e?.isAtlas&&e?.overridesAlpha)??!1,vertexTableOffset:t,numMaterials:i.length/4}}else n=i;return{indices:this.indices.toVertexIndices(),vertices:this.vertices.buildVertexTable(t,this.colors?.buildColorTable(),i),material:n}}}class Ka{_input;_computeNodeId;_nodes=new Map;constructor(t,e){this._input=t,this._computeNodeId=e}static split(t,e){const i=new Ka(t,e);return i.split(),i._nodes}split(){const t={featureIndex:-1,node:void 0},e=this._input.vertices.numRgbaPerVertex,i=new Uint32Array(e),n=new Uint32Array(this._input.vertices.data.buffer,this._input.vertices.data.byteOffset,this._input.vertices.numVertices*e);let s;if(this._input.vertices.usesUnquantizedPositions){const t=new Uint8Array(i.buffer);s=()=>t[3]|t[7]<<8|t[11]<<16}else s=()=>16777215&i[2];for(const r of this._input.indices){const o=r*e;for(let t=0;t<i.length;t++)i[t]=n[o+t];const a=s();if(t.featureIndex!==a){t.featureIndex=a;const e=this._computeNodeId(a);let i=this._nodes.get(e);void 0===i&&this._nodes.set(e,i=new Ja(this._input.vertices,this._input.atlasInfo)),t.node=i}t.node.addVertex(r,i)}}}function $a(t){const e=Ka.split({indices:t.params.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),i=new Map;for(const[n,s]of e){const{vertices:e,indices:r}=s.buildOutput(t.maxDimension);i.set(n,{vertices:e,indices:r,weight:t.params.weight})}return i}class tc{indices=new Ga;prevIndices=new Ga;nextIndicesAndParams=new qa}function ec(t,e,i){for(const[n,s]of i){const i=s.remappedIndices.get(e);if(void 0!==i)return t.index=i,t.node=s,t.id=n,!0}return!1}function ic(t,e,i,n){const s=e[t];if(!s)return;const r=new Uint32Array(s.endPointAndQuadIndices.buffer,s.endPointAndQuadIndices.byteOffset,s.endPointAndQuadIndices.length/4);let o;"silhouettes"===t&&(e.silhouettes,o=new Uint32Array(e.silhouettes.normalPairs.buffer,e.silhouettes.normalPairs.byteOffset,e.silhouettes.normalPairs.length/4));let a=0;const c={};for(const e of s.indices){if(ec(c,e,i)){let e=r[a];const i=(16777215&e)>>>0;e=4278190080&e|c.node.remappedIndices.get(i);let s=n.get(c.id);s||n.set(c.id,s={}),o?(s.silhouettes||(s.silhouettes={indices:new Ga,endPointAndQuadIndices:new qa,normalPairs:new qa}),s.silhouettes.normalPairs.push(o[a])):s.segments||(s.segments={indices:new Ga,endPointAndQuadIndices:new qa});const l=s[t];l.indices.push(c.index),l.endPointAndQuadIndices.push(e)}++a}}function nc(t){const e=new Map,i=t.params.surface.material,n=void 0!==i&&i.isAtlas?i.vertexTableOffset:void 0,s=void 0!==n?{offset:n,createMaterial:t.createMaterial}:void 0,r=Ka.split({indices:t.params.surface.indices,vertices:t.params.vertices,featureTable:t.featureTable,atlasInfo:s},t.computeNodeId),o=t.params.edges?function(t,e,i){const n=new Map;ic("segments",t,e,n),ic("silhouettes",t,e,n),t.polylines&&function(t,e,i){const n=new Uint32Array(t.nextIndicesAndParams.buffer,t.nextIndicesAndParams.byteOffset,t.nextIndicesAndParams.length/4),s=t.prevIndices[Symbol.iterator]();let r=0;const o={};for(const a of t.indices){if(ec(o,a,e)){const t=s.next().value,e=o.node.remappedIndices.get(t);let a=n[r];const c=(16777215&a)>>>0;a=4278190080&a|o.node.remappedIndices.get(c);let l=i.get(o.id);l||i.set(o.id,l={}),l.polylines||(l.polylines=new tc),l.polylines.indices.push(o.index),l.polylines.prevIndices.push(e),l.polylines.nextIndicesAndParams.push(a)}++r}}(t.polylines,e,n),t.indexed&&function(t,e,i){const n=t.edges.data,s=t.edges.numSegments,r=6*s+t.edges.silhouettePadding;function o(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16]}function a(t){return[n[t+0]|n[t+1]<<8|n[t+2]<<16,n[t+3]|n[t+4]<<8|n[t+5]<<16,n[t+6]|n[t+7]<<8,n[t+8]|n[t+9]<<8]}function c(t,e,i,n,s){t.silhouettes.push(255&e),t.silhouettes.push((65280&e)>>>8),t.silhouettes.push((16711680&e)>>>16),t.silhouettes.push(255&i),t.silhouettes.push((65280&i)>>>8),t.silhouettes.push((16711680&i)>>>16),t.silhouettes.push(255&n),t.silhouettes.push((65280&n)>>>8),t.silhouettes.push(255&s),t.silhouettes.push((65280&s)>>>8)}let l=0;for(const e of t.indices)l=Math.max(e,l);const h={};let d=0,u=0,f=0,g=0;for(let t=0,n=0;t<=l;++t)if(t<s?([d,u]=o(n),n+=6):(n=r+10*(t-s),[d,u,f,g]=a(n)),ec(h,d,e)){let e=i.get(h.id);if(e||i.set(h.id,e={}),e.indexed||(e.indexed={edges:new Ua,silhouettes:new Ua}),t<s)m=h.node.remappedIndices.get(d),_=h.node.remappedIndices.get(u),(p=e.indexed).edges.push(255&m),p.edges.push((65280&m)>>>8),p.edges.push((16711680&m)>>>16),p.edges.push(255&_),p.edges.push((65280&_)>>>8),p.edges.push((16711680&_)>>>16);else{const t=h.node.remappedIndices.get(d),i=h.node.remappedIndices.get(u);c(e.indexed,t,i,f,g)}}var p,m,_}(t.indexed,e,n);const s=new Map;for(const[e,r]of n){if(!r.segments&&!r.silhouettes&&!r.indexed)continue;let n={},o={};if(r.indexed){const t=r.indexed.edges.length/6,e=r.indexed.silhouettes.length/10,{width:s,height:a,silhouettePadding:c,silhouetteStartByteIndex:l}=Za(t,e,i),h=new Uint8Array(s*a*4);h.set(r.indexed.edges.toTypedArray(),0),e>0&&h.set(r.indexed.silhouettes.toTypedArray(),l+c);const d=t+e;o=new Wa(new Uint8Array(6*d*3));for(let t=0;t<d;t++)for(let e=0;e<6;e++)o.setNthIndex(6*t+e,t);n={data:h,width:s,height:a,numSegments:t,silhouettePadding:c}}s.set(e,{weight:t.weight,linePixels:t.linePixels,segments:r.segments?{indices:r.segments.indices.toVertexIndices(),endPointAndQuadIndices:r.segments.endPointAndQuadIndices.toUint8Array()}:void 0,silhouettes:r.silhouettes?{indices:r.silhouettes.indices.toVertexIndices(),endPointAndQuadIndices:r.silhouettes.endPointAndQuadIndices.toUint8Array(),normalPairs:r.silhouettes.normalPairs.toUint8Array()}:void 0,polylines:r.polylines?{indices:r.polylines.indices.toVertexIndices(),prevIndices:r.polylines.prevIndices.toVertexIndices(),nextIndicesAndParams:r.polylines.nextIndicesAndParams.toUint8Array()}:void 0,indexed:r.indexed?{indices:o,edges:n}:void 0})}return s}(t.params.edges,r,t.maxDimension):void 0;for(const[i,n]of r){const{vertices:s,indices:r,material:a}=n.buildOutput(t.maxDimension,t.params.surface.material),c={vertices:s,surface:{type:t.params.surface.type,indices:r,fillFlags:t.params.surface.fillFlags,hasBakedLighting:t.params.surface.hasBakedLighting,textureMapping:t.params.surface.textureMapping,material:void 0!==a?a:t.params.surface.material},edges:o?.get(i),isPlanar:t.params.isPlanar,auxChannels:t.params.auxChannels};e.set(i,c)}return e}function sc(t){const e=Ka.split({indices:t.params.polyline.indices,vertices:t.params.vertices,featureTable:t.featureTable},t.computeNodeId),i=t.params.polyline,n=new Uint32Array(i.nextIndicesAndParams.buffer,i.nextIndicesAndParams.byteOffset,i.nextIndicesAndParams.length/4);let s=0;const r={};for(const t of i.prevIndices){if(ec(r,t,e)){const t=r.node;t.prevIndices?t.nextIndicesAndParams:(t.nextIndicesAndParams,t.prevIndices=new Ga(t.indices.numIndices),t.nextIndicesAndParams=new qa({initialCapacity:t.indices.numIndices})),t.prevIndices.push(r.index);let e=n[s];const i=(16777215&e)>>>0;e=4278190080&e|r.node.remappedIndices.get(i),t.nextIndicesAndParams.push(e)}++s}const o=new Map;for(const[i,n]of e){void 0!==n.prevIndices&&n.nextIndicesAndParams;const{vertices:e,indices:s}=n.buildOutput(t.maxDimension),r={...t.params,vertices:e,polyline:{indices:s,prevIndices:n.prevIndices.toVertexIndices(),nextIndicesAndParams:n.nextIndicesAndParams.toUint8Array()}};o.set(i,r)}return o}var rc,oc,ac,cc,lc;function hc(t,e,i){t[e+0]=255&i,t[e+1]=(65280&i)>>>8,t[e+2]=(16711680&i)>>>16}!function(t){t[t.Untransformed=4294967295]="Untransformed"}(rc||(rc={})),function(t){t[t.Hidden=0]="Hidden",t[t.Silhouette=1]="Silhouette",t[t.Visible=2]="Visible"}(oc||(oc={}));class dc{static reThrowImmediate=t=>{throw t};static reThrowDeferred=t=>setTimeout((()=>{throw t}),0);static consoleLog=t=>console.error(t);static errorLog=t=>fc.logException("unhandled",t);static _telemetry=[];static _handler=this.errorLog;constructor(){}static addTelemetry(t){return this._telemetry.push(t),()=>this._telemetry.splice(this._telemetry.indexOf(t),1)}static handle(t,e=!0){this._handler(t),e&&this._telemetry.forEach((e=>{try{e(t)}catch{}}))}static setHandler(t){const e=this._handler;return this._handler=t,e}}class uc{_listeners=[];_insideRaiseEvent=!1;get numberOfListeners(){return this._listeners.length}addListener(t,e){return this._listeners.push({listener:t,scope:e,once:!1}),()=>this.removeListener(t,e)}addOnce(t,e){return this._listeners.push({listener:t,scope:e,once:!0}),()=>this.removeListener(t,e)}removeListener(t,e){const i=this._listeners;for(let n=0;n<i.length;++n){const s=i[n];if(s.listener===t&&s.scope===e)return this._insideRaiseEvent?s.listener=void 0:i.splice(n,1),!0}return!1}raiseEvent(...t){this._insideRaiseEvent=!0;const e=this._listeners,i=e.length;let n=!1;for(let s=0;s<i;++s){const i=e[s];if(i.listener){try{i.listener.apply(i.scope,t)}catch(t){dc.handle(t)}i.once&&(i.listener=void 0,n=!0)}else n=!0}n&&(this._listeners=this._listeners.filter((t=>void 0!==t.listener))),this._insideRaiseEvent=!1}has(t,e){for(const i of this._listeners)if(i.listener===t&&i.scope===e)return!0;return!1}clear(){this._listeners.length=0}}!function(t){t.Performance="Performance"}(ac||(ac={})),function(t){t[t.Trace=0]="Trace",t[t.Info=1]="Info",t[t.Warning=2]="Warning",t[t.Error=3]="Error",t[t.None=4]="None"}(cc||(cc={}));class fc{static _logError;static _logWarning;static _logInfo;static _logTrace;static _onLogLevelChanged;static _staticMetaData=new Map;static get onLogLevelChanged(){return void 0===fc._onLogLevelChanged&&(fc._onLogLevelChanged=new uc),fc._onLogLevelChanged}static _categoryFilter={};static get categoryFilter(){return this._categoryFilter}static _minLevel;static get minLevel(){return this._minLevel}static logExceptionCallstacks=!1;static get staticMetaData(){return this._staticMetaData}static initialize(t,e,i,n){fc._logError=t,fc._logWarning=e,fc._logInfo=i,fc._logTrace=n,fc.turnOffLevelDefault(),fc.turnOffCategories()}static initializeToConsole(){const t=t=>(e,i,n)=>console.log(`${t} | ${e} | ${i} ${fc.stringifyMetaData(n)}`);fc.initialize(t("Error"),t("Warning"),t("Info"),t("Trace"))}static getMetaData(t){const e={};for(const t of this._staticMetaData){const i=fa.getMetaData(t[1]);i&&Object.assign(e,i)}return Object.assign(e,fa.getMetaData(t)),e}static stringifyMetaData(t){const e=this.getMetaData(t);return Object.keys(e).length>0?JSON.stringify(e):""}static setLevelDefault(t){this._minLevel=t,this.onLogLevelChanged.raiseEvent()}static setLevel(t,e){fc._categoryFilter[t]=e,this.onLogLevelChanged.raiseEvent()}static parseLogLevel(t){switch(t.toUpperCase()){case"EXCEPTION":case"FATAL":case"ERROR":return cc.Error;case"WARNING":return cc.Warning;case"INFO":return cc.Info;case"TRACE":case"DEBUG":return cc.Trace}return cc.None}static configureLevels(t){if(fc.validateProps(t),void 0!==t.defaultLevel&&this.setLevelDefault(fc.parseLogLevel(t.defaultLevel)),void 0!==t.categoryLevels)for(const e of t.categoryLevels)this.setLevel(e.category,fc.parseLogLevel(e.logLevel))}static isLogLevel(t){return cc.hasOwnProperty(t)}static validateProps(t){const e=["defaultLevel","categoryLevels"];for(const i of Object.keys(t)){if(!e.includes(i))throw new fa(Ro.BadArg,`LoggerLevelsConfig - unrecognized property: ${i}`);if("defaultLevel"===i){if(!fc.isLogLevel(t.defaultLevel))throw new fa(Ro.BadArg,`LoggerLevelsConfig.defaultLevel must be a LogLevel. Invalid value: ${JSON.stringify(t.defaultLevel)}`)}else if("categoryLevels"===i){const e=t[i];if(!Array.isArray(e))throw new fa(Ro.BadArg,`LoggerLevelsConfig.categoryLevels must be an array. Invalid value: ${JSON.stringify(e)}`);for(const e of t[i]){if(!e.hasOwnProperty("category")||!e.hasOwnProperty("logLevel"))throw new fa(Ro.BadArg,`LoggerLevelsConfig.categoryLevels - each item must be a LoggerCategoryAndLevel {category: logLevel:}. Invalid value: ${JSON.stringify(e)}`);if(!fc.isLogLevel(e.logLevel))throw new fa(Ro.BadArg,`LoggerLevelsConfig.categoryLevels - each item's logLevel property must be a LogLevel. Invalid value: ${JSON.stringify(e.logLevel)}`)}}}}static getLevel(t){const e=fc.categoryFilter[t];if(void 0!==e)return e;const i=t.lastIndexOf(".");return-1!==i?fc.getLevel(t.slice(0,i)):fc.minLevel}static turnOffLevelDefault(){fc._minLevel=void 0}static turnOffCategories(){fc._categoryFilter={}}static isEnabled(t,e){const i=fc.getLevel(t);return void 0!==i&&e>=i}static logError(t,e,i){fc._logError&&fc.isEnabled(t,cc.Error)&&fc._logError(t,e,i)}static getExceptionMessage(t){if(void 0===t)return"Error: err is undefined.";if(null===t)return"Error: err is null.";const e=fc.logExceptionCallstacks?`\n${fa.getErrorStack(t)}`:"";return fa.getErrorMessage(t)+e}static logException(t,e,i=(t,e,i)=>fc.logError(t,e,i)){i(t,fc.getExceptionMessage(e),(()=>fa.isError(e)?{...fa.getErrorMetadata(e),exceptionType:e?.constructor?.name??"<Unknown>"}:{...e}))}static logWarning(t,e,i){fc._logWarning&&fc.isEnabled(t,cc.Warning)&&fc._logWarning(t,e,i)}static logInfo(t,e,i){fc._logInfo&&fc.isEnabled(t,cc.Info)&&fc._logInfo(t,e,i)}static logTrace(t,e,i){fc._logTrace&&fc.isEnabled(t,cc.Trace)&&fc._logTrace(t,e,i)}}cc.Info,Symbol.dispose,function(t){t.Package="core-frontend",t.IModelConnection="core-frontend.IModelConnection",t.NativeApp="core-frontend.NativeApp",t.Request="core-frontend.Request",t.FeatureTracking="core-frontend.FeatureTracking",t.RealityData="core-frontend.RealityData",t.Render="core-frontend.Render",t.Extensions="core-frontend.Extensions"}(lc||(lc={}));let gc,pc=!1;class mc extends ga{gltfLength;scenePosition=0;sceneStrLength=0;binaryPosition=0;get isValid(){return Lo.Gltf===this.format}constructor(t){super(t),this.gltfLength=t.readUint32(),this.sceneStrLength=t.readUint32();const e=t.readUint32();if(this.version===Vo.Version2&&e===Vo.Gltf1SceneFormat&&(this.version=Vo.Version1),this.version===Vo.Version1){const i=e;if(Vo.Gltf1SceneFormat!==i)return void this.invalidate();this.scenePosition=t.curPos,this.binaryPosition=t.curPos+this.sceneStrLength}else if(this.version===Vo.Version2){const i=e;this.scenePosition=t.curPos,t.curPos=t.curPos+this.sceneStrLength;const n=t.readUint32(),s=t.readUint32();if(Uo.JSON!==i||Uo.Binary!==s||0===n)return void this.invalidate();this.binaryPosition=t.curPos}else this.invalidate()}}const _c=/Node_(.*)/;function xc(t){const e=t.match(_c);if(!!e&&e.length,!e||2!==e.length)return 0;const i=Number.parseInt(e[1],10);return Number.isNaN(i),Number.isNaN(i)?0:i}class yc extends ma{constructor(t){super(t)}dispose(){}get bytesUsed(){return 0}}class vc extends yc{_name;constructor(t,e){super(e),this._name=t}toImdl(){return this._name}}class Pc extends yc{_gradient;constructor(t){super(ma.Type.Normal),this._gradient=t}toImdl(){return this._gradient}}class Ic extends _a{materialParams;toImdl(){return{isAtlas:!1,material:this.key??this.materialParams}}constructor(t,e){super(t),this.materialParams=e??{alpha:t.alpha,diffuse:{color:t.diffuseColor?.toJSON(),weight:t.diffuse},specular:{color:t.specularColor?.toJSON(),weight:t.specular,exponent:t.specularExponent}}}static create(t){const e=new xa;return e.alpha=t.alpha,t.diffuse&&(void 0!==t.diffuse.weight&&(e.diffuse=t.diffuse?.weight),t.diffuse?.color&&(e.diffuseColor=t.diffuse.color instanceof Hr?t.diffuse.color:jr.fromJSON(t.diffuse.color).toColorDef())),t.specular&&(void 0!==t.specular.weight&&(e.specular=t.specular.weight),void 0!==t.specular.exponent&&(e.specularExponent=t.specular.exponent),t.specular.color&&(e.specularColor=t.specular.color instanceof Hr?t.specular.color:jr.fromJSON(t.specular.color).toColorDef())),new Ic(e)}}function Sc(t){return{...t,uniformColor:void 0!==t.uniformColor?Hr.fromJSON(t.uniformColor):void 0,qparams:Pa.fromJSON(t.qparams),uvParams:t.uvParams?ya.fromJSON(t.uvParams):void 0}}function bc(t){return{...t,uniformColor:t.uniformColor?.toJSON(),qparams:t.qparams.toJSON(),uvParams:t.uvParams?.toJSON()}}function Ac(t){return{...t,segments:t.segments?{...t.segments,indices:t.segments.indices.data}:void 0,silhouettes:t.silhouettes?{...t.silhouettes,indices:t.silhouettes.indices.data}:void 0,polylines:t.polylines?{...t.polylines,indices:t.polylines.indices.data,prevIndices:t.polylines.prevIndices.data}:void 0,indexed:t.indexed?{indices:t.indexed.indices.data,edges:t.indexed.edges}:void 0}}class Cc{_document;_binaryData;_options;_featureTableInfo;_patterns=new Map;_stream;_timeline;_meshoptDecoder;constructor(t,e,i,n,s){this._document=t,this._binaryData=e,this._options=i,this._featureTableInfo=n,this._stream=s,this._timeline=i.timeline}async parse(){const t=this.parseFeatureTable();if(!t)return Yo.InvalidFeatureTable;if(this.hasMeshoptCompression()&&(this._meshoptDecoder=await async function(){return pc||(gc=await async function(){const t=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),e=new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);if("object"!=typeof WebAssembly)return void fc.logError(lc.Render,"WebAssembly is not supported in this environment");const i=WebAssembly.validate(t)?s("b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;b9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;e8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincbhHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAcd0hHalhOaAcefgAclSmdxekkcbhlaHceGTmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;tzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhrcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgDc;Ve0mbavc;abfalaDcu7gPcl4fcsGcitfgsydlhzasydbhHdnaDcsGgDak9pmbavaiaPfcsGcdtfydbaxaDEhsaDThDdndnadcd9hmbabarcetfgPaH87ebaPcdfaz87ebaPclfas87ebxekabarcdtfgPaHBdbaPclfazBdbaPcwfasBdbkaxaDfhxavc;abfalcitfgPasBdbaPazBdlavaicdtfasBdbavc;abfalcefcsGglcitfgPaHBdbaPasBdlaiaDfhialcefhlxdkdndnaDcsSmbamaDfaDc987fcefhmxekaocefhDao8SbbgscFeGhPdndnascu9mmbaDhoxekaocvfhoaPcFbGhPcrhsdninaD8SbbgOcFbGastaPVhPaOcu9kmeaDcefhDascrfgsc8J9hmbxdkkaDcefhokaPce4cbaPceG9R7amfhmkdndnadcd9hmbabarcetfgDaH87ebaDcdfaz87ebaDclfam87ebxekabarcdtfgDaHBdbaDclfazBdbaDcwfamBdbkavc;abfalcitfgDamBdbaDazBdlavaicdtfamBdbavc;abfalcefcsGglcitfgDaHBdbaDamBdlaicefhialcefhlxekdnaDcpe0mbaxcefgOavaiaqaDcsGfRbbgscl49RcsGcdtfydbascz6gPEhDavaias9RcsGcdtfydbaOaPfgzascsGgOEhsaOThOdndnadcd9hmbabarcetfgHax87ebaHcdfaD87ebaHclfas87ebxekabarcdtfgHaxBdbaHclfaDBdbaHcwfasBdbkavaicdtfaxBdbavc;abfalcitfgHaDBdbaHaxBdlavaicefgicsGcdtfaDBdbavc;abfalcefcsGcitfgHasBdbaHaDBdlavaiaPfcsGgicdtfasBdbavc;abfalcdfcsGglcitfgDaxBdbaDasBdlalcefhlaiaOfhiazaOfhxxekaxcbaoRbbgHEgAaDc;:eSgDfhzaHcsGhCaHcl4hXdndnaHcs0mbazcefhOxekazhOavaiaX9RcsGcdtfydbhzkdndnaCmbaOcefhxxekaOhxavaiaH9RcsGcdtfydbhOkdndnaDTmbaocefhDxekaocdfhDao8SbegPcFeGhsdnaPcu9kmbaocofhAascFbGhscrhodninaD8SbbgPcFbGaotasVhsaPcu9kmeaDcefhDaocrfgoc8J9hmbkaAhDxekaDcefhDkasce4cbasceG9R7amfgmhAkdndnaXcsSmbaDhsxekaDcefhsaD8SbbgocFeGhPdnaocu9kmbaDcvfhzaPcFbGhPcrhodninas8SbbgDcFbGaotaPVhPaDcu9kmeascefhsaocrfgoc8J9hmbkazhsxekascefhskaPce4cbaPceG9R7amfgmhzkdndnaCcsSmbashoxekascefhoas8SbbgDcFeGhPdnaDcu9kmbascvfhOaPcFbGhPcrhDdninao8SbbgscFbGaDtaPVhPascu9kmeaocefhoaDcrfgDc8J9hmbkaOhoxekaocefhokaPce4cbaPceG9R7amfgmhOkdndnadcd9hmbabarcetfgDaA87ebaDcdfaz87ebaDclfaO87ebxekabarcdtfgDaABdbaDclfazBdbaDcwfaOBdbkavc;abfalcitfgDazBdbaDaABdlavaicdtfaABdbavc;abfalcefcsGcitfgDaOBdbaDazBdlavaicefgicsGcdtfazBdbavc;abfalcdfcsGcitfgDaABdbaDaOBdlavaiaHcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiarcifgrae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:wPliuo97eue978Jjjjjbca9Rhiaec98Ghldndnadcl9hmbdnalTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaipxbbbbbbbbbbbbbbbbgqpklbaiabalcdtfgdaeciGglcdtgv;8qbbdnalTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDaqp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkadaiav;8qbbskdnalTmbcbhvabhdinadczfgxaxpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgval6mbkkalae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabalcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbheabhdinadadpbbbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepkbbadczfhdaeclfgeav6mbkkdnaval9pmbaialciGgecdtgdVcbc;abad9R;8kbaiabavcdtfgvad;8qbbdnaeTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjFbbjFbbjFbbjFp9opxbbjZbbjZbbjZbbjZp:Uep;Mepklbkavaiad;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb"):s("b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq;d8Yqdbk:yzeHu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhlaicefhodnadTmbalc;WFbGglcjdalcjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfglcl4cifcd4hxdndndndnalc9WGgmTmbcbhPcehsawcjdfhzaohHinaraH9Rax6midnaraHaxfgo9RcK6mbczhlcbhOinalgic9WfgAawcj;cbffhldndndndndnaHaAco4fRbbaOcoG4ciGPlbedibkal9cb83ibalcwf9cb83ibxikalaoRblaoRbbgAco4gCaCciSgCE86bbawcj;cbfaifglcGfaoclfaCfgCRbbaAcl4ciGgXaXciSgXE86bbalcVfaCaXfgCRbbaAcd4ciGgXaXciSgXE86bbalc7faCaXfgCRbbaAciGgAaAciSgAE86bbalctfaCaAfgCRbbaoRbegAco4gXaXciSgXE86bbalc91faCaXfgCRbbaAcl4ciGgXaXciSgXE86bbalc4faCaXfgCRbbaAcd4ciGgXaXciSgXE86bbalc93faCaXfgCRbbaAciGgAaAciSgAE86bbalc94faCaAfgCRbbaoRbdgAco4gXaXciSgXE86bbalc95faCaXfgCRbbaAcl4ciGgXaXciSgXE86bbalc96faCaXfgCRbbaAcd4ciGgXaXciSgXE86bbalc97faCaXfgCRbbaAciGgAaAciSgAE86bbalc98faCaAfgARbbaoRbigoco4gCaCciSgCE86bbalc99faAaCfgARbbaocl4ciGgCaCciSgCE86bbalc9:faAaCfgARbbaocd4ciGgCaCciSgCE86bbalcufaAaCfglRbbaociGgoaociSgoE86bbalaofhoxdkalaoRbwaoRbbgAcl4gCaCcsSgCE86bbawcj;cbfaifglcGfaocwfaCfgCRbbaAcsGgAaAcsSgAE86bbalcVfaCaAfgARbbaoRbegCcl4gXaXcsSgXE86bbalc7faAaXfgARbbaCcsGgCaCcsSgCE86bbalctfaAaCfgARbbaoRbdgCcl4gXaXcsSgXE86bbalc91faAaXfgARbbaCcsGgCaCcsSgCE86bbalc4faAaCfgARbbaoRbigCcl4gXaXcsSgXE86bbalc93faAaXfgARbbaCcsGgCaCcsSgCE86bbalc94faAaCfgARbbaoRblgCcl4gXaXcsSgXE86bbalc95faAaXfgARbbaCcsGgCaCcsSgCE86bbalc96faAaCfgARbbaoRbvgCcl4gXaXcsSgXE86bbalc97faAaXfgARbbaCcsGgCaCcsSgCE86bbalc98faAaCfgARbbaoRbogCcl4gXaXcsSgXE86bbalc99faAaXfgARbbaCcsGgCaCcsSgCE86bbalc9:faAaCfgARbbaoRbrgocl4gCaCcsSgCE86bbalcufaAaCfglRbbaocsGgoaocsSgoE86bbalaofhoxekalao8Pbb83bbalcwfaocwf8Pbb83bbaoczfhokdnaiam9pmbaOcdfhOaiczfhlarao9RcL0mekkaiam6miaoTmidnakTmbawaPfRbbhOawcj;cbfhlazhiakhAinaialRbbgHce4cbaHceG9R7aOfgO86bbaiadfhialcefhlaAcufgAmbkkazcefhzaPcefgPad6hsaohHaPad9hmexvkkcbhoasceGmdxikaoaxad2fhXdnakTmbcbhmcehsawcjdfhCinarao9Rax6miaoTmdaoaxfhoawamfRbbhOawcj;cbfhlaChiakhAinaialRbbgHce4cbaHceG9R7aOfgO86bbaiadfhialcefhlaAcufgAmbkaCcefhCamcefgmad6hsamad9hmbkaXhoxikcbhlcehsinarao9Rax6mdaoTmeaoaxfhoalcefglad6hsadal9hmbkaXhoxdkcbhoasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqaombkc9:hoxekcbc99arao9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;xzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhrcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgDc;Ve0mbavc;abfalaDcu7gPcl4fcsGcitfgsydlhzasydbhHdnaDcsGgDak9pmbavaiaPfcsGcdtfydbaxaDEhsaDThDdndnadcd9hmbabarcetfgPaH87ebaPcdfaz87ebaPclfas87ebxekabarcdtfgPaHBdbaPclfazBdbaPcwfasBdbkaxaDfhxavc;abfalcitfgPasBdbaPazBdlavaicdtfasBdbavc;abfalcefcsGglcitfgPaHBdbaPasBdlaiaDfhialcefhlxdkdndnaDcsSmbamaDfaDc987fcefhmxekaocefhDao8SbbgscFeGhPdndnascu9mmbaDhoxekaocvfhoaPcFbGhPcrhsdninaD8SbbgOcFbGastaPVhPaOcu9kmeaDcefhDascrfgsc8J9hmbxdkkaDcefhokaPce4cbaPceG9R7amfhmkdndnadcd9hmbabarcetfgDaH87ebaDcdfaz87ebaDclfam87ebxekabarcdtfgDaHBdbaDclfazBdbaDcwfamBdbkavc;abfalcitfgDamBdbaDazBdlavaicdtfamBdbavc;abfalcefcsGglcitfgDaHBdbaDamBdlaicefhialcefhlxekdnaDcpe0mbaxcefgOavaiaqaDcsGfRbbgscl49RcsGcdtfydbascz6gPEhDavaias9RcsGcdtfydbaOaPfgzascsGgOEhsaOThOdndnadcd9hmbabarcetfgHax87ebaHcdfaD87ebaHclfas87ebxekabarcdtfgHaxBdbaHclfaDBdbaHcwfasBdbkavaicdtfaxBdbavc;abfalcitfgHaDBdbaHaxBdlavaicefgicsGcdtfaDBdbavc;abfalcefcsGcitfgHasBdbaHaDBdlavaiaPfcsGgicdtfasBdbavc;abfalcdfcsGglcitfgDaxBdbaDasBdlalcefhlaiaOfhiazaOfhxxekaxcbaoRbbgHEgAaDc;:eSgDfhzaHcsGhCaHcl4hXdndnaHcs0mbazcefhOxekazhOavaiaX9RcsGcdtfydbhzkdndnaCmbaOcefhxxekaOhxavaiaH9RcsGcdtfydbhOkdndnaDTmbaocefhDxekaocdfhDao8SbegPcFeGhsdnaPcu9kmbaocofhAascFbGhscrhodninaD8SbbgPcFbGaotasVhsaPcu9kmeaDcefhDaocrfgoc8J9hmbkaAhDxekaDcefhDkasce4cbasceG9R7amfgmhAkdndnaXcsSmbaDhsxekaDcefhsaD8SbbgocFeGhPdnaocu9kmbaDcvfhzaPcFbGhPcrhodninas8SbbgDcFbGaotaPVhPaDcu9kmeascefhsaocrfgoc8J9hmbkazhsxekascefhskaPce4cbaPceG9R7amfgmhzkdndnaCcsSmbashoxekascefhoas8SbbgDcFeGhPdnaDcu9kmbascvfhOaPcFbGhPcrhDdninao8SbbgscFbGaDtaPVhPascu9kmeaocefhoaDcrfgDc8J9hmbkaOhoxekaocefhokaPce4cbaPceG9R7amfgmhOkdndnadcd9hmbabarcetfgDaA87ebaDcdfaz87ebaDclfaO87ebxekabarcdtfgDaABdbaDclfazBdbaDcwfaOBdbkavc;abfalcitfgDazBdbaDaABdlavaicdtfaABdbavc;abfalcefcsGcitfgDaOBdbaDazBdlavaicefgicsGcdtfazBdbavc;abfalcdfcsGcitfgDaABdbaDaOBdlavaiaHcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiarcifgrae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:flevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaic8Etc8F91aicd47avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabaiavcefciGfcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabaiavcdfciGfcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabaiavcufciGfcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabaiavciGfcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2gdTmbinababydbgecwtcw91:Yaece91cjjj98Gcjjj;8if::NUdbabclfhbadcufgdmbkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaeczfheaiczfhiadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb");let n;try{const t=await WebAssembly.instantiate(i,{});n=t.instance,n.exports.__wasm_call_ctors()}catch(t){return void fc.logException(lc.Render,t)}function s(t){const i=new Uint8Array(t.length);for(let e=0;e<t.length;++e){const n=t.charCodeAt(e);i[e]=n>96?n-97:n>64?n-39:n+4}let n=0;for(let s=0;s<t.length;++s)i[n++]=i[s]<60?e[i[s]]:64*(i[s]-60)+i[++s];return i.buffer.slice(0,n)}function r(t,e,i,s,r,o){const a=n.exports[t],c=n.exports.sbrk,l=i+3&-4,h=c(l*s),d=c(r.length),u=new Uint8Array(n.exports.memory.buffer);u.set(r,d);const f=a(h,i,s,d,r.length);if(0===f&&o&&o(h,l,s),e.set(u.subarray(h,h+i*s)),c(h-c(0)),0!==f)throw new Error(`Malformed buffer data: ${f}`)}const o={ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"},a={NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"};return{decodeVertexBuffer(t,e,i,s,c){r(o.ATTRIBUTES,t,e,i,s,c?n.exports[a[c]]:void 0)},decodeIndexBuffer(t,e,i,n){r(o.TRIANGLES,t,e,i,n)},decodeIndexSequence(t,e,i,n){r(o.INDICES,t,e,i,n)},decodeGltfBuffer(t,e,i,s,c,l){r(o[c],t,e,i,s,l?n.exports[a[l]]:void 0)}}}(),pc=!0),gc}(),!this._meshoptDecoder))return Yo.InvalidTileData;const e=this._document.rtcCenter?{x:this._document.rtcCenter[0]??0,y:this._document.rtcCenter[1]??0,z:this._document.rtcCenter[2]??0}:void 0,i=this.parseNodes(t);return{featureTable:t,nodes:this.groupPrimitiveNodes(i,t),rtcCenter:e,binaryData:this._binaryData,json:this._document,patterns:this._patterns}}hasMeshoptCompression(){let t=!1;for(const e of Object.keys(this._document.meshes)){const i=this._document.meshes[e];i?.primitives?.forEach((e=>{if("areaPattern"!==e.type){const i=e,n=i.vertices;n.compressedSize&&n.compressedSize>0&&(t=!0);const s=i.surface;s&&s.compressedIndexCount&&s.compressedIndexCount>0&&(t=!0)}}))}return t}parseFeatureTable(){this._stream.curPos=this._featureTableInfo.startPos;const t=ba.readFrom(this._stream);if(!t||0!=t.length%4)return;const e=(t.length-ba.sizeInBytes)/4,i=new Uint32Array(this._stream.nextUint32s(e));if(this._stream.isPastTheEnd)return;let n;if(this._featureTableInfo.multiModel)n={multiModel:!0,data:i,numFeatures:t.count,numSubCategories:t.numSubCategories};else{let e;const s=this._document.animationNodes;if(void 0!==s){const t=Ao.asInt(s.bytesPerId),i=Ao.asString(s.bufferView),n=this._document.bufferViews[i];if(void 0!==n){const i=Ao.asInt(n.byteOffset),s=Ao.asInt(n.byteLength),r=this._binaryData.subarray(i,i+s);switch(t){case 1:e=new Uint8Array(r);break;case 2:e=Uint16Array.from(new Uint16Array(r.buffer,r.byteOffset,r.byteLength/2));break;case 4:e=Uint32Array.from(new Uint32Array(r.buffer,r.byteOffset,r.byteLength/4))}}}n={multiModel:!1,data:i,numFeatures:t.count,animationNodeIds:e}}return this._stream.curPos=this._featureTableInfo.startPos+t.length,n}parseNodes(t){const e=[],i=this._document.nodes,n=this._document.meshes;if(void 0===i.Node_Root)return e;for(const s of Object.keys(i)){const i=n[this._document.nodes[s]],r=i?.primitives;if(!r)continue;const o=i.layer;"Node_Root"===s?this._timeline?this.parseAnimationBranches(e,i,t,this._timeline):this._options.createUntransformedRootNode?e.push({animationNodeId:rc.Untransformed,primitives:this.parseNodePrimitives(r)}):e.push({primitives:this.parseNodePrimitives(r)}):void 0===o?e.push({animationNodeId:xc(s),animationId:`${this._options.batchModelId}_${s}`,primitives:this.parseNodePrimitives(r)}):e.push({layerId:o,primitives:this.parseNodePrimitives(r)})}return e}parseAnimationBranches(t,e,i,n){const s=e.primitives;if(!s)return;const r=s.map((t=>this.parseNodePrimitive(t))).filter((t=>void 0!==t));if(0===r.length)return;const o=new Map;i.animationNodeIds;const a=Tc(i,this._options.batchModelId);a.populateAnimationNodeIds((t=>n.getBatchIdForFeature(t)),n.maxBatchId),i.animationNodeIds=a.animationNodeIds;const c=n.discreteBatchIds;this.splitPrimitives(r,a,(t=>{const e=a.getAnimationNodeId(t);return 0!==e&&c.has(e)?e:0}),(e=>{e=e??rc.Untransformed;let i=o.get(e);return i||(i={animationNodeId:e,animationId:`${this._options.batchModelId}_Node_${e}`,primitives:[]},o.set(e,i),t.push(i)),i}))}splitPrimitives(t,e,i,n){const s={maxDimension:this._options.maxVertexTableSize,computeNodeId:i,featureTable:e},r=t=>{if(!t)return;if(t.isAtlas)return t;const e="string"==typeof t.material?this.materialFromJson(t.material):Ic.create(function(t){const e={alpha:t.alpha};return t.diffuse&&(e.diffuse={weight:t.diffuse.weight,color:void 0!==t.diffuse.color?Hr.fromJSON(t.diffuse.color):void 0}),t.specular&&(e.specular={weight:t.specular.weight,exponent:t.specular.exponent,color:void 0!==t.specular.color?Hr.fromJSON(t.specular.color):void 0}),e}(t.material));return e?{isAtlas:!1,material:e}:void 0};for(const e of t)switch(e.type){case"pattern":n(void 0).primitives.push(e);break;case"mesh":{const t=e.params,i=t.surface.textureMapping,a={vertices:Sc(e.params.vertices),surface:{...e.params.surface,indices:new Wa(e.params.surface.indices),material:r(t.surface.material),textureMapping:i?{alwaysDisplayed:i.alwaysDisplayed,texture:"string"==typeof i.texture?new vc(i.texture,ma.Type.Normal):new Pc(i.texture)}:void 0},edges:e.params.edges?(o=e.params.edges,{...o,segments:o.segments?{...o.segments,indices:new Wa(o.segments.indices)}:void 0,silhouettes:o.silhouettes?{...o.silhouettes,indices:new Wa(o.silhouettes.indices)}:void 0,polylines:o.polylines?{...o.polylines,indices:new Wa(o.polylines.indices),prevIndices:new Wa(o.polylines.prevIndices)}:void 0,indexed:o.indexed?{indices:new Wa(o.indexed.indices),edges:o.indexed.edges}:void 0}):void 0,isPlanar:e.params.isPlanar,auxChannels:e.params.auxChannels?Xa.fromJSON(e.params.auxChannels):void 0},c=nc({...s,params:a,createMaterial:t=>Ic.create(t)});for(const[t,i]of c){let s;i.surface.material&&(i.surface.material.isAtlas?s=i.surface.material:(i.surface.material.material,s=i.surface.material.material.toImdl())),void 0===i.surface.textureMapping||i.surface.textureMapping.texture,n(t).primitives.push({type:"mesh",modifier:e.modifier,params:{vertices:bc(i.vertices),surface:{...i.surface,indices:i.surface.indices.data,material:s,textureMapping:i.surface.textureMapping?.texture instanceof yc?{texture:i.surface.textureMapping.texture.toImdl(),alwaysDisplayed:i.surface.textureMapping.alwaysDisplayed}:void 0},edges:i.edges?Ac(i.edges):void 0,isPlanar:i.isPlanar,auxChannels:i.auxChannels?.toJSON()}})}break}case"point":{const t={vertices:Sc(e.params.vertices),indices:new Wa(e.params.indices),weight:e.params.weight},i=$a({...s,params:t});for(const[t,s]of i)n(t).primitives.push({type:"point",modifier:e.modifier,params:{vertices:bc(s.vertices),indices:s.indices.data,weight:s.weight}});break}case"polyline":{const t={...e.params,vertices:Sc(e.params.vertices),polyline:{indices:new Wa(e.params.polyline.indices),prevIndices:new Wa(e.params.polyline.prevIndices),nextIndicesAndParams:e.params.polyline.nextIndicesAndParams}},i=sc({...s,params:t});for(const[t,s]of i)n(t).primitives.push({type:"polyline",modifier:e.modifier,params:{...s,vertices:bc(s.vertices),polyline:{indices:s.polyline.indices.data,prevIndices:s.polyline.prevIndices.data,nextIndicesAndParams:s.polyline.nextIndicesAndParams}}});break}}var o}groupPrimitiveNodes(t,e){const i=this._options.modelGroups;if(!i?.length)return t;const n=[];let s;const r=t=>{if(i.length,t===i.length)return s??(s={groupId:t,nodes:[]});let e=n[t];return e||(n[t]=e={groupId:t,nodes:[]}),e},o=Tc(e,this._options.batchModelId),a={lower:0,upper:0},l=t=>{o.getModelIdPair(t,a);const e=c.fromUint32PairObject(a);for(let t=0;t<i.length;t++)if(i[t].has(e))return t;return i.length};for(const e of t){const t=[],n=n=>{if(n=n??i.length,!t[n]){const i=t[n]={...e,primitives:[]};r(n).nodes.push(i)}return t[n]};this.splitPrimitives(e.primitives,o,l,n)}return n.filter((t=>void 0!==t))}parseTesselatedPolyline(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.prevIndices),n=this.findBuffer(t.nextIndicesAndParams);return e&&i&&n?{indices:e,prevIndices:i,nextIndicesAndParams:n}:void 0}parseSegmentEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.endPointAndQuadIndices);return e&&i?{indices:e,endPointAndQuadIndices:i}:void 0}parseSilhouetteEdges(t){const e=this.parseSegmentEdges(t),i=this.findBuffer(t.normalPairs);return e&&i?{...e,normalPairs:i}:void 0}parseIndexedEdges(t){const e=this.findBuffer(t.indices),i=this.findBuffer(t.edges);if(e&&i)return{indices:e,edges:{data:i,width:t.width,height:t.height,silhouettePadding:t.silhouettePadding,numSegments:t.numSegments}}}parseCompactEdges(t,e){const i=this.findBuffer(t.visibility);if(!i)return;const n=void 0!==t.normalPairs?this.findBuffer(t.normalPairs):void 0;return function(t){const e=t.normalPairs?.length??0,i=t.numVisibleEdges+e;if(i<=0)return;const n=new Wa(new Uint8Array(6*i*3));for(let t=0;t<i;t++)for(let e=0;e<6;e++)n.setNthIndex(6*t+e,t);const{width:s,height:r,silhouettePadding:o,silhouetteStartByteIndex:a}=Za(t.numVisibleEdges,e,t.maxEdgeTableDimension),c=new Uint8Array(s*r*4);let l=0,h=0;for(const e of function*(t,e,i){let n=0,s=0,r=0;const o={index0:0,index1:1};for(let a=0;a<e.length;a++){const c=t[s]>>n&3;n+=2,8===n&&(n=0,s++),oc.Hidden!==c&&(o.index0=e.decodeIndex(a),o.index1=e.decodeIndex(a%3==2?a-2:a+1),oc.Silhouette===c?o.normals=i[r++]:o.normals=void 0,yield o)}}(t.visibility,t.vertexIndices,t.normalPairs))if(void 0===e.normals){const t=6*l++;hc(c,t,e.index0),hc(c,t+3,e.index1)}else{const t=a+o+10*h++;hc(c,t,e.index0),hc(c,t+3,e.index1),c[t+6]=255&e.normals,c[t+7]=(65280&e.normals)>>>8,c[t+8]=(16711680&e.normals)>>>16,c[t+9]=(4278190080&e.normals)>>>24}return{indices:n.data,edges:{data:c,width:s,height:r,numSegments:t.numVisibleEdges,silhouettePadding:o}}}({numVisibleEdges:t.numVisible,visibility:i,vertexIndices:e,normalPairs:n?new Uint32Array(n.buffer,n.byteOffset,n.byteLength/4):void 0,maxEdgeTableDimension:this._options.maxVertexTableSize})}parseEdges(t,e,i){if(!t)return;const n=t.segments?this.parseSegmentEdges(t.segments):void 0,s=t.silhouettes?this.parseSilhouetteEdges(t.silhouettes):void 0,r=t.polylines?this.parseTesselatedPolyline(t.polylines):void 0;let o=t.indexed?this.parseIndexedEdges(t.indexed):void 0;return!o&&t.compact&&(o=this.parseCompactEdges(t.compact,new Wa(i))),n||s||o||r?{segments:n,silhouettes:s,polylines:r,indexed:o,weight:e.width,linePixels:e.linePixels}:void 0}getPattern(t){let e=this._patterns.get(t);if(!e){const i=this._document.patternSymbols[t];e=i?this.parsePrimitives(i.primitives):[],this._patterns.set(t,e)}return e.length>0?e:void 0}parseAreaPattern(t){const e=this.getPattern(t.symbolName);if(!e||0===e.length)return;const i=this.findBuffer(t.xyOffsets);return i?{type:"pattern",params:{...t,xyOffsets:new Float32Array(i.buffer,i.byteOffset,i.byteLength/4)}}:void 0}parseNodePrimitives(t){const e=[];for(const i of t){const t=this.parseNodePrimitive(i);t&&e.push(t)}return e}parseNodePrimitive(t){return"areaPattern"===t.type?this.parseAreaPattern(t):this.parsePrimitive(t)}parsePrimitives(t){const e=[];for(const i of t){const t=this.parsePrimitive(i);t&&e.push(t)}return e}parsePrimitive(t){let e=this.parseInstances(t);if(!e&&t.viewIndependentOrigin){const i=$.fromJSON(t.viewIndependentOrigin);e={type:"viewIndependentOrigin",origin:{x:i.x,y:i.y,z:i.z}}}const i=t.material??"",n=i.length?Ao.asObject(this._document.materials[i]):void 0,s=n?this.parseDisplayParams(n):void 0;if(!s)return;const r=this.parseVertexTable(t);if(!r)return;let o;const a=!this._options.is3d||Ao.asBool(t.isPlanar);switch(t.type){case oa.Mesh:{const e=this.parseSurface(t,s);e&&(o={type:"mesh",params:{vertices:r,surface:e,isPlanar:a,auxChannels:this.parseAuxChannelTable(t),edges:this.parseEdges(t.edges,s,e.indices)}});break}case oa.Polyline:{const e=this.parseTesselatedPolyline(t);if(e){let t=Ho.Normal;wa.RegionEdgeType.Outline===s.regionEdgeType&&(t=!s.gradient||s.gradient.isOutlined?Ho.Edge:Ho.Outline),o={type:"polyline",params:{vertices:r,polyline:e,isPlanar:a,type:t,weight:s.width,linePixels:s.linePixels}}}break}case oa.Point:{const e=this.findBuffer(t.indices),i=s.width;e&&(o={type:"point",params:{vertices:r,indices:e,weight:i}});break}}return o&&(o.modifier=e),o}parseSurface(t,e){const i=t.surface;if(!i)return;let n=this.findBuffer(i.indices);if(!n)return;if(i.compressedIndexCount&&i.compressedIndexCount>0){if(!this._meshoptDecoder)return;const t=new Uint8Array(4*i.compressedIndexCount);this._meshoptDecoder.decodeIndexSequence(t,i.compressedIndexCount,4,n),n=new Uint8Array(3*i.compressedIndexCount);for(let e=0;e<i.compressedIndexCount;e++){const i=4*e,s=3*e;n[s+0]=t[i+0],n[s+1]=t[i+1],n[s+2]=t[i+2]}}const s=i.type;if(!function(t){switch(t){case aa.Unlit:case aa.Lit:case aa.Textured:case aa.TexturedLit:case aa.VolumeClassifier:return!0;default:return!1}}(s))return;const r=e.textureMapping?.texture;let o;const a=t.vertices.materialAtlas,c=t.vertices.numColors;let l;return a&&void 0!==c?o={isAtlas:!0,hasTranslucency:Ao.asBool(a.hasTranslucency),overridesAlpha:Ao.asBool(a.overridesAlpha,!1),vertexTableOffset:Ao.asInt(c),numMaterials:Ao.asInt(a.numMaterials)}:e.material&&(e.material,o=e.material.toImdl()),r&&(l={texture:r.toImdl(),alwaysDisplayed:Ao.asBool(i.alwaysDisplayTexture)}),{type:s,indices:n,fillFlags:e.fillFlags,hasBakedLighting:!1,material:o,textureMapping:l}}parseAuxChannelTable(t){const e=t.auxChannels;if(void 0===e)return;const i=this.findBuffer(Ao.asString(e.bufferView));return void 0!==i?{data:i,width:e.width,height:e.height,count:e.count,numBytesPerVertex:e.numBytesPerVertex,displacements:e.displacements,normals:e.normals,params:e.params}:void 0}parseVertexTable(t){const e=t.vertices;if(!e)return;let i;if(e.compressedSize&&e.compressedSize>0){if(!this._meshoptDecoder)return;const t=this._document.bufferViews[Ao.asString(e.bufferView)];if(void 0===t)return;const n=Ao.asInt(t.byteOffset),s=Ao.asInt(t.byteLength);if(0===s)return;const r=this._binaryData.subarray(n,n+e.compressedSize);if(!r)return;i=new Uint8Array(e.width*e.height*4),this._meshoptDecoder.decodeVertexBuffer(i,e.count,4*e.numRgbaPerVertex,r);const o=s-e.compressedSize;if(o>0){const t=this._binaryData.subarray(n+e.compressedSize,n+s);if(!t)return;const r=e.count*e.numRgbaPerVertex*4;for(let e=0;e<o;e++)i[r+e]=t[e]}}else if(i=this.findBuffer(Ao.asString(e.bufferView)),!i)return;const n=void 0!==e.featureID?Ao.asInt(e.featureID):void 0,s=Ao.asArray(e.params.decodedMin),r=Ao.asArray(e.params.decodedMax);if(void 0===s||void 0===r)return;const o=Pa.fromRange(ft.create($.create(s[0],s[1],s[2]),$.create(r[0],r[1],r[2]))),a=void 0!==e.uniformColor?Hr.fromJSON(e.uniformColor):void 0;let c;if(oa.Mesh===t.type&&t.surface&&t.surface.uvParams){const e=t.surface.uvParams.decodedMin,i=t.surface.uvParams.decodedMax,n=new pt(e[0],e[1],i[0],i[1]);c=ya.fromRange(n)}return{data:i,usesUnquantizedPositions:!0===e.usesUnquantizedPositions,qparams:o.toJSON(),width:e.width,height:e.height,hasTranslucency:e.hasTranslucency,uniformColor:a?.toJSON(),featureIndexType:e.featureIndexType,uniformFeatureID:n,numVertices:e.count,numRgbaPerVertex:e.numRgbaPerVertex,uvParams:c?.toJSON()}}parseInstances(t){const e=t.instances;if(!e)return;const i=Ao.asInt(e.count,0);if(i<=0)return;const n=Ao.asArray(e.transformCenter);if(void 0===n||3!==n.length)return;const s=$.create(n[0],n[1],n[2]),r=this.findBuffer(Ao.asString(e.featureIds));if(void 0===r)return;const o=this.findBuffer(Ao.asString(e.transforms));if(void 0===o)return;const a=o.byteLength/4;Math.floor(a);const c=new Float32Array(o.buffer,o.byteOffset,a);let l;return void 0!==e.symbologyOverrides&&(l=this.findBuffer(Ao.asString(e.symbologyOverrides))),{type:"instances",count:i,transforms:c,transformCenter:s,featureIds:r,symbologyOverrides:l}}findBuffer(t){if("string"!=typeof t||0===t.length)return;const e=this._document.bufferViews[t];if(void 0===e)return;const i=Ao.asInt(e.byteOffset),n=Ao.asInt(e.byteLength);return 0!==n?this._binaryData.subarray(i,i+n):void 0}colorDefFromMaterialJson(t){return void 0!==t?Hr.from(255*t[0]+.5,255*t[1]+.5,255*t[2]+.5):void 0}materialFromJson(t){const e=this._document.renderMaterials[t];if(!e)return;const i=new xa(t);return i.diffuseColor=this.colorDefFromMaterialJson(e.diffuseColor),void 0!==e.diffuse&&(i.diffuse=Ao.asDouble(e.diffuse)),i.specularColor=this.colorDefFromMaterialJson(e.specularColor),void 0!==e.specular&&(i.specular=Ao.asDouble(e.specular)),i.reflectColor=this.colorDefFromMaterialJson(e.reflectColor),void 0!==e.reflect&&(i.reflect=Ao.asDouble(e.reflect)),void 0!==e.specularExponent&&(i.specularExponent=e.specularExponent),void 0!==e.transparency&&(i.alpha=1-e.transparency),i.refract=Ao.asDouble(e.refract),i.shadows=Ao.asBool(e.shadows),i.ambient=Ao.asDouble(e.ambient),void 0!==e.textureMapping&&(i.textureMapping=this.textureMappingFromJson(e.textureMapping.texture)),new Ic(i)}parseNamedTexture(t,e){const i=Ao.asBool(t.isGlyph)?ma.Type.Glyph:Ao.asBool(t.isTileSection)?ma.Type.TileSection:ma.Type.Normal;return new vc(e,i)}parseConstantLodProps(t){if(void 0!==t)return{repetitions:Ao.asDouble(t.repetitions,1),offset:{x:t.offset?Ao.asDouble(t.offset[0]):0,y:t.offset?Ao.asDouble(t.offset[1]):0},minDistClamp:Ao.asDouble(t.minDistClamp,1),maxDistClamp:Ao.asDouble(t.maxDistClamp,4294967296)}}textureMappingFromJson(t){if(!t)return;const e=Ao.asString(t.name),i=0!==e.length?this._document.namedTextures[e]:void 0,n=i?this.parseNamedTexture(i,e):void 0;if(!n)return;const s=t.params,r=s.transform,o={textureMat2x3:new Aa.Trans2x3(r[0][0],r[0][1],r[0][2],r[1][0],r[1][1],r[1][2]),textureWeight:Ao.asDouble(s.weight,1),mapMode:Ao.asInt(s.mode),worldMapping:Ao.asBool(s.worldMapping),useConstantLod:Ao.asBool(s.useConstantLod),constantLodProps:this.parseConstantLodProps(s.constantLodParams)},a=new Aa(n,new Aa.Params(o)),c=t.normalMapParams;if(c){const t=Ao.asString(c.textureName),e=t.length>0?this._document.namedTextures[t]:void 0,i=e?this.parseNamedTexture(e,t):void 0;i&&(a.normalMapParams={normalMap:i,greenUp:Ao.asBool(c.greenUp),scale:Ao.asDouble(c.scale,1),useConstantLod:Ao.asBool(c.useConstantLod)})}return a}parseDisplayParams(t){const e=Ao.asInt(t.type,wa.Type.Mesh),i=Hr.create(Ao.asInt(t.lineColor)),n=Hr.create(Ao.asInt(t.fillColor)),s=Ao.asInt(t.lineWidth),r=Ao.asInt(t.linePixels,jo.Solid),o=Ao.asInt(t.fillFlags,Jo.None),a=Ao.asBool(t.ignoreLighting),c=t.materialId,l=void 0!==c?this.materialFromJson(c):void 0;let h,d;if(!l){const e=t.texture;if(h=void 0!==e?this.textureMappingFromJson(e):void 0,void 0===h){const e=t.gradient;if(d=void 0!==e?ra.Symb.fromJSON(e):void 0,d){const t=new Pc(e);h=new Aa(t,new Aa.Params({textureMat2x3:new Aa.Trans2x3(0,1,0,1,0,0)}))}}}return new wa(e,i,n,s,r,o,l,d,a,h)}}function Tc(t,e){const i=t.multiModel?ro.create(t.data,e,t.numFeatures,uo.Primary,t.numSubCategories):new io(t.data,e,t.numFeatures,uo.Primary);return i.animationNodeIds=t.animationNodeIds,i}let wc;var Ec;Ec={parse:async t=>{const e=await async function(t){const e=ua.fromUint8Array(t.data),i=new Sa(e);if(!i.isValid)return Yo.InvalidHeader;if(!i.isReadableVersion)return Yo.NewerMajorVersion;const n=e.curPos,s=ba.readFrom(e);if(!s)return Yo.InvalidFeatureTable;e.curPos=n+s.length;const r=new mc(e);if(!r.isValid)return Yo.InvalidTileData;e.curPos=r.scenePosition;const o=(a=e.nextBytes(r.sceneStrLength),new TextDecoder("utf-8").decode(a));var a;if(!o)return Yo.InvalidScene;try{const s=JSON.parse(o),a={scene:Ao.asString(s.scene),scenes:Ao.asArray(s.scenes),animationNodes:Ao.asObject(s.animationNodes),bufferViews:Ao.asObject(s.bufferViews)??{},meshes:Ao.asObject(s.meshes),nodes:Ao.asObject(s.nodes)??{},materials:Ao.asObject(s.materials)??{},renderMaterials:Ao.asObject(s.renderMaterials)??{},namedTextures:Ao.asObject(s.namedTextures)??{},patternSymbols:Ao.asObject(s.patternSymbols)??{},rtcCenter:Ao.asArray(s.rtcCenter)};if(!a.meshes)return Yo.InvalidTileData;const c=new Uint8Array(e.arrayBuffer,r.binaryPosition),l={startPos:n,multiModel:!!(i.flags&Go.MultiModelFeatureTable)},h=new Cc(a,c,t,l,e);return await h.parse()}catch{return Yo.InvalidTileData}}({...t,data:t.data,timeline:wc});return"number"==typeof e?e:{result:e,transfer:da(e)}},setTimeline:t=>{wc=Array.isArray(t)?bo.Script.fromJSON(t):bo.ModelTimeline.fromJSON(t)}},onmessage=async t=>{const e=t.data,i=e.msgId;try{let t=(0,Ec[e.operation])(e.payload);t instanceof Promise&&(t=await t),"object"==typeof t&&"transfer"in t?postMessage({result:t.result,msgId:i},{transfer:t.transfer}):postMessage({result:t,msgId:i})}catch(t){const e=t instanceof Error?t:new Error("Unknown worker error");postMessage({error:e,msgId:i})}}})();